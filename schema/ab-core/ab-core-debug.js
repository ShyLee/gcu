/*
 * ab-core
 * Copyright(c) 2006-2008, ARCHIBUS Inc.
 * 
 * 
 */



(function(){

var EV = Ext.lib.Event;

Ext.ux.ManagedIFrame = function(){
    var args=Array.prototype.slice.call(arguments, 0)
        ,el = Ext.get(args[0])
        ,config = args[0];

    if(el && el.dom && el.dom.tagName == 'IFRAME'){
            config = args[1] || {};
    }else{
            config = args[0] || args[1] || {};

            el = config.autoCreate?
            Ext.get(Ext.DomHelper.append(config.autoCreate.parent||document.body,
                Ext.apply({tag:'iframe', src:(Ext.isIE&&Ext.isSecure)?Ext.SSL_SECURE_URL:''},config.autoCreate))):null;
    }

    if(!el || el.dom.tagName != 'IFRAME') return el;

    el.dom.name || (el.dom.name = el.dom.id); //make sure there is a valid frame name

    this.addEvents({
        
        "focus"         : true,

        
        "blur"          : true,

        
        "unload"        : true,

       
        "domready"       : true,

       
        "documentloaded" : true,

        
        "exception" : true,
        
        "message" : true
        
        //"message:tagName"  is supported for X-frame messaging
    });

    if(config.listeners){
        this.listeners=config.listeners;
        Ext.ux.ManagedIFrame.superclass.constructor.call(this);
    }

    Ext.apply(el,this);  // apply this class interface ( pseudo Decorator )

    el.addClass('x-managed-iframe');
    if(config.style){
        el.applyStyles(config.style);
    }

    el._maskEl = el.parent('.x-managed-iframe-mask')||el.parent().addClass('x-managed-iframe-mask');

    Ext.apply(el,{
      disableMessaging : config.disableMessaging===true
     ,loadMask         : Ext.apply({msg:'Loading..'
                            ,msgCls:'x-mask-loading'
                            ,maskEl: el._maskEl
                            ,hideOnReady:true
                            ,disabled:!config.loadMask},config.loadMask)
    //Hook the Iframes loaded state handler
     ,_eventName       : Ext.isIE?'onreadystatechange':'onload'
     ,_windowContext   : null
     ,eventsFollowFrameLinks  : typeof config.eventsFollowFrameLinks=='undefined'?
                                true  :  config.eventsFollowFrameLinks
    });

    el.dom[el._eventName] = el.loadHandler.createDelegate(el);

    if(document.addEventListener){  //for Gecko and Opera and any who might support it later
       Ext.EventManager.on(window,"DOMFrameContentLoaded", el.dom[el._eventName]);
    }

    var um = el.updateManager=new Ext.UpdateManager(el,true);
    um.showLoadIndicator= config.showLoadIndicator || false;

    if(config.src){
        el.setSrc(config.src);
    }else{

        var content = config.html || config.content || false;

        if(content){
            el.update.defer(10,el,[content]); //allow frame to quiesce
        }
    }

    return Ext.ux.ManagedIFrame.Manager.register(el);

};

var MIM = Ext.ux.ManagedIFrame.Manager = function(){
  var frames = {};
  return {
    shimCls      : 'x-frame-shim',
    register     :function(frame){
        frame.manager = this;
        frames[frame.id] = frames[frame.dom.name] = {ref:frame, elCache:{}};
        return frame;
    },

    deRegister     :function(frame){

        frame._unHook();
        delete frames[frame.id];
        delete frames[frame.dom.name];

    },
    hideShims : function(){

        if(!this.shimApplied)return;
        Ext.select('.'+this.shimCls,true).removeClass(this.shimCls+'-on');
        this.shimApplied = false;
    },

    
    showShims : function(){
       if(!this.shimApplied){
          this.shimApplied = true;
          //Activate the shimCls globally
          Ext.select('.'+this.shimCls,true).addClass(this.shimCls+'-on');
       }

    },
    getFrameById  : function(id){

       return typeof id == 'string'?(frames[id]?frames[id].ref||null:null):null;

    },

    getFrameByName : function(name){
        return this.getFrameById(name);
    },

    //retrieve the internal frameCache object
    getFrameHash  : function(frame){
       return frame.id?frames[frame.id]:null;

    },
    //to be called under the scope of the managing MIF
    eventProxy     : function(e){
        e = Ext.lib.Event.getEvent(e);
        if(!e)return;
        var be=e.browserEvent||e;

        //same-domain unloads should clear ElCache for use with the next document rendering
        if(e.type == 'unload'){ this._unHook(); }

        if(!be['eventPhase'] || (be['eventPhase'] == (be['AT_TARGET']||2))){
            return this.fireEvent(e.type, e);
        }
    },

    _flyweights : {},

    //safe removal of embedded frame element
    removeNode : Ext.isIE ?
               function(frame, n){
                    frame = MIM.getFrameHash(frame);
                    if(frame && n && n.tagName != 'BODY'){
                        d = frame.scratchDiv || (frame.scratchDiv = frame.getDocument().createElement('div'));
                        d.appendChild(n);
                        d.innerHTML = '';
                    }
                }
              : function(frame, n){
                    if(n && n.parentNode && n.tagName != 'BODY'){
                        n.parentNode.removeChild(n);
                    }
                }


   }
 }();

 MIM.showDragMask = MIM.showShims;
 MIM.hideDragMask = MIM.hideShims;

 //Provide an Ext.Element interface to frame document elements
 MIM.El =function(frame, el, forceNew){

     var frameObj;
     frame = (frameObj = MIM.getFrameHash(frame))?frameObj.ref:null ;

     if(!frame ){ return null; }
     var elCache = frameObj.elCache || (frameObj.elCache = {});

     var dom = frame.getDom(el);

     if(!dom){ // invalid id/element
         return null;
     }
     var id = dom.id;
     if(forceNew !== true && id && elCache[id]){ // element object already exists
         return elCache[id];
     }

     
     this.dom = dom;

     
    this.id = id || Ext.id(dom);
 };

 MIM.El.get =function(frame, el){
     var ex, elm, id, doc;
     if(!frame || !el ){ return null; }

     var frameObj;
     frame = (frameObj = MIM.getFrameHash(frame))?frameObj.ref:null ;

     if(!frame ){ return null;}

     var elCache = frameObj.elCache || (frameObj.elCache = {} );

     if(!(doc = frame.getDocument())){ return null; }
     if(typeof el == "string"){ // element id
         if(!(elm = frame.getDom(el))){
             return null;
         }
         if(ex = elCache[el]){
             ex.dom = elm;
         }else{
             ex = elCache[el] = new MIM.El(frame, elm);
         }
         return ex;
     }else if(el.tagName){ // dom element
         if(!(id = el.id)){
             id = Ext.id(el);
         }
         if(ex = elCache[id]){
             ex.dom = el;
         }else{
             ex = elCache[id] = new MIM.El(frame, el);
         }
         return ex;
     }else if(el instanceof MIM.El){
         if(el != frameObj.docEl){
             el.dom = frame.getDom(el.id) || el.dom; // refresh dom element in case no longer valid,
                                                     // catch case where it hasn't been appended
             elCache[el.id] = el; // in case it was created directly with Element(), let's cache it
         }
         return el;
     }else if(el.isComposite){
         return el;
     }else if(Ext.isArray(el)){
         return frame.select(el);
     }else if(el == doc){
         // create a bogus element object representing the document object
         if(!frameObj.docEl){
             var f = function(){};
             f.prototype = MIM.El.prototype;
             frameObj.docEl = new f();
             frameObj.docEl.dom = doc;
         }
         return frameObj.docEl;
     }
    return null;

 };

 Ext.apply(MIM.El.prototype,Ext.Element.prototype);



 Ext.extend(Ext.ux.ManagedIFrame , Ext.util.Observable,
    {

    src : null ,
      
    setSrc : function(url, discardUrl, callback){
          var reset = Ext.isIE&&Ext.isSecure?Ext.SSL_SECURE_URL:'';
          var src = url || this.src || reset;

          if(Ext.isOpera){
              this.dom.src = reset;
           }
          this._windowContext = null;
          this._unHook();

          this._callBack = callback || false;

          this.showMask();

          (function(){
                var s = typeof src == 'function'?src()||'':src;
                try{
                    this._frameAction = true; //signal listening now
                    this.dom.src = s;
                    this.frameInit= true; //control initial event chatter
                    this.checkDOM();
                }catch(ex){ this.fireEvent('exception', this, ex); }

          }).defer(10,this);

          if(discardUrl !== true){ this.src = src; }

          return this;

    },
    reset     : function(src, callback){
          this.setSrc(src || (Ext.isIE&&Ext.isSecure?Ext.SSL_SECURE_URL:''),true,callback);

    },
    //Private: script removal RegeXp
    scriptRE  : /(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/gi
    ,
    
    update : function(content,loadScripts,callback){

        loadScripts = loadScripts || this.getUpdateManager().loadScripts || false;

        content = Ext.DomHelper.markup(content||'');
        content = loadScripts===true ? content:content.replace(this.scriptRE , "");

        var doc;

        if(doc = this.getDocument()){

            this._frameAction = !!content.length;
            this._windowContext = this.src = null;
            this._callBack = callback || false;
            this._unHook();
            this.showMask();
            doc.open();
            doc.write(content);
            doc.close();
            this.frameInit= true; //control initial event chatter
            if(this._frameAction){
                this.checkDOM();
            } else {
                this.hideMask(true);
                if(this._callBack)this._callBack();
            }

        }else{
            this.hideMask(true);
            if(this._callBack)this._callBack();
        }
        return this;
    },

    
    disableMessaging :  true,

    //Private, frame messaging interface (for same-domain-policy frames only)
    _XFrameMessaging  :  function(){
        //each tag gets a hash queue ($ = no tag ).
        var tagStack = {'$' : [] };
        var isEmpty = function(v, allowBlank){
             return v === null || v === undefined || (!allowBlank ? v === '' : false);
        };
        window.sendMessage = function(message, tag, origin ){
            var MIF;
            if(MIF = arguments.callee.manager){
                if(message._fromHost){
                    var fn, result;
                    //only raise matching-tag handlers
                    var compTag= message.tag || tag || null;
                    var mstack = !isEmpty(compTag)? tagStack[compTag.toLowerCase()]||[] : tagStack["$"];

                    for(var i=0,l=mstack.length;i<l;i++){
                        if(fn = mstack[i]){
                            result = fn.apply(fn.__scope,arguments)===false?false:result;
                            if(fn.__single){mstack[i] = null;}
                            if(result === false){break;}
                        }
                    }

                    return result;
                }else{

                    message =
                        {type   :isEmpty(tag)?'message':'message:'+tag.toLowerCase().replace(/^\s+|\s+$/g,'')
                        ,data   :message
                        ,domain :origin || document.domain
                        ,uri    :document.documentURI
                        ,source :window
                        ,tag    :isEmpty(tag)?null:tag.toLowerCase()
                        };

                    try{
                       return MIF.disableMessaging !== true
                        ? MIF.fireEvent.call(MIF,message.type,MIF, message)
                        : null;
                    }catch(ex){} //trap for message:tag handlers not yet defined

                    return null;
                }

            }
        };
        window.onhostmessage = function(fn,scope,single,tag){

            if(typeof fn == 'function' ){
                if(!isEmpty(fn.__index)){
                    throw "onhostmessage: duplicate handler definition" + (tag?" for tag:"+tag:'');
                }

                var k = isEmpty(tag)? "$":tag.toLowerCase();
                tagStack[k] || ( tagStack[k] = [] );
                Ext.apply(fn,{
                   __tag    : k
                  ,__single : single || false
                  ,__scope  : scope || window
                  ,__index  : tagStack[k].length
                });
                tagStack[k].push(fn);

            } else
               {throw "onhostmessage: function required";}


        };
        window.unhostmessage = function(fn){
            if(typeof fn == 'function' && typeof fn.__index != 'undefined'){
                var k = fn.__tag || "$";
                tagStack[k][fn.__index]=null;
            }
        };


    }
    ,get   :function(el){
             return  MIM.El.get(this, el);
         }

    ,fly : function(el, named){
        named = named || '_global';
        el = this.getDom(el);
        if(!el){
            return null;
        }
        if(!MIM._flyweights[named]){
            MIM._flyweights[named] = new Ext.Element.Flyweight();
        }
        MIM._flyweights[named].dom = el;
        return MIM._flyweights[named];
    }

    ,getDom  : function(el){
         var d;
         if(!el || !(d = this.getDocument())){
            return null;
         }
         return el.dom ? el.dom : (typeof el == 'string' ? d.getElementById(el) : el);

    }
    
    ,select : function(selector, unique){
        var d;
        return (d = this.getDocument())?Ext.Element.select(selector, unique, d):null;
     }

    
    ,query : function(selector){
        var d;
        return (d = this.getDocument())?Ext.DomQuery.select(selector, d):null;
     }


    
    ,getDoc  : function(){

        return this.get(this.getDocument());

    }

    
    ,removeNode  : function(node){
        MIM.removeNode(this,this.getDom(node));
    }

    //Private : clear all event listeners and Element cache
    ,_unHook     : function(){

        var elcache, h = MIM.getFrameHash(this)||{};

        if( this._hooked && h && (elcache = h.elCache)){

            for (var id in elcache){
                var el = elcache[id];

                delete elcache[id];
                if(el.removeAllListeners)el.removeAllListeners();
            }
            if(h.docEl){
                h.docEl.removeAllListeners();
                h.docEl=null;
                delete h.docEl;
            }
        }
        this._hooked = this._domReady = this._domFired = false;

    }
    //Private execScript sandbox and messaging interface
    ,_renderHook : function(){

        this._windowContext = null;
        this._hooked = false;
        try{
           if(this.writeScript('(function(){(window.hostMIF = parent.Ext.get("'+
                                this.dom.id+
                                '"))._windowContext='+
                                (Ext.isIE?'window':'{eval:function(s){return eval(s);}}')+
                                ';})();')
                ){
                this._frameProxy || (this._frameProxy = MIM.eventProxy.createDelegate(this));
                EV.doAdd(this.getWindow(), 'focus', this._frameProxy);
                EV.doAdd(this.getWindow(), 'blur',  this._frameProxy);
                EV.doAdd(this.getWindow(), 'unload', this._frameProxy );

                if(this.disableMessaging !== true){
                   this.loadFunction({name:'XMessage',fn:this._XFrameMessaging},false,true);
                   var sm;
                   if(sm=this.getWindow().sendMessage){
                       sm.manager = this;
                   }
                }
                this.CSS = new CSSInterface(this.getDocument());
           }
           return this.domWritable();
          }catch(ex){}

        return false;

    },
    
    sendMessage : function (message,tag,origin){
         var win;
         if(this.disableMessaging !== true && (win = this.getWindow())){
              //support frame-to-frame messaging relay
              tag || (tag= message.tag || '');
              tag = tag.toLowerCase();
              message = Ext.applyIf(message.data?message:{data:message},
                                 {type   :Ext.isEmpty(tag)?'message':'message:'+tag
                                 ,domain :origin || document.domain
                                 ,uri    : document.documentURI
                                 ,source : window
                                 ,tag    :tag || null
                                 ,_fromHost: this
                    });
             return win.sendMessage?win.sendMessage.call(null,message,tag,origin): null;
         }
         return null;

    },
    _windowContext : null,
    
    getDocument:function(){
        var win;
        return (win = this.getWindow())?win.document:null;
    },

    //Attempt to retrieve the frames current document.body
    getBody : function(){
        var d;
        return (d = this.getDocument())?d.body:null;

    },

    //Attempt to retrieve the frames current URI
    getDocumentURI : function(){
        var URI;
        try{
           URI = this.src?this.getDocument().location.href:null;
        }catch(ex){} //will fail on NON-same-origin domains

        return URI || this.src;
    },
    
    getWindow:function(){
        var dom= this.dom;
        
        if(Ext.isIE){
        	 if(dom && window.frames){
             	return window.frames[dom.name];
        	 }else{
        		 return null;
        	 }
        }else{
        	return dom?dom.contentWindow||window.frames[dom.name]:null
        }
       
        //return dom?dom.contentWindow||window.frames[dom.name]:null;
    },

    
    print:function(){
        try{
            var win = this.getWindow();
            if(Ext.isIE){win.focus();}
            win.print();
        } catch(ex){
            throw 'print exception: ' + (ex.description || ex.message || ex);
        }
    },
    //private
    destroy:function(){
        this.removeAllListeners();

        if(this.dom){
             //unHook the Iframes loaded state handlers
             if(document.addEventListener){ //Gecko/Opera
                Ext.EventManager.un(window,"DOMFrameContentLoaded", this.dom[this._eventName]);
               }
             this.dom[this._eventName]=null;
             Ext.ux.ManagedIFrame.Manager.deRegister(this);
             this._windowContext = null;
             //IE Iframe cleanup
             if(Ext.isIE && this.dom.src){
                this.dom.src = 'javascript:false';
             }
             this._maskEl = null;
             Ext.removeNode(this.dom);

        }

        Ext.apply(this.loadMask,{masker :null ,maskEl : null});

    }
    
    ,domWritable  : function(){
        return !!this._windowContext;
    }
    
    ,execScript: function(block, useDOM){
      try{
        if(this.domWritable()){
            if(useDOM){
               this.writeScript(block);
            }else{
                return this._windowContext.eval(block);
            }

        }else{ throw 'execScript:non-secure context' }
       }catch(ex){
            this.fireEvent('exception', this, ex);
            return false;
        }
        return true;

    }
    
    ,writeScript  : function(block, attributes) {
        attributes = Ext.apply({},attributes||{},{type :"text/javascript",text:block});

         try{
            var head,script, doc= this.getDocument();
            if(doc && doc.getElementsByTagName){
                if(!(head = doc.getElementsByTagName("head")[0] )){
                    //some browsers (Webkit, Safari) do not auto-create
                    //head elements during document.write
                    head =doc.createElement("head");
                    doc.getElementsByTagName("html")[0].appendChild(head);
                }
                if(head && (script = doc.createElement("script"))){
                    for(var attrib in attributes){
                          if(attributes.hasOwnProperty(attrib) && attrib in script){
                              script[attrib] = attributes[attrib];
                          }
                    }
                    return !!head.appendChild(script);
                }
            }
         }catch(ex){ this.fireEvent('exception', this, ex);}
         return false;
    }
    
    ,loadFunction : function(fn, useDOM, invokeIt){

       var name  =  fn.name || fn;
       var    fn =  fn.fn   || window[fn];
       this.execScript(name + '=' + fn, useDOM); //fn.toString coercion
       if(invokeIt){
           this.execScript(name+'()') ; //no args only
        }
    }

    //Private
    ,showMask: function(msg,msgCls,forced){
          var lmask;
          if((lmask = this.loadMask) && (!lmask.disabled|| forced)){
               if(lmask._vis)return;
               lmask.masker || (lmask.masker = Ext.get(lmask.maskEl||this.dom.parentNode||this.wrap({tag:'div',style:{position:'relative'}})));
               lmask._vis = true;
               lmask.masker.mask.defer(lmask.delay||5,lmask.masker,[msg||lmask.msg , msgCls||lmask.msgCls] );
           }
       }
    //Private
    ,hideMask: function(forced){
           var tlm;
           if((tlm = this.loadMask) && !tlm.disabled && tlm.masker ){
               if(!forced && (tlm.hideOnReady!==true && this._domReady)){return;}
               tlm._vis = false;
               tlm.masker.unmask.defer(tlm.delay||5,tlm.masker);
           }
    }

    
    ,loadHandler : function(e){

        if(!this.frameInit || (!this._frameAction && !this.eventsFollowFrameLinks)){return;}

        var rstatus = (e && typeof e.type !== 'undefined'?e.type:this.dom.readyState );
        switch(rstatus){
            case 'loading':  //IE
            case 'interactive': //IE

              break;
            case 'DOMFrameContentLoaded': //Gecko, Opera

              if(this._domFired || (e && e.target !== this.dom)){ return;} //not this frame.

            case 'domready': //MIF
              if(this._domFired)return;
              if(this._domFired = this._hooked = this._renderHook() ){

                 this._frameAction = (this.fireEvent("domready",this) === false?false:this._frameAction);  //Only raise if sandBox injection succeeded (same domain)
              }
            case 'domfail': //MIF

              this._domReady = true;
              this.hideMask();
              break;
            case 'load': //Gecko, Opera
            case 'complete': //IE
              if(!this._domFired ){  // one last try for slow DOMS.
                  this.loadHandler({type:'domready'});
              }
              this.hideMask(true);
              if(this._frameAction || this.eventsFollowFrameLinks ){
                //not going to wait for the event chain, as its not cancellable anyhow.
                this.fireEvent.defer(50,this,["documentloaded",this]);
              }
              this._frameAction = false;
              if(this.eventsFollowFrameLinks){  //reset for link tracking
                  this._domFired = this._domReady = false;
              }
              if(this._callBack){
                   this._callBack(this);
              }

              break;
            default:
        }

    }
    
    ,checkDOM : function(win){
        if(Ext.isOpera)return;
        //initialise the counter
        var n = 0
            ,win = win||this.getWindow()
            ,manager = this
            ,domReady = false
            ,max = 100;

            var poll =  function(){  //DOM polling for IE and others
               try{
                 domReady  =false;
                 var doc = win.document,body;
                 if(!manager._domReady){
                    domReady = (doc && doc.getElementsByTagName);
                    domReady = domReady && (body = doc.getElementsByTagName('body')[0]) && !!body.innerHTML.length;
                 }

               }catch(ex){
                     n = max; //likely same-domain policy violation
               }

                //if the timer has reached 100 (timeout after 3 seconds)
                //in practice, shouldn't take longer than 7 iterations [in kde 3
                //in second place was IE6, which takes 2 or 3 iterations roughly 5% of the time]

                if(!manager._frameAction || manager._domReady)return;

                if(n++ < max && !domReady )
                {
                    //try again
                    setTimeout(arguments.callee, 10);
                    return;
                }
                manager.loadHandler ({type:domReady?'domready':'domfail'});

            };
            setTimeout(poll,50);
         }
 });


var styleCamelRe = /(-[a-z])/gi;
var styleCamelFn = function(m, a){ return a.charAt(1).toUpperCase(); };
var CSSInterface = function(hostDocument){
    var doc;
    if(hostDocument){

        doc = hostDocument;

    return {
        rules : null,
       
       createStyleSheet : function(cssText, id){
           var ss;

           if(!doc)return;
           var head = doc.getElementsByTagName("head")[0];
           var rules = doc.createElement("style");
           rules.setAttribute("type", "text/css");
           if(id){
               rules.setAttribute("id", id);
           }
           if(Ext.isIE){
               head.appendChild(rules);
               ss = rules.styleSheet;
               ss.cssText = cssText;
           }else{
               try{
                    rules.appendChild(doc.createTextNode(cssText));
               }catch(e){
                   rules.cssText = cssText;
               }
               head.appendChild(rules);
               ss = rules.styleSheet ? rules.styleSheet : (rules.sheet || doc.styleSheets[doc.styleSheets.length-1]);
           }
           this.cacheStyleSheet(ss);
           return ss;
       },

       
       removeStyleSheet : function(id){

           if(!doc)return;
           var existing = doc.getElementById(id);
           if(existing){
               existing.parentNode.removeChild(existing);
           }
       },

       
       swapStyleSheet : function(id, url){
           this.removeStyleSheet(id);

           if(!doc)return;
           var ss = doc.createElement("link");
           ss.setAttribute("rel", "stylesheet");
           ss.setAttribute("type", "text/css");
           ss.setAttribute("id", id);
           ss.setAttribute("href", url);
           doc.getElementsByTagName("head")[0].appendChild(ss);
       },

       
       refreshCache : function(){
           return this.getRules(true);
       },

       // private
       cacheStyleSheet : function(ss){
           if(this.rules){
               this.rules = {};
           }
           try{// try catch for cross domain access issue
               var ssRules = ss.cssRules || ss.rules;
               for(var j = ssRules.length-1; j >= 0; --j){
                   this.rules[ssRules[j].selectorText] = ssRules[j];
               }
           }catch(e){}
       },

       
       getRules : function(refreshCache){
            if(this.rules == null || refreshCache){
                this.rules = {};

                if(doc){
                    var ds = doc.styleSheets;
                    for(var i =0, len = ds.length; i < len; i++){
                        try{
                            this.cacheStyleSheet(ds[i]);
                        }catch(e){}
                    }
                }
            }
            return this.rules;
        },

        
       getRule : function(selector, refreshCache){
            var rs = this.getRules(refreshCache);
            if(!Ext.isArray(selector)){
                return rs[selector];
            }
            for(var i = 0; i < selector.length; i++){
                if(rs[selector[i]]){
                    return rs[selector[i]];
                }
            }
            return null;
        },

        
       updateRule : function(selector, property, value){
            if(!Ext.isArray(selector)){
                var rule = this.getRule(selector);
                if(rule){
                    rule.style[property.replace(styleCamelRe, styleCamelFn)] = value;
                    return true;
                }
            }else{
                for(var i = 0; i < selector.length; i++){
                    if(this.updateRule(selector[i], property, value)){
                        return true;
                    }
                }
            }
            return false;
        }
    };}
};

 
 Ext.ux.ManagedIframePanel = Ext.extend(Ext.Panel, {

    
    defaultSrc  :null,
    bodyStyle   :{height:'100%',width:'100%', position:'relative'},

    
    frameStyle  : {overflow:'auto'},
    frameConfig : null,
    hideMode    : !Ext.isIE?'nosize':'display',
    shimCls     : Ext.ux.ManagedIFrame.Manager.shimCls,
    shimUrl     : null,
    loadMask    : false,
    animCollapse: Ext.isIE,
    autoScroll  : false,
    closable    : true, 
    ctype       : "Ext.ux.ManagedIframePanel",
    showLoadIndicator : false,

    
    unsupportedText : 'Inline frames are NOT enabled\/supported by your browser.'

   ,initComponent : function(){

        var unsup =this.unsupportedText?{html:this.unsupportedText}:false;
        //this.frameConfig || (this.frameConfig = {autoCreate:{}});
        this.bodyCfg ||
           (this.bodyCfg =
               {tag:'div'
               ,cls:'x-panel-body'
               ,children:[
                  {  cls    :'x-managed-iframe-mask' //shared masking DIV for hosting loadMask/dragMask
                    ,children:[
                        Ext.apply(
                          Ext.apply({
                              tag          :'iframe',
                              frameborder  : 0,
                              cls          : 'x-managed-iframe',
                              style        : this.frameStyle || null
                            },this.frameConfig)
                            ,unsup , Ext.isIE&&Ext.isSecure?{src:Ext.SSL_SECURE_URL}:false )
                            //the shimming agent
                            ,{tag:'img', src:this.shimUrl||Ext.BLANK_IMAGE_URL , cls: this.shimCls }
                         ]
                    }
                  ]
           });

         this.autoScroll = false; //Force off as the Iframe manages this
         this.items = null;

         //setup stateful events if not defined
         if(this.stateful !== false){
             this.stateEvents || (this.stateEvents = ['documentloaded']);
         }

         Ext.ux.ManagedIframePanel.superclass.initComponent.call(this);

         this.monitorResize || (this.monitorResize = this.fitToParent);

         this.addEvents({documentloaded:true, domready:true,message:true,exception:true});

         //apply the addListener patch for 'message:tagging'
         this.addListener = this.on;

    },

    doLayout   :  function(){
        //only resize (to Parent) if the panel is NOT in a layout.
        //parentNode should have {style:overflow:hidden;} applied.
        if(this.fitToParent && !this.ownerCt){
            var pos = this.getPosition(), size = (Ext.get(this.fitToParent)|| this.getEl().parent()).getViewSize();
            this.setSize(size.width - pos[0], size.height - pos[1]);
        }
        Ext.ux.ManagedIframePanel.superclass.doLayout.apply(this,arguments);

    },

      // private
    beforeDestroy : function(){

        if(this.rendered){

             if(this.tools){
                for(var k in this.tools){
                      Ext.destroy(this.tools[k]);
                }
             }

             if(this.header && this.headerAsText){
                var s;
                if( s=this.header.child('span')) s.remove();
                this.header.update('');
             }

             Ext.each(['iframe','shim','header','topToolbar','bottomToolbar','footer','loadMask','body','bwrap'],
                function(elName){
                  if(this[elName]){
                    if(typeof this[elName].destroy == 'function'){
                         this[elName].destroy();
                    } else { Ext.destroy(this[elName]); }

                    this[elName] = null;
                    delete this[elName];
                  }
             },this);
        }

        Ext.ux.ManagedIframePanel.superclass.beforeDestroy.call(this);
    },
    onDestroy : function(){
        //Yes, Panel.super (Component), since we're doing Panel cleanup beforeDestroy instead.
        Ext.Panel.superclass.onDestroy.call(this);
    },
    // private
    onRender : function(ct, position){
        Ext.ux.ManagedIframePanel.superclass.onRender.call(this, ct, position);

        if(this.iframe = this.body.child('iframe.x-managed-iframe')){

            // Set the Visibility Mode for el, bwrap for collapse/expands/hide/show
            var El = Ext.Element;
            var mode = El[this.hideMode.toUpperCase()] || 'x-hide-nosize';
            Ext.each(
                [this[this.collapseEl],this.floating? null: this.getActionEl(),this.iframe]
                ,function(el){
                     if(el)el.setVisibilityMode(mode);
            },this);

            if(this.loadMask){
                this.loadMask = Ext.apply({disabled     :false
                                          ,maskEl       :this.body
                                          ,hideOnReady  :true}
                                          ,this.loadMask);
             }

            if(this.iframe = new Ext.ux.ManagedIFrame(this.iframe, {
                    loadMask           :this.loadMask
                   ,showLoadIndicator  :this.showLoadIndicator
                   ,disableMessaging   :this.disableMessaging
                   ,style              :this.frameStyle
                   })){

                this.loadMask = this.iframe.loadMask;
                this.iframe.ownerCt = this;
                this.relayEvents(this.iframe, ["blur", "focus", "unload", "documentloaded","domready","exception","message"].concat(this._msgTagHandlers ||[]));
                delete this._msgTagHandlers;
            }

            this.getUpdater().showLoadIndicator = this.showLoadIndicator || false;

            // Enable auto-dragMask if the panel participates in (nested?) border layout.
            // Setup event handlers on the SplitBars to enable the frame dragMask when needed
            var ownerCt = this.ownerCt;
            while(ownerCt){

                ownerCt.on('afterlayout',function(container,layout){
                        var MIM = Ext.ux.ManagedIFrame.Manager,st=false;
                        Ext.each(['north','south','east','west'],function(region){
                            var reg;
                            if((reg = layout[region]) && reg.splitEl){
                                st = true;
                                if(!reg.split._splitTrapped){
                                    reg.split.on('beforeresize',MIM.showShims,MIM);
                                    reg.split._splitTrapped = true;
                                }
                            }
                        },this);
                        if(st && !this._splitTrapped ){
                            this.on('resize',MIM.hideShims,MIM);
                            this._splitTrapped = true;

                        }

                },this,{single:true}); //and discard

                ownerCt = ownerCt.ownerCt; //nested layouts?
             }


        }
        this.shim = Ext.get(this.body.child('.'+this.shimCls));
    },

    
    toggleShim   : function(){

        if(this.shim && this.shimCls)this.shim.toggleClass(this.shimCls+'-on');
    },
        // private
    afterRender : function(container){
        var html = this.html;
        delete this.html;
        Ext.ux.ManagedIframePanel.superclass.afterRender.call(this);
        if(this.iframe){
            if(this.defaultSrc){
                this.setSrc();
            }
            else if(html){
                this.iframe.update(typeof html == 'object' ? Ext.DomHelper.markup(html) : html);
            }
        }

    }
    ,sendMessage :function (){
        if(this.iframe){
            this.iframe.sendMessage.apply(this.iframe,arguments);
        }

    }
    //relay all defined 'message:tag' event handlers
    ,on : function(name){
           var tagRE=/^message\:/i, n = null;
           if(typeof name == 'object'){
               for (var na in name){
                   if(!this.filterOptRe.test(na) && tagRE.test(na)){
                      n || (n=[]);
                      n.push(na.toLowerCase());
                   }
               }
           } else if(tagRE.test(name)){
                  n=[name.toLowerCase()];
           }

           if(this.getFrame() && n){
               this.relayEvents(this.iframe,n);
           }else{
               this._msgTagHandlers || (this._msgTagHandlers =[]);
               if(n)this._msgTagHandlers = this._msgTagHandlers.concat(n); //queued for onRender when iframe is available
           }
           Ext.ux.ManagedIframePanel.superclass.on.apply(this, arguments);

    },

    
    setSrc : function(url, discardUrl,callback){
         url = url || this.defaultSrc || false;

         if(!url)return this;

         if(url.url){
            callback = url.callback || false;
            discardUrl = url.discardUrl || false;
            url = url.url || false;

         }
         var src = url || (Ext.isIE&&Ext.isSecure?Ext.SSL_SECURE_URL:'');

         if(this.rendered && this.iframe){
              this.iframe.setSrc(src,discardUrl,callback);
           }

         return this;
    },

    //Make it state-aware
    getState: function(){

         var URI = this.iframe?this.iframe.getDocumentURI()||null:null;
         return Ext.apply(Ext.ux.ManagedIframePanel.superclass.getState.call(this) || {},
             URI?{defaultSrc  : typeof URI == 'function'?URI():URI}:null );

    },
    
    getUpdater : function(){
        return this.rendered?(this.iframe||this.body).getUpdater():null;
    },
    
    getFrame : function(){
        return this.rendered?this.iframe:null
    },
    
    getFrameWindow : function(){
        return this.rendered && this.iframe?this.iframe.getWindow():null
    },
    
    getFrameDocument : function(){
        return this.rendered && this.iframe?this.iframe.getDocument():null
    },

    
    getFrameDoc : function(){
        return this.rendered && this.iframe?this.iframe.getDoc():null
    },

    
    getFrameBody : function(){
        return this.rendered && this.iframe?this.iframe.getBody():null
    },
     
    load : function(loadCfg){
         var um;
         if(um = this.getUpdater()){
            if (loadCfg && loadCfg.renderer) {
                 um.setRenderer(loadCfg.renderer);
                 delete loadCfg.renderer;
            }
            um.update.apply(um, arguments);
         }
         return this;
    }
     // private
    ,doAutoLoad : function(){
        this.load(
            typeof this.autoLoad == 'object' ?
                this.autoLoad : {url: this.autoLoad});
    }

});

Ext.reg('iframepanel', Ext.ux.ManagedIframePanel);

Ext.ux.ManagedIframePortlet = Ext.extend(Ext.ux.ManagedIframePanel, {
     anchor: '100%',
     frame:true,
     collapseEl:'bwrap',
     collapsible:true,
     draggable:true,
     cls:'x-portlet'
 });
Ext.reg('iframeportlet', Ext.ux.ManagedIframePortlet);



Ext.apply(Ext.Element.prototype, {
  setVisible : function(visible, animate){
        if(!animate || !Ext.lib.Anim){
            if(this.visibilityMode == Ext.Element.DISPLAY){
                this.setDisplayed(visible);
            }else if(this.visibilityMode == Ext.Element.VISIBILITY){
                this.fixDisplay();
                this.dom.style.visibility = visible ? "visible" : "hidden";
            }else {
                this[visible?'removeClass':'addClass'](String(this.visibilityMode));
            }

        }else{
            // closure for composites
            var dom = this.dom;
            var visMode = this.visibilityMode;

            if(visible){
                this.setOpacity(.01);
                this.setVisible(true);
            }
            this.anim({opacity: { to: (visible?1:0) }},
                  this.preanim(arguments, 1),
                  null, .35, 'easeIn', function(){

                     if(!visible){
                         if(visMode == Ext.Element.DISPLAY){
                             dom.style.display = "none";
                         }else if(visMode == Ext.Element.VISIBILITY){
                             dom.style.visibility = "hidden";
                         }else {
                             Ext.get(dom).addClass(String(visMode));
                         }
                         Ext.get(dom).setOpacity(1);
                     }
                 });
        }
        return this;
    },
    
    isVisible : function(deep) {
        var vis = !(this.getStyle("visibility") == "hidden" || this.getStyle("display") == "none" || this.hasClass(this.visibilityMode));
        if(deep !== true || !vis){
            return vis;
        }
        var p = this.dom.parentNode;
        while(p && p.tagName.toLowerCase() != "body"){
            if(!Ext.fly(p, '_isVisible').isVisible()){
                return false;
            }
            p = p.parentNode;
        }
        return true;
    }
});

Ext.onReady( function(){
  //Generate CSS Rules but allow for overrides.
    var CSS = Ext.util.CSS, rules=[];

    CSS.getRule('.x-managed-iframe') || ( rules.push('.x-managed-iframe {height:100%;width:100%;overflow:auto;}'));
    CSS.getRule('.x-managed-iframe-mask')||(rules.push('.x-managed-iframe-mask{width:100%;height:100%;position:relative;}'));
    if(!CSS.getRule('.x-frame-shim')){
        rules.push('.x-frame-shim {z-index:9000;position:absolute;top:0px;left:0px;background:transparent!important;overflow:hidden;display:none;}');
        rules.push('.x-frame-shim-on{width:100%;height:100%;display:block;zoom:1;}');
        rules.push('.ext-ie6 .x-frame-shim{margin-left:5px;margin-top:3px;}');
    }
    CSS.getRule('.x-hide-nosize') || (rules.push('.x-hide-nosize,.x-hide-nosize object,.x-hide-nosize iframe{height:0px!important;width:0px!important;border:none;}'));

    if(!!rules.length){
        CSS.createStyleSheet(rules.join(' '));
    }
});
})();
//@ sourceURL=<miframe.js>


//Debug is used to make decision if some javascript results are shown
//to developers for debugging purpose
var Debug = false;
//set up Debug variable used in common.xsl
//<afmXmlView debug="true|false"> will enable or disable the debug
//feature in client-side
//bDebug: the value from <afmXmlView debug="true|false">
function SetDebugVariable(bDebug)
{
	Debug = bDebug;
}

// @begin_translatable
var z_MESSAGE_CANT_FIND_FRAME = 'Cannot find frame named by';
// @end_translatable


var mozillaFireFoxBrowser=(navigator.userAgent.toUpperCase()).indexOf("FIREFOX")>0;
var microsoftIEBrowser=(navigator.userAgent.toUpperCase()).indexOf("MSIE")>0;



//the form with a hidden field is used to send client-side
//request data to server in xml-formatted string
//<form name="afmHiddenForm" method="POST">
//<input type="hidden" name="xml" value="..."/>
//</form>
var afmHiddenFormName = "afmHiddenForm";
var xmlName = "xml";


//user inputs form's name
var afmInputsFormName = "afmInputsForm";

//sending xml data string from hidden form with POST method to server
//strHiddenFormName is the hidden form's name: sending xml data
//strViewDefinitionFormName is the form's name to hold user's inputs
var strSerializedStartTag = "<";				//do not use &lt;
var strSerializedCloseTag = ">";				//do not use &gt;
var strSerializedInsertingDataFirstPart = "";	//<afmAction ....>
var strSerializedInsertingDataRestPart	= "";    //...</afmAction>

//set up from common.xsl
var strPdfAfmActionSerialized = "";
var strExcelAfmActionSerialized = "";
var strPdfGeneratingViewUrl = "";



function $(elemID){
	var domElem = Ext.get(elemID);
	if(domElem !=  null){
	   domElem = domElem.dom;
	}
	// compatibility code to get form field element in version 2 (document id is now form id + '_' + tablename + '.' + fieldname)
	if ((typeof domElem == 'undefined' || domElem == null) && AFM.view.View.version == '2.0') {
		for (var pCnt = 0, panel; panel = AFM.view.View.panels.items[pCnt]; pCnt++) {
			if (panel.type != 'form') {
				continue;
			}
			var test = Ext.get(panel.id + '_' + elemID);
			if (test != null) {
				domElem = test.dom;
				break;
			}
		}
	}
	return domElem;
}


function valueExists(value) {
    return (typeof(value) != 'undefined' && value != null);
}


function getValueIfExists(value, defaultValue) {
    return valueExists(value) ? value : defaultValue;
}


function valueExistsNotEmpty(value) {
    return (valueExists(value) && (typeof value != 'string' || trim(value) != ''));
}


function objectsEqual(o1, o2) {
    var result = true;
    if (typeof o1 == 'object' && typeof o2 == 'object') {
        for (var p in o1){
            if (o1[p] != o2[p]) {
                result = false;
                break;
            }
        }
    } else {
        result = (o1 == o2);
    }
    return result;
}


function getBoolean(value) {
    var result = false;
    if (valueExists(value) && value != '') {
        if (typeof value == 'boolean') {
            result = value;
        } else if (typeof value == 'string') {
            result = (value == 'true');
        }
    }
    return result;
}

///strUrl: url link to server, currently this value is always "dump.axvw"
//strSerialized: xml string to communicate with server, coming from action
//strTarget: request's target
//subFrameName: the frame's names will be refreshed following this request
//bData:if inserting client's data into strSerialized(xml string)
function sendingDataFromHiddenForm(strUrl, strSerialized, strTarget, subFrameName ,bData, newWindowSettings)
{
	var objHiddenForm = document.forms[afmHiddenFormName];
	var strData = "";
	var strXMLValue = "";
	//if bData is true, insert client data into xml string

	if(bData){
		setSerializedInsertingDataVariables(strSerialized);
		//gettingRecordsData() is defined in corresponding JS file
		//which XSL is calling sendingDataFromHiddenForm
		strData = gettingRecordsData();
		if(strData==null) return;
		if(strData != ""){
			if(strData.indexOf("<userInputRecordsFlag>") < 0)
				strData = "<userInputRecordsFlag>" + strData + "</userInputRecordsFlag>";
			strXMLValue = strSerializedInsertingDataFirstPart + strData +  strSerializedInsertingDataRestPart;
		}else{
			strXMLValue = strSerialized;
		}
	}else{
		strXMLValue = strSerialized;
	}

	if(objHiddenForm != null){
		//a new window is opened
		if(strTarget == "_blank" || strTarget == "blank"){
			var newTargetWindowName	= "newTargetWindow";
			var newTargetWindowSettings = "titlebar=no,toolbar=no,menubar=no,resizable=yes,scrollbars=yes,status=yes,width=1000,height=650";
			if(newWindowSettings != "")
				newTargetWindowSettings = newWindowSettings;
			var newWindowObj			= window.open("", newTargetWindowName,newTargetWindowSettings);
			//avoid the some part of new window is hidden form screen,
			//move it to the left top of screen
			newWindowObj.moveTo(10,10);
			strTarget = newTargetWindowName;
		}

		if(strUrl == "")
			strUrl = "login.axvw";

		objHiddenForm.elements[xmlName].value = strXMLValue;
		objHiddenForm.target = strTarget;
		objHiddenForm.action = strUrl;

		//sending the hidden form to server
		objHiddenForm.submit();
		//refreshing sub frame if thare is subFrame content in XML
		if(subFrameName != '')
			reloadFrameWindow(subFrameName);
	}
}

//set up related javascript varaibles
//strSerializedStartTag, strSerializedCloseTag,
//strSerializedInsertingDataFirstPart, strSerializedInsertingDataRestPart = "";    //...</afmAction>
//strSerialized: xml string from action
function setSerializedInsertingDataVariables(strSerialized)
{
	var numPos1 = 0;
	var numPos2 = 0;
	//since the format of strSerialized is dependent on how to pass it
	//to javascript in XSLT, two tag cases must be included.
	var strCloseTag1 = ">";
	var strStartTag1 = "<";
	var strCloseTag2 = "&gt;";
	var strStartTag2 = "&lt;";
	numPos1 = strSerialized.indexOf(strCloseTag1);
	if(numPos1 > 0){
		strSerializedInsertingDataFirstPart = strSerialized.substring(0, numPos1 + strCloseTag1.length);
		//strSerializedInsertingDataRestPart = strSerialized.substring(numPos1 + 1 + strCloseTag1.length);
		strSerializedInsertingDataRestPart = strSerialized.substring(numPos1  + strCloseTag1.length);
	}else{
		numPos2 = strSerialized.indexOf(strCloseTag2);
		if(numPos2 > 0){
			strSerializedInsertingDataFirstPart = strSerialized.substring(0, numPos2 + strCloseTag2.length);
			//strSerializedInsertingDataRestPart = strSerialized.substring(numPos2 + 1 + strCloseTag2.length);
			strSerializedInsertingDataRestPart = strSerialized.substring(numPos2 + strCloseTag2.length);
		}
	}
}

//sending afmAction request with client-side data string to the server
function sendingAfmActionRequestWithClientDataXMLString2Server(targetName, afmActionSerializedXSLString, clientDataXMLString)
{
	if(clientDataXMLString!=""){
		if(clientDataXMLString.indexOf("<userInputRecordsFlag>") < 0){
			clientDataXMLString = "<userInputRecordsFlag>" + clientDataXMLString + "</userInputRecordsFlag>";
		}
	}
	var strXML = "";
	//parsing afmActionSerializedXSLString into two parts
	setSerializedInsertingDataVariables(afmActionSerializedXSLString);
	//inserting client-side data
	strXML = strSerializedInsertingDataFirstPart + clientDataXMLString + strSerializedInsertingDataRestPart;
	//sending to server
	sendingDataFromHiddenForm('',strXML, targetName, '', false, '');
}

//reloading specified frame window by name
function reloadFrameWindow(frameName)
{
	var objFrame  = null;
	//passing window as initial object
	objFrame = getFrameObject(window, frameName);
	if(objFrame != null){
		if(Debug){
			//showing frame's url
			alert(objFrame.name +" href: " + objFrame.location.href);
		}
		if (document.images){
			//browsers support reload();
			objFrame.location.reload();
		}else{
			//browsers don't support reload();
			objFrame.location.href = objFrame.location.href;
		}
	}else{
		if(Debug){
			alert(Ab.view.View.getLocalizedString(z_MESSAGE_CANT_FIND_FRAME) + ' ' + frameName);
		}
	}
}

//looking up to search a specified frame object by its name
function getFrameObject(parentObj,frameName)
{
	var returnedFrameObj = null;
	if(parentObj != null){
        // first search all frames of the parentObj
		if(parentObj.frames != null){
			for(var i=0; i< parentObj.frames.length; i++){
				var arr = [];
                var name = parentObj.frames[i].name;
				if(name != null || name != ""){
					arr = name.match(frameName);
				}
				if(arr != null){
					//finding a name-matched frame object
					returnedFrameObj = parentObj.frames[i];
					break;
				}
			}
		}
		// if not found, recursively search on the next level up
		if(returnedFrameObj == null){
			if(parentObj!=window.top && parentObj.parent!=window.top)
				returnedFrameObj = getFrameObject(parentObj.parent, frameName);
		}
	}
	return returnedFrameObj;
}

//called when users push selectV button
function OpenSelectVWindow(strXMLData)
{
	//open a new browser window
	var selectValueWindowName		= "selectValueWindow";
	var selectValueWindowSettings	= "toolbar=no,menubar=no,resizable=yes,scrollbars=yes,status=yes,width=500,height=600";
	var selectValueWindow			= window.open("", selectValueWindowName,selectValueWindowSettings);
	//call sendingDataFromHiddenForm(strUrl, strSerialized, strTarget,
	//subFrameName ,bData) to target selectValueWindow
	sendingDataFromHiddenForm("dynamic-content.axvw", strXMLData, selectValueWindowName, "", false);
}

//????how to handle a few localized strings?????
//opening a separation window to show server-side error message
var objErrorMsgWindow = null;
function OpenErrorMessageWindow(window_title, show_detail_button, original_exception, stack_trace, close_window, form_name, originalException_input_name,stackTrace_input_name,stackTraceAllowed_input_name, message, abSchemaSystemJavascriptFolder, previousPage, title)
{
	//???formating html???
	if(objErrorMsgWindow == null || objErrorMsgWindow.closed){
		objErrorMsgWindow = window.open("","errorMessageDisplayWindow","menubar=no,scrollbars=yes,resizable=yes,status=yes,width=300,height=300");
	}

	//js variable schemaPath will look like "/archibus/schema".
	//ab-trigger-close-dialog.js is making error dialog window look
	//like modal window
	//temp_string = temp_string + '<script language="JavaScript" src="'+abSchemaSystemJavascriptFolder+'/ab-trigger-close-dialog.js"><\/script>';

	var temp_string = '<html><head><title>' + window_title + '<\/title>';
	temp_string = temp_string + '<script language="JavaScript">function showMessage(){var obj_originalException=document.getElementById("originalException");obj_originalException.style.display="";var obj_stackTrace=document.getElementById("stackTrace");obj_stackTrace.style.display="";}; self.moveTo(0,0); setInterval("popupItself()",100); self.focus(); function popupItself(){self.focus();};<\/script>';
	temp_string = temp_string + '<\/head><body style="margin: 0px; font-family: verdana; font-size: 12px"><center>';
	temp_string = temp_string + '<div style="width: 100%; height: 23px; background-color: #AEBAB6; color: #FFFFFF; font-weight: bold; padding-top: 3px; margin-bottom: 12px">'+title+'</div>';
	temp_string = temp_string + '<div style="width: 80%; margin-bottom: 12px">' + message + '</div>';
	temp_string = temp_string + '<div style="width: 80%; margin-bottom: 12px"><input name="detailButton" type="button" value="'+show_detail_button+'" onclick="showMessage();" style="margin-right: 8px">';
    temp_string = temp_string + '<script language="JavaScript">if(opener!=null){var stackTraceAllowed=opener.document.forms["'+form_name+'"].elements["'+stackTraceAllowed_input_name+'"].value;var detailButtonObj=document.getElementById("detailButton");if( undefined !=detailButtonObj) { if(stackTraceAllowed=="true"){detailButtonObj.style.display="";} else {detailButtonObj.style.display="none";}}}<\/script>';
    temp_string = temp_string + '<input type="button" value="'+ close_window +'" onclick="window.close()"></div>';
	temp_string = temp_string + '<div style="width: 80%; margin-bottom: 12px; display: none" id="originalException">' + original_exception + ' : <script language="JavaScript">if(opener!=null)document.write(opener.document.forms["'+form_name+'"].elements["'+originalException_input_name+'"].value);<\/script><\/div>';
	temp_string = temp_string + '<div style="width: 80%; margin-bottom: 12px; display: none" id="stackTrace">' + stack_trace + ' : <script language="JavaScript">if(opener!=null)document.write(opener.document.forms["'+form_name+'"].elements["'+stackTrace_input_name+'"].value);<\/script><\/div><\/center><\/body><\/html>';

	objErrorMsgWindow.document.write(temp_string);
	if(previousPage=='true')
		window.history.go(-1);
}

//javascript to set up cookie
function setCookie(name, value, expire)
{
	var today = new Date() ;
	if(expire == null)
		today.setTime(today.getTime() - 1);
	document.cookie = name + "=" + escape(value) + ((expire == null) ? ("; expires="+today.toGMTString()) : ("; expires=" + expire.toGMTString()))
}
//javascript to get cookie
function getCookie(name)
{
	var re = new RegExp(name + "=([^;]+)");
	var value = re.exec(document.cookie);
	return (value != null) ? unescape(value[1]) : null;
}
//trim left side of input string
function trimLeft(str)
{
	//remove all whitespaces from str's left side
	return str.replace(/^\s+/,'');
}
//trim right side of input string
function trimRight(str)
{
	//remove all whitespaces from str's right side
	return str.replace(/\s+$/,'');
}
//trim left and right sides of input string
function trim(str)
{
	if (str) {
		var temp_str = trimLeft(str);
		return trimRight(temp_str);
	}
	return str;
}

//open content
function openNewContent(requestUrl, target)
{
	openNewContent(requestUrl, target, "");
}
function openNewContent(requestUrl, target, selectValueWindowconfig)
{
	var selectValueWindowSettings = "toolbar=no,menubar=no,resizable=yes,scrollbars=yes,status=yes,width=450,height=450,left=10,top=10";
	if (selectValueWindowconfig != null && selectValueWindowconfig != "") {
		selectValueWindowSettings = selectValueWindowconfig;
	}

	if (target == "_blank" || target == "") {
		var selectValueWindowName = "newWindow";

		var selectValueWindow = window.open(requestUrl, selectValueWindowName, selectValueWindowSettings);
		
		// return new window object so caller can set focus if desired
		return selectValueWindow;
	}
	else {
		//target to frame
		var objHiddenForm = document.forms[afmHiddenFormName];
		objHiddenForm.target = target;
		objHiddenForm.action = requestUrl;
		objHiddenForm.submit();
	}
}
//working in IE and NN7.1
//usage: <input type="text" value="" name="" onkeypress="return disableInputEnterKeyEvent( event)"/>
function disableInputEnterKeyEvent(event)
{
	var keyCode = event.keyCode ? event.keyCode : event.which ? event.which : event.charCode;
	if (keyCode == 13)
		return false;
	else
		return true;
}
//changing five special characters into valid XML characters

 //make sure that never convert any field values more than one times
 //otherwise, five special characters will be messed up.
 function convert2validXMLValue(fieldValue)
 {
	////must first convert & character////
	//make sure that existing "&amp;" in user's input will not become "&amp;amp;"!!!
	fieldValue = fieldValue.replace(/&amp;/g, '&')
	fieldValue = fieldValue.replace(/&/g, '&amp;')
	/////////////////////////////////////////////
	fieldValue = fieldValue.replace(/>/g, "&gt;");
	fieldValue = fieldValue.replace(/</g, "&lt;");
	fieldValue = fieldValue.replace(/\'/g, "&apos;");
	fieldValue = fieldValue.replace(/\"/g, '&quot;');
	return fieldValue;
 }
 // performs the conversion opposite to convert2validXMLValue()
 function convertFromXMLValue(fieldValue){
	 if(valueExistsNotEmpty(fieldValue)){
		fieldValue = fieldValue.replace(/&amp;/g, '&')
		fieldValue = fieldValue.replace(/&gt;/g, '>');
		fieldValue = fieldValue.replace(/&lt;/g, '<');
		fieldValue = fieldValue.replace(/&apos;/g, '\'');
		fieldValue = fieldValue.replace(/&quot;/g, '\"');
	 }
	 return fieldValue;
 }
 //AND literalize Value for sql statement
 function convert2validXMLValueAndLiteralizeValue(fieldValue)
 {
	////must first convert & character////
	//make sure that existing "&amp;" in user's input will not become "&amp;amp;"!!!
	 fieldValue = fieldValue.replace(/&amp;/g, '&')
	 fieldValue = fieldValue.replace(/&/g, '&amp;')
	/////////////////////////////////////////////
	 fieldValue = fieldValue.replace(/>/g, "&gt;");
	 fieldValue = fieldValue.replace(/</g, "&lt;");
	//double ' for SQL statement
	 fieldValue = fieldValue.replace(/\'/g, "&apos;&apos;");
	 fieldValue = fieldValue.replace(/\"/g, '&quot;');
	 return fieldValue;
 }
 //handling memo field value when being sent to server
 //make sure that never convert any field values more than one times
 //otherwise, five special characters will be messed up.
 function convertMemo2validateXMLValue(fieldValue)
 {
	 //normal convertion
	 fieldValue = convert2validXMLValue(fieldValue);
	 //handling new line feeding characters: \r\n
	 var regular_expression = new RegExp ('\r\n', 'gi') ;
	 //never change the name "#AFM_FLAG_NEWLINE#"!!!!!
	 fieldValue = fieldValue.replace(regular_expression,"#AFM_FLAG_NEWLINE#");
	 //handling new line feeding characters: \n
	 var regular_expression_n = new RegExp ('\n', 'gi') ;
	 fieldValue = fieldValue.replace(regular_expression_n,"#AFM_FLAG_NEWLINE#");
	 //handling new line feeding characters: \r
	 var regular_expression_r = new RegExp ('\r', 'gi') ;
	 fieldValue = fieldValue.replace(regular_expression_r,"#AFM_FLAG_NEWLINE#");

	 return fieldValue;
 }
//insert a view name for rendering when afmAction is excuted by server
function insertRenderedAXVWFile2AfmAction(strAfmActionSerialized, renderedAXVWFileName)
{
      var xmlDoc= parseXml(unescape(strAfmActionSerialized), null, true);
      var afmActions=xmlDoc.getElementsByTagName('afmAction');
      for(var i=0; i <afmActions.length; i++){
          var stateAttrib = afmActions[i].getAttribute('state');
          if(!stateAttrib){
            stateAttrib=xmlDoc.createAttribute("state");
            stateAttrib.value=renderedAXVWFileName;
            afmActions[i].setAttributeNode(stateAttrib);
          } else {
            afmActions[i].setAttribute("state",renderedAXVWFileName);
          }
      }
      return serializingXML(xmlDoc);
 }


 //opening none axvw files such as html, PDF, and MS Word/EXCEL/PPT
 //when URL comes from two different domain, new window must be used
 //projectGraphicsFolder: archibus/../.../ in which folder the opened file is
 //located;
 //referredFileName: opened file name;
 //bNewWindow: true|false
 function openNoneAXVWFile(relativeWebRootFolderName, referredFileName, bNewWindow)
 {
	 if(relativeWebRootFolderName != "" && referredFileName != ""){
		 //weblogic server: ?a=1;?????
		 var urlLink =  relativeWebRootFolderName + "/" + referredFileName + "?a=1";
		 if(bNewWindow){
			 var newWindowName		= "newWindow";
			 var newWindowSettings	= "toolbar=no,menubar=no,resizable=yes,scrollbars=yes,status=yes,width=450,height=450";
			 var newWindowObject = window.open(urlLink, newWindowName,newWindowSettings);
		 }else{
			 window.location.href = urlLink;
		 }
	 }
 }
 /////////////////////////////////////////////
 //XXX: export reports
  //opening the printable pdf report
 var loadingPdfGeneratingView = false;
 function openPdfGeneratingView(xml)
 {
	 if(xml!=null && xml!=""){
		 loadingPdfGeneratingView = true;
		 strPdfAfmActionSerialized = xml;
		 var selectValueWindowSettings	= "toolbar=no,menubar=no,resizable=yes,scrollbars=yes,status=yes,width=800,height=600";
		 strPdfGeneratingViewUrl="ab-generating-pdf.axvw";
		 openNewContent(strPdfGeneratingViewUrl, "_blank", selectValueWindowSettings);
	 }
 }
 //opening the printable excel report
 var loadingExcelGeneratingView = false;
 function openExcelGeneratingView(xml)
 {
	 if(xml!=null && xml!=""){
		 loadingExcelGeneratingView = true;
		 strExcelAfmActionSerialized = xml;
		 var selectValueWindowSettings	= "toolbar=no,menubar=no,resizable=yes,scrollbars=yes,status=yes,width=800,height=600";
		 var excelGeneratingViewUrl="ab-generating-excel.axvw";
		 openNewContent(excelGeneratingViewUrl, "_blank", selectValueWindowSettings);
	 }
 }

////////////////////////////////////////////////
function insertXML2AfmActionXML(xml, data)
{
	setSerializedInsertingDataVariables(xml);
	if(data != "")
		xml = strSerializedInsertingDataFirstPart + data +  strSerializedInsertingDataRestPart;
	return xml;
}
//////////////////////////////////////////////////////////////////////

function getXmlAttribute(fieldId, xpath, name)
{
	var node = selectSingleNode(null, fieldId, xpath);
	if(node==null)return;
	return node.getAttribute(name);
}

function setXmlAttribute(fieldId, xpath, name, value)
{
	var fieldObject = $(fieldId);
	if(fieldObject==null)return;

	var xml=fieldObject.value;
	var xmlDocument = parseXml(xml, null, true);
	var nodes = selectNodes(xmlDocument, null, xpath);
	if(nodes==null || nodes.length==0)return;

	for(var i=0; i<nodes.length; i++){
		nodes[i].setAttribute(name,value);
	}

	fieldObject.value=serializingXML(xmlDocument);
}

function parseXml(xmlString, fieldId, bEncoding)
{
	var xml = "";
	if(xmlString!=null && xmlString!=""){
		xml = xmlString;
	}else{
		var fieldObject = $(fieldId);
		if(fieldObject==null) return null;
		xml = fieldObject.value;
	}

	if(xml==null || xml==""){
		return;
	}
	if(bEncoding){
		xml = xml.replace(/&gt;/g, ">");
		xml = xml.replace(/&lt;/g, "<");
		xml = xml.replace(/&quot;/g, '"');
		xml = xml.replace(/\'\'/g, '"');
	}

	var xmlDocument = null;
	if (window.ActiveXObject) {
		xmlDocument = new ActiveXObject('Microsoft.XMLDOM');
		xmlDocument.async = false;
		var loaded = xmlDocument.loadXML(xml);
	}else if(document.implementation && document.implementation.createDocument){
		xmlDocument = document.implementation.createDocument("","",null);
		xmlDocument.async = false;
		var objDOMParser = new DOMParser();
		xmlDocument = objDOMParser.parseFromString(xml, "text/xml");
		objDOMParser=null;
	}

	return xmlDocument;
}

function serializingXML(xmlDocument)
{
	var result="";
	if (window.ActiveXObject) {
		result = xmlDocument.xml;
	}else if(document.implementation && document.implementation.createDocument){
		var objXMLSerializer = new XMLSerializer;
		result = objXMLSerializer.serializeToString(xmlDocument);
		objXMLSerializer = null;
	}
	return result;
}

function selectNodes(xmlDocument, fieldId, xpath)
{
	var result=[];
	if(xmlDocument==null)
		xmlDocument = parseXml(null, fieldId, true);

	if(xmlDocument==null)return null;

	if (window.ActiveXObject) {
		result = xmlDocument.selectNodes(xpath);
	}else if(document.implementation && document.implementation.createDocument){
		var tempResult = xmlDocument.evaluate(xpath, xmlDocument,null, XPathResult.ANY_TYPE,null);
		var i=0;
		while (tempNode=tempResult.iterateNext()) {result[i++] = tempNode;}
	}
	return result;
}

function selectSingleNode(xmlDocument, fieldId, xpath)
{
	var result=null;
	var nodes = selectNodes(xmlDocument, fieldId, xpath);
	if(nodes!=null)
		result = nodes[0];
	return result;
}
//return localized message
function getMessage(name){
	var result = name;
    
    var message = View.messages[name];
    if (valueExists(message)) {
        result = message;
    }

	return replaceHTMLPlaceholders(result);
}
// replace [ and ] placeholders by HTML < and > brackets        
function replaceHTMLPlaceholders(message) {
    result = message.replace(/\[/g, '<');
    result = result.replace(/\]/g, '>');
    result = result.replace(/&apos;/g, '\'');
    return result;
}

function setPanelTitle(panelName, title) {
    var panelTitleTD = $(panelName + '_title');
    if (panelTitleTD != null) {
        panelTitleTD.innerHTML = title;
    }
}


function getPanelTitle(panelName) {
    var title = '';
    var panelTitleTD = $(panelName + '_title');
    if (panelTitleTD != null) {
        title = panelTitleTD.innerHTML;
    }
    return title;
}

function endsWith(str, suffix){
	return str.indexOf(suffix, str.length - suffix.length) !== -1;
}

//////////////////////////////////////////////////////////////////////////



//all of them are coming from server-side: xml's locale
//all default values are overwritten by XML's locale settings
//holding each month's name
var arrMonthNames		= new Array();
//holding each part of date short pattern
//overwitten in locale.xsl
var arrDateShortPattern	= new Array();
var strCurrencySign		= "$";
var strDecimalSeparator	= ".";
var strDateShortPattern	= "";
var strDateLongPattern	= "dddd, MMMM dd, yyyy";
var strGroupingSeparator = ",";
var timePattern	= "H:MM:SS TT";
var arrTimeAmPmSigns = new Array();
var bDefaultDateShortFormat = true;
var bDefaultTimeFormat = true;
var strLocaleName = "en_US";
var intFirstDayOfWeek = 1;

//most of following functions are called by locale.xsl
//Set javascript locale variables
function SetLocaleCommonJSVariables(name, value, firstDayOfWeek){
	var strName = name.toUpperCase();
	var strValue = "" + value;
	if (valueExists(firstDayOfWeek)){
		intFirstDayOfWeek = firstDayOfWeek;	
	}
    if (strName == "DECIMALSEPARATOR"){
		strDecimalSeparator = strValue;
	}else if (strName == "GROUPINGSEPARATOR"){
		strGroupingSeparator = strValue.toUpperCase();
	}else if(strName == "NAME"){
		strLocaleName = strValue;
	}
}
function SetLocaleDateJSVariables(name, value){
	
	var strName = name.toUpperCase();
	var strValue = "" + value;
	if (strName == "MONTHNAMES"){
		//the delimit in month names string can be "," or ";"
		//arrMonthNames = strValue.split(/,|;/); not working in NN7.1
		arrMonthNames = strValue.split(",");
		if(arrMonthNames[1]==null)
			arrMonthNames = strValue.split(";");
	}else if (strName == "FORMAT" && strValue != ""){
		//since this one is set up in afm-config.xml, just use it
		//directly???????
		//if there is "format", use it
		//otherwise use "short"
		strDateShortPattern = strValue.toUpperCase();
		//strDateShortPattern = strDateShortPattern.replace(/\'MM/g, " MM");
		//strDateShortPattern = strDateShortPattern.replace(/\'DD/g, " DD");
		//strDateShortPattern = strDateShortPattern.replace(/\'M/g, " M");
		//strDateShortPattern = strDateShortPattern.replace(/\'D/g, " D");
		//if(bRemovingSingleQuotaFromDateFormat(strValue.toUpperCase()))
		//	strDateShortPattern = strDateShortPattern.replace(/\'/g, "");
		strDateShortPattern = trim(strDateShortPattern);
		bDefaultDateShortFormat = false;
		SetDateShortArray();
	}else if (strName == "SHORT" && strValue != "" && bDefaultDateShortFormat){
		strDateShortPattern = strValue.toUpperCase();
		strDateShortPattern = strDateShortPattern.replace(/\'MM/g, " MM");
		strDateShortPattern = strDateShortPattern.replace(/\'DD/g, " DD");
		strDateShortPattern = strDateShortPattern.replace(/\'M/g, " M");
		strDateShortPattern = strDateShortPattern.replace(/\'D/g, " D");
		if(bRemovingSingleQuotaFromDateFormat(strValue.toUpperCase()))
			strDateShortPattern = strDateShortPattern.replace(/\'/g, "");
		strDateShortPattern = trim(strDateShortPattern);
		SetDateShortArray();
	}else if (strName == "LONG"){
		strValue = strValue.toUpperCase();
		var strTemp = strValue;
		///?????
		//strValue = strValue.
		//used in the hints for date fields
		//Chinese|Korean|Japanese
		strValue = strValue.replace(/\'MM/g, " MM");
		strValue = strValue.replace(/\'DD/g, " DD");
		strValue = strValue.replace(/\'M/g, " M");
		strValue = strValue.replace(/\'D/g, " D");
		if(bRemovingSingleQuotaFromDateFormat(strTemp))
			strValue = strValue.replace(/\'/g, "");
		//remove EEEE or (EE) or EE
		strValue = strValue.replace("EEEE,", "");
		strValue = strValue.replace("EEEE", "");
		strValue = strValue.replace("(EE)", "");
		strValue = strValue.replace("EE", "");
		//Spanish
		strValue = strValue.replace("'MMMM'", "MM");
		strValue = strValue.replace("'YYYY", "YYYY");
		strValue = strValue.replace("D'", "D");
		//change OF back to de??????
		//strValue = strValue.replace(/DE/g, "OF");
		strValue = trim(strValue);

		strDateLongPattern = strValue;

	}
}
function SetLocaleTimeJSVariables(name, value){
	var strName = name.toUpperCase();
	var strValue = "" + value;
	if(strValue!=""){
		//italian time java issue:
		strValue = strValue.replace('H.', 'H:');
		
		if(strName == "FORMAT" ){
			//similar with date format
			timePattern = strValue;
			bDefaultTimeFormat = false;
		}else if(strName == "SHORT"  && bDefaultTimeFormat){
			 if(strValue.indexOf("H:")==0){
			       strValue = "H"+strValue;
			    }
				timePattern = strValue;
		}else if (strName == "AMPMSTRINGS"){
			//separator can be "," or ";"
			//arrTimeAmPmSigns = strValue.split(/,|;/); not working in
			//NN7.1
			arrTimeAmPmSigns = strValue.split(",");
			if(arrTimeAmPmSigns[1]==null)
				arrTimeAmPmSigns = strValue.split(";");
		}
	}
}
//getting date_separator from date in its short format
//if str = "mm/dd/yyyy", the output will be "/"
function GetDateSeparator(strInput){
	strInput = strInput.toUpperCase();
	var strChar = "";
	var strReturned = "";
	for(var i = 0; i < strInput.length; i++){
		strChar = strInput.charAt(i);
		//checking if only "Y|M|D" is used?
		if(strChar != "Y" && strChar != "M" && strChar != "D"){
			strReturned = strChar;
			break;
		}
	}
	return strReturned;
}
//set up a array to hold date short pattern
//like arrDateShortPattern = {"MM", "DD", "YYYY"};
function SetDateShortArray(){
	var strDateSeparator = GetDateSeparator(strDateShortPattern);
	var strTemp = "strDateShortPattern.split(/\\"+strDateSeparator+"/)";
	arrDateShortPattern = eval(strTemp);
}

//checking if it's need to remove single quota ' from date format
function bRemovingSingleQuotaFromDateFormat(format){
	return ((format.match("'MMMM'")!=null) || (format.match("YYYY'")!=null));
}




//this function will format date according to the specified date format
//format is in UpperCase
//input (17, 6, 2002, "dddd, mmm dd, yyyy") ==> "June 17, 2002"(long
//format)
//("dddd" in date long format is ignored in this application)
//input (17, 06, 2002, "mm/dd/yyyy") ==> "06/17/2002" (short format)
function FormattingDate(day, month, year, format)
{
	var strFormat		=	format + "";
	var returnedResult	=	"";
	var numCounter		=	0;
	var strChar			=	"";
	var strToken		=	"";
	var arrValue		=	new Array();
	//converting "05" into "5" 
	day		= parseInt(day, 10);
	month	= parseInt(month, 10);
	year	= parseInt(year, 10);
	//year format: yyyy/YYYY/yyy/YYY/Y/Y ==> 4 digits; YY/yy ==> 2
	//digits 0-30 are 2000 years, and 31-99 are 1900 years.
	if(year <= 30)
		year = 2000+year;
	if(year>30 && year<=99)
		year = 1900+year;
	if(year > 99 && year <= 999)
		year = 2000+year;
	
	year = year + "";
	arrValue["YYYY"]	=	arrValue["YYY"] = arrValue["Y"] = year;
	arrValue["YY"]		=	year.substring(2,4);

	//month format: M/M/MM/mm ==> 2 digits; MMMM/mmmm/MMM/mmm ==> full
	//month names digits
	if(month > 12)
		month = 12;

	arrValue["M"]	 =	month;
	arrValue["MM"]	 = (month<10)?("0"+month):month;
	arrValue["MMM"]	 = arrValue["MMMM"] = arrMonthNames[month-1];
	//don't show any week days if date format contains "DDDD" or "DDD"
	arrValue["DDD"]  = arrValue["DDDD"] = "";

	//day format: DD/dd/D/d ==> 2 digits
	arrValue["DD"] = (day<10)?("0"+day):day;
	//Spanish?????
	var objSP = (format.match("DE"));
	if(objSP!=null){
		arrValue["DE"]  = "de";
		arrValue["E"]  = "";
	}
	arrValue["D"]  = day;

	while (numCounter < strFormat.length){
		strChar = strFormat.charAt(numCounter);
		strToken = "";
		while ((strFormat.charAt(numCounter)==strChar) && (numCounter < strFormat.length)){
			strToken += strFormat.charAt(numCounter++);
		}
		
		if((objSP!=null) && (strFormat.charAt(numCounter)=='E')){
			strToken = strToken + "E";
		}
		if (arrValue[strToken] != null){
			if(strToken=="DDD" || strToken=="DDDD")
				numCounter = numCounter + 1;
			returnedResult	=	returnedResult + arrValue[strToken];
		}else
			returnedResult	=	returnedResult + strToken;
	}
	return returnedResult;
}

//this function is formatting user's input time according to specified
//format (second pattern is ignored in this application)
//format is in UpperCase
//format with "tt" or "t" ==> 12-hours otherwise 24-hours
//if parameter ampm is "", AM or PM will not be shown in output string
//if format is "HH:MM tt" and input is "2 33 p" ==> "02:33 PM" (12-hours)
//if format is "H:MM tt" and input is "2 33 p" ==> "2:33 PM" (12-hours)
//if format is "H:MM" and input is "2 33" ==> "2:33" (24-hours)
//if format is "HH:MM" and input is "22 33" ==> "22:33" (24-hours)
function FormattingTime(hour, minute, ampm, format)
{
	
	format = format.toUpperCase();
	var strFormat		=	format + "";
	var returnedResult	=	"";
	var numCounter		=	0;
	var strChar			=	"";
	var strToken		=	"";
	var arrValue		=	new Array();
	hour	= parseInt(hour, 10);
	minute	= parseInt(minute, 10);
	if(isInteger(hour)){
		//"HH" must be first search!!!
		if(strFormat.search("HH")>=0){
			while(hour > 24)
				hour = (hour > 24) ? (hour-24): hour;
		}else if(strFormat.search("H")>=0){
			while(hour > 12)
				hour = (hour>12) ? (hour-12): hour;
		}
	}

	if(isInteger(hour)){
		arrValue["H"] = (hour==0)?12:hour;
		arrValue["HH"] = (hour<10)?("0"+hour):hour;
	}else{
		arrValue["H"] = "H";
		arrValue["HH"] = "HH";
	}

	if(isInteger(minute)){
		arrValue["MM"] = (minute<10)?("0"+minute):minute;
		arrValue["M"]	= minute;
	}else{
		arrValue["MM"] = "MM";
		arrValue["M"]	= "M";
	}
	arrValue["TT"] = arrValue["T"] = arrValue["A"] = arrValue["AM"]  =  arrValue["P"] = arrValue["PM"] = ampm;
	arrValue["Z"]  = arrValue["ZZZZ"]  =  ""; //zone pattern in time format
	arrValue["S"]  = arrValue["SS"]    =  ""; //second pattern in time format
	while (numCounter < strFormat.length){
		strChar = strFormat.charAt(numCounter);
		strToken = "";
		while ((strFormat.charAt(numCounter)==strChar) && (numCounter < strFormat.length)){
			strToken += strFormat.charAt(numCounter++);
		}
		if (arrValue[strToken] != null){
			if(strToken=="SS" || strToken=="S"){
				//removing separator sign ahead of SS
				if(returnedResult.length > 1)
					returnedResult = returnedResult.substring(0, returnedResult.length-1);
			}
			returnedResult	=	returnedResult + arrValue[strToken];
		}else
			returnedResult	=	returnedResult + strToken;
	}
	return returnedResult;
}

//this function will covert user's input alphabetic month into a number
//when users type feb... in date field, this function will return 2
function MonthNameToMonthNum(strInput)
{
	var strTemp = "";
	var strMonthName = "";
	var strReturned = 0;
	for (var i = 0; i < 12; i++){
		strMonthName = (arrMonthNames[i]).toLowerCase();
		strTemp = strInput.toLowerCase();
		//if user's input is not found in arrMonthNames,
		//return 0
		if (strMonthName.substring(0,strTemp.length)==strTemp){
			strReturned = i+1;
			break;
		}
	}
	return strReturned;		
}

//this function is used to get the max days in input month/year
//(leap-year is processed in this function) 
function GetMonthMaxDays(numMonth, numYear)
{
	var numReturned = -1;
	if(numMonth < 0)
		numMonth = 1;
	if(numMonth > 12)
		numMonth = 12;
	if(numYear<0)
		numYear = 0;
	
	for(var i = 0; i < 12; i++){
		if((numMonth-1) == i){
			if(i == 0 || i == 2 || i == 4 || i == 6 || i == 7 || i == 9 || i == 11)
				numReturned = 31;
			else if (i == 3 || i == 5 || i == 8 || i == 10)
				numReturned = 30;
			else{
				// leap-year / february / days
				if ((numYear % 4 == 0) || (numYear % 100 == 0) || (numYear % 400 == 0))
					numReturned = 29;
				else
					numReturned = 28;
			}
			break;
		}
	}
	return numReturned;
}

//this function will validate user's input date string when users type date into date fields
//the validation will depend on the order of year, month, and day in
//date short format and covert the input into localized date in its short
//pattern
//tempObj: form's element object
//fieldID: the id for form's element
//dateArrayObj: to hold Year/Month/Day
//bRequired: if the date field is required in edit forms
//bShow: if showing date hint in date long-format
//sReplaced("true" or "false"): if replacing the value in date field input
function validationAndConvertionDateInput(tempObj, fieldID, dateArrayObj , sRequired, bShow, bReplaced)
{
	var bRequired = false;
	//sRquired is initially a string value??? make it as boolean
	if(sRequired == "true")
		bRequired = true;
	else
		bRequired = false;
	//user's date input value
	var value = tempObj.value;
	//trim() is defined in common.js
	value = trim(value);
	var temp_curDate = new Date();
	var year	=	"";
	var month	=	"";
	var day		=	"";
	var tempArrDate = new Array();
	
    //dateArrayObj is defined for handling form's loading since XML
    //will use neutral formats for edit-forms??
    if(dateArrayObj != null){
        //there is already known date's year, month, and day
        //year
        year = dateArrayObj[0];
        //month
        month = dateArrayObj[1];
        //day
        day = dateArrayObj[2];
    }else if (value != null && value!= ""){
        if(isBeingISODateFormat(value)){
            tempArrDate["year"] = value.split("-")[0];
            tempArrDate["month"]= value.split("-")[1];;
            tempArrDate["day"] = value.split("-")[2];;
        }else
            tempArrDate = gettingYearMonthDayFromDate(value);
        //if(tempArrDate != null)
        {
            year = tempArrDate["year"];
            month = tempArrDate["month"];
            day = tempArrDate["day"];
        }
    }
    
    //replacing input's date by new date in its localized short format
    //type new date or existing date from record or required 
    if((bReplaced && value != null && value != "" || bReplaced && dateArrayObj!=null && dateArrayObj.length > 1) || bRequired ){
		
		if(year=="")
			year = temp_curDate.getFullYear();
		if(month=="")
			month = temp_curDate.getMonth()+ 1;
		if(day=="")
			day	  = temp_curDate.getDate();
		//alert(day+"//"+month+"//"+year);
		//alert(strDateShortPattern);
		tempObj.value =  FormattingDate(day, month, year, strDateShortPattern);
		
		// SK: need to set the value so that it's displayed in the date hint below
		value = tempObj.value;
		
		//readOnly Date fields???? fixed ID format
		var showDateShortFormatID = "Show" + fieldID + "_short";
		var temp_obj_date_short = document.getElementById(showDateShortFormatID);
		if(temp_obj_date_short!=null){
			temp_obj_date_short.innerHTML = FormattingDate(day, month, year, strDateShortPattern);
		}
		var showDateLongFormatID = "Show" + fieldID + "_long";
		var temp_obj_date_long = document.getElementById(showDateLongFormatID);
		if(temp_obj_date_long!=null){
			temp_obj_date_long.innerHTML = FormattingDate(day, month, year, strDateLongPattern);
		}
	}
	
	//showing the date hint in its long date format if bowser is IE5- and netscape6-
	if(bShow){
		var strShowingDate;
		//strShowingDate will be used to show user's validated date input in
		//date long format (whithout dddd in this application like "March
		//22, 2002")
		//strDateLongPattern,strDateShortPattern are defined in
		//locale.js 
		if(bRequired || (value != null && value!= "") ){
			if(year=="")
				year = temp_curDate.getFullYear();
			if(month=="")
				month = temp_curDate.getMonth()+ 1;
			if(day=="")
				day	  = temp_curDate.getDate();
			strShowingDate =  FormattingDate(day, month, year,  strDateLongPattern);
		}else{
			// kb# 3016317
			// do not show date pattern for read only fields
			if(arrFieldsInformation[fieldID] != null && arrFieldsInformation[fieldID]["readOnly"] == "true"){
				//showing the short-date format, so users can type date in
				strShowingDate = "";
			} else {
				strShowingDate = strDateShortPattern;
			}
		}
		//"Show" is fixed prefix for hint field ID which is defined in
		//edit-form-data.xsl
	
		var showLongFieldID = "Show" + fieldID + "_long";
		var showLongDateFieldObj = null;
		if(document.all){
			showLongDateFieldObj = document.all[showLongFieldID];
		}else if(!document.all && document.getElementById){
			showLongDateFieldObj = document.getElementById(showLongFieldID);
		}
		if(showLongDateFieldObj != null)
			showLongDateFieldObj.innerHTML = strShowingDate;

	}
}
//XXX:  Just call one time per user's change with time field input!!!!!!!
//convert user's input into valid time in a localized format
//tempObj: form's element object
//fieldID: the id for form's element
//TimeArrayObj: to hold hour/minute
//bRequired: if the time field is required in edit forms
//bShow: if showing time hint
//sReplaced("true" or "false"): if replacing the value in time field input
function validationAndConvertionTimeInput(tempObj, fieldID,  TimeArrayObj, sRequired, bShow, bReplaced)
{
	// we need to set the time hint even though no need to change the time field
	//if(window.temp==tempObj.value)
	//	return;

	var bRequired = false;
	//sRquired is initially a string value??? make it as boolean
	if(sRequired == "true")
		bRequired = true;
	else
		bRequired = false;
	var value				= tempObj.value;
	//trim() is defined in common.js
	value					= trim(value);
	var curDate				= new Date();
	var hoursNow			= curDate.getHours();
	var minsNow				= curDate.getMinutes();
	var tokens				= value.match(/\w+/g);
	
	// get the current second in "SS" format	
	var secsNow				= curDate.getSeconds();
	var secondNumber = parseInt(secsNow);
	if(secondNumber >= 0 && secondNumber < 10){
		secsNow = "0" + secsNow;
	}
	
	//default values which are overwritten by XML's locale settings
	var am	= "AM";
	var pm	= "PM";		  
	if(arrTimeAmPmSigns != null){
		if(arrTimeAmPmSigns[0] != null && arrTimeAmPmSigns[0] != "")
			am = arrTimeAmPmSigns[0];
		if(arrTimeAmPmSigns[1] != null && arrTimeAmPmSigns[1] != "")
			pm = arrTimeAmPmSigns[1];
	}
	var AM_PM = "";//((hoursNow >= 0) && (hoursNow < 12))?am:pm;

	// if user pass in the time array, this is the value we are use to set the time value
	if(TimeArrayObj != null){
		if(TimeArrayObj[0] != null && TimeArrayObj[0] != ""){
			// set AM_PM toggle according to hour
			var hourNumber = 0;
			hoursNow = TimeArrayObj[0];
			hourNumber = parseInt(hoursNow);
			AM_PM = ((hourNumber >= 0) && (hourNumber < 12))?am:pm;
		}
		if(TimeArrayObj[1] != null && TimeArrayObj[1] != ""){
			minsNow = TimeArrayObj[1];
			//time value could be "01:24 AM" or "01:24.00.000"
			minsNow = minsNow.substring(0, 2);
			
			// if minutes part contains AM/PM as last 2 characters
		    var minsLength = TimeArrayObj[1].length;
			if (minsLength > 2) {
			    var nextToMinutes = TimeArrayObj[1].substring(minsLength - 2, minsLength);
			    if (nextToMinutes == am || nextToMinutes == pm) {
			        AM_PM = nextToMinutes;
			    }
			}
		}
		if(TimeArrayObj[2] != null && TimeArrayObj[2] != ""){
			secsNow = TimeArrayObj[2];
		} else {
			secsNow = "00";
		}
	} else if (value != null && value != ""){
		if(tokens){
			// if user change the edit form time manually, the second will default to "00"				
			secsNow = "00";

			if(tokens.length == 1) {
				//time input string like: "1233" or "1233am" or "1233a"
				var temp_time = "";
				var temp_AMFM = "";
				var temp_index = 0;
				for(var i = 0; i < value.length; i++){
					var char_temp = value.charAt(i);
					if (isInteger(char_temp))
						temp_time = temp_time + char_temp;
					else
						temp_AMFM = temp_AMFM + char_temp;
				}
				if((temp_AMFM != '') || (temp_AMFM == value)){
					AM_PM = temp_AMFM;
				}

				if(temp_time != ''){
					if(temp_time.length == 4){
						hoursNow = temp_time.substring(0,2);
						minsNow  = temp_time.substring(2);
					}else if(temp_time.length == 3){
						hoursNow = temp_time.substring(0,1);
						minsNow  = temp_time.substring(1);
					}else if(temp_time.length <= 2){
						hoursNow = temp_time;
						minsNow=0;
					}
				}
			}else if(tokens.length == 2){
				//time input string like: "12 33" or "1233 am" or "1233 a" or "12 33am" or "12 33a"
				if(isInteger(tokens[0])){
					if(tokens[0].length == 4){
						hoursNow = tokens[0].substring(0,2);
						minsNow  = tokens[0].substring(2);
						if(!isInteger(tokens[1]))
							AM_PM = tokens[1];
					}else if(tokens[0].length == 3){
						hoursNow = tokens[0].substring(0,1);
						minsNow  = tokens[0].substring(1);
						if(!isInteger(tokens[1])){
							AM_PM = tokens[1];
							minsNow=0;
						}

					}else if(tokens[0].length <= 2){
						hoursNow = tokens[0];
						if(isInteger(tokens[1]))
							minsNow = tokens[1];
						else{
							minsNow=0;
							if(!isInteger(tokens[1].substring(0, 1)))
								AM_PM = tokens[1];
							else{
								if(!isInteger(tokens[1].substring(1, 2))){
									minsNow = tokens[1].substring(0, 1);
									AM_PM = tokens[1].substring(1);
								}else{
									minsNow = tokens[1].substring(0, 2);
									AM_PM = tokens[1].substring(2);
								}
							}
						}
					}
				}
			}		else if(tokens.length == 3){
				//time input string like: "12:33 am" or "12 33 am" or "12:33 a" or "am 12 33"
				var temp_pos = 0;
				for(var j = 0; j < tokens.length; j++){
					if(!isInteger(tokens[j])){
						AM_PM = tokens[j];
						temp_pos = j;
					}
				}
				if(temp_pos == 2){
					if(isInteger(tokens[0]))
						hoursNow = tokens[0];
					if(isInteger(tokens[1]))
						minsNow  = tokens[1];
				}else if(temp_pos == 0){
					if(isInteger(tokens[1]))
						hoursNow = tokens[1];
					if(isInteger(tokens[2]))
						minsNow  = tokens[2];
				}else{
					if(isInteger(tokens[0]))
						hoursNow = tokens[0];
					if(isInteger(tokens[2]))
						minsNow  = tokens[2];
				}
			}
		}
		hoursNow = parseInt(hoursNow,10);
		minsNow = parseInt(minsNow,10);
		var temp_firstCharacter_AM_PM = AM_PM.toUpperCase();

		// if input doesn't include AM / PM value, use previous val if hour and minute haven't changed, else give preference to AM
		// note: am.toUpperCase().match(temp_firstCharacter_AM_PM) == true ALWAYS when temp_firstCharacter_AM_PM == ''
		if (temp_firstCharacter_AM_PM == '' ) {
			var timeLongFormatElemID = "Show" + fieldID;
			var timeLongFormatElem = document.getElementById(timeLongFormatElemID);
			if (timeLongFormatElem != null) {
				var longFormatTokens = timeLongFormatElem.innerHTML.match(/\w+/g);
				if (typeof longFormatTokens!='undefined' && longFormatTokens!=null && tokens[0] == longFormatTokens[0] && tokens[1] == longFormatTokens[1]) {
					AM_PM = longFormatTokens[2];
				}
				else {
					AM_PM = am;
				}
			}
			else {
				AM_PM = am;
			}
		}
		else if (temp_firstCharacter_AM_PM =="A" || am.toUpperCase().match(temp_firstCharacter_AM_PM) ) {
			AM_PM = am;
		}
		else {
			//AM_PM = pm;
			var temp_format1 = curDate.format1();
			AM_PM = (temp_format1.indexOf("AM") != -1) ? am : pm; 
		}

		if(minsNow >=60 ){
			hoursNow = hoursNow + Math.floor(minsNow/60);
			minsNow = (minsNow % 60);
		}
		
		if (hoursNow % 12 == 0) AM_PM = pm;
		// Update AM/PM if 24 hour time was entered		
		// If hoursNow is between 1 and 12, stick with the current am/pm value
		if (hoursNow % 24 == 0) AM_PM = am;  // 00 or 24 entered as hour
		if (hoursNow % 24 > 12)	AM_PM = pm;  // 13 to 23 entered as hour
		
		//make sure all are valid
		if(isNaN(hoursNow))
			hoursNow = curDate.getHours();
		if(isNaN(minsNow))
			minsNow = curDate.getMinutes();
	}
	//save 24-format to a hidden input for being sent to server
	{
		// correct 24 hour time when pm was specified
		var hours24 = (hoursNow < 12 && AM_PM==pm) ? (hoursNow+12) : hoursNow;
		// special case: midnight == 00
		hours24 = (hours24 == 12 && AM_PM==am) ? 0 : hours24;

		// Store 24h time(HH:mm:ss.sss) in hidden field
		var strStoredName = "Stored" + tempObj.name;
		var hiddenTimeFieldObj = null;
		if(document.all){
			hiddenTimeFieldObj = document.all[strStoredName];
		}else if(!document.all && document.getElementById){
			hiddenTimeFieldObj = document.getElementById(strStoredName);
		}
		if(hiddenTimeFieldObj != null){
			// if the time value in the form is empty and we try to set the time value 
			// from client side js (i.e room reservation console form).
			if(bReplaced && (value==null || value=="" ) && TimeArrayObj!=null && TimeArrayObj[0]!=null ) {
					tempObj.value    = FormattingTime(hoursNow, minsNow, "", timePattern);
			}
				
			var temp_tempObj_value = tempObj.value;
			if(temp_tempObj_value!=''){
				var temp_hiddenTimeFieldObj_original_value = hiddenTimeFieldObj.value;
				if (!valueExists(temp_hiddenTimeFieldObj_original_value)) {
				    temp_hiddenTimeFieldObj_original_value = "";
				}
				// add the seconds to format the stored hidden value
				var temp_hiddenTimeFieldObj_new_value = FormattingTime(hours24, minsNow, "", "HH:MM");
				temp_hiddenTimeFieldObj_new_value = temp_hiddenTimeFieldObj_new_value + "." + secsNow + ".000";
				
				temp_hiddenTimeFieldObj_new_value = trim(temp_hiddenTimeFieldObj_new_value);
				temp_hiddenTimeFieldObj_original_value = trim(temp_hiddenTimeFieldObj_original_value);
				if(temp_hiddenTimeFieldObj_original_value!=""){
					if(temp_hiddenTimeFieldObj_original_value.substring(0,5)!=temp_hiddenTimeFieldObj_new_value)
						hiddenTimeFieldObj.value = temp_hiddenTimeFieldObj_new_value;
				}else{
					//kb# 3016442
					hiddenTimeFieldObj.value = temp_hiddenTimeFieldObj_new_value;
				}
			}else{
				hiddenTimeFieldObj.value = ""; 
			}
		}
	}
	//replacing input's time by new time(not showing AM or PM?)
	if(bReplaced && (bRequired || (value != null && value != "" )
					|| ((value==null || value=="" ) && TimeArrayObj!=null && TimeArrayObj[0]!=null))){
		tempObj.value    = FormattingTime(hoursNow, minsNow, "", timePattern);
		var showTimeLongFormatID = "Show" + fieldID + "_long";
		var temp_obj_time_long = document.getElementById(showTimeLongFormatID);
		if(temp_obj_time_long!=null){
			temp_obj_time_long.innerHTML = FormattingTime(hoursNow, minsNow, AM_PM, timePattern);
		} else {
			// kb# 3015954
			var showTimeFormatID = "Show" + fieldID;
			var temp_obj_time = document.getElementById(showTimeFormatID);
			if(temp_obj_time!=null){
				temp_obj_time.innerHTML = FormattingTime(hoursNow, minsNow, AM_PM, timePattern);
			}
		}
	}
	
	//showing the time if bowser is IE5- and netscape6-
	if(bShow){
		var strShowingTime;
		//showing this string to user in form
		if(bRequired || (value != null && value != "")
		   || (bReplaced && (value==null || value=="" ) && TimeArrayObj!=null && TimeArrayObj[0]!=null)){
			strShowingTime = FormattingTime(hoursNow, minsNow, AM_PM, timePattern);
		} else 
			strShowingTime = timePattern;
		
		//fixed prefix "Show" for time hint field which is defined in
		//edit-form-data.xsl
		var showFieldID = "Show" + fieldID;
		var showLongDateFieldObj = null;
		if(document.all){
			showLongDateFieldObj = document.all[showFieldID];
		}else if(!document.all && document.getElementById){
			showLongDateFieldObj = document.getElementById(showFieldID);
		}
		if(showLongDateFieldObj != null)
			showLongDateFieldObj.innerHTML = strShowingTime;
	}	
}

//return date in ISO format: YYYY-MM-DD
//used when client sends user's input date to server
function getDateWithISOFormat(date)
{
	var strDateSeparator = GetDateSeparator(strDateShortPattern);
	var arrDate = new Array();
	var curDate = new Date();
	var month = curDate.getMonth()+ 1;
	var day	  = curDate.getDate();
	var year  = curDate.getFullYear();
	if(date != ""){
		arrDate = date.split(strDateSeparator);
		for(var i=0; i < arrDate.length; i++){
			var temp = arrDateShortPattern[i];
			if(temp!=null){
			if(temp.indexOf("Y")>=0)
				year = arrDate[i];
			else if(temp.indexOf("M")>=0)
				month = arrDate[i];
			else if(temp.indexOf("D")>=0)
				day = arrDate[i];
			}
		}
		day		= parseInt(day,10);
		month	= parseInt(month,10);
		year	= parseInt(year,10);
		//digits 0-30 are 2000 years, and 31-99 are 1900 years.
		if(year <= 30)
			year = 2000+year;
		if(year>30 && year<=99)
			year = 1900+year;
		if(year > 99 && year <= 999)
			year = 2000+year;
		
		month =  (month<10)?("0"+month):month;
		day =  (day<10)?("0"+day):day;
		//date in ISO format(YYYY-MM-DD)
		date = year + "-" + month + "-" + day;
	}
	return date;
}
//format a time(h:mm or h:m) by 24-hour format (hh:mm)
function getTimeWith24Format(time)
{
	if(time!=""){
		var hour, minute;
		var temp_array = new Array();
		//javascript variable: timePattern is in locale.js
		var timeFomat = timePattern;
		timeFomat = timeFomat.toUpperCase();
		var nPosition = timeFomat.indexOf("HH");
		//javascript function trim() is defined in common.js
		time = trim(time);

		if(nPosition >=0){
			//time in edit-form is already in the 24-hours format
			return time;
		}else{
			//time in edit-form is already in the 12-hours format
			//transform it into 24-hours format
			//time separator: ".", " ", ":", or "-"???
			//temp_array = time.split(/[.| |:|-|]/); not working in
			//NN7.1
			temp_array = time.split(".");
			if(temp_array[1]==null)
				temp_array = time.split(":");
			if(temp_array[1]==null)
				temp_array = time.split("-");
			if(temp_array[1]==null)
				temp_array = time.split(" ");
			
			if(temp_array != null && temp_array[0] != null && temp_array[0]!="")
				hour = temp_array[0];
			if(temp_array != null && temp_array[1] != null && temp_array[1]!="")	
				minute = temp_array[1];
			// Parse AM PM
			//default values which are overwritten by XML's locale settings
			var am	= "AM";
			var pm	= "PM";		  
			if(arrTimeAmPmSigns != null){
				if(arrTimeAmPmSigns[0] != null && arrTimeAmPmSigns[0] != "")
					am = arrTimeAmPmSigns[0];
				if(arrTimeAmPmSigns[1] != null && arrTimeAmPmSigns[1] != "")
					pm = arrTimeAmPmSigns[1];
			}
			if(temp_array != null && temp_array[2] != null && temp_array[2]!=""){
				if (temp_array[2].indexOf(pm) >= 0 && parseInt(hour,10) < 12){
					hour = parseInt(hour,10) + 12;
					hour = hour.toString();
					
				}
			}
			//formatting time by 24-hour format[HH:MM]
			time = FormattingTime(hour, minute, "", "HH:MM")
		}
	}
	return time;
}
///checking if input value is an integer (cannot start with "+" or "-")
function isInteger(value) 
{
	var objRegExp  = /\d\d*$/;
	var bReturned = true;
	if(value != ""){
		if(!objRegExp.test(value))
			bReturned = false;
	}
	return bReturned;
}

//date1 and date2 should be in same format(mm/dd/yyyy)
function bDateIsBefore(date1, date2)
{
	var d1 = new Date(date1);
	var d2 = new Date(date2);
	
	if (typeof arguments[2] != "undefined" && arguments[2])
		return (d1<=d2);
	else{
		
		return (d1<d2);
	}
}
//date1 and date2 must be in locale-dependent format
//if date1 is earlier than date2, it returns true, otherwise false.
function compareLocalizedDates(date1, date2)
{
	var arrDate1 = getDateArray(date1);
	var y1 = arrDate1['year'];
	var m1= arrDate1['month'];
	var d1= arrDate1['day'];
	date1 = m1+"/" + d1 + "/" + y1;
	
	var arrDate2 = getDateArray(date2);
	var y2 = arrDate2['year'];
	var m2= arrDate2['month'];
	var d2= arrDate2['day'];
	date2 = m2+"/" + d2 + "/" + y2;
	if (typeof arguments[2] != "undefined" && arguments[2]) 
		return bDateIsBefore(date1, date2, true);
	else
		return bDateIsBefore(date1, date2);
}
//date1 and date2 must be in ISO format(yyyy-mm-dd)
//if date1 is earlier than date2, it returns true, otherwise false.
function compareISODates(date1, date2)
{
	return bDateIsBefore(date1, date2);

}
//return date array(arr['year']=year, arr['month']=month, arr['day']=day)
//from date formatted in localized short-format(e.g. 'dd/mm/yyyy')
function getDateArray(strDate)
{
	var arr = new Array();
	var curDate = new Date();
	var month = curDate.getMonth()+ 1;
	var day	  = curDate.getDate();
	var year  = curDate.getFullYear();
	arr['year']		=	year;
	arr['month']	=	month;
	arr['day']		=	day;
	if(strDate != null || strDate != ""){
		//strDateSeparator and arrDateShortPattern are defined in
		//locale.js
		strDateSeparator = GetDateSeparator(strDateShortPattern);
		var temp_arr = new Array();
		//strDateSeparator: "/| |, |.|-"
		temp_arr =  strDate.split(strDateSeparator);
		if(temp_arr != null && temp_arr.length==3){
			for(var i=0; i<temp_arr.length; i++){
				//arrDateShortPattern looks like {'yyyy','mm','dd'}
				//up to browser's date preference stting????
				var temp = arrDateShortPattern[i];
				if(temp.indexOf('y')>=0 || temp.indexOf('Y')>=0)
					arr['year']	 =	temp_arr[i];
				else if(temp.indexOf('m')>=0 || temp.indexOf('M')>=0)
					arr['month'] =	temp_arr[i];
				else
					arr['day']	 =	temp_arr[i];
					
			}
		}
	}
	return arr;
}
//independent of localized date format, return a associate array to
//contain year, month, and day from input date
function gettingYearMonthDayFromDate(inputDate)
{
	var arrDate = new Array();
	var tokens = inputDate.match(/\w+/g);
	var curDate = new Date();
	var month = curDate.getMonth()+ 1;
	var day	  = curDate.getDate();
	var year  = curDate.getFullYear();
	var temp_datePattern = "";
	//there is no separator character in user's date input string
	//input (like "dec2220002" or "12222002")
	if (tokens){
		if (tokens.length == 1){
			var temp_month = "";
			var temp_index = 0;
			for(var i = 0; i < inputDate.length; i++){
				var char_temp = inputDate.charAt(i);
				if (!isInteger(char_temp)){
					temp_month = temp_month + char_temp;
				}
			}
			temp_index = inputDate.indexOf(temp_month);
			//date input string like "dec222002"
			if(temp_month != '' && temp_index >= 0){
				if(MonthNameToMonthNum (temp_month) > 0)
					month = MonthNameToMonthNum (temp_month);
				var temp_str = inputDate.substring(0,temp_index)+inputDate.substring(temp_index+temp_month.length);
				if(temp_str != "" && strDateShortPattern.indexOf("D") < strDateShortPattern.indexOf("Y")){
					if(isInteger(temp_str.substring(0,2)))
						day = temp_str.substring(0,2);
					if(isInteger(temp_str.substring(2,6)))
						year = temp_str.substring(2,6);
				}
				else if(temp_str != ""){
					if(isInteger(temp_str.substring(0,4)))
						year = temp_str.substring(0,4);
					if(isInteger(temp_str.substring(4,6)))
						day = temp_str.substring(4,6);
				}
			}else {
				//date input string like: "12222002"
				for(var i = 0; i < arrDateShortPattern.length; i++){
					temp_datePattern = arrDateShortPattern[i].toUpperCase();
					if(temp_datePattern.indexOf("Y")>=0){
						if(isInteger(inputDate.substring(i*2, i*2+4)))
							year =  inputDate.substring(i*2, i*2+4);
						var temp_str = inputDate.substring(0, i*2)+ inputDate.substring(i*2+4);
						if(strDateShortPattern.indexOf("D") < strDateShortPattern.indexOf("M")){
							if(isInteger(temp_str.substring(0,2)))
								day = temp_str.substring(0,2);
							if(isInteger(temp_str.substring(2,4)))
								month = temp_str.substring(2,4);
						}else {
							if(isInteger(temp_str.substring(0,2)))
								month = temp_str.substring(0,2);
							if(isInteger(temp_str.substring(2,4)))
								day = temp_str.substring(2,4);
						}
					}
				}
			}
		}else if(tokens.length == 2){
			//date input string like: "dec22 2002" or "1222 2002"
			temp_datePattern = arrDateShortPattern[2].toUpperCase();
			var month_day_str = "";
			if(temp_datePattern.indexOf("Y")>=0) {
				if(isInteger(tokens[1]))
					year = tokens[1];
				month_day_str =  tokens[0];
			}else{
				if(isInteger(tokens[0]))
					year = tokens[0];
				month_day_str =  tokens[1];
			}
			var temp_month = "";
			var temp_index = 0;
			for(var i = 0; i < month_day_str.length; i++){
				var char_temp = month_day_str.charAt(i);
				if (!isInteger(char_temp)){
					temp_month = temp_month + char_temp;
				}
			}
			temp_index = month_day_str.indexOf(temp_month);
			if(temp_month != '' && temp_index >= 0){
				if(MonthNameToMonthNum (temp_month) > 0)
					month = MonthNameToMonthNum(temp_month);
				var temp_day = month_day_str.substring(0,temp_index)+month_day_str.substring(temp_index+temp_month.length);
				temp_day = temp_day.substring(0,2);
				if(isInteger(temp_day))
					day = temp_day;
			}else{
				if(strDateShortPattern.indexOf("D") < strDateShortPattern.indexOf("M")){
					if(isInteger(month_day_str.substring(0,2)))
						day = month_day_str.substring(0,2);
					if(isInteger(month_day_str.substring(2,4)))
						month = month_day_str.substring(2,4);
				}else {
					if(isInteger(month_day_str.substring(0,2)))
						month = month_day_str.substring(0,2);
					if(isInteger(month_day_str.substring(2,4)))
						day = month_day_str.substring(2,4);
				}
			}
		}else{
			//date input string like: "dec 22 2002" or "12 22 2002" or "12/22/2002"
			for(var i = 0; i < arrDateShortPattern.length; i++){
				temp_datePattern = arrDateShortPattern[i].toUpperCase();
				if(temp_datePattern.indexOf("M")>=0){
					if (isNaN(tokens[i])){
						if(MonthNameToMonthNum(tokens[i]) > 0)
							month = MonthNameToMonthNum(tokens[i]);
					}else{
						if(isInteger(tokens[i]))
							month = tokens[i];
					}
				}else if(temp_datePattern.indexOf("D")>=0){
					if (!isNaN(tokens[i]) && (isInteger(tokens[i])))
						day = tokens[i];
				}else{
					if (!isNaN(tokens[i]) && (isInteger(tokens[i])))
						year = tokens[i];
				}
			}
		}
	}
	//converting strings into integers
	day		= parseInt(day,10);
	month	= parseInt(month,10);
	year	= parseInt(year,10);
	//make sure all are valid, otherwise use default
	if(isNaN(day))
		day	  = curDate.getDate();
	if(isNaN(month))
		month = curDate.getMonth()+ 1;
	if(isNaN(year))
		year  = curDate.getFullYear();
	//turning them into valid if they are not
	day		= (day<=0)?(curDate.getDate()):(day);
	month	= (month<=0)?(curDate.getMonth()+ 1):(month);
	year	= (year<=0)?(curDate.getFullYear()):(year);
	//year in "YYYY" format when year > 9999
	if(year > 9999){
		year = "" + year;
		year = year.substring(0,4);
		year = parseInt(year,10);
	}
	//finding out the allowed max days in user's input month
	var max_day_num = GetMonthMaxDays(month, year);
	day = (max_day_num<day)?(max_day_num):(day);
	
	arrDate['year'] = year;
	arrDate['month'] = month;
	arrDate['day'] = day;
	return arrDate;
}
//return a associate array to contain hour and minute from input
//time(HH:MM format)
function gettingHourMinuteFromHHMMFormattedTime(inputTime)
{
	var arrTime = new Array();
	var tempArray = new Array();
	tempArray = inputTime.split(":");
	arrTime['HH'] = tempArray[0];
	arrTime['MM'] = tempArray[1];
	return arrTime;
}
//2000-20-20(yyyy-mm-dd) will return true
function isBeingISODateFormat(strInput)
{
	var bReturned = false;
	var temp_ArrayObj = strInput.split("-");
	if(temp_ArrayObj[1]!=null){
		//4 digit
		if(temp_ArrayObj[0].length==4)
			bReturned = true;
	}
	return bReturned;
}




DateMath = {
    
    HOUR: "H",
    
    
    DAY : "D",

    
    WEEK : "W",

    
    YEAR : "Y",

    
    MONTH : "M",

    
    ONE_DAY_MS : 1000*60*60*24,

    
    add : function(date, field, amount) {
        var d = new Date(date.getTime());
        switch (field) {
            case this.MONTH:
                var newMonth = date.getMonth() + amount;
                var years = 0;


                if (newMonth < 0) {
                    while (newMonth < 0) {
                        newMonth += 12;
                        years -= 1;
                    }
                } else if (newMonth > 11) {
                    while (newMonth > 11) {
                        newMonth -= 12;
                        years += 1;
                    }
                }
                
                d.setMonth(newMonth);
                d.setFullYear(date.getFullYear() + years);
                break;
            case this.DAY:
                d.setDate(date.getDate() + amount);
                break;
            case this.YEAR:
                d.setFullYear(date.getFullYear() + amount);
                break;
            case this.WEEK:
                d.setDate(date.getDate() + (amount * 7));
                break;
            case this.HOUR:
                var hours = date.getHours() + amount;
                var days = Math.floor(hours/24);
                if (days > 0) {
                    d.setDate(date.getDate() + amount);
                    hours = hours - days*24;
                }           
                d.setHours(date.getHours() + amount); // no minutes
                break;  
                
        }
        return d;
    },

    
    subtract : function(date, field, amount) {
        return this.add(date, field, (amount*-1));
    },

    
    before : function(date, compareTo) {
        var ms = compareTo.getTime();
        if (date.getTime() < ms) {
            return true;
        } else {
            return false;
        }
    },

    
    after : function(date, compareTo) {
        var ms = compareTo.getTime();
        if (date.getTime() > ms) {
            return true;
        } else {
            return false;
        }
    },

    
    between : function(date, dateBegin, dateEnd) {
        if (this.after(date, dateBegin) && this.before(date, dateEnd)) {
            return true;
        } else {
            return false;
        }
    },
    
    
    getJan1 : function(calendarYear) {
        return new Date(calendarYear,0,1); 
    },

    
    getDayOffset : function(date, calendarYear) {
        var beginYear = this.getJan1(calendarYear); // Find the start of the year. This will be in week 1.
        
        // Find the number of days the passed in date is away from the calendar year start
        var dayOffset = Math.ceil((date.getTime()-beginYear.getTime()) / this.ONE_DAY_MS);
        return dayOffset;
    },

    
    getWeekNumber : function(date, calendarYear) {
        date = this.clearTime(date);
        var nearestThurs = new Date(date.getTime() + (4 * this.ONE_DAY_MS) - ((date.getDay()) * this.ONE_DAY_MS));

        var jan1 = new Date(nearestThurs.getFullYear(),0,1);
        var dayOfYear = ((nearestThurs.getTime() - jan1.getTime()) / this.ONE_DAY_MS) - 1;

        var weekNum = Math.ceil((dayOfYear)/ 7);
        return weekNum;
    },

    
    isYearOverlapWeek : function(weekBeginDate) {
        var overlaps = false;
        var nextWeek = this.add(weekBeginDate, this.DAY, 6);
        if (nextWeek.getFullYear() != weekBeginDate.getFullYear()) {
            overlaps = true;
        }
        return overlaps;
    },

    
    isMonthOverlapWeek : function(weekBeginDate) {
        var overlaps = false;
        var nextWeek = this.add(weekBeginDate, this.DAY, 6);
        if (nextWeek.getMonth() != weekBeginDate.getMonth()) {
            overlaps = true;
        }
        return overlaps;
    },

    
    findMonthStart : function(date) {
        var start = new Date(date.getFullYear(), date.getMonth(), 1);
        return start;
    },

    
    findMonthEnd : function(date) {
        var start = this.findMonthStart(date);
        var nextMonth = this.add(start, this.MONTH, 1);
        var end = this.subtract(nextMonth, this.DAY, 1);
        return end;
    },

    
    clearTime : function(date) {
        date.setHours(0,0,0,0);
        return date;
    }
};


//coming from XML??? which is used to transform client-input-data into
//neutral format before be sent to server
var sNeutralDecimalSeparator = ".";
var sNeutralGroupingSeparator = ",";
//this array variable to hold the some attributes of all fields:
//datatype, dataformat, primarykey, datasize ...
var arrFieldsInformation = new Array();
//all except for "isEnum" are coming from schema in XML
//FieldName: like rm.rm_id
//arrInformationList= new Array();
//arrInformationList["type"]=type;
//arrInformationList["format"]=format;
//arrInformationList["required"]=required;
//arrInformationList["primarykey"]=primarykey;
//arrInformationList["foreignKey"]=foreignKey;
//arrInformationList["size"]=size;
//arrInformationList["decimal"]=decimal;
//arrInformationList["displaySizeHeading"]=displaySizeHeading;
//arrInformationList["isEnum"]=true|false;(isEnum is defined by related XSL)
function setupArrFieldsInformation(FieldName, arrInformationList){
	arrFieldsInformation[FieldName] = arrInformationList;
}
//validating string in "UPPERALPHA" format
//tempObj: form's input element object
function validationUPPERALPHAString(tempObj){
	var bReturned = true;
	//following check will fail for CHINESE ....?????????????
	var value	= tempObj.value;	
	if(typeof value != 'undefined' && value != null && value != ""){
		value = trim(value);
		if( value != "" && unescape( encodeURIComponent( value ) )==value){
			var objRegExp  = /[A-Z]+$/;
			if(!objRegExp.test(value)){
				//removing last input character
				//tempObj.value = tempObj.value.substring(0, tempObj.value.length-1);
				bReturned = false;
			}
		}
	}
	return bReturned;
}
//validating string in "UPPERALPHANUM" format
//tempObj: form's input element object
function validationUPPERALPHANUMString(tempObj, showValidationMessage, fieldDef){
	if(!valueExists(showValidationMessage)){
		showValidationMessage = true;
	}
	
	var bReturned = true;
	//following check will fail for CHINESE ....?????????????
	var value	= tempObj.value;
	if(typeof value != 'undefined' && value != null && value != ""){
		value = trim(value);
		if(value != "" && unescape( encodeURIComponent( value ) )==value){
			var objRegExp  = /^[A-Z0-9]+$/;
			if(!objRegExp.test(value)){
				//removing last input character
				//tempObj.value = tempObj.value.substring(0, tempObj.value.length-1);
				bReturned = false;
			}
		}
		if(!bReturned && showValidationMessage){
			var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_UPPERALPHANUM);
			message = String.format(message, fieldDef.title);
			
			View.alert(message);
			
		}
	}
	return bReturned;
}
//validating an integer or smallint
//tempObj: form's input element object
function validationIntegerOrSmallint(tempObj, showValidationMessage, fieldDef){
	if(!valueExists(showValidationMessage)){
		showValidationMessage = true;
	}
	
	var bReturned = true;
	var value	= tempObj.value;	
	var  warning_message_invalid_input = "";
	if(typeof value != 'undefined' && value != null && value != ""){
		value = trim(value);
		value = removeGroupingSeparator(value);
		var objRegExp  = /^-?\d+$/;
		if(!objRegExp.test(value)){
			//removing last input character????
			//tempObj.value = "";//tempObj.value.substring(0, tempObj.value.length-1);
			bReturned = false;
		}
	}else{
		//kb# 3022399,  change the behavior to make it the same as that of the numeric field
	    // KB 3022549: we cannot assign 0 to integer values because this breaks autonumerated PKs
	    // also, empty field does not mean 0
		// tempObj.value = 0;
	}
	if(!bReturned){
		if(showValidationMessage) {
			var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_INTEGERORSMALLINT);
			message = String.format(message, fieldDef.title);
			
			View.alert(message);
			
			if(!mozillaFireFoxBrowser)
				setElementFocus(tempObj);
		}
	}
	return bReturned;
}

//validating a numeric number (or with a correct separator)
//tempObj: form's input element object
//decimal: coming from database schema
function validationNumeric(tempObj,decimal, showValidationMessage, defaultValue, fieldDef){
	if(!valueExists(showValidationMessage)){
		showValidationMessage = true;
	}
	
	var bReturned = true;
	var value	= tempObj.value;	
	var  warning_message_invalid_input = "";	
	if(typeof value != 'undefined' && value != null && value != ""){
		value = trim(value);
		//check if value is ".33", then changing it into "0.33"
		if(value.charAt(0)==strDecimalSeparator){
			value = "0" + value;
			tempObj.value = value;
		}
		//changing "+33" into "33" for the purpose of the size validation
		if(value.charAt(0)=="+" && value.length>1){
			value = value.substring(1);
			tempObj.value = value;
		}
		value = removeCurrencySign(value);
		value = removeGroupingSeparator(value);
		if(!isNumeric(value)){
			if(showValidationMessage){
				var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_NUMERIC);
				message = String.format(message, fieldDef.title);
				
				View.alert(message);
				if(!mozillaFireFoxBrowser)
					setElementFocus(tempObj);
			}
			bReturned = false;
		}else{
			//strDecimalSeparator is defined by locale.js
			var objRegExp  = "";
			if(parseInt(decimal+"")>=1){
				objRegExp = "/(^-?\\d\\d*\\"+strDecimalSeparator+"\\d{1,"+decimal+"}$)|(^-?\\d\\d*$)|(^-?\\"+strDecimalSeparator+"\\r\\d\\d{1,"+decimal+"}$)/";
			}else{
				objRegExp = "/(^-?\\d\\d*\\"+strDecimalSeparator+"\\d$)|(^-?\\d\\d*$)|(^-?\\"+strDecimalSeparator+"\\r\\d\\d$)/";
			}
			objRegExp = eval(objRegExp);
			value = removeGroupingSeparator(value);
			//value = removeCurrencySign(value);
			//if last character in input string is decimal separator, adding a zero to
			//it for validation purpose

			//if(value.charAt(value.length-1) == strDecimalSeparator)
			//	value = value + "0";


			if(!objRegExp.test(value)){
				if(showValidationMessage){
					var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_NUMERIC_DECIMAL);
					message = String.format(message, fieldDef.title, decimal);
					
					View.alert(message);
				
					if(!mozillaFireFoxBrowser)
						setElementFocus(tempObj);
				}
				//removing extra decimals
				//var pos = value.indexOf(strDecimalSeparator);
				//if(pos>=0)
				//{
					//value = value.substring(0, pos+parseInt(decimal,10)+1);
					//tempObj.value = value;
					//bReturned = true;
				//}
				//else
				//{
					//tempObj.value = "";//tempObj.value.substring(0, tempObj.value.length-1);
					bReturned = false;
				//}
			}
		}
	}else{
		if(valueExistsNotEmpty(defaultValue)){
			tempObj.value = defaultValue;
		}
	}

	return bReturned;
}
//validating required field
//tempObj: form's input element object
//required: if the input is required in edit forms
function validationRequiredField(tempObj, required){
	var value	= tempObj.value;
	value = trim(value);
	required    = required.toUpperCase();
	var bReturned = true;
	if(required == "TRUE" && (value == null || value == "" )){
		try{
			setElementFocus(tempObj);
		}catch(e){
			setElementFocus(tempObj.parentNode);
		}	
		bReturned = false;
	}
	return bReturned;
}
//99% email address validation
//(rarely-used syntax "someone@123.com")
function validationEmailAddress(tempObj){
	//var value	= tempObj.value;
	//var objRegExp  = /^([a-zA-Z0-9_\.\-])+\@(([a-zA-Z0-9\-])+\.)+([a-zA-Z0-9]{2,4})+$/;
	//return objRegExp.test(value);
}
//for validation purpose, temporially remove CurrencySign
//from validating value
function removeCurrencySign(value){
	if(value.indexOf(strCurrencySign)>=0){
		value = value.replace(strCurrencySign,"");
		value = trim(value);
	}
	return value;
}
//showing money value to users
function insertCurrencySign(value){
	value = strCurrencySign + value;
	return value;
}
//for validation purpose, temporially remove Grouping Separator
//from validating value
function removeGroupingSeparator(value, useLocalizedFormat){
	var result = value;
	//XXX: if strGroupingSeparator is white space, value.indexOf(strGroupingSeparator) will not work in firefox
	//loop through all strGroupingSeparator and remove them
	var temp_str = strGroupingSeparator;
	// when using ARCHIBUS neutral value, use neutral grouping separator
	if (typeof useLocalizedFormat != 'undefined' && useLocalizedFormat === false) {
		temp_str = sNeutralGroupingSeparator;
	}

	temp_str = trim(temp_str);
	if (temp_str.length == 0) {
		result = result.replace(/\s+/g,"");
	}
	else {
		while (result.indexOf(temp_str) >= 0){
			result = result.replace(temp_str,"");
			result = trim(result);
		}
	}	
	return result;
}

//showing value to users, insert Grouping Separator
//into displayed value
function insertGroupingSeparator(value, isNeutralValue, useLocalizedFormat){
	var strReturned = value;
	if(value != null && value != ""){
		//three digits as one group???
		var objRegExp  = new RegExp('(-?[0-9]+)([0-9]{3})');

		var grp_sep = strGroupingSeparator;
		var dec_sep = strDecimalSeparator;
		var value_dec_sep = strDecimalSeparator;
		// when using ARCHIBUS neutral value, use neutral separators
		if (typeof isNeutralValue != 'undefined' && isNeutralValue === true) {
			value_dec_sep = sNeutralDecimalSeparator;
		}
		if (typeof useLocalizedFormat != 'undefined' && useLocalizedFormat === false) {
			grp_sep = sNeutralGroupingSeparator;
			dec_sep = sNeutralDecimalSeparator;
		}

		//location of decimal separator in value
		var iPos = value.indexOf(value_dec_sep);
		var str_temp1 = value;
		var str_temp2 = "";
		if(iPos > 0){
			str_temp1 = value.substring(0, iPos);
			str_temp2  = dec_sep + value.substring(iPos + 1, value.length);
		}		

		while(objRegExp.test(str_temp1)){
			str_temp1 = str_temp1.replace(objRegExp, '$1' + grp_sep + '$2');
		}
		strReturned = str_temp1 + str_temp2;
	}
	return strReturned;
}

//<input ... maxsize="" /> is not working(IE) if maxsize is dynamically changed
//check allowable max size of data
//special case: numeric fields ==> group separator and decimal

//tempObj: form's input element object
//maxsize: coming from DB schema
//type: coming from DB schema. using java.lang.*???????????????
//format: coming from DB schema
function validationDataMaxSize(tempObj, fieldDef, showValidationMessage){
	if(!valueExists(showValidationMessage)){
		showValidationMessage = true;
	}
	
	var maxsize = fieldDef["size"];
	maxsize = parseInt(maxsize, 10);
	var format  = fieldDef["format"];
	var type  = fieldDef["type"];
	var decimal = fieldDef["decimal"];
	if (typeof this.Ab != 'undefined' && Ab.view.View.version == "2.0") {
		decimal = fieldDef["decimals"];
	}
	decimal = parseInt(decimal, 10);

	var afmType = fieldDef["afmType"];

	var readOnly = fieldDef["readOnly"];

	var typeUpperCase = type.toUpperCase();
	var formatUpperCase = format.toUpperCase();
	var bReturned = true;
	var temp_value = tempObj.value;
	temp_value = trim(temp_value);

	var bNegativeNumber = false;

	var message_too_large = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_NUMERIC_TOO_LARGE);
	var message_too_small = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_NUMERIC_TOO_SMALL);
	
	if(temp_value != ""){
		if( maxsize > 0){
			if(typeUpperCase== "JAVA.LANG.INTEGER"){
				bReturned = validationIntegerOrSmallint(tempObj, false);
				if(bReturned){
					if(temp_value.charAt(0)=="-"){
						bNegativeNumber = true;
						//remove -
						temp_value = temp_value.substring(1, temp_value.length);
					}
					//removing GroupingSeparator
					temp_value = removeGroupingSeparator(temp_value);
					var max_integer_allowed = "";
					for(var i = 0; i< maxsize; i++)
						max_integer_allowed = max_integer_allowed+"0";
					max_integer_allowed = "1" + max_integer_allowed;
					// 2^31 - 1 is the maximum storage size for an integer
					if(Number(max_integer_allowed) > 2147483647){
						max_integer_allowed = "2147483647";
					}
					max_integer_allowed = insertGroupingSeparator(max_integer_allowed);
					if((readOnly!="true") && (temp_value.length > maxsize) || (temp_value > 2147483647)){
						if(showValidationMessage){
							if(bNegativeNumber){
								message_too_small = String.format(message_too_small, fieldDef.title, max_integer_allowed);
								View.alert(message_too_small);
							}else{
								message_too_large = String.format(message_too_large, fieldDef.title, max_integer_allowed);
								View.alert(message_too_large);
							}
						}
						if(!mozillaFireFoxBrowser){
							setElementFocus(tempObj);
						}
						bReturned = false;
					}

					//if format is not "NoSeparator", insert removed
					//Grouping Separator
					if(formatUpperCase != "NOSEPARATOR"){
						temp_value =  insertGroupingSeparator(temp_value);
						//readOnly numeric fields???? fixed ID format
						var showNumericFormatID = "Show" + tempObj.name + "_numeric";
						var temp_obj_numeric = document.getElementById(showNumericFormatID);
						if(temp_obj_numeric!=null){
							temp_obj_numeric.innerHTML = insertGroupingSeparator(temp_value);
						}
					}
					if(bNegativeNumber)
						temp_value = "-"+ temp_value;
				}
			}else if(typeUpperCase== "JAVA.LANG.DOUBLE" || typeUpperCase== "JAVA.LANG.FLOAT"){
				bReturned = validationNumeric(tempObj, decimal, false);
				if(bReturned){
					if(temp_value.charAt(0)=="-"){
						bNegativeNumber = true;
						//remove -
						temp_value = temp_value.substring(1, temp_value.length);
					}
					
					//XXX: KB3035486
					maxsize = maxsize + 1;
					
					//numeric(integer, float|double) cases
					//removing GroupingSeparator
					temp_value = removeGroupingSeparator(temp_value);
					temp_value = removeCurrencySign(temp_value);
					var iPos = temp_value.indexOf(strDecimalSeparator);
					//all numeric: excludes decimal sign and decimals for max integer part????
					var max_number_allowed = "";
					for(var i = 0; i< (maxsize-1-decimal); i++)
						max_number_allowed = max_number_allowed+"0";
					max_number_allowed = "1" + max_number_allowed;
					max_number_allowed = insertGroupingSeparator(max_number_allowed);
					if(iPos > 0){
						var temp_integer_part = temp_value.substring(0, iPos);

						if((readOnly!="true") && (temp_integer_part.length > (maxsize-1-decimal))){
							if(showValidationMessage){
								if(bNegativeNumber){
									message_too_small = String.format(message_too_small, fieldDef.title, max_number_allowed);
									View.alert(message_too_small);
									
								}else{
									message_too_large = String.format(message_too_large, fieldDef.title, max_number_allowed);
									View.alert(message_too_large);
									
								}
							}
							if(!mozillaFireFoxBrowser){
								setElementFocus(tempObj);
							}
							bReturned = false;
						}
					}else{
						//without decimal separator
						if((readOnly!="true") && (temp_value.length > (maxsize-1-decimal))){
							if(showValidationMessage){
								if(bNegativeNumber){
									message_too_small = String.format(message_too_small, fieldDef.title, max_number_allowed);
									View.alert(message_too_small);

								}else{
									message_too_large = String.format(message_too_large, fieldDef.title, max_number_allowed);
									View.alert(message_too_large);
									
								}
							}
							if(!mozillaFireFoxBrowser){
								setElementFocus(tempObj);
							}
							bReturned = false;
						}
					}
					
					if(bNegativeNumber)
						temp_value = "-"+ temp_value;
						
					//if format is not "NoSeparator", insert removed
					//Grouping Separator
					if(formatUpperCase != "NOSEPARATOR"){
						temp_value =  insertGroupingSeparator(temp_value);
						//readOnly numeric fields???? fixed ID format
						var showNumericFormatID = "Show" + tempObj.name + "_numeric";
						var temp_obj_numeric = document.getElementById(showNumericFormatID);
						if(temp_obj_numeric!=null){										
							temp_obj_numeric.innerHTML = insertGroupingSeparator(temp_value);
						}
					}
				}
			}else if(typeUpperCase== "JAVA.LANG.STRING"){
				//string cases
				if(temp_value.length > maxsize){
					temp_value = temp_value.substring(0, maxsize);
					bReturned = false;
				}
			}
			//if(formatUpperCase == "MONEY")
			//	temp_value = insertCurrencySign(temp_value);
			//showing up to users
			tempObj.value = temp_value;
		}
	}
	return bReturned;
}


function doMaxAndMinValidation(value, fieldDef, showValidationMessage){
	if(!valueExistsNotEmpty(value) || !valueExists(fieldDef)){
		return true;
	}
	if(!valueExists(showValidationMessage)){
		showValidationMessage = true;
	}
	
	//change value into neutral one to do comparation
	value = removeGroupingSeparator(value);
	value = removeCurrencySign(value);
	value = value.replace(strDecimalSeparator, ".");
	
	if(valueExistsNotEmpty(fieldDef.maxValue)){
		if(value > fieldDef.maxValue){
			if(showValidationMessage){
				var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_NUMERIC_MAX);
				message = String.format(message, fieldDef.title, fieldDef.formatValue(fieldDef.maxValue + '', true));
				View.alert(message);
			}
		
			return false;
		}
	}
	if(valueExistsNotEmpty(fieldDef.minValue)){
		if(value < fieldDef.minValue){
			if(showValidationMessage){
				var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_NUMERIC_MIN);
				message = String.format(message, fieldDef.title, fieldDef.formatValue(fieldDef.minValue+'', true));
				View.alert(message);
			}
			
			return false;
		}
	}
	
	return true;
}

//when sending input's data to server
//remove currency sign and data grouping separator sign
//and change date into ISO format
//more??????????????like convert locale decimal separator
//such as "," to neutral one "."
//and handling XML-unlike special characters like "<", "&"
//type: coming from DB schema
//format: coming from DB schema
//value: a string value for form's input field
function convertFieldValueIntoValidFormat(type, format, value){
	value = trim(value);
	if(value != null && value != ""){
		if(type== "JAVA.LANG.INTEGER" || type== "JAVA.LANG.DOUBLE" || type== "JAVA.LANG.FLOAT"){
			//remove all from value string
			value = removeGroupingSeparator(value);
			//remove currency sign if format is "Money"
			//if(format == "MONEY")
				//value = removeCurrencySign(value);
			//replace localized decimal separator by neutral one(".")
			value = replaceLocalizedDecimalSeparatorByDot(value);
		}
		//if data type is date, using ISO format for date
		if(type== "JAVA.SQL.DATE"){
			//getDateWithISOFormat() is defined in date-time.js
			value = getDateWithISOFormat(value);
		}
		//if data type is date, using ISO format for date
		if(type== "JAVA.SQL.TIME"){
			//getTimeWith24Format() is defined in date-time.js
			value = getTimeWith24Format(value);
		}
	}
	return value;
}
//replace localized decimal separator by neutral one
function replaceLocalizedDecimalSeparatorByDot(value){
	//strDecimalSeparator is defined by locale.js
	//in case when value is not string value
	value = "" + value;
	//replace strDecimalSeparator by sNeutralDecimalSeparator in value
	value = value.replace(strDecimalSeparator, sNeutralDecimalSeparator);
	return value;
}
//generally
function isNumeric(sText){
	//allow negative???????????????
	if(sText.charAt(0)=='-')
		sText = sText.substring(1,sText.length);
	var ValidChars = "0123456789"+strDecimalSeparator+""+strGroupingSeparator;
	var IsNumber=true;
	var Char;
	var iPos = -1;
	iPos = sText.indexOf(strDecimalSeparator);
	for (i = 0; i < sText.length && IsNumber == true; i++){
		Char = sText.charAt(i);
		if (ValidChars.indexOf(Char) == -1){
			IsNumber = false;
		}
	}
	if(iPos==0)
		IsNumber = false;

	return IsNumber;
}
//check the max size of memo fields(<textarea>)
function checkMemoMaxSize(objElem, maxlimit){
	maxlimit = maxlimit + "";
	maxlimit = parseInt(maxlimit, 10);
	var memo_value = objElem.value;
	memo_value = replaceNewlinesTextarea(memo_value);
	var memo_size = memo_value.length;
	
	if (memo_size > maxlimit){
		var message = View.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_MEMO_TOO_LARGE);
		message = message.replace('{0}', maxlimit);
		View.alert(message);
		objElem.value = memo_value.substring(0, maxlimit);
	}
}

//HTML element's focus
function setElementFocus(elem){
	//focusing a hidden element will get error in IE
	try{
		elem.focus();
	}catch(er){}
}

function replaceNewlinesTextarea(val){             
  if (val.indexOf('\r\n')!=-1)
    ; 																					//  No need to alter
  else if (val.indexOf('\r')!=-1)
    val = val.replace ( /\r/g, "\r\n" );        // for IE.
  else if (val.indexOf('\n')!=-1)
    val = val.replace ( /\n/g, "\r\n" );        // for FF. Need to add carriage return
  else ;                                        // no newlines in the textarea  
  return val;
}


Calendar = function(){};

Calendar.MMID		= "MM";
Calendar.YYYYID		= "YYYY";
Calendar.CalendarAreaID	= "Calendar";
Calendar.DateButton	= "But";
//overwrite in runtime
Calendar.abSchemaSystemGraphicsFolder="/schema/ab-system/graphics";  //reset 1st time getController() calls requireCalendar()
//controller||dailog
Calendar.mode = "controller";
//div in html to hold calendar
Calendar.containerName = "AFM_CALENDAR";
//defaults
Calendar.width = 260;
Calendar.height = 250;
Calendar.anchorObject = null;
Calendar.calendar_available = false;


// @begin_translatable
Calendar.MESSAGE_CANT_BE_FOUND = 'cannot be found!';
Calendar.MESSAGE_TODAY = 'Today';
Calendar.MESSAGE_CLOSE = 'Close';
Calendar.MESSAGE_SUN = 'Sun';
Calendar.MESSAGE_MON = 'Mon';
Calendar.MESSAGE_TUE = 'Tue';
Calendar.MESSAGE_WED = 'Wed';
Calendar.MESSAGE_THUR = 'Thur';
Calendar.MESSAGE_FRI = 'Fri';
Calendar.MESSAGE_SAT = 'Sat';
// @end_translatable


//public api: to get calendar as a dialog used in select-date-from-calendar.xsl
Calendar.getDialog = function (abSchemaSystemGraphicsFolder, width, height){
	this.mode="dialog";
	if(typeof width != "undefined")
		this.width=width;
	if(typeof height != "undefined")
		this.height=height;

	this.requireCalendar(abSchemaSystemGraphicsFolder);

	//post calendar into position
	if(typeof objSelectedValueInput != "undefined"){
		this.setCalenderPosition(objSelectedValueInput);
		this.anchorObject = objSelectedValueInput;
	}
	this.setCalendarVisibility(true);
};
//public api to get calendar as a control anchored in forms
Calendar.getController = function (anchorName, abSchemaSystemGraphicsFolder, width, height){
    this.getControllerForEvent(null, anchorName, abSchemaSystemGraphicsFolder, width, height);    
};
Calendar.getControllerForEvent = function (event, anchorName, abSchemaSystemGraphicsFolder, width, height){
	this.mode="controller";
	if(!this.calendar_available){
		if(typeof width != "undefined")
			this.width=width;
		else
			this.width=230;
		if(typeof height != "undefined")
			this.height=height;
		else
			this.height=200;

		this.requireCalendar(abSchemaSystemGraphicsFolder);
		this.calendar_available = true;
	}
	
	//position calendar
	//$ defined in common.js
	this.anchorObject = $(anchorName, false);
	if(this.anchorObject.disabled){
		return;
	}
	if(this.anchorObject==null){
		alert(anchorName + " " + Ab.view.View.getLocalizedString(Calendar.MESSAGE_CANT_BE_FOUND));
		return;
	}
	if (valueExists(event)) {
        this.setCalenderPositionForEvent(event, this.anchorObject);
	} else {
	    this.setCalenderPosition(this.anchorObject);
	}
	//show calendar
	this.setCalendarVisibility(true);
};
//private api to create calendar
Calendar.requireCalendar =  function (abSchemaSystemGraphicsFolder){
	if(typeof abSchemaSystemGraphicsFolder!="undefined" && abSchemaSystemGraphicsFolder!="")
		this.abSchemaSystemGraphicsFolder=abSchemaSystemGraphicsFolder;

	//current date
	var curDate= new Date();
	var year= curDate.getFullYear();
	var month= curDate.getMonth()+ 1;
	var day	= curDate.getDate();

	//wrire calendar
	this.writeCalendar(month);
	//format calendar
	this.formatCalendar(year, month, day);
};
//release calendar therefore it can be recalled
Calendar.releaseCalendar =  function (){
	//restore calendar to its default status
	var curDate	= new Date();
	var year	= curDate.getFullYear();
	var month	= curDate.getMonth()+ 1;
	var day		= curDate.getDate();
	this.formatCalendar(year, month, day);
	//hide it
	this.setCalendarVisibility(false);
};
//called when users click on their selecting date
//elemID:the ID of each date cell in calendar
Calendar.SetDate =  function (elemID){
	var objElem = $(elemID);
	var day = objElem.innerHTML;
	day = parseInt(day, 10);
	var month = $(this.MMID).value;
	month = parseInt(month, 10);
	var year = $(this.YYYYID).innerHTML ;
	year = parseInt(year, 10);
	this.fillDate2Anchor(day, month, year);
};
Calendar.fillDate2Anchor =  function (day, month, year){
	//setupDateInputFieldValue() is javascript functon defined by calendar caller)
	this.setupDateInputFieldValue(day, month, year);
	if(this.mode=="controller"){
		this.releaseCalendar();
	}else{
		self.close();
	}
};
//set up detailed calendar content
Calendar.formatCalendar = function (year, month, day){
	month = month + "";
	month = parseInt(month, 10);
	var obj_MM = $(this.MMID, false);
	if(obj_MM!=null){
		for(var i=0;i<obj_MM.length;i++){
			if(obj_MM[i]!=null && obj_MM[i].value==month){
				obj_MM[i].selected=1;
				break;
			}
		}
	}
	var obj_YYYY = $(this.YYYYID, false);
	if(obj_YYYY!=null)
		obj_YYYY.innerHTML = year;
	var daysOfMonth = 31;
	if(month==4||month==6||month==9||month==11){
		daysOfMonth = 30;
	}else{
		if( month == 2 ){
			daysOfMonth = 28;
			if( ( year % 4 == 0 && year % 100 != 0 ) || ( year % 400 == 0) )
				daysOfMonth = 29;
		}
	}
	var date	= new Date( year, month-1, 1);
	var dayOfFirst	= date.getDay();
	var var_day	= 1;
	var dd;

	var curDate	= new Date();
	var curYear	= curDate.getFullYear();
	var curMonth	= curDate.getMonth()+ 1;
	var curDay	= curDate.getDate();
	if(typeof day == "undefined")
		day = curDay;

	var endDay = 41;
	if (intFirstDayOfWeek == 2) {
		endDay = 42;
		if (dayOfFirst == 0) {
			dayOfFirst = 7;
		}
	}
	
	for(var i = 0; i <= endDay; i++){
		var objElem = $(this.DateButton+(i+1), false);
		if (intFirstDayOfWeek == 2){
			objElem = $(this.DateButton+(i), false);
		}
		if(objElem!=null){
			if( ( i < dayOfFirst )  ||  ( var_day > daysOfMonth ) ){
				if( document.all ||(!document.all && document.getElementById) )
					if(objElem.style != null)objElem.style.visibility = "hidden";
			}else{
				if( var_day.toString().length < 2 )
					dd = " " + var_day + " ";
				else
					dd = var_day;

				objElem.innerHTML = dd;
				if(objElem.style!=null){
				objElem.style.visibility = "visible";
				if(curYear==year && curMonth==month && dd == day){
					objElem.style.backgroundColor="#FFCC66";
					objElem.style.borderStyle="solid";
					objElem.style.borderColor="#FF9900";
					objElem.style.borderWidth="thin";
				}else{
					objElem.style.backgroundColor="";
					objElem.style.borderStyle="";
					objElem.style.borderColor="";
					objElem.style.borderWidth="";
				}
				var_day = var_day + 1;
				}
			}
		}
	}
};
//called when users click Previous/Next button
//bPrevious: if users click on the previous arrow
Calendar.getMM_YYYY = function (bPrevious){
	var obj_YYYY = $(this.YYYYID, false);
	var year = obj_YYYY.innerHTML;
	var obj_MM = $(this.MMID, false);
	var month = obj_MM.value;

	if(bPrevious){
		month = this.getPrevMonth(month);
		//if month is reaching 1, reduce year
		if(month < 1){
			month = 12;
			year = this.getPrevYear(year);
		}
	}else{
		month = this.getNextMonth(month);
		//if month is reaching 12, increase year
		if(month > 12){
			month = 1;
			year = this.getNextYear(year);
		}
	}
	for(var i=0;i<obj_MM.length;i++){
		if(obj_MM[i].value==month){
			obj_MM[i].selected=1;
			break;
		}
	}
	obj_YYYY.innerHTML = year;
	this.formatCalendar(year, month);
};
//year 1900-9999
Calendar.getPrevYear = function (year){
	year = year + "";
	year = parseInt(year, 10);
	if( year > 1900 )
		year =  year - 1;
	else
		year =  9999;
	return year;
};
//year 1900-9999
Calendar.getNextYear = function (year){
	year = year + "";
	year = parseInt(year, 10);
	if(  year < 9999 )
		year = year + 1;
	else
		year = 1900;
	return year;
};
//moth 1-12
Calendar.getPrevMonth = function (month){
	month = month + "";
	month = parseInt(month, 10);
	month = month - 1;
	return month;
};
//moth 1-12
Calendar.getNextMonth = function (month){
	month = month + "";
	month = parseInt(month, 10);
	month = month + 1;
	return month;
};
/////////////////////////////////////////////
//called to show or hide calenar
Calendar.setCalendarVisibility = function (show){
	var container = $(this.containerName, false);
	if(container != null){
		var calendarIframe = $("AFM_CALENDAR_IFRAME");
		if(show){
			container.style.display  = "";
			if(calendarIframe!=null){
				container.style.display  = "block";
				calendarIframe.style.width = container.offsetWidth;
				calendarIframe.style.height = container.offsetHeight;
				calendarIframe.style.top = container.style.top;
				calendarIframe.style.left = container.style.left;
				calendarIframe.style.zIndex = container.style.zIndex - 1;
				calendarIframe.style.display  = "block";
			}
			//focus today button???
			var but_today = $("But_today");
			if(but_today!=null){
				//required by firefox
				if(typeof but_today.setAttribute == 'function')
					but_today.setAttribute("autocomplete","off");
				but_today.focus();
			}
			if(this.mode=="dialog"){
				//hide scrollbars in IE???
				document.body.style.overflowY="hidden";
				document.body.style.overflowX="hidden";
			}
		}else{
		    if(container.style!=null){
			container.style.display  = "none";
			if(calendarIframe!=null){
				calendarIframe.style.display  = "none";
			}
			}
		}
	}
};
//////////////////////////////////////////////////////////////////////////
//create calendar
Calendar.writeCalendar = function (month){
	var calendarContainer = $(this.containerName, false);
	if(calendarContainer==null){
		alert(this.containerName + " " + Ab.view.View.getLocalizedString(Calendar.MESSAGE_CANT_BE_FOUND));
		return;
	}
	var str = '<table CELLSPACING="0" valign="top" width="100%">';
	str = str +'<tbody><tr><td>' + this.getCalendarTop(month) +'</td></tr>';
	str = str +'<tr><td>' + this.getCalendarTable()  +'</td></tr>';
	str = str +'</tbody></table>';
	calendarContainer.innerHTML = str;
};

//calendar top area
Calendar.getCalendarTop = function (month){
	var str = '<table id="AFMCALENDARTOP" name="AFMCALENDARTOP" CELLSPACING="0"   class="calendarTop" valign="top" width="100%">';
	str = str +'<tr nowrap="1"><td><input  id="AFMCALENDAR_but_up" name="AFMCALENDAR_but_year_up" onclick="Calendar.getMM_YYYY(true);return false;" WIDTH="18" HEIGHT="18" HSPACE="1" type="image" src="'+this.abSchemaSystemGraphicsFolder+'/but_prev.gif"/>';
	str = str +'<\/td>';
	str = str +'<td class="calendarmmyyyyA">';
	str = str + this.getMonthNames(month);
	str = str +'<\/td><td><\/td>';
	str = str +'<td class="calendarmmyyyyA">';
	str = str +'<span id="'+this.YYYYID+'">2003<\/span>';
	str = str +'<\/td><td>';
	str = str +'<INPUT  id="AFMCALENDAR_but_year_up" name="AFMCALENDAR_but_year_up" TYPE="image" SRC="'+this.abSchemaSystemGraphicsFolder+'/but_yeard.gif" WIDTH="18" HEIGHT="9" onClick=\'var y=$("'+this.YYYYID+'").innerHTML;y=parseInt(y,10)+1;$("'+this.YYYYID+'", false).innerHTML=y;var m=$("'+this.MMID+'", false).value;m=parseInt(m,10);Calendar.formatCalendar(y,m);return false;\'/>';
	str = str +'<BR \/>';
	str = str +'<INPUT  id="AFMCALENDAR_but_year_down" name="AFMCALENDAR_but_year_down" TYPE="image" SRC="'+this.abSchemaSystemGraphicsFolder+'/but_yearu.gif" WIDTH="18" HEIGHT="9" onClick=\'var y=$("'+this.YYYYID+'").innerHTML;y=parseInt(y,10)-1;$("'+this.YYYYID+'", false).innerHTML=y;var m=$("'+this.MMID+'", false).value;m=parseInt(m,10);Calendar.formatCalendar(y,m);return false;\'/>';
	str = str +'<\/td>';
	str = str +'<td>';
	str = str +'<input id="AFMCALENDAR_but_down" name="AFMCALENDAR_but_down" onclick="Calendar.getMM_YYYY(false);return false;" WIDTH="18" HEIGHT="18" HSPACE="1" type="image" src="'+this.abSchemaSystemGraphicsFolder+'/but_next.gif"/>';
	str = str +'<\/td><\/tr>';

	str = str +'<\/table>';
	return str;
}
//month names list
Calendar.getMonthNames = function (month){
	var str = '';
	for(var i=0; i < arrMonthNames.length; i++){
		if(arrMonthNames[i]!=""){
			if(month==(i+1))
				str = str + '<option selected="1" value="'+(i+1)+'">'+arrMonthNames[i]+'<\/option>';
			else
				str = str + '<option  value="'+(i+1)+'">'+arrMonthNames[i]+'<\/option>';
		}
	}
	str = '<select name="'+this.MMID+'" id="'+this.MMID+'" style="visibility:visible" onchange="var y=$(\''+this.YYYYID+'\').innerHTML;y=parseInt(y,10);Calendar.formatCalendar(y,this.value);return false;">' + str + '<\/select>';
	return str;
};
//calendar days
Calendar.getCalendarTable = function (){
	////////////localization///////////////
	var sun = Ab.view.View.getLocalizedString(Calendar.MESSAGE_SUN);
	var mon = Ab.view.View.getLocalizedString(Calendar.MESSAGE_MON);
	var tue = Ab.view.View.getLocalizedString(Calendar.MESSAGE_TUE);
	var wed = Ab.view.View.getLocalizedString(Calendar.MESSAGE_WED);
	var thur = Ab.view.View.getLocalizedString(Calendar.MESSAGE_THUR);
	var fri = Ab.view.View.getLocalizedString(Calendar.MESSAGE_FRI);			
	var sat = Ab.view.View.getLocalizedString(Calendar.MESSAGE_SAT);	
	var ids = ['sun','mon','tue','wed','thur','fri','sat'];
	var days = [sun,mon,tue,wed,thur,fri,sat];
	//////////////////////////////////////////
	var counter = 0;
	
	if (intFirstDayOfWeek == 2){
		// counter = 1;
		days = [mon,tue,wed,thur,fri,sat,sun];
		ids = ['mon','tue','wed','thur','fri','sat', 'sun'];
	}
		
	var curDate	= new Date();
	var year	= curDate.getFullYear();
	var month	= curDate.getMonth()+ 1;
	var today	= curDate.getDate();
	var str = '<table  id="AFMCALENDARAREA" name="AFMCALENDARAREA" class="calendarTable" BORDER="0" CELLPADDING="2" CELLSPACING="0" width="100%">';
	str = str + '<tr class="calendarTableDays" ALIGN="center">';
	for(var i=0;i<ids.length; i++){
		var day =  $(ids[i], false);
		if(day==null)
			day = days[i];
		else
			day = day.innerHTML;
		str = str + '<td>'+day+'<\/td>';
	}
	str = str +'<\/tr>';

	for(var i=0; i < 6; i++){
		str = str + '<tr ALIGN="center">';
		for(var j=0; j<7; j++){
			counter+=1;
			str = str + '<td class="calendar"><A  id="But'+counter+'" href="#" onClick=\'Calendar.SetDate("But'+counter+'"); return false;\'>'+counter+'<\/A><\/td>';
		}
		str = str +'<\/tr>';
	}

	str = str +'<tr  ALIGN="center"><td colspan="7"  ALIGN="center">';
	//today button
	var but_today =  Ab.view.View.getLocalizedString(Calendar.MESSAGE_TODAY);	
	str = str +'<input id="But_today" name="But_today" type="button" class="perRowButton" value="'+but_today+'" title="'+but_today+'" onclick="Calendar.fillDate2Anchor('+today+','+ month +','+ year+');return false;"/>';

	//close button
	var but_close =  Ab.view.View.getLocalizedString(Calendar.MESSAGE_CLOSE);
	var closeAction = '';
	if(this.mode=="controller")
		closeAction = 'Calendar.releaseCalendar();';
	else
		closeAction = 'self.close();';
	str = str +'<input id="But_close" name="But_close" type="button" class="perRowButton" value="'+but_close+'" title="'+but_close+'" onclick="'+closeAction+'"/>';

	str = str +'<\/td><\/tr>';
	str = str +'<\/table>';
	return str;
};
//set up the size and position of calendar
Calendar.setCalenderPosition = function (anchorObj){
	if(typeof anchorObj!="undefined" && anchorObj!=null && this.mode=="dialog"){
		var position = this.getAnchorPosition(opener.window, anchorObj);
		//size calendar
		window.resizeTo(this.width,this.height);
		window.moveTo(position.x, position.y);
	}else if(typeof anchorObj!="undefined" && anchorObj!=null && this.mode=="controller"){
		var position = this.getAnchorPosition(window, anchorObj);
		var calendarContainer = $(this.containerName, false);
		calendarContainer.style.left = position.x + "px";
		calendarContainer.style.top =  position.y + "px";
		calendarContainer.style.width=this.width + "px";
		calendarContainer.style.height=this.height + "px";
	}

};
Calendar.setCalenderPositionForEvent = function (event, anchorObj){
    var calendarContainer = $(this.containerName, false);
    var layoutHeight = calendarContainer.parentNode.offsetHeight;
    var layoutWidth = calendarContainer.parentNode.offsetWidth;
   
    var position = this.getAnchorPosition(window, anchorObj);
    position.y = event.clientY + anchorObj.offsetHeight/2;
    if ((position.y + this.height) > layoutHeight){
    	position.y = event.clientY - (this.height + anchorObj.offsetHeight / 2);
    }
    
    if ((position.x + this.width) > layoutWidth){
    	position.x = event.clientX - (this.width);
    }

    calendarContainer.style.top =  position.y + "px";
    calendarContainer.style.left = position.x + "px";
    calendarContainer.style.width=this.width + "px";
    calendarContainer.style.height=this.height + "px";    
};
//return object with x and y to indicate element's location
Calendar.getAnchorPosition = function (windowObj, inputElement) {
	var coords =  new Object();
	coords.x = 0;
	coords.y = 0;
	try {
		targetElement = inputElement;
		if(targetElement.x && targetElement.y) {
			coords.x = targetElement.x;
			coords.y = targetElement.y;
		} else {
			if(targetElement.offsetParent) {
				coords.x += targetElement.offsetLeft;
				coords.y += targetElement.offsetTop;
				while(targetElement = targetElement.offsetParent) {
					coords.x += targetElement.offsetLeft;
					coords.y += targetElement.offsetTop;
				}
			}
		}

	    var windowX = windowY = 0;
	    if (window.innerHeight) {
	        windowX=windowObj.outerWidth-windowObj.innerWidth;
	        windowY=windowObj.innerHeight;
	    }else {
	        windowX=windowObj.screenLeft;
	        windowY=windowObj.screenTop;
	    }

	    if(this.mode=="dialog"&& screen && screen.availHeight && (screen.availHeight - windowY < this.height + inputElement.offsetHeight)){
	        coords.y -= this.height;
	    }else{
	        coords.y += inputElement.offsetHeight;
	        coords.y += 2;
	    }

	    if(this.mode=="dialog"){
	        coords.y += windowY;
	        coords.x += windowX;
	        coords.x -= 140;

	    }else{
	        coords.x -= 80;
	    }


	    if(coords.x<0)
	        coords.x=0;

		return coords;
	} catch(error) {
		alert(error.msg);
	}
};
//put the selected date into required input in forms
Calendar.setupDateInputFieldValue = function (day, month, year){
	if(this.anchorObject!=null){
		//FormattingDate in date-time.js
		var newDate=FormattingDate(day, month, year, strDateShortPattern);
		if(typeof afm_form_values_changed!="undefined" && this.anchorObject.value!=newDate)
			if(afm_form_values_changed!=null)
				afm_form_values_changed=true;

		this.anchorObject.value = newDate;

		//force to fire onchange event???
		if(this.anchorObject.onchange)
			this.anchorObject.onchange();

		//required by firefox
		if(typeof this.anchorObject.setAttribute == 'function')
				this.anchorObject.setAttribute("autocomplete","off");
		this.anchorObject.focus();
		this.anchorObject.blur();
		this.anchorObject.focus();
	}
};
/////////////////////////////////////////////////////////////////
//handle mouse or key events to release the calendar
Calendar.handeCalendarController_mouse = function (e){
	if(Calendar.mode=="controller"){
		var hide = true;
		var targetObj = null;
		if(window.event){
			targetObj = window.event.srcElement;
		}else{
			targetObj = e.target;
		}

		if(targetObj!=null){
			while ( (targetObj.parentElement && targetObj.parentElement!=null) || (targetObj.parentNode && targetObj.parentNode != null)) {
				if (targetObj.id!=null && (targetObj.id=="AFMCALENDARAREA" || targetObj.id=="AFMCALENDARTOP")) {
					hide = false;
					break;
				}
				if(targetObj.parentElement)
					targetObj = targetObj.parentElement;
				else
					targetObj = targetObj.parentNode;
			}

			if(hide){
				hide = !( targetObj.id!=null && (targetObj.id.indexOf("AFMCALENDAR") >=0));
			}
		}

		if(hide){

			var container = $(Calendar.containerName, false);
			if(typeof container != "undefined" && container != null){
				//release calendar
				Calendar.releaseCalendar();
			}

		}
	}
};
//"ESC" key is pressed -> release calendar
Calendar.handeCalendarController_key = function (e){
	if(Calendar.mode=="controller"){
		var ESC_KEYCODE = 27;
		var key;
		if (window.event)
			key = window.event.keyCode;
		else
			key = e.which;
		if(key == ESC_KEYCODE){
			Calendar.releaseCalendar();
		}
	}
};
Calendar.disableInputEnterKeyEvent = function (e){
	var ENTER_KEYCODE = 13;
	var key;
	var name;
	var elemtType;
	if (window.event){
		name = window.event.srcElement.name;
		elemtType= window.event.srcElement.type;
		key = window.event.keyCode;
	}else{
		key = e.which;
		name=e.target.name;
		elemtType= e.target.type;
	}

	if(elemtType!="textarea" && key == ENTER_KEYCODE && name != "But_today"){
		return false;
	}else{
		return true;
	}
};
document.onmousedown=Calendar.handeCalendarController_mouse;
document.onkeyup=Calendar.handeCalendarController_key;
document.onkeypress=Calendar.disableInputEnterKeyEvent;



//will be overwritten in XSL
var abSchemaSystemGraphicsFolder = "";

var strIMGDirectory	= "";
var previouSelectedNodeImgID	= "";
var strPreviousSelectedIcon		= "ab-icon-tree-deselected.gif";
var strBeingSelectedIcon		= "ab-icon-tree-exp.gif";//ab-icon-tree-selected.gif";
var strNotBeingSelectedIcon		= "ab-icon-task-dflt.gif";


//this variable value must be same as the xslt variable "bSelect" in report-table-data.xsl
var strBSelectCheckBoxName = "bSelect";
//each tgrp has a unquie form with it
//hold each form's row selection action button's names
//arrSelectionActionButtonNames[formName][0]=selectionButton1Name;
//arrSelectionActionButtonNames[formName][1]=selectionButton2Name;
var arrSelectionActionButtonNames = new Array();
//checking if any row is selectd in a report table
//objForm: the object of form
function CheckSelectionAfmReportForm(objForm)
{
	var isSelected = false;
	var objBSelectCheckbox = objForm.elements[strBSelectCheckBoxName];
	if(objBSelectCheckbox != null){
		if(objBSelectCheckbox.length != null){
			//existing multiple rows?
			for(var i = 0; i < objBSelectCheckbox.length; i++){
				if( objBSelectCheckbox[i].checked){
					//rows are selected
					isSelected = true;
					break;
				}
			}
		}else{
			//existing only one row? it seems objBSelectCheckbox.length
			//is not working in this case(bug in IE or Javascript
			//engine?).
			if(objBSelectCheckbox.checked)
				isSelected = true;
		}
	}
	return isSelected;
}

//inserting user's data records into strSerialized
//formName: form's name
//strSerialized: xml string coming from action in xml
function insertingRecodDataString(formName, strSerialized)
{
	var strXMLValue = strSerialized;
	var objForm = document.forms[formName];
	var strData = "";
	//setSerializedInsertingDataVariables() in common.js
	//to set strSerializedStartTag, strSerializedCloseTag,
	//strSerializedInsertingDataFirstPart,
	//strSerializedInsertingDataRestPart in common.js
	setSerializedInsertingDataVariables(strSerialized);
	
	var bRowSelected = CheckSelectionAfmReportForm(objForm);
	if(bRowSelected && strSerializedInsertingDataFirstPart!="" && strSerializedInsertingDataRestPart!=""){
		var objBSelectCheckbox = objForm.elements[strBSelectCheckBoxName];
		if(objBSelectCheckbox != null){
			//getting value(only primary keys) from each selected row in the table 
			for(var i = 0; i < objBSelectCheckbox.length; i++){
				if( objBSelectCheckbox[i].checked){
					//forming record data string like
					//&lt;record rm.bl_id='HQ'/&gt;(<record rm.bl_id='HQ'/>)
					strData = strData + strSerializedStartTag + 'record' + objBSelectCheckbox[i].value + ' /' + strSerializedCloseTag;
				}
			}
		}
		//inserting into strSerialized
		strXMLValue = strSerializedInsertingDataFirstPart + strData +  strSerializedInsertingDataRestPart;
	}
	return strXMLValue;
}

//when users click URL linkings or actions, set up proper linking url with
//restriction information in xml
//formName: form's name
//strSerialized: xml string coming from action in XML
//strTarget: request's target
//isRowsAction: if the action is on data rows in the form
function sendingRequestToServer(formName, strSerialized, strTarget, isRowsAction)
{
	var strXMLValue = strSerialized;
	if(isRowsAction){
		//inserting selected rows' pks value into strSerialized
		strXMLValue = insertingRecodDataString(formName,strSerialized);
	}
	//sending data to server through a hidden form
	sendingDataFromHiddenForm('', strXMLValue, strTarget, '', false,"");
	//calling onLoadTableRefreshChildren to refresh all other child frames
	onLoadTableRefreshChildren(formName, strTarget);
}


//calling to enable selection action buttons
//formName: form's name
function EnableSelectionActionButtons(formName)
{
	//get array for sepecified form's row selection action button's
	//names
	var arrSelectionButtonNames = arrSelectionActionButtonNames[formName];
	if(arrSelectionButtonNames != null){
		var objForm = document.forms[formName];
		//check if any row selection check box is checked
		var bFlag = CheckSelectionAfmReportForm(objForm);
		for(var i=0; i < arrSelectionButtonNames.length; i++){
			var strButtonName = arrSelectionButtonNames[i];
			var objButton = objForm.elements[strButtonName];
			if(objButton != null){
				if(bFlag)
					//enable it
					objButton.disabled = 0;
				else
					//disable it
					objButton.disabled = 1;
			}
		}
	}
}

//depreciated????????????????
function printOutView(printButtonID, printCloseWndID)
{
	var objPrintButton = document.getElementById(printButtonID);
	var objPrintCloseWndButton = document.getElementById(printCloseWndID);
	//hidding buttons
	if(objPrintButton != null && objPrintCloseWndButton != null){
		if( document.all ||(!document.all && document.getElementById) ){
			objPrintButton.style.visibility = "hidden";
			objPrintCloseWndButton.style.visibility = "hidden";
		}
	}
	//print out
	self.print();
	//reshow buttons after print ???
	if(objPrintButton != null && objPrintCloseWndButton != null){
		if( document.all ||(!document.all && document.getElementById) ){
			objPrintButton.style.visibility = "visible";
			objPrintCloseWndButton.style.visibility = "visible";
		}
	}
	//<A href="#"></A> 
	return false;
}



//when document Item is clicked, this function is called to
//change the image with this item to indicate it is selected. 
function ChangeItToActiveItem(IMGID, strUrl, strXML, strTarget)
{
	strIMGDirectory = abSchemaSystemGraphicsFolder + "/";
	//send out request to server
	sendingDataFromHiddenForm(strUrl, strXML, strTarget, "", false,"");
	//change previous active node icon as selected
	if(previouSelectedNodeImgID != ""){
		var previousSelectedImgObj = document.getElementById(previouSelectedNodeImgID);
		if(previousSelectedImgObj != null)
			previousSelectedImgObj.src = strIMGDirectory + strPreviousSelectedIcon;;
	}
	if(IMGID != ""){
		//change icon to indicate active link
		var strIMGName = "IMG_"+IMGID;
		//assign strIMGName to previouSelectedNodeImgID for next time use 
		previouSelectedNodeImgID = strIMGName;

		var imgObj = document.getElementById(strIMGName);
		if(imgObj!=null)
			imgObj.src = strIMGDirectory + strBeingSelectedIcon;
	}
}
///////////////////////////
////////panel
//single row
function getRowPKs(rowIndex, formName)
{
	var returnValue="";
	var form = formName;
	if (typeof arguments[0] == "undefined"){
		form = document.forms[1].name;
	}
	var objForm = document.forms[form];
	var objBSelectCheckbox = objForm.elements[strBSelectCheckBoxName]
	if(objBSelectCheckbox.length != null){
		returnValue = objBSelectCheckbox[rowIndex].value;
	}else{
		returnValue = objBSelectCheckbox.value;
	}
	return returnValue;
}
//multi-select rows by checking checkbox
function getRowsPKs(formName)
{
	var form = formName;
	if (typeof arguments[0] == "undefined"){
		form = document.forms[1].name;
	}
	var returnedValue = "";
	var objForm = document.forms[form];
	var objBSelectCheckbox = objForm.elements[strBSelectCheckBoxName];
	if(objBSelectCheckbox != null){
		if(objBSelectCheckbox.length != null){
			for(var i = 0; i < objBSelectCheckbox.length; i++){
				if( objBSelectCheckbox[i].checked){
					var rowPKs =  objBSelectCheckbox[i].value;
					rowPKs = generateRecordXML(rowPKs)
					if(rowPKs!=""){
						returnedValue = returnedValue +rowPKs;
					}
				}
			}
		}else{

			if( objBSelectCheckbox.checked){
				var rowPKs =  objBSelectCheckbox.value;
				rowPKs = generateRecordXML(rowPKs)
				if(rowPKs!=""){
					returnedValue = returnedValue +rowPKs;
				}
			}
		}

	}
	if(returnedValue!=""){
		returnedValue = "<userInputRecordsFlag>"+returnedValue+"</userInputRecordsFlag>";
	}
	
	return returnedValue;
}


function generateRecordXML(rowPKs)
{
	rowPKs = trim(rowPKs);
	if(rowPKs!=""){
		rowPKs = convert2validXMLValue(rowPKs);
		rowPKs = rowPKs.replace(/AFM_FLAG::QUOTE/g, '"');
		rowPKs = rowPKs.replace(/AFM_FLAG::GROUP/g, '');
		rowPKs = "<record "+rowPKs+"><keys "+rowPKs+"/></record>";		
	}
	return rowPKs;
}

function getSQLRestrictionMultiSelection(formName)
{
	var form = formName;
	if (typeof arguments[0] == "undefined"){
		form = document.forms[1].name;
	}
	var returnedValue = "";
	
	var objForm = document.forms[form];
	var objBSelectCheckbox = objForm.elements[strBSelectCheckBoxName];
	if(objBSelectCheckbox != null){
		if(objBSelectCheckbox.length != null){
			for(var i = 0; i < objBSelectCheckbox.length; i++){
				if( objBSelectCheckbox[i].checked){
					var rowPKs =  objBSelectCheckbox[i].value;
					rowPKs = trim(rowPKs);
					if(rowPKs!=""){
						rowPKs = convert2validXMLValue(rowPKs);
						rowPKs = rowPKs.replace(/AFM_FLAG::QUOTE/g, '\'');
						var tempArray = rowPKs.split("AFM_FLAG::GROUP");
						var clauses = "";
						for(var j=0;j<tempArray.length;j++){
							var tempArray2 = tempArray[j];
							if(tempArray2!=""){
								var name= tempArray2.split("=")[0];
								name = trim(name);
								var value = tempArray2.split("=")[1];
								value = trim(value);
								if(clauses==""){
									clauses = '('+name+'='+value;
								}else{
									clauses = clauses + ' AND '+name+'='+value;
								}
							}
						}
						if(clauses!="")
							clauses = clauses + ") ";
						if(returnedValue=="")
							returnedValue = returnedValue + clauses;
						else
							returnedValue = returnedValue + " OR " + clauses;
					}
				}
			}
		}else{

			if( objBSelectCheckbox.checked){
				var rowPKs =  objBSelectCheckbox.value;
				rowPKs = trim(rowPKs);
				if(rowPKs!=""){
					rowPKs = convert2validXMLValue(rowPKs);
					rowPKs = rowPKs.replace(/AFM_FLAG::QUOTE/g, '\'');
					var tempArray = rowPKs.split("AFM_FLAG::GROUP");
					var clauses = "";
					for(var j=0;j<tempArray.length;j++){
						var tempArray2 = tempArray[j];
						if(tempArray2!=""){
							var name= tempArray2.split("=")[0];
							name = trim(name);
							var value = tempArray2.split("=")[1];
							value = trim(value);
							if(clauses==""){
								clauses = '('+name+'='+value;
							}else{
								clauses = clauses + ' AND '+name+'='+value;
							}
						}
					}
					if(clauses!="")
						clauses = clauses + ") ";
					if(returnedValue=="")
						returnedValue = returnedValue + clauses;
					else
						returnedValue = returnedValue + " OR " + clauses;
				}
			}
		}

	}
	if(returnedValue!=""){
		returnedValue = '<userInputRecordsFlag><restrictions><restriction type="sql" sql="'+returnedValue+'"/></restrictions></userInputRecordsFlag>';
	}
	
	return returnedValue;

}


function getParsedRestrictionFromRowPrimaryKeys(rowPKs, fieldName, tableName) {
	var returnedValue = "";
	if (typeof(rowPKs) == "string" && rowPKs.indexOf("AFM_FLAG::QUOTE") >= 0) {
		returnedValue = getClausesFromRowKeys(rowPKs, fieldName, tableName);
	}
	else if (typeof(rowPKs) == "string" && rowPKs.indexOf("<record") >= 0) {
		returnedValue = getClausesFromPrimaryKeys(rowPKs, fieldName, tableName);
	}
	else {
		returnedValue = getClausesFromPrimaryKeyObject(rowPKs, fieldName, tableName);
	}

	if (returnedValue != "") {
		returnedValue = '<userInputRecordsFlag><restrictions><restriction type="parsed">'+returnedValue+'</restriction></restrictions></userInputRecordsFlag>';
	}
	return returnedValue;
}


//one row
//return <clause...></clause><clause...></clause>...

function getClausesFromRowKeys(rowPKs, fieldName, tableName){
	var cluses="";
	rowPKs = trim(rowPKs);
	if(rowPKs!=""){
		rowPKs = convert2validXMLValue(rowPKs);
		rowPKs = rowPKs.replace(/AFM_FLAG::QUOTE/g, '"');
		var tempArray = rowPKs.split("AFM_FLAG::GROUP");
		for(var j=0;j<tempArray.length;j++){
			var tempArray2 = tempArray[j];
			if(tempArray2!=""){
				var name= tempArray2.split("=")[0];
				name = trim(name);
				var table = name.split(".")[0];
				var field = name.split(".")[1];
				if (typeof fieldName != 'undefined' && fieldName!="") {
					field = fieldName;
				}
				if (typeof tableName != 'undefined' && tableName!="") {
					table = tableName;
				}
				var value = tempArray2.split("=")[1];
				value = trim(value);
				value = convert2validXMLValue(value);
				cluses = cluses + '<clause relop="AND" op="=" value='+value+'><field name="'+field+'" table="'+table+'"/></clause>';
			}
		}
	}
	return cluses;
}
//one row
function getParsedRestrictionFromRowKeys(rowPKs, fieldName, tableName)
{
	var returnedValue=getClausesFromRowKeys(rowPKs, fieldName, tableName);
	if(returnedValue!=""){
		returnedValue = '<userInputRecordsFlag><restrictions><restriction type="parsed">'+returnedValue+'</restriction></restrictions></userInputRecordsFlag>';
	}

	return returnedValue;
}


function getClausesFromPrimaryKeys(rowPKs, fieldName, tableName){
	var clauses="";
	var delimiter = "AFM_FLAG::GROUP";
	rowPKs = trim(rowPKs);
	if(rowPKs!=""){
		rowPKs = convert2validXMLValue(rowPKs);
		var position = rowPKs.indexOf('keys');
		if (position > 0) {
			rowPKs = rowPKs.substring(position + 4);
		}
		position = rowPKs.indexOf('/&gt;&lt;/record&gt;');
		if (position > 0) {
			rowPKs = rowPKs.substring(0, position);
		}
		while (rowPKs.indexOf('&apos;') > 0) {
			rowPKs = rowPKs.replace('&apos;', '"');
		}

		var tempArray = rowPKs.split(delimiter);
		for(var j=0;j<tempArray.length;j++){
			var tempArray2 = tempArray[j];
			if(tempArray2!=""){
				var name= tempArray2.split("=")[0];
				name = trim(name);
				var table = name.split(".")[0];
				var field = name.split(".")[1];
				if (typeof fieldName != 'undefined' && fieldName!="") {
					field = fieldName;
				}
				if (typeof tableName != 'undefined' && tableName!="") {
					table = tableName;
				}
				var value = tempArray2.split("=")[1];
				value = trim(value);
				value = convert2validXMLValue(value);
				clauses = clauses + '<clause relop="AND" op="=" value='+value+'><field name="'+field+'" table="'+table+'"/></clause>';
			}
		}
	}
	return clauses;
}


function getParsedRestrictionFromPrimaryKeys(rowPKs, fieldName, tableName)
{
	var returnedValue=getClausesFromPrimaryKeys(rowPKs, fieldName, tableName);
	if(returnedValue!=""){
		returnedValue = '<userInputRecordsFlag><restrictions><restriction type="parsed">'+returnedValue+'</restriction></restrictions></userInputRecordsFlag>';
	}

	return returnedValue;
}


function getClausesFromPrimaryKeyObject(rowPKs, fieldName, tableName){
	var clauses="";

	// kb# 3015962
	// if the rowPk is an array, then loop through the rowPk and compose the clause for each rowPK record
	if(rowPKs.constructor==Array) {
		for (var name in rowPKs) {	
			clauses = clauses + getClausesFromPrimaryKeyObject(rowPKs[name]	, fieldName, tableName);
		}
	} else {
		// for non-array rowPks
		for (var name in rowPKs) {		
			var value = rowPKs[name];
			name = trim(name);
			var table = name.split(".")[0];
			var field = name.split(".")[1];
			if (typeof fieldName != 'undefined' && fieldName!="") {
				field = fieldName;
			}
			if (typeof tableName != 'undefined' && tableName!="") {
				table = tableName;
			}
			value = trim(value);
			value = convert2validXMLValue(value);
			clauses = clauses + '<clause relop="AND" op="=" value="'+value+'"><field name="'+field+'" table="'+table+'"/></clause>';
		}
	}
	return clauses;
}




function getRestrictionObjectFromRowKeys(rowPKs) {
	var fieldValues = new Array();
	rowPKs = trim(rowPKs);
	if(rowPKs!=""){
		rowPKs = convert2validXMLValue(rowPKs);
		rowPKs = rowPKs.replace(/AFM_FLAG::QUOTE/g, '');
		var tempArray = rowPKs.split("AFM_FLAG::GROUP");
		for (var j=0, tempArray2; tempArray2 = tempArray[j]; j++){
			if (tempArray2 != "") {
				var name = trim(tempArray2.split("=")[0]);
				var value = trim(tempArray2.split("=")[1]);
				fieldValues[name] = value;
			}
		}
	}
	return new Ab.view.Restriction(fieldValues);
}




function sendSelectedRequest2Server(target, xml, form, rowPKs)
{
	var data = "";
	if(rowPKs == null)
		data=getSQLRestrictionMultiSelection(form);
	else
		data=getParsedRestrictionFromRowKeys(rowPKs);
	if(data!="" && xml!="")
		sendingAfmActionRequestWithClientDataXMLString2Server(target, xml, data);
}


// -------------------------------------------------------------------------------------------------
// Sends afmAction request with client-side data XML to the server.
// Parameters:
// 		action	String containing serialized afmAction.
// 		data		Request XML data or "" if no data is attached.	
// 		target	Request target: "_blank" to open a new window, "" to reuse the current window.
//
function sendAction(action, data, target)
{
	sendingAfmActionRequestWithClientDataXMLString2Server(target, action, data);
}


// -------------------------------------------------------------------------------------------------
// Sends afmAction request with current row PKs restriction to the server.
// Parameters:
// 		action	String containing serialized afmAction.
// 		rowPKs	List of current row primary key values.	
// 		target	Request target: "_blank" to open a new window, "" to reuse the current window.
//
function sendActionWithRestrictionForRow(action, rowPKs, target)
{
	var restriction = getParsedRestrictionFromRowKeys(rowPKs);
	sendAction(action, restriction, target);
}


// -------------------------------------------------------------------------------------------------
// Sends afmAction request with multi-selection PKs restrictions to the server.
// Parameters:
// 		action	String containing serialized afmAction.
// 		formName HTML form name.	
// 		target	Request target: "_blank" to open a new window, "" to reuse the current window.
//
function sendActionWithRestrictionForSelectedRows(action, formName, target)
{
	var restriction = getSQLRestrictionMultiSelection(formName);
	sendAction(action, restriction, target);
}


// -------------------------------------------------------------------------------------------------
// Returns XML string containing a list of <record> elements for selected rows PKs.
// Parameters:
// 		rowPKs	List of current row primary key values.	
//
function getRecordForRow(rowPKs) 
{
	return generateRecordXML(rowPKs);
}


// -------------------------------------------------------------------------------------------------
// Returns XML string containing a list of <record> elements for selected rows PKs.
// Parameters:
// 		formName       HTML form name.	
//
function getRecordsForSelectedRows(formName) {
	var records = "<userInputRecordsFlag><records>";
	
	var objForm = getForm(formName);
	var objBSelectCheckbox = objForm.elements[strBSelectCheckBoxName];
	if(objBSelectCheckbox != null){
		if(objBSelectCheckbox.length != null){
			// array of check box controls 
			for(var i = 0; i < objBSelectCheckbox.length; i++){
				if( objBSelectCheckbox[i].checked ){
					var rowPKs =  objBSelectCheckbox[i].value;
					var record = getRecordForRow(rowPKs);
					records = records + record;
				}
			}
		}else{
			// single check box control
			if( objBSelectCheckbox.checked){
				var rowPKs =  objBSelectCheckbox.value;
				var record = getRecordForRow(rowPKs);
				records = records + record;
			}
		}

	}
	
	records = records + '</records></userInputRecordsFlag>';
	return records;
}


// -------------------------------------------------------------------------------------------------
// Returns XML string containing a list of <record> elements for all rows PKs.
// Parameters:
//      reportId       Report panel ID attribute in AXVW.
//
function getRecordsForAllRows(reportId) {
    var records = "<userInputRecordsFlag><records>";
    
    var table = $(reportId);
    var tbody = table.childNodes[0];
    for (var i = 1; i < tbody.childNodes.length; i++) {
        var tr = tbody.childNodes[i];
        var record = getRecordForRow(tr.id);
        records = records + record;
    }
    
    records = records + '</records></userInputRecordsFlag>';
    return records;
}



function getNumberOfRows(reportId) {
    var table = $(reportId);
    var tbody = table.childNodes[0];
    return tbody.childNodes.length - 1;
}



function getCellContent(reportId, row, column) {
    var table = $(reportId);
    var tbody = table.childNodes[0];
    var tr = tbody.childNodes[row + 1];
    var td = tr.childNodes[column];
    return td.childNodes[0];
}

// -------------------------------------------------------------------------------------------------
// Returns HTML form object by name. If the name is not specified, returns first form.
//
function getForm(formName) 
{
	var actualFormName = formName;
	if (typeof arguments[0] == "undefined"){
		actualFormName = document.forms[1].name;
	}
	return document.forms[actualFormName];
}



function Base() {
};

Base.version = "1.0.1";

Base.prototype = {
	extend: function(source, value) {
		var extend = Base.prototype.extend;
		if (arguments.length == 2) {
			var ancestor = this[source];
			// overriding?
			if ((ancestor instanceof Function) && (value instanceof Function) &&
				ancestor.valueOf() != value.valueOf() && /\binherit\b/.test(value)) {
				var method = value;
				value = function() {
					var previous = this.inherit;
					this.inherit = ancestor;
					var returnValue = method.apply(this, arguments);
					this.inherit = previous;
					return returnValue;
				};
				// point to the underlying method
				value.valueOf = function() {
					return method;
				};
				value.toString = function() {
					return String(method);
				};
			}
			return this[source] = value;
		} else if (source) {
			var _prototype = {toSource: null};
			// do the "toString" and other methods manually
			var _protected = ["toString", "valueOf"];
			// if we are prototyping then include the constructor
			if (Base._prototyping) _protected[2] = "constructor";
			for (var i = 0; (name = _protected[i]); i++) {
				if (source[name] != _prototype[name]) {
					extend.call(this, name, source[name]);
				}
			}
			// copy each of the source object's properties to this object
			for (var name in source) {
				if (!_prototype[name]) {
					extend.call(this, name, source[name]);
				}
			}
		}
		return this;
	},

	inherit: function() {
		// call this method from any other method to invoke that method's ancestor
	}
};

Base.extend = function(_instance, _static) {	
	var extend = Base.prototype.extend;
	if (!_instance) _instance = {};
	// create the constructor
	if (_instance.constructor == Object) {
		_instance.constructor = new Function;
	}
	// build the prototype
	Base._prototyping = true;
	var _prototype = new this;
	extend.call(_prototype, _instance);
	var constructor = _prototype.constructor;
	_prototype.constructor = this;
	delete Base._prototyping;
	// create the wrapper for the constructor function
	var klass = function() {
		if (!Base._prototyping) constructor.apply(this, arguments);
		this.constructor = klass;
	};
	klass.prototype = _prototype;
	// build the class interface
	klass.extend = this.extend;
	klass.toString = function() {
		return String(constructor);
	};
	extend.call(klass, _static);
	// support singletons
	var object = constructor ? klass : _prototype;
	// class initialisation
	if (object.init instanceof Function) object.init();
	return object;
};






escapeJSONChar =
function escapeJSONChar(c)
{
    if(c == "\"" || c == "\\") return "\\" + c;
    else if (c == "\b") return "\\b";
    else if (c == "\f") return "\\f";
    else if (c == "\n") return "\\n";
    else if (c == "\r") return "\\r";
    else if (c == "\t") return "\\t";
    var hex = c.charCodeAt(0).toString(16);
    if(hex.length == 1) return "\\u000" + hex;
    else if(hex.length == 2) return "\\u00" + hex;
    else if(hex.length == 3) return "\\u0" + hex;
    else return "\\u" + hex;
};




escapeJSONString =
function escapeJSONString(s)
{
    

    
    var parts = s.split("");
    for(var i=0; i < parts.length; i++) {
	var c =parts[i];
	if(c == '"' ||
	   c == '\\' ||
	   c.charCodeAt(0) < 32 ||
	   c.charCodeAt(0) >= 128)
	    parts[i] = escapeJSONChar(parts[i]);
    }
    return "\"" + parts.join("") + "\"";
};




toJSON = function toJSON(o)
{
    if(o == null) {
	return "null";
    } else if(o.constructor == String) {
	return escapeJSONString(o);
    } else if(o.constructor == Number) {
	return o.toString();
    } else if(o.constructor == Boolean) {
	return o.toString();
    } else if(o.constructor == Date) {
	return '{javaClass: "java.util.Date", time: ' + o.valueOf() +'}';
    } else if(o.constructor == Array || typeof(o.length) != 'undefined') {
	var v = [];
	for(var i = 0; i < o.length; i++) v.push(toJSON(o[i]));
	return "[" + v.join(", ") + "]";
    } else {
	var v = [];
	for(attr in o) {
	    if(o[attr] == null) v.push("\"" + attr + "\": null");
	    else if(typeof o[attr] == "function"); 
	    else v.push(escapeJSONString(attr) + ": " + toJSON(o[attr]));
	}
	return "{" + v.join(", ") + "}";
    }
};



(function () {
    var INTEND = "&nbsp;&nbsp;";
    var NEWLINE = "<br/>";
    var pPr = false;
    var intendLevel = 0;
    var intend = function(a) {
        if (!pPr) return a;
        for (var l=0; l<intendLevel; l++) {
            a[a.length] = INTEND;
        }
        return a;
    };

    var newline = function(a) {
        if (pPr) a[a.length] = NEWLINE;
        return a;
    };

    var m = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        s = {
            array: function (x) {
                var a = ['['], b, f, i, l = x.length, v;
                a = newline(a);
                intendLevel++;
                for (i = 0; i < l; i += 1) {
                    v = x[i];
                    f = s[typeof v];
                    if (f) {
                        v = f(v);
                        if (typeof v == 'string') {
                            if (b) {
                                a[a.length] = ',';
                                a = newline(a);
                            }
                            a = intend(a);
                            a[a.length] = v;
                            b = true;
                        }
                    }
                }
                intendLevel--;
                a = newline(a);
                a = intend(a);
                a[a.length] = ']';
                return a.join('');
            },
            'boolean': function (x) {
                return String(x);
            },
            'null': function (x) {
                return "null";
            },
            number: function (x) {
                return isFinite(x) ? String(x) : 'null';
            },
            object: function (x, formatedOutput) {
                if (x) {
                    if (x instanceof Array) {
                        return s.array(x);
                    }
                    var a = ['{'], b, f, i, v;
                    a = newline(a);
                    intendLevel++;
                    for (i in x) {
                        v = x[i];
                        f = s[typeof v];
                        if (f) {
                            v = f(v);
                            if (typeof v == 'string') {
                                if (b) {
                                    a[a.length] = ',';
                                    a = newline(a);
                                }
                                a = intend(a);
                                a.push(s.string(i), ((pPr) ? ' : ' : ':'), v);
                                b = true;
                            }
                        }
                    }
                    intendLevel--;
                    a = newline(a);
                    a = intend(a);
                    a[a.length] = '}';
                    return a.join('');
                }
                return 'null';
            },
            string: function (x) {
                if (/["\\\x00-\x1f]/.test(x)) {
                    x = x.replace(/([\x00-\x1f\\"])/g, function(a, b) {
                        var c = m[b];
                        if (c) {
                            return c;
                        }
                        c = b.charCodeAt();
                        return '\\u00' +
                            Math.floor(c / 16).toString(16) +
                            (c % 16).toString(16);
                    });
                }
                return '"' + x + '"';
            }
        };

    prettyPrintJson = function (json) {
        pPr = true;
        if (json.constructor == String) {
            return json;
        } else if (json.constructor == Array) {
            return s.array(json);
        } else {
            return s.object(json);
        }
    };
})();


var TrimPath;

// TODO: Debugging mode vs stop-on-error mode - runtime flag.
// TODO: Handle || (or) characters and backslashes.
// TODO: Add more modifiers.

(function() {               // Using a closure to keep global namespace clean.
    if (TrimPath == null)
        TrimPath = new Object();
    if (TrimPath.evalEx == null)
        TrimPath.evalEx = function(src) { return eval(src); };

    var UNDEFINED;
    if (Array.prototype.pop == null)  // IE 5.x fix from Igor Poteryaev.
        Array.prototype.pop = function() {
            if (this.length === 0) {return UNDEFINED;}
            return this[--this.length];
        };
    if (Array.prototype.push == null) // IE 5.x fix from Igor Poteryaev.
        Array.prototype.push = function() {
            for (var i = 0; i < arguments.length; ++i) {this[this.length] = arguments[i];}
            return this.length;
        };

    TrimPath.parseTemplate = function(tmplContent, optTmplName, optEtc) {
        if (optEtc == null)
            optEtc = TrimPath.parseTemplate_etc;
        var funcSrc = parse(tmplContent, optTmplName, optEtc);
        var func = TrimPath.evalEx(funcSrc, optTmplName, 1);
        if (func != null)
            return new optEtc.Template(optTmplName, tmplContent, funcSrc, func, optEtc);
        return null;
    }
    
    try {
        String.prototype.process = function(context, optFlags) {
            var template = TrimPath.parseTemplate(this, null);
            if (template != null)
                return template.process(context, optFlags);
            return this;
        }
    } catch (e) { // Swallow exception, such as when String.prototype is sealed.
    }
    
    TrimPath.parseTemplate_etc = {};            // Exposed for extensibility.
    TrimPath.parseTemplate_etc.statementTag = "forelse|for|if|elseif|else|var|macro";
    TrimPath.parseTemplate_etc.statementDef = { // Lookup table for statement tags.
        "if"     : { delta:  1, prefix: "if (", suffix: ") {", paramMin: 1 },
        "else"   : { delta:  0, prefix: "} else {" },
        "elseif" : { delta:  0, prefix: "} else if (", suffix: ") {", paramDefault: "true" },
        "/if"    : { delta: -1, prefix: "}" },
        "for"    : { delta:  1, paramMin: 3, 
                     prefixFunc : function(stmtParts, state, tmplName, etc) {
                        if (stmtParts[2] != "in")
                            throw new etc.ParseError(tmplName, state.line, "bad for loop statement: " + stmtParts.join(' '));
                        var iterVar = stmtParts[1];
                        var listVar = "__LIST__" + iterVar;
                        return [ "var ", listVar, " = ", stmtParts[3], ";",
                             // Fix from Ross Shaull for hash looping, make sure that we have an array of loop lengths to treat like a stack.
                             "var __LENGTH_STACK__;",
                             "if (typeof(__LENGTH_STACK__) == 'undefined' || !__LENGTH_STACK__.length) __LENGTH_STACK__ = new Array();", 
                             "__LENGTH_STACK__[__LENGTH_STACK__.length] = 0;", // Push a new for-loop onto the stack of loop lengths.
                             "if ((", listVar, ") != null) { ",
                             "var ", iterVar, "_ct = 0;",       // iterVar_ct variable, added by B. Bittman     
                             "for (var ", iterVar, "_index in ", listVar, ") { ",
                             iterVar, "_ct++;",
                             "if (typeof(", listVar, "[", iterVar, "_index]) == 'function') {continue;}", // IE 5.x fix from Igor Poteryaev.
                             "__LENGTH_STACK__[__LENGTH_STACK__.length - 1]++;",
                             "var ", iterVar, " = ", listVar, "[", iterVar, "_index];" ].join("");
                     } },
        "forelse" : { delta:  0, prefix: "} } if (__LENGTH_STACK__[__LENGTH_STACK__.length - 1] == 0) { if (", suffix: ") {", paramDefault: "true" },
        "/for"    : { delta: -1, prefix: "} }; delete __LENGTH_STACK__[__LENGTH_STACK__.length - 1];" }, // Remove the just-finished for-loop from the stack of loop lengths.
        "var"     : { delta:  0, prefix: "var ", suffix: ";" },
        "macro"   : { delta:  1, 
                      prefixFunc : function(stmtParts, state, tmplName, etc) {
                          var macroName = stmtParts[1].split('(')[0];
                          return [ "var ", macroName, " = function", 
                                   stmtParts.slice(1).join(' ').substring(macroName.length),
                                   "{ var _OUT_arr = []; var _OUT = { write: function(m) { if (m) _OUT_arr.push(m); } }; " ].join('');
                     } }, 
        "/macro"  : { delta: -1, prefix: " return _OUT_arr.join(''); };" }
    }
    TrimPath.parseTemplate_etc.modifierDef = {
        "eat"        : function(v)    { return ""; },
        "escape"     : function(s)    { return String(s).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"); },
        "capitalize" : function(s)    { return String(s).toUpperCase(); },
        "default"    : function(s, d) { return s != null ? s : d; }
    }
    TrimPath.parseTemplate_etc.modifierDef.h = TrimPath.parseTemplate_etc.modifierDef.escape;

    TrimPath.parseTemplate_etc.Template = function(tmplName, tmplContent, funcSrc, func, etc) {
        this.process = function(context, flags) {
            if (context == null)
                context = {};
            if (context._MODIFIERS == null)
                context._MODIFIERS = {};
            if (context.defined == null)
                context.defined = function(str) { return (context[str] != undefined); };
            for (var k in etc.modifierDef) {
                if (context._MODIFIERS[k] == null)
                    context._MODIFIERS[k] = etc.modifierDef[k];
            }
            if (flags == null)
                flags = {};
            var resultArr = [];
            var resultOut = { write: function(m) { resultArr.push(m); } };
            try {
                func(resultOut, context, flags);
            } catch (e) {
                if (flags.throwExceptions == true)
                    throw e;
                var result = new String(resultArr.join("") + "[ERROR: " + e.toString() + (e.message ? '; ' + e.message : '') + "]");
                result["exception"] = e;
                return result;
            }
            return resultArr.join("");
        }
        this.name       = tmplName;
        this.source     = tmplContent; 
        this.sourceFunc = funcSrc;
        this.toString   = function() { return "TrimPath.Template [" + tmplName + "]"; }
    }
    TrimPath.parseTemplate_etc.ParseError = function(name, line, message) {
        this.name    = name;
        this.line    = line;
        this.message = message;
    }
    TrimPath.parseTemplate_etc.ParseError.prototype.toString = function() { 
        return ("TrimPath template ParseError in " + this.name + ": line " + this.line + ", " + this.message);
    }
    
    var parse = function(body, tmplName, etc) {
        body = cleanWhiteSpace(body);
        var funcText = [ "var TrimPath_Template_TEMP = function(_OUT, _CONTEXT, _FLAGS) { with (_CONTEXT) {" ];
        var state    = { stack: [], line: 1 };                              // TODO: Fix line number counting.
        var endStmtPrev = -1;
        while (endStmtPrev + 1 < body.length) {
            var begStmt = endStmtPrev;
            // Scan until we find some statement markup.
            begStmt = body.indexOf("{", begStmt + 1);
            while (begStmt >= 0) {
                var endStmt = body.indexOf('}', begStmt + 1);
                var stmt = body.substring(begStmt, endStmt);
                var blockrx = stmt.match(/^\{(cdata|minify|eval)/); // From B. Bittman, minify/eval/cdata implementation.
                if (blockrx) {
                    var blockType = blockrx[1]; 
                    var blockMarkerBeg = begStmt + blockType.length + 1;
                    var blockMarkerEnd = body.indexOf('}', blockMarkerBeg);
                    if (blockMarkerEnd >= 0) {
                        var blockMarker;
                        if( blockMarkerEnd - blockMarkerBeg <= 0 ) {
                            blockMarker = "{/" + blockType + "}";
                        } else {
                            blockMarker = body.substring(blockMarkerBeg + 1, blockMarkerEnd);
                        }                        
                        
                        var blockEnd = body.indexOf(blockMarker, blockMarkerEnd + 1);
                        if (blockEnd >= 0) {                            
                            emitSectionText(body.substring(endStmtPrev + 1, begStmt), funcText);
                            
                            var blockText = body.substring(blockMarkerEnd + 1, blockEnd);
                            if (blockType == 'cdata') {
                                emitText(blockText, funcText);
                            } else if (blockType == 'minify') {
                                emitText(scrubWhiteSpace(blockText), funcText);
                            } else if (blockType == 'eval') {
                                if (blockText != null && blockText.length > 0) // From B. Bittman, eval should not execute until process().
                                    funcText.push('_OUT.write( (function() { ' + blockText + ' })() );');
                            }
                            begStmt = endStmtPrev = blockEnd + blockMarker.length - 1;
                        }
                    }                        
                } else if (body.charAt(begStmt - 1) != '$' &&               // Not an expression or backslashed,
                           body.charAt(begStmt - 1) != '\\') {              // so check if it is a statement tag.
                    var offset = (body.charAt(begStmt + 1) == '/' ? 2 : 1); // Close tags offset of 2 skips '/'.
                                                                            // 10 is larger than maximum statement tag length.
                    if (body.substring(begStmt + offset, begStmt + 10 + offset).search(TrimPath.parseTemplate_etc.statementTag) == 0) 
                        break;                                              // Found a match.
                }
                begStmt = body.indexOf("{", begStmt + 1);
            }
            if (begStmt < 0)                              // In "a{for}c", begStmt will be 1.
                break;
            var endStmt = body.indexOf("}", begStmt + 1); // In "a{for}c", endStmt will be 5.
            if (endStmt < 0)
                break;
            emitSectionText(body.substring(endStmtPrev + 1, begStmt), funcText);
            emitStatement(body.substring(begStmt, endStmt + 1), state, funcText, tmplName, etc);
            endStmtPrev = endStmt;
        }
        emitSectionText(body.substring(endStmtPrev + 1), funcText);
        if (state.stack.length != 0)
            throw new etc.ParseError(tmplName, state.line, "unclosed, unmatched statement(s): " + state.stack.join(","));
        funcText.push("}}; TrimPath_Template_TEMP");
        return funcText.join("");
    }
    
    var emitStatement = function(stmtStr, state, funcText, tmplName, etc) {
        var parts = stmtStr.slice(1, -1).split(' ');
        var stmt = etc.statementDef[parts[0]]; // Here, parts[0] == for/if/else/...
        if (stmt == null) {                    // Not a real statement.
            emitSectionText(stmtStr, funcText);
            return;
        }
        if (stmt.delta < 0) {
            if (state.stack.length <= 0)
                throw new etc.ParseError(tmplName, state.line, "close tag does not match any previous statement: " + stmtStr);
            state.stack.pop();
        } 
        if (stmt.delta > 0)
            state.stack.push(stmtStr);

        if (stmt.paramMin != null &&
            stmt.paramMin >= parts.length)
            throw new etc.ParseError(tmplName, state.line, "statement needs more parameters: " + stmtStr);
        if (stmt.prefixFunc != null)
            funcText.push(stmt.prefixFunc(parts, state, tmplName, etc));
        else 
            funcText.push(stmt.prefix);
        if (stmt.suffix != null) {
            if (parts.length <= 1) {
                if (stmt.paramDefault != null)
                    funcText.push(stmt.paramDefault);
            } else {
                for (var i = 1; i < parts.length; i++) {
                    if (i > 1)
                        funcText.push(' ');
                    funcText.push(parts[i]);
                }
            }
            funcText.push(stmt.suffix);
        }
    }

    var emitSectionText = function(text, funcText) {
        if (text.length <= 0)
            return;
        var nlPrefix = 0;               // Index to first non-newline in prefix.
        var nlSuffix = text.length - 1; // Index to first non-space/tab in suffix.
        while (nlPrefix < text.length && (text.charAt(nlPrefix) == '\n'))
            nlPrefix++;
        while (nlSuffix >= 0 && (text.charAt(nlSuffix) == ' ' || text.charAt(nlSuffix) == '\t'))
            nlSuffix--;
        if (nlSuffix < nlPrefix)
            nlSuffix = nlPrefix;
        if (nlPrefix > 0) {
            funcText.push('if (_FLAGS.keepWhitespace == true) _OUT.write("');
            var s = text.substring(0, nlPrefix).replace('\n', '\\n'); // A macro IE fix from BJessen.
            if (s.charAt(s.length - 1) == '\n')
            	s = s.substring(0, s.length - 1);
            funcText.push(s);
            funcText.push('");');
        }
        var lines = text.substring(nlPrefix, nlSuffix + 1).split('\n');
        for (var i = 0; i < lines.length; i++) {
            emitSectionTextLine(lines[i], funcText);
            if (i < lines.length - 1)
                funcText.push('_OUT.write("\\n");\n');
        }
        if (nlSuffix + 1 < text.length) {
            funcText.push('if (_FLAGS.keepWhitespace == true) _OUT.write("');
            var s = text.substring(nlSuffix + 1).replace('\n', '\\n');
            if (s.charAt(s.length - 1) == '\n')
            	s = s.substring(0, s.length - 1);
            funcText.push(s);
            funcText.push('");');
        }
    }
    
    var emitSectionTextLine = function(line, funcText) {
        var endMarkPrev = '}';
        var endExprPrev = -1;
        while (endExprPrev + endMarkPrev.length < line.length) {
            var begMark = "${", endMark = "}";
            var begExpr = line.indexOf(begMark, endExprPrev + endMarkPrev.length); // In "a${b}c", begExpr == 1
            if (begExpr < 0)
                break;
            if (line.charAt(begExpr + 2) == '%') {
                begMark = "${%";
                endMark = "%}";
            }
            var endExpr = line.indexOf(endMark, begExpr + begMark.length);         // In "a${b}c", endExpr == 4;
            if (endExpr < 0)
                break;
            emitText(line.substring(endExprPrev + endMarkPrev.length, begExpr), funcText);                
            // Example: exprs == 'firstName|default:"John Doe"|capitalize'.split('|')
            var exprArr = line.substring(begExpr + begMark.length, endExpr).replace(/\|\|/g, "#@@#").split('|');
            for (var k in exprArr) {
                if (exprArr[k].replace) // IE 5.x fix from Igor Poteryaev.
                    exprArr[k] = exprArr[k].replace(/#@@#/g, '||');
            }
            funcText.push('_OUT.write(');
            emitExpression(exprArr, exprArr.length - 1, funcText); 
            funcText.push(');');
            endExprPrev = endExpr;
            endMarkPrev = endMark;
        }
        emitText(line.substring(endExprPrev + endMarkPrev.length), funcText); 
    }
    
    var emitText = function(text, funcText) {
        if (text == null ||
            text.length <= 0)
            return;
        text = text.replace(/\\/g, '\\\\');
        text = text.replace(/\n/g, '\\n');
        text = text.replace(/"/g,  '\\"');
        funcText.push('_OUT.write("');
        funcText.push(text);
        funcText.push('");');
    }
    
    var emitExpression = function(exprArr, index, funcText) {
        // Ex: foo|a:x|b:y1,y2|c:z1,z2 is emitted as c(b(a(foo,x),y1,y2),z1,z2)
        var expr = exprArr[index]; // Ex: exprArr == [firstName,capitalize,default:"John Doe"]
        if (index <= 0) {          // Ex: expr    == 'default:"John Doe"'
            funcText.push(expr);
            return;
        }
        var parts = expr.split(':');
        funcText.push('_MODIFIERS["');
        funcText.push(parts[0]); // The parts[0] is a modifier function name, like capitalize.
        funcText.push('"](');
        emitExpression(exprArr, index - 1, funcText);
        if (parts.length > 1) {
            funcText.push(',');
            funcText.push(parts[1]);
        }
        funcText.push(')');
    }

    var cleanWhiteSpace = function(result) {
        result = result.replace(/\t/g,   "    ");
        result = result.replace(/\r\n/g, "\n");
        result = result.replace(/\r/g,   "\n");
        result = result.replace(/^(\s*\S*(\s+\S+)*)\s*$/, '$1'); // Right trim by Igor Poteryaev.
        return result;
    }

    var scrubWhiteSpace = function(result) {
        result = result.replace(/^\s+/g,   "");
        result = result.replace(/\s+$/g,   "");
        result = result.replace(/\s+/g,   " ");
        result = result.replace(/^(\s*\S*(\s+\S+)*)\s*$/, '$1'); // Right trim by Igor Poteryaev.
        return result;
    }

    // The DOM helper functions depend on DOM/DHTML, so they only work in a browser.
    // However, these are not considered core to the engine.
    //
    TrimPath.parseDOMTemplate = function(elementId, optDocument, optEtc) {
        if (optDocument == null)
            optDocument = document;
        var element = optDocument.getElementById(elementId);
        var content = element.value;     // Like textarea.value.
        if (content == null)
            content = element.innerHTML; // Like textarea.innerHTML.
        content = content.replace(/&lt;/g, "<").replace(/&gt;/g, ">");
        return TrimPath.parseTemplate(content, elementId, optEtc);
    }

    TrimPath.processDOMTemplate = function(elementId, context, optFlags, optDocument, optEtc) {
        return TrimPath.parseDOMTemplate(elementId, optDocument, optEtc).process(context, optFlags);
    }
}) ();














if (typeof YAHOO == "undefined" || !YAHOO) {
    
    var YAHOO = {};
}


YAHOO.namespace = function() {
    var a=arguments, o=null, i, j, d;
    for (i=0; i<a.length; i=i+1) {
        d=(""+a[i]).split(".");
        o=YAHOO;

        // YAHOO is implied, so it is ignored if it is included
        for (j=(d[0] == "YAHOO") ? 1 : 0; j<d.length; j=j+1) {
            o[d[j]]=o[d[j]] || {};
            o=o[d[j]];
        }
    }

    return o;
};


YAHOO.log = function(msg, cat, src) {
    var l=YAHOO.widget.Logger;
    if(l && l.log) {
        return l.log(msg, cat, src);
    } else {
        return false;
    }
};


YAHOO.register = function(name, mainClass, data) {
    var mods = YAHOO.env.modules, m, v, b, ls, i;

    if (!mods[name]) {
        mods[name] = { 
            versions:[], 
            builds:[] 
        };
    }

    m  = mods[name];
    v  = data.version;
    b  = data.build;
    ls = YAHOO.env.listeners;

    m.name = name;
    m.version = v;
    m.build = b;
    m.versions.push(v);
    m.builds.push(b);
    m.mainClass = mainClass;

    // fire the module load listeners
    for (i=0;i<ls.length;i=i+1) {
        ls[i](m);
    }
    // label the main class
    if (mainClass) {
        mainClass.VERSION = v;
        mainClass.BUILD = b;
    } else {
        YAHOO.log("mainClass is undefined for module " + name, "warn");
    }
};


YAHOO.env = YAHOO.env || {

    
    modules: [],
    
    
    listeners: []
};


YAHOO.env.getVersion = function(name) {
    return YAHOO.env.modules[name] || null;
};


YAHOO.env.ua = function() {

        var numberfy = function(s) {
            var c = 0;
            return parseFloat(s.replace(/\./g, function() {
                return (c++ == 1) ? '' : '.';
            }));
        },

        nav = navigator,

        o = {

        
        ie: 0,

        
        opera: 0,

        
        gecko: 0,

        
        webkit: 0,

        
        mobile: null,

        
        air: 0,

        
        caja: nav.cajaVersion,

        
        secure: false,

        
        os: null

    },

    ua = navigator && navigator.userAgent, 
    
    loc = window && window.location,

    href = loc && loc.href,
    
    m;

    o.secure = href && (href.toLowerCase().indexOf("https") === 0);

    if (ua) {

        if ((/windows|win32/i).test(ua)) {
            o.os = 'windows';
        } else if ((/macintosh/i).test(ua)) {
            o.os = 'macintosh';
        }
    
        // Modern KHTML browsers should qualify as Safari X-Grade
        if ((/KHTML/).test(ua)) {
            o.webkit=1;
        }

        // Modern WebKit browsers are at least X-Grade
        m=ua.match(/AppleWebKit\/([^\s]*)/);
        if (m&&m[1]) {
            o.webkit=numberfy(m[1]);

            // Mobile browser check
            if (/ Mobile\//.test(ua)) {
                o.mobile = "Apple"; // iPhone or iPod Touch
            } else {
                m=ua.match(/NokiaN[^\/]*/);
                if (m) {
                    o.mobile = m[0]; // Nokia N-series, ex: NokiaN95
                }
            }

            m=ua.match(/AdobeAIR\/([^\s]*)/);
            if (m) {
                o.air = m[0]; // Adobe AIR 1.0 or better
            }

        }

        if (!o.webkit) { // not webkit
            // @todo check Opera/8.01 (J2ME/MIDP; Opera Mini/2.0.4509/1316; fi; U; ssr)
            m=ua.match(/Opera[\s\/]([^\s]*)/);
            if (m&&m[1]) {
                o.opera=numberfy(m[1]);
                m=ua.match(/Opera Mini[^;]*/);
                if (m) {
                    o.mobile = m[0]; // ex: Opera Mini/2.0.4509/1316
                }
            } else { // not opera or webkit
                m=ua.match(/MSIE\s([^;]*)/);
                if (m&&m[1]) {
                    o.ie=numberfy(m[1]);
                } else { // not opera, webkit, or ie
                    m=ua.match(/Gecko\/([^\s]*)/);
                    if (m) {
                        o.gecko=1; // Gecko detected, look for revision
                        m=ua.match(/rv:([^\s\)]*)/);
                        if (m&&m[1]) {
                            o.gecko=numberfy(m[1]);
                        }
                    }
                }
            }
        }
    }

    return o;
}();


(function() {
    YAHOO.namespace("util", "widget", "example");
    
    if ("undefined" !== typeof YAHOO_config) {
        var l=YAHOO_config.listener, ls=YAHOO.env.listeners,unique=true, i;
        if (l) {
            // if YAHOO is loaded multiple times we need to check to see if
            // this is a new config object.  If it is, add the new component
            // load listener to the stack
            for (i=0; i<ls.length; i++) {
                if (ls[i] == l) {
                    unique = false;
                    break;
                }
            }

            if (unique) {
                ls.push(l);
            }
        }
    }
})();

YAHOO.lang = YAHOO.lang || {};

(function() {


var L = YAHOO.lang,

    OP = Object.prototype,
    ARRAY_TOSTRING = '[object Array]',
    FUNCTION_TOSTRING = '[object Function]',
    OBJECT_TOSTRING = '[object Object]',
    NOTHING = [],

    // ADD = ["toString", "valueOf", "hasOwnProperty"],
    ADD = ["toString", "valueOf"],

    OB = {

    
    isArray: function(o) { 
        return OP.toString.apply(o) === ARRAY_TOSTRING;
    },

    
    isBoolean: function(o) {
        return typeof o === 'boolean';
    },
    
    
    isFunction: function(o) {
        return (typeof o === 'function') || OP.toString.apply(o) === FUNCTION_TOSTRING;
    },
        
    
    isNull: function(o) {
        return o === null;
    },
        
    
    isNumber: function(o) {
        return typeof o === 'number' && isFinite(o);
    },
      
      
    isObject: function(o) {
return (o && (typeof o === 'object' || L.isFunction(o))) || false;
    },
        
    
    isString: function(o) {
        return typeof o === 'string';
    },
        
    
    isUndefined: function(o) {
        return typeof o === 'undefined';
    },
    
 
    
    _IEEnumFix: (YAHOO.env.ua.ie) ? function(r, s) {
            var i, fname, f;
            for (i=0;i<ADD.length;i=i+1) {

                fname = ADD[i];
                f = s[fname];

                if (L.isFunction(f) && f!=OP[fname]) {
                    r[fname]=f;
                }
            }
    } : function(){},
       
    
    extend: function(subc, superc, overrides) {
        if (!superc||!subc) {
            throw new Error("extend failed, please check that " +
                            "all dependencies are included.");
        }
        var F = function() {}, i;
        F.prototype=superc.prototype;
        subc.prototype=new F();
        subc.prototype.constructor=subc;
        subc.superclass=superc.prototype;
        if (superc.prototype.constructor == OP.constructor) {
            superc.prototype.constructor=superc;
        }
    
        if (overrides) {
            for (i in overrides) {
                if (L.hasOwnProperty(overrides, i)) {
                    subc.prototype[i]=overrides[i];
                }
            }

            L._IEEnumFix(subc.prototype, overrides);
        }
    },
   
    
    augmentObject: function(r, s) {
        if (!s||!r) {
            throw new Error("Absorb failed, verify dependencies.");
        }
        var a=arguments, i, p, overrideList=a[2];
        if (overrideList && overrideList!==true) { // only absorb the specified properties
            for (i=2; i<a.length; i=i+1) {
                r[a[i]] = s[a[i]];
            }
        } else { // take everything, overwriting only if the third parameter is true
            for (p in s) { 
                if (overrideList || !(p in r)) {
                    r[p] = s[p];
                }
            }
            
            L._IEEnumFix(r, s);
        }
    },
 
    
    augmentProto: function(r, s) {
        if (!s||!r) {
            throw new Error("Augment failed, verify dependencies.");
        }
        //var a=[].concat(arguments);
        var a=[r.prototype,s.prototype], i;
        for (i=2;i<arguments.length;i=i+1) {
            a.push(arguments[i]);
        }
        L.augmentObject.apply(this, a);
    },

      
    
    dump: function(o, d) {
        var i,len,s=[],OBJ="{...}",FUN="f(){...}",
            COMMA=', ', ARROW=' => ';

        // Cast non-objects to string
        // Skip dates because the std toString is what we want
        // Skip HTMLElement-like objects because trying to dump 
        // an element will cause an unhandled exception in FF 2.x
        if (!L.isObject(o)) {
            return o + "";
        } else if (o instanceof Date || ("nodeType" in o && "tagName" in o)) {
            return o;
        } else if  (L.isFunction(o)) {
            return FUN;
        }

        // dig into child objects the depth specifed. Default 3
        d = (L.isNumber(d)) ? d : 3;

        // arrays [1, 2, 3]
        if (L.isArray(o)) {
            s.push("[");
            for (i=0,len=o.length;i<len;i=i+1) {
                if (L.isObject(o[i])) {
                    s.push((d > 0) ? L.dump(o[i], d-1) : OBJ);
                } else {
                    s.push(o[i]);
                }
                s.push(COMMA);
            }
            if (s.length > 1) {
                s.pop();
            }
            s.push("]");
        // objects {k1 => v1, k2 => v2}
        } else {
            s.push("{");
            for (i in o) {
                if (L.hasOwnProperty(o, i)) {
                    s.push(i + ARROW);
                    if (L.isObject(o[i])) {
                        s.push((d > 0) ? L.dump(o[i], d-1) : OBJ);
                    } else {
                        s.push(o[i]);
                    }
                    s.push(COMMA);
                }
            }
            if (s.length > 1) {
                s.pop();
            }
            s.push("}");
        }

        return s.join("");
    },

    
    substitute: function (s, o, f) {
        var i, j, k, key, v, meta, saved=[], token, 
            DUMP='dump', SPACE=' ', LBRACE='{', RBRACE='}',
            dump, objstr;


        for (;;) {
            i = s.lastIndexOf(LBRACE);
            if (i < 0) {
                break;
            }
            j = s.indexOf(RBRACE, i);
            if (i + 1 >= j) {
                break;
            }

            //Extract key and meta info 
            token = s.substring(i + 1, j);
            key = token;
            meta = null;
            k = key.indexOf(SPACE);
            if (k > -1) {
                meta = key.substring(k + 1);
                key = key.substring(0, k);
            }

            // lookup the value
            v = o[key];

            // if a substitution function was provided, execute it
            if (f) {
                v = f(key, v, meta);
            }

            if (L.isObject(v)) {
                if (L.isArray(v)) {
                    v = L.dump(v, parseInt(meta, 10));
                } else {
                    meta = meta || "";

                    // look for the keyword 'dump', if found force obj dump
                    dump = meta.indexOf(DUMP);
                    if (dump > -1) {
                        meta = meta.substring(4);
                    }

                    objstr = v.toString();

                    // use the toString if it is not the Object toString 
                    // and the 'dump' meta info was not found
                    if (objstr === OBJECT_TOSTRING || dump > -1) {
                        v = L.dump(v, parseInt(meta, 10));
                    } else {
                        v = objstr;
                    }
                }
            } else if (!L.isString(v) && !L.isNumber(v)) {
                // This {block} has no replace string. Save it for later.
                v = "~-" + saved.length + "-~";
                saved[saved.length] = token;

                // break;
            }

            s = s.substring(0, i) + v + s.substring(j + 1);


        }

        // restore saved {block}s
        for (i=saved.length-1; i>=0; i=i-1) {
            s = s.replace(new RegExp("~-" + i + "-~"), "{"  + saved[i] + "}", "g");
        }

        return s;
    },


    
    trim: function(s){
        try {
            return s.replace(/^\s+|\s+$/g, "");
        } catch(e) {
            return s;
        }
    },

    
    merge: function() {
        var o={}, a=arguments, l=a.length, i;
        for (i=0; i<l; i=i+1) {
            L.augmentObject(o, a[i], true);
        }
        return o;
    },

    
    later: function(when, o, fn, data, periodic) {
        when = when || 0; 
        o = o || {};
        var m=fn, d=data, f, r;

        if (L.isString(fn)) {
            m = o[fn];
        }

        if (!m) {
            throw new TypeError("method undefined");
        }

        if (d && !L.isArray(d)) {
            d = [data];
        }

        f = function() {
            m.apply(o, d || NOTHING);
        };

        r = (periodic) ? setInterval(f, when) : setTimeout(f, when);

        return {
            interval: periodic,
            cancel: function() {
                if (this.interval) {
                    clearInterval(r);
                } else {
                    clearTimeout(r);
                }
            }
        };
    },
    
    
    isValue: function(o) {
        // return (o || o === false || o === 0 || o === ''); // Infinity fails
return (L.isObject(o) || L.isString(o) || L.isNumber(o) || L.isBoolean(o));
    }

};


L.hasOwnProperty = (OP.hasOwnProperty) ?
    function(o, prop) {
        return o && o.hasOwnProperty(prop);
    } : function(o, prop) {
        return !L.isUndefined(o[prop]) && 
                o.constructor.prototype[prop] !== o[prop];
    };

// new lang wins
OB.augmentObject(L, OB, true);


YAHOO.util.Lang = L;
 

L.augment = L.augmentProto;


YAHOO.augment = L.augmentProto;
       

YAHOO.extend = L.extend;

})();
YAHOO.register("yahoo", YAHOO, {version: "2.8.1", build: "19"});




(function() {
    // for use with generateId (global to save state if Dom is overwritten)
    YAHOO.env._id_counter = YAHOO.env._id_counter || 0;

    // internal shorthand
    var Y = YAHOO.util,
        lang = YAHOO.lang,
        UA = YAHOO.env.ua,
        trim = YAHOO.lang.trim,
        propertyCache = {}, // for faster hyphen converts
        reCache = {}, // cache className regexes
        RE_TABLE = /^t(?:able|d|h)$/i, // for _calcBorders
        RE_COLOR = /color$/i,

        // DOM aliases 
        document = window.document,     
        documentElement = document.documentElement,

        // string constants
        OWNER_DOCUMENT = 'ownerDocument',
        DEFAULT_VIEW = 'defaultView',
        DOCUMENT_ELEMENT = 'documentElement',
        COMPAT_MODE = 'compatMode',
        OFFSET_LEFT = 'offsetLeft',
        OFFSET_TOP = 'offsetTop',
        OFFSET_PARENT = 'offsetParent',
        PARENT_NODE = 'parentNode',
        NODE_TYPE = 'nodeType',
        TAG_NAME = 'tagName',
        SCROLL_LEFT = 'scrollLeft',
        SCROLL_TOP = 'scrollTop',
        GET_BOUNDING_CLIENT_RECT = 'getBoundingClientRect',
        GET_COMPUTED_STYLE = 'getComputedStyle',
        CURRENT_STYLE = 'currentStyle',
        CSS1_COMPAT = 'CSS1Compat',
        _BACK_COMPAT = 'BackCompat',
        _CLASS = 'class', // underscore due to reserved word
        CLASS_NAME = 'className',
        EMPTY = '',
        SPACE = ' ',
        C_START = '(?:^|\\s)',
        C_END = '(?= |$)',
        G = 'g',
        POSITION = 'position',
        FIXED = 'fixed',
        RELATIVE = 'relative',
        LEFT = 'left',
        TOP = 'top',
        MEDIUM = 'medium',
        BORDER_LEFT_WIDTH = 'borderLeftWidth',
        BORDER_TOP_WIDTH = 'borderTopWidth',
    
    // brower detection
        isOpera = UA.opera,
        isSafari = UA.webkit, 
        isGecko = UA.gecko, 
        isIE = UA.ie; 
    
    
    Y.Dom = {
        CUSTOM_ATTRIBUTES: (!documentElement.hasAttribute) ? { // IE < 8
            'for': 'htmlFor',
            'class': CLASS_NAME
        } : { // w3c
            'htmlFor': 'for',
            'className': _CLASS
        },

        DOT_ATTRIBUTES: {},

        
        get: function(el) {
            var id, nodes, c, i, len, attr;

            if (el) {
                if (el[NODE_TYPE] || el.item) { // Node, or NodeList
                    return el;
                }

                if (typeof el === 'string') { // id
                    id = el;
                    el = document.getElementById(el);
                    attr = (el) ? el.attributes : null;
                    if (el && attr && attr.id && attr.id.value === id) { // IE: avoid false match on "name" attribute
                        return el;
                    } else if (el && document.all) { // filter by name
                        el = null;
                        nodes = document.all[id];
                        for (i = 0, len = nodes.length; i < len; ++i) {
                            if (nodes[i].id === id) {
                                return nodes[i];
                            }
                        }
                    }
                    return el;
                }
                
                if (YAHOO.util.Element && el instanceof YAHOO.util.Element) {
                    el = el.get('element');
                }

                if ('length' in el) { // array-like 
                    c = [];
                    for (i = 0, len = el.length; i < len; ++i) {
                        c[c.length] = Y.Dom.get(el[i]);
                    }
                    
                    return c;
                }

                return el; // some other object, just pass it back
            }

            return null;
        },
    
        getComputedStyle: function(el, property) {
            if (window[GET_COMPUTED_STYLE]) {
                return el[OWNER_DOCUMENT][DEFAULT_VIEW][GET_COMPUTED_STYLE](el, null)[property];
            } else if (el[CURRENT_STYLE]) {
                return Y.Dom.IE_ComputedStyle.get(el, property);
            }
        },

        
        getStyle: function(el, property) {
            return Y.Dom.batch(el, Y.Dom._getStyle, property);
        },

        // branching at load instead of runtime
        _getStyle: function() {
            if (window[GET_COMPUTED_STYLE]) { // W3C DOM method
                return function(el, property) {
                    property = (property === 'float') ? property = 'cssFloat' :
                            Y.Dom._toCamel(property);

                    var value = el.style[property],
                        computed;
                    
                    if (!value) {
                        computed = el[OWNER_DOCUMENT][DEFAULT_VIEW][GET_COMPUTED_STYLE](el, null);
                        if (computed) { // test computed before touching for safari
                            value = computed[property];
                        }
                    }
                    
                    return value;
                };
            } else if (documentElement[CURRENT_STYLE]) {
                return function(el, property) {                         
                    var value;

                    switch(property) {
                        case 'opacity' :// IE opacity uses filter
                            value = 100;
                            try { // will error if no DXImageTransform
                                value = el.filters['DXImageTransform.Microsoft.Alpha'].opacity;

                            } catch(e) {
                                try { // make sure its in the document
                                    value = el.filters('alpha').opacity;
                                } catch(err) {
                                }
                            }
                            return value / 100;
                        case 'float': // fix reserved word
                            property = 'styleFloat'; // fall through
                        default: 
                            property = Y.Dom._toCamel(property);
                            value = el[CURRENT_STYLE] ? el[CURRENT_STYLE][property] : null;
                            return ( el.style[property] || value );
                    }
                };
            }
        }(),
    
        
        setStyle: function(el, property, val) {
            Y.Dom.batch(el, Y.Dom._setStyle, { prop: property, val: val });
        },

        _setStyle: function() {
            if (isIE) {
                return function(el, args) {
                    var property = Y.Dom._toCamel(args.prop),
                        val = args.val;

                    if (el) {
                        switch (property) {
                            case 'opacity':
                                if ( lang.isString(el.style.filter) ) { // in case not appended
                                    el.style.filter = 'alpha(opacity=' + val * 100 + ')';
                                    
                                    if (!el[CURRENT_STYLE] || !el[CURRENT_STYLE].hasLayout) {
                                        el.style.zoom = 1; // when no layout or cant tell
                                    }
                                }
                                break;
                            case 'float':
                                property = 'styleFloat';
                            default:
                            el.style[property] = val;
                        }
                    } else {
                    }
                };
            } else {
                return function(el, args) {
                    var property = Y.Dom._toCamel(args.prop),
                        val = args.val;
                    if (el) {
                        if (property == 'float') {
                            property = 'cssFloat';
                        }
                        el.style[property] = val;
                    } else {
                    }
                };
            }

        }(),
        
        
        getXY: function(el) {
            return Y.Dom.batch(el, Y.Dom._getXY);
        },

        _canPosition: function(el) {
            return ( Y.Dom._getStyle(el, 'display') !== 'none' && Y.Dom._inDoc(el) );
        },

        _getXY: function() {
            if (document[DOCUMENT_ELEMENT][GET_BOUNDING_CLIENT_RECT]) {
                return function(node) {
                    var scrollLeft, scrollTop, box, doc,
                        off1, off2, mode, bLeft, bTop,
                        floor = Math.floor, // TODO: round?
                        xy = false;

                    if (Y.Dom._canPosition(node)) {
                        box = node[GET_BOUNDING_CLIENT_RECT]();
                        doc = node[OWNER_DOCUMENT];
                        scrollLeft = Y.Dom.getDocumentScrollLeft(doc);
                        scrollTop = Y.Dom.getDocumentScrollTop(doc);
                        xy = [floor(box[LEFT]), floor(box[TOP])];

                        if (isIE && UA.ie < 8) { // IE < 8: viewport off by 2
                            off1 = 2;
                            off2 = 2;
                            mode = doc[COMPAT_MODE];

                            if (UA.ie === 6) {
                                if (mode !== _BACK_COMPAT) {
                                    off1 = 0;
                                    off2 = 0;
                                }
                            }
                            
                            if ((mode === _BACK_COMPAT)) {
                                bLeft = _getComputedStyle(doc[DOCUMENT_ELEMENT], BORDER_LEFT_WIDTH);
                                bTop = _getComputedStyle(doc[DOCUMENT_ELEMENT], BORDER_TOP_WIDTH);
                                if (bLeft !== MEDIUM) {
                                    off1 = parseInt(bLeft, 10);
                                }
                                if (bTop !== MEDIUM) {
                                    off2 = parseInt(bTop, 10);
                                }
                            }
                            
                            xy[0] -= off1;
                            xy[1] -= off2;

                        }

                        if ((scrollTop || scrollLeft)) {
                            xy[0] += scrollLeft;
                            xy[1] += scrollTop;
                        }

                        // gecko may return sub-pixel (non-int) values
                        xy[0] = floor(xy[0]);
                        xy[1] = floor(xy[1]);
                    } else {
                    }

                    return xy;
                };
            } else {
                return function(node) { // ff2, safari: manually calculate by crawling up offsetParents
                    var docScrollLeft, docScrollTop,
                        scrollTop, scrollLeft,
                        bCheck,
                        xy = false,
                        parentNode = node;

                    if  (Y.Dom._canPosition(node) ) {
                        xy = [node[OFFSET_LEFT], node[OFFSET_TOP]];
                        docScrollLeft = Y.Dom.getDocumentScrollLeft(node[OWNER_DOCUMENT]);
                        docScrollTop = Y.Dom.getDocumentScrollTop(node[OWNER_DOCUMENT]);

                        // TODO: refactor with !! or just falsey
                        bCheck = ((isGecko || UA.webkit > 519) ? true : false);

                        // TODO: worth refactoring for TOP/LEFT only?
                        while ((parentNode = parentNode[OFFSET_PARENT])) {
                            xy[0] += parentNode[OFFSET_LEFT];
                            xy[1] += parentNode[OFFSET_TOP];
                            if (bCheck) {
                                xy = Y.Dom._calcBorders(parentNode, xy);
                            }
                        }

                        // account for any scrolled ancestors
                        if (Y.Dom._getStyle(node, POSITION) !== FIXED) {
                            parentNode = node;

                            while ((parentNode = parentNode[PARENT_NODE]) && parentNode[TAG_NAME]) {
                                scrollTop = parentNode[SCROLL_TOP];
                                scrollLeft = parentNode[SCROLL_LEFT];

                                //Firefox does something funky with borders when overflow is not visible.
                                if (isGecko && (Y.Dom._getStyle(parentNode, 'overflow') !== 'visible')) {
                                        xy = Y.Dom._calcBorders(parentNode, xy);
                                }

                                if (scrollTop || scrollLeft) {
                                    xy[0] -= scrollLeft;
                                    xy[1] -= scrollTop;
                                }
                            }
                            xy[0] += docScrollLeft;
                            xy[1] += docScrollTop;

                        } else {
                            //Fix FIXED position -- add scrollbars
                            if (isOpera) {
                                xy[0] -= docScrollLeft;
                                xy[1] -= docScrollTop;
                            } else if (isSafari || isGecko) {
                                xy[0] += docScrollLeft;
                                xy[1] += docScrollTop;
                            }
                        }
                        //Round the numbers so we get sane data back
                        xy[0] = Math.floor(xy[0]);
                        xy[1] = Math.floor(xy[1]);
                    } else {
                    }
                    return xy;                
                };
            }
        }(), // NOTE: Executing for loadtime branching
        
        
        getX: function(el) {
            var f = function(el) {
                return Y.Dom.getXY(el)[0];
            };
            
            return Y.Dom.batch(el, f, Y.Dom, true);
        },
        
        
        getY: function(el) {
            var f = function(el) {
                return Y.Dom.getXY(el)[1];
            };
            
            return Y.Dom.batch(el, f, Y.Dom, true);
        },
        
        
        setXY: function(el, pos, noRetry) {
            Y.Dom.batch(el, Y.Dom._setXY, { pos: pos, noRetry: noRetry });
        },

        _setXY: function(node, args) {
            var pos = Y.Dom._getStyle(node, POSITION),
                setStyle = Y.Dom.setStyle,
                xy = args.pos,
                noRetry = args.noRetry,

                delta = [ // assuming pixels; if not we will have to retry
                    parseInt( Y.Dom.getComputedStyle(node, LEFT), 10 ),
                    parseInt( Y.Dom.getComputedStyle(node, TOP), 10 )
                ],

                currentXY,
                newXY;
        
            if (pos == 'static') { // default to relative
                pos = RELATIVE;
                setStyle(node, POSITION, pos);
            }

            currentXY = Y.Dom._getXY(node);

            if (!xy || currentXY === false) { // has to be part of doc to have xy
                return false; 
            }
            
            if ( isNaN(delta[0]) ) {// in case of 'auto'
                delta[0] = (pos == RELATIVE) ? 0 : node[OFFSET_LEFT];
            } 
            if ( isNaN(delta[1]) ) { // in case of 'auto'
                delta[1] = (pos == RELATIVE) ? 0 : node[OFFSET_TOP];
            } 

            if (xy[0] !== null) { // from setX
                setStyle(node, LEFT, xy[0] - currentXY[0] + delta[0] + 'px');
            }

            if (xy[1] !== null) { // from setY
                setStyle(node, TOP, xy[1] - currentXY[1] + delta[1] + 'px');
            }
          
            if (!noRetry) {
                newXY = Y.Dom._getXY(node);

                // if retry is true, try one more time if we miss 
               if ( (xy[0] !== null && newXY[0] != xy[0]) || 
                    (xy[1] !== null && newXY[1] != xy[1]) ) {
                   Y.Dom._setXY(node, { pos: xy, noRetry: true });
               }
            }        

        },
        
        
        setX: function(el, x) {
            Y.Dom.setXY(el, [x, null]);
        },
        
        
        setY: function(el, y) {
            Y.Dom.setXY(el, [null, y]);
        },
        
        
        getRegion: function(el) {
            var f = function(el) {
                var region = false;
                if ( Y.Dom._canPosition(el) ) {
                    region = Y.Region.getRegion(el);
                } else {
                }

                return region;
            };
            
            return Y.Dom.batch(el, f, Y.Dom, true);
        },
        
        
        getClientWidth: function() {
            return Y.Dom.getViewportWidth();
        },
        
        
        getClientHeight: function() {
            return Y.Dom.getViewportHeight();
        },

        
        getElementsByClassName: function(className, tag, root, apply, o, overrides) {
            tag = tag || '*';
            root = (root) ? Y.Dom.get(root) : null || document; 
            if (!root) {
                return [];
            }

            var nodes = [],
                elements = root.getElementsByTagName(tag),
                hasClass = Y.Dom.hasClass;

            for (var i = 0, len = elements.length; i < len; ++i) {
                if ( hasClass(elements[i], className) ) {
                    nodes[nodes.length] = elements[i];
                }
            }
            
            if (apply) {
                Y.Dom.batch(nodes, apply, o, overrides);
            }

            return nodes;
        },

        
        hasClass: function(el, className) {
            return Y.Dom.batch(el, Y.Dom._hasClass, className);
        },

        _hasClass: function(el, className) {
            var ret = false,
                current;
            
            if (el && className) {
                current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                if (className.exec) {
                    ret = className.test(current);
                } else {
                    ret = className && (SPACE + current + SPACE).
                        indexOf(SPACE + className + SPACE) > -1;
                }
            } else {
            }

            return ret;
        },
    
        
        addClass: function(el, className) {
            return Y.Dom.batch(el, Y.Dom._addClass, className);
        },

        _addClass: function(el, className) {
            var ret = false,
                current;

            if (el && className) {
                current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                if ( !Y.Dom._hasClass(el, className) ) {
                    Y.Dom.setAttribute(el, CLASS_NAME, trim(current + SPACE + className));
                    ret = true;
                }
            } else {
            }

            return ret;
        },
    
        
        removeClass: function(el, className) {
            return Y.Dom.batch(el, Y.Dom._removeClass, className);
        },
        
        _removeClass: function(el, className) {
            var ret = false,
                current,
                newClass,
                attr;

            if (el && className) {
                current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                Y.Dom.setAttribute(el, CLASS_NAME, current.replace(Y.Dom._getClassRegex(className), EMPTY));

                newClass = Y.Dom._getAttribute(el, CLASS_NAME);
                if (current !== newClass) { // else nothing changed
                    Y.Dom.setAttribute(el, CLASS_NAME, trim(newClass)); // trim after comparing to current class
                    ret = true;

                    if (Y.Dom._getAttribute(el, CLASS_NAME) === '') { // remove class attribute if empty
                        attr = (el.hasAttribute && el.hasAttribute(_CLASS)) ? _CLASS : CLASS_NAME;
                        el.removeAttribute(attr);
                    }
                }

            } else {
            }

            return ret;
        },
        
        
        replaceClass: function(el, oldClassName, newClassName) {
            return Y.Dom.batch(el, Y.Dom._replaceClass, { from: oldClassName, to: newClassName });
        },

        _replaceClass: function(el, classObj) {
            var className,
                from,
                to,
                ret = false,
                current;

            if (el && classObj) {
                from = classObj.from;
                to = classObj.to;

                if (!to) {
                    ret = false;
                }  else if (!from) { // just add if no "from"
                    ret = Y.Dom._addClass(el, classObj.to);
                } else if (from !== to) { // else nothing to replace
                    // May need to lead with DBLSPACE?
                    current = Y.Dom._getAttribute(el, CLASS_NAME) || EMPTY;
                    className = (SPACE + current.replace(Y.Dom._getClassRegex(from), SPACE + to)).
                               split(Y.Dom._getClassRegex(to));

                    // insert to into what would have been the first occurrence slot
                    className.splice(1, 0, SPACE + to);
                    Y.Dom.setAttribute(el, CLASS_NAME, trim(className.join(EMPTY)));
                    ret = true;
                }
            } else {
            }

            return ret;
        },
        
        
        generateId: function(el, prefix) {
            prefix = prefix || 'yui-gen';

            var f = function(el) {
                if (el && el.id) { // do not override existing ID
                    return el.id;
                }

                var id = prefix + YAHOO.env._id_counter++;

                if (el) {
                    if (el[OWNER_DOCUMENT] && el[OWNER_DOCUMENT].getElementById(id)) { // in case one already exists
                        // use failed id plus prefix to help ensure uniqueness
                        return Y.Dom.generateId(el, id + prefix);
                    }
                    el.id = id;
                }
                
                return id;
            };

            // batch fails when no element, so just generate and return single ID
            return Y.Dom.batch(el, f, Y.Dom, true) || f.apply(Y.Dom, arguments);
        },
        
        
        isAncestor: function(haystack, needle) {
            haystack = Y.Dom.get(haystack);
            needle = Y.Dom.get(needle);
            
            var ret = false;

            if ( (haystack && needle) && (haystack[NODE_TYPE] && needle[NODE_TYPE]) ) {
                if (haystack.contains && haystack !== needle) { // contains returns true when equal
                    ret = haystack.contains(needle);
                }
                else if (haystack.compareDocumentPosition) { // gecko
                    ret = !!(haystack.compareDocumentPosition(needle) & 16);
                }
            } else {
            }
            return ret;
        },
        
        
        inDocument: function(el, doc) {
            return Y.Dom._inDoc(Y.Dom.get(el), doc);
        },

        _inDoc: function(el, doc) {
            var ret = false;
            if (el && el[TAG_NAME]) {
                doc = doc || el[OWNER_DOCUMENT]; 
                ret = Y.Dom.isAncestor(doc[DOCUMENT_ELEMENT], el);
            } else {
            }
            return ret;
        },
        
        
        getElementsBy: function(method, tag, root, apply, o, overrides, firstOnly) {
            tag = tag || '*';
            root = (root) ? Y.Dom.get(root) : null || document; 

            if (!root) {
                return [];
            }

            var nodes = [],
                elements = root.getElementsByTagName(tag);
            
            for (var i = 0, len = elements.length; i < len; ++i) {
                if ( method(elements[i]) ) {
                    if (firstOnly) {
                        nodes = elements[i]; 
                        break;
                    } else {
                        nodes[nodes.length] = elements[i];
                    }
                }
            }

            if (apply) {
                Y.Dom.batch(nodes, apply, o, overrides);
            }

            
            return nodes;
        },
        
        
        getElementBy: function(method, tag, root) {
            return Y.Dom.getElementsBy(method, tag, root, null, null, null, true); 
        },

        
        batch: function(el, method, o, overrides) {
            var collection = [],
                scope = (overrides) ? o : window;
                
            el = (el && (el[TAG_NAME] || el.item)) ? el : Y.Dom.get(el); // skip get() when possible
            if (el && method) {
                if (el[TAG_NAME] || el.length === undefined) { // element or not array-like 
                    return method.call(scope, el, o);
                } 

                for (var i = 0; i < el.length; ++i) {
                    collection[collection.length] = method.call(scope, el[i], o);
                }
            } else {
                return false;
            } 
            return collection;
        },
        
        
        getDocumentHeight: function() {
            var scrollHeight = (document[COMPAT_MODE] != CSS1_COMPAT || isSafari) ? document.body.scrollHeight : documentElement.scrollHeight,
                h = Math.max(scrollHeight, Y.Dom.getViewportHeight());

            return h;
        },
        
        
        getDocumentWidth: function() {
            var scrollWidth = (document[COMPAT_MODE] != CSS1_COMPAT || isSafari) ? document.body.scrollWidth : documentElement.scrollWidth,
                w = Math.max(scrollWidth, Y.Dom.getViewportWidth());
            return w;
        },

        
        getViewportHeight: function() {
            var height = self.innerHeight, // Safari, Opera
                mode = document[COMPAT_MODE];
        
            if ( (mode || isIE) && !isOpera ) { // IE, Gecko
                height = (mode == CSS1_COMPAT) ?
                        documentElement.clientHeight : // Standards
                        document.body.clientHeight; // Quirks
            }
        
            return height;
        },
        
        
        
        getViewportWidth: function() {
            var width = self.innerWidth,  // Safari
                mode = document[COMPAT_MODE];
            
            if (mode || isIE) { // IE, Gecko, Opera
                width = (mode == CSS1_COMPAT) ?
                        documentElement.clientWidth : // Standards
                        document.body.clientWidth; // Quirks
            }
            return width;
        },

       
        getAncestorBy: function(node, method) {
            while ( (node = node[PARENT_NODE]) ) { // NOTE: assignment
                if ( Y.Dom._testElement(node, method) ) {
                    return node;
                }
            } 

            return null;
        },
        
        
        getAncestorByClassName: function(node, className) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }
            var method = function(el) { return Y.Dom.hasClass(el, className); };
            return Y.Dom.getAncestorBy(node, method);
        },

        
        getAncestorByTagName: function(node, tagName) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }
            var method = function(el) {
                 return el[TAG_NAME] && el[TAG_NAME].toUpperCase() == tagName.toUpperCase();
            };

            return Y.Dom.getAncestorBy(node, method);
        },

        
        getPreviousSiblingBy: function(node, method) {
            while (node) {
                node = node.previousSibling;
                if ( Y.Dom._testElement(node, method) ) {
                    return node;
                }
            }
            return null;
        }, 

        
        getPreviousSibling: function(node) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }

            return Y.Dom.getPreviousSiblingBy(node);
        }, 

        
        getNextSiblingBy: function(node, method) {
            while (node) {
                node = node.nextSibling;
                if ( Y.Dom._testElement(node, method) ) {
                    return node;
                }
            }
            return null;
        }, 

        
        getNextSibling: function(node) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }

            return Y.Dom.getNextSiblingBy(node);
        }, 

        
        getFirstChildBy: function(node, method) {
            var child = ( Y.Dom._testElement(node.firstChild, method) ) ? node.firstChild : null;
            return child || Y.Dom.getNextSiblingBy(node.firstChild, method);
        }, 

        
        getFirstChild: function(node, method) {
            node = Y.Dom.get(node);
            if (!node) {
                return null;
            }
            return Y.Dom.getFirstChildBy(node);
        }, 

        
        getLastChildBy: function(node, method) {
            if (!node) {
                return null;
            }
            var child = ( Y.Dom._testElement(node.lastChild, method) ) ? node.lastChild : null;
            return child || Y.Dom.getPreviousSiblingBy(node.lastChild, method);
        }, 

        
        getLastChild: function(node) {
            node = Y.Dom.get(node);
            return Y.Dom.getLastChildBy(node);
        }, 

        
        getChildrenBy: function(node, method) {
            var child = Y.Dom.getFirstChildBy(node, method),
                children = child ? [child] : [];

            Y.Dom.getNextSiblingBy(child, function(node) {
                if ( !method || method(node) ) {
                    children[children.length] = node;
                }
                return false; // fail test to collect all children
            });

            return children;
        },
 
        
        getChildren: function(node) {
            node = Y.Dom.get(node);
            if (!node) {
            }

            return Y.Dom.getChildrenBy(node);
        },

        
        getDocumentScrollLeft: function(doc) {
            doc = doc || document;
            return Math.max(doc[DOCUMENT_ELEMENT].scrollLeft, doc.body.scrollLeft);
        }, 

        
        getDocumentScrollTop: function(doc) {
            doc = doc || document;
            return Math.max(doc[DOCUMENT_ELEMENT].scrollTop, doc.body.scrollTop);
        },

        
        insertBefore: function(newNode, referenceNode) {
            newNode = Y.Dom.get(newNode); 
            referenceNode = Y.Dom.get(referenceNode); 
            
            if (!newNode || !referenceNode || !referenceNode[PARENT_NODE]) {
                return null;
            }       

            return referenceNode[PARENT_NODE].insertBefore(newNode, referenceNode); 
        },

        
        insertAfter: function(newNode, referenceNode) {
            newNode = Y.Dom.get(newNode); 
            referenceNode = Y.Dom.get(referenceNode); 
            
            if (!newNode || !referenceNode || !referenceNode[PARENT_NODE]) {
                return null;
            }       

            if (referenceNode.nextSibling) {
                return referenceNode[PARENT_NODE].insertBefore(newNode, referenceNode.nextSibling); 
            } else {
                return referenceNode[PARENT_NODE].appendChild(newNode);
            }
        },

        
        getClientRegion: function() {
            var t = Y.Dom.getDocumentScrollTop(),
                l = Y.Dom.getDocumentScrollLeft(),
                r = Y.Dom.getViewportWidth() + l,
                b = Y.Dom.getViewportHeight() + t;

            return new Y.Region(t, r, b, l);
        },

        
        setAttribute: function(el, attr, val) {
            Y.Dom.batch(el, Y.Dom._setAttribute, { attr: attr, val: val });
        },

        _setAttribute: function(el, args) {
            var attr = Y.Dom._toCamel(args.attr),
                val = args.val;

            if (el && el.setAttribute) {
                if (Y.Dom.DOT_ATTRIBUTES[attr]) {
                    el[attr] = val;
                } else {
                    attr = Y.Dom.CUSTOM_ATTRIBUTES[attr] || attr;
                    el.setAttribute(attr, val);
                }
            } else {
            }
        },

        
        getAttribute: function(el, attr) {
            return Y.Dom.batch(el, Y.Dom._getAttribute, attr);
        },


        _getAttribute: function(el, attr) {
            var val;
            attr = Y.Dom.CUSTOM_ATTRIBUTES[attr] || attr;

            if (el && el.getAttribute) {
                val = el.getAttribute(attr, 2);
            } else {
            }

            return val;
        },

        _toCamel: function(property) {
            var c = propertyCache;

            function tU(x,l) {
                return l.toUpperCase();
            }

            return c[property] || (c[property] = property.indexOf('-') === -1 ? 
                                    property :
                                    property.replace( /-([a-z])/gi, tU ));
        },

        _getClassRegex: function(className) {
            var re;
            if (className !== undefined) { // allow empty string to pass
                if (className.exec) { // already a RegExp
                    re = className;
                } else {
                    re = reCache[className];
                    if (!re) {
                        // escape special chars (".", "[", etc.)
                        className = className.replace(Y.Dom._patterns.CLASS_RE_TOKENS, '\\$1');
                        re = reCache[className] = new RegExp(C_START + className + C_END, G);
                    }
                }
            }
            return re;
        },

        _patterns: {
            ROOT_TAG: /^body|html$/i, // body for quirks mode, html for standards,
            CLASS_RE_TOKENS: /([\.\(\)\^\$\*\+\?\|\[\]\{\}\\])/g
        },


        _testElement: function(node, method) {
            return node && node[NODE_TYPE] == 1 && ( !method || method(node) );
        },

        _calcBorders: function(node, xy2) {
            var t = parseInt(Y.Dom[GET_COMPUTED_STYLE](node, BORDER_TOP_WIDTH), 10) || 0,
                l = parseInt(Y.Dom[GET_COMPUTED_STYLE](node, BORDER_LEFT_WIDTH), 10) || 0;
            if (isGecko) {
                if (RE_TABLE.test(node[TAG_NAME])) {
                    t = 0;
                    l = 0;
                }
            }
            xy2[0] += l;
            xy2[1] += t;
            return xy2;
        }
    };
        
    var _getComputedStyle = Y.Dom[GET_COMPUTED_STYLE];
    // fix opera computedStyle default color unit (convert to rgb)
    if (UA.opera) {
        Y.Dom[GET_COMPUTED_STYLE] = function(node, att) {
            var val = _getComputedStyle(node, att);
            if (RE_COLOR.test(att)) {
                val = Y.Dom.Color.toRGB(val);
            }

            return val;
        };

    }

    // safari converts transparent to rgba(), others use "transparent"
    if (UA.webkit) {
        Y.Dom[GET_COMPUTED_STYLE] = function(node, att) {
            var val = _getComputedStyle(node, att);

            if (val === 'rgba(0, 0, 0, 0)') {
                val = 'transparent'; 
            }

            return val;
        };

    }

    if (UA.ie && UA.ie >= 8 && document.documentElement.hasAttribute) { // IE 8 standards
        Y.Dom.DOT_ATTRIBUTES.type = true; // IE 8 errors on input.setAttribute('type')
    }
})();

YAHOO.util.Region = function(t, r, b, l) {

    
    this.top = t;
    
    
    this.y = t;
    
    
    this[1] = t;

    
    this.right = r;

    
    this.bottom = b;

    
    this.left = l;
    
    
    this.x = l;
    
    
    this[0] = l;

    
    this.width = this.right - this.left;

    
    this.height = this.bottom - this.top;
};


YAHOO.util.Region.prototype.contains = function(region) {
    return ( region.left   >= this.left   && 
             region.right  <= this.right  && 
             region.top    >= this.top    && 
             region.bottom <= this.bottom    );

};


YAHOO.util.Region.prototype.getArea = function() {
    return ( (this.bottom - this.top) * (this.right - this.left) );
};


YAHOO.util.Region.prototype.intersect = function(region) {
    var t = Math.max( this.top,    region.top    ),
        r = Math.min( this.right,  region.right  ),
        b = Math.min( this.bottom, region.bottom ),
        l = Math.max( this.left,   region.left   );
    
    if (b >= t && r >= l) {
        return new YAHOO.util.Region(t, r, b, l);
    } else {
        return null;
    }
};


YAHOO.util.Region.prototype.union = function(region) {
    var t = Math.min( this.top,    region.top    ),
        r = Math.max( this.right,  region.right  ),
        b = Math.max( this.bottom, region.bottom ),
        l = Math.min( this.left,   region.left   );

    return new YAHOO.util.Region(t, r, b, l);
};


YAHOO.util.Region.prototype.toString = function() {
    return ( "Region {"    +
             "top: "       + this.top    + 
             ", right: "   + this.right  + 
             ", bottom: "  + this.bottom + 
             ", left: "    + this.left   + 
             ", height: "  + this.height + 
             ", width: "    + this.width   + 
             "}" );
};


YAHOO.util.Region.getRegion = function(el) {
    var p = YAHOO.util.Dom.getXY(el),
        t = p[1],
        r = p[0] + el.offsetWidth,
        b = p[1] + el.offsetHeight,
        l = p[0];

    return new YAHOO.util.Region(t, r, b, l);
};

/////////////////////////////////////////////////////////////////////////////



YAHOO.util.Point = function(x, y) {
   if (YAHOO.lang.isArray(x)) { // accept input from Dom.getXY, Event.getXY, etc.
      y = x[1]; // dont blow away x yet
      x = x[0];
   }
 
    YAHOO.util.Point.superclass.constructor.call(this, y, x, y, x);
};

YAHOO.extend(YAHOO.util.Point, YAHOO.util.Region);

(function() {


var Y = YAHOO.util, 
    CLIENT_TOP = 'clientTop',
    CLIENT_LEFT = 'clientLeft',
    PARENT_NODE = 'parentNode',
    RIGHT = 'right',
    HAS_LAYOUT = 'hasLayout',
    PX = 'px',
    OPACITY = 'opacity',
    AUTO = 'auto',
    BORDER_LEFT_WIDTH = 'borderLeftWidth',
    BORDER_TOP_WIDTH = 'borderTopWidth',
    BORDER_RIGHT_WIDTH = 'borderRightWidth',
    BORDER_BOTTOM_WIDTH = 'borderBottomWidth',
    VISIBLE = 'visible',
    TRANSPARENT = 'transparent',
    HEIGHT = 'height',
    WIDTH = 'width',
    STYLE = 'style',
    CURRENT_STYLE = 'currentStyle',

// IE getComputedStyle
// TODO: unit-less lineHeight (e.g. 1.22)
    re_size = /^width|height$/,
    re_unit = /^(\d[.\d]*)+(em|ex|px|gd|rem|vw|vh|vm|ch|mm|cm|in|pt|pc|deg|rad|ms|s|hz|khz|%){1}?/i,

    ComputedStyle = {
        get: function(el, property) {
            var value = '',
                current = el[CURRENT_STYLE][property];

            if (property === OPACITY) {
                value = Y.Dom.getStyle(el, OPACITY);        
            } else if (!current || (current.indexOf && current.indexOf(PX) > -1)) { // no need to convert
                value = current;
            } else if (Y.Dom.IE_COMPUTED[property]) { // use compute function
                value = Y.Dom.IE_COMPUTED[property](el, property);
            } else if (re_unit.test(current)) { // convert to pixel
                value = Y.Dom.IE.ComputedStyle.getPixel(el, property);
            } else {
                value = current;
            }

            return value;
        },

        getOffset: function(el, prop) {
            var current = el[CURRENT_STYLE][prop],                        // value of "width", "top", etc.
                capped = prop.charAt(0).toUpperCase() + prop.substr(1), // "Width", "Top", etc.
                offset = 'offset' + capped,                             // "offsetWidth", "offsetTop", etc.
                pixel = 'pixel' + capped,                               // "pixelWidth", "pixelTop", etc.
                value = '',
                actual;

            if (current == AUTO) {
                actual = el[offset]; // offsetHeight/Top etc.
                if (actual === undefined) { // likely "right" or "bottom"
                    value = 0;
                }

                value = actual;
                if (re_size.test(prop)) { // account for box model diff 
                    el[STYLE][prop] = actual; 
                    if (el[offset] > actual) {
                        // the difference is padding + border (works in Standards & Quirks modes)
                        value = actual - (el[offset] - actual);
                    }
                    el[STYLE][prop] = AUTO; // revert to auto
                }
            } else { // convert units to px
                if (!el[STYLE][pixel] && !el[STYLE][prop]) { // need to map style.width to currentStyle (no currentStyle.pixelWidth)
                    el[STYLE][prop] = current;              // no style.pixelWidth if no style.width
                }
                value = el[STYLE][pixel];
            }
            return value + PX;
        },

        getBorderWidth: function(el, property) {
            // clientHeight/Width = paddingBox (e.g. offsetWidth - borderWidth)
            // clientTop/Left = borderWidth
            var value = null;
            if (!el[CURRENT_STYLE][HAS_LAYOUT]) { // TODO: unset layout?
                el[STYLE].zoom = 1; // need layout to measure client
            }

            switch(property) {
                case BORDER_TOP_WIDTH:
                    value = el[CLIENT_TOP];
                    break;
                case BORDER_BOTTOM_WIDTH:
                    value = el.offsetHeight - el.clientHeight - el[CLIENT_TOP];
                    break;
                case BORDER_LEFT_WIDTH:
                    value = el[CLIENT_LEFT];
                    break;
                case BORDER_RIGHT_WIDTH:
                    value = el.offsetWidth - el.clientWidth - el[CLIENT_LEFT];
                    break;
            }
            return value + PX;
        },

        getPixel: function(node, att) {
            // use pixelRight to convert to px
            var val = null,
                styleRight = node[CURRENT_STYLE][RIGHT],
                current = node[CURRENT_STYLE][att];

            node[STYLE][RIGHT] = current;
            val = node[STYLE].pixelRight;
            node[STYLE][RIGHT] = styleRight; // revert

            return val + PX;
        },

        getMargin: function(node, att) {
            var val;
            if (node[CURRENT_STYLE][att] == AUTO) {
                val = 0 + PX;
            } else {
                val = Y.Dom.IE.ComputedStyle.getPixel(node, att);
            }
            return val;
        },

        getVisibility: function(node, att) {
            var current;
            while ( (current = node[CURRENT_STYLE]) && current[att] == 'inherit') { // NOTE: assignment in test
                node = node[PARENT_NODE];
            }
            return (current) ? current[att] : VISIBLE;
        },

        getColor: function(node, att) {
            return Y.Dom.Color.toRGB(node[CURRENT_STYLE][att]) || TRANSPARENT;
        },

        getBorderColor: function(node, att) {
            var current = node[CURRENT_STYLE],
                val = current[att] || current.color;
            return Y.Dom.Color.toRGB(Y.Dom.Color.toHex(val));
        }

    },

//fontSize: getPixelFont,
    IEComputed = {};

IEComputed.top = IEComputed.right = IEComputed.bottom = IEComputed.left = 
        IEComputed[WIDTH] = IEComputed[HEIGHT] = ComputedStyle.getOffset;

IEComputed.color = ComputedStyle.getColor;

IEComputed[BORDER_TOP_WIDTH] = IEComputed[BORDER_RIGHT_WIDTH] =
        IEComputed[BORDER_BOTTOM_WIDTH] = IEComputed[BORDER_LEFT_WIDTH] =
        ComputedStyle.getBorderWidth;

IEComputed.marginTop = IEComputed.marginRight = IEComputed.marginBottom =
        IEComputed.marginLeft = ComputedStyle.getMargin;

IEComputed.visibility = ComputedStyle.getVisibility;
IEComputed.borderColor = IEComputed.borderTopColor =
        IEComputed.borderRightColor = IEComputed.borderBottomColor =
        IEComputed.borderLeftColor = ComputedStyle.getBorderColor;

Y.Dom.IE_COMPUTED = IEComputed;
Y.Dom.IE_ComputedStyle = ComputedStyle;
})();
(function() {


var TO_STRING = 'toString',
    PARSE_INT = parseInt,
    RE = RegExp,
    Y = YAHOO.util;

Y.Dom.Color = {
    KEYWORDS: {
        black: '000',
        silver: 'c0c0c0',
        gray: '808080',
        white: 'fff',
        maroon: '800000',
        red: 'f00',
        purple: '800080',
        fuchsia: 'f0f',
        green: '008000',
        lime: '0f0',
        olive: '808000',
        yellow: 'ff0',
        navy: '000080',
        blue: '00f',
        teal: '008080',
        aqua: '0ff'
    },

    re_RGB: /^rgb\(([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\)$/i,
    re_hex: /^#?([0-9A-F]{2})([0-9A-F]{2})([0-9A-F]{2})$/i,
    re_hex3: /([0-9A-F])/gi,

    toRGB: function(val) {
        if (!Y.Dom.Color.re_RGB.test(val)) {
            val = Y.Dom.Color.toHex(val);
        }

        if(Y.Dom.Color.re_hex.exec(val)) {
            val = 'rgb(' + [
                PARSE_INT(RE.$1, 16),
                PARSE_INT(RE.$2, 16),
                PARSE_INT(RE.$3, 16)
            ].join(', ') + ')';
        }
        return val;
    },

    toHex: function(val) {
        val = Y.Dom.Color.KEYWORDS[val] || val;
        if (Y.Dom.Color.re_RGB.exec(val)) {
            var r = (RE.$1.length === 1) ? '0' + RE.$1 : Number(RE.$1),
                g = (RE.$2.length === 1) ? '0' + RE.$2 : Number(RE.$2),
                b = (RE.$3.length === 1) ? '0' + RE.$3 : Number(RE.$3);

            val = [
                r[TO_STRING](16),
                g[TO_STRING](16),
                b[TO_STRING](16)
            ].join('');
        }

        if (val.length < 6) {
            val = val.replace(Y.Dom.Color.re_hex3, '$1$1');
        }

        if (val !== 'transparent' && val.indexOf('#') < 0) {
            val = '#' + val;
        }

        return val.toLowerCase();
    }
};
}());
YAHOO.register("dom", YAHOO.util.Dom, {version: "2.8.1", build: "19"});




YAHOO.util.CustomEvent = function(type, context, silent, signature, fireOnce) {

    
    this.type = type;

    
    this.scope = context || window;

    
    this.silent = silent;

    
    this.fireOnce = fireOnce;

    
    this.fired = false;

    
    this.firedWith = null;

    
    this.signature = signature || YAHOO.util.CustomEvent.LIST;

    
    this.subscribers = [];

    if (!this.silent) {
    }

    var onsubscribeType = "_YUICEOnSubscribe";

    // Only add subscribe events for events that are not generated by 
    // CustomEvent
    if (type !== onsubscribeType) {

        
        this.subscribeEvent = 
                new YAHOO.util.CustomEvent(onsubscribeType, this, true);

    } 


    
    this.lastError = null;
};


YAHOO.util.CustomEvent.LIST = 0;


YAHOO.util.CustomEvent.FLAT = 1;

YAHOO.util.CustomEvent.prototype = {

    
    subscribe: function(fn, obj, overrideContext) {

        if (!fn) {
throw new Error("Invalid callback for subscriber to '" + this.type + "'");
        }

        if (this.subscribeEvent) {
            this.subscribeEvent.fire(fn, obj, overrideContext);
        }

        var s = new YAHOO.util.Subscriber(fn, obj, overrideContext);

        if (this.fireOnce && this.fired) {
            this.notify(s, this.firedWith);
        } else {
            this.subscribers.push(s);
        }
    },

    
    unsubscribe: function(fn, obj) {

        if (!fn) {
            return this.unsubscribeAll();
        }

        var found = false;
        for (var i=0, len=this.subscribers.length; i<len; ++i) {
            var s = this.subscribers[i];
            if (s && s.contains(fn, obj)) {
                this._delete(i);
                found = true;
            }
        }

        return found;
    },

    
    fire: function() {

        this.lastError = null;

        var errors = [],
            len=this.subscribers.length;


        var args=[].slice.call(arguments, 0), ret=true, i, rebuild=false;

        if (this.fireOnce) {
            if (this.fired) {
                return true;
            } else {
                this.firedWith = args;
            }
        }

        this.fired = true;

        if (!len && this.silent) {
            return true;
        }

        if (!this.silent) {
        }

        // make a copy of the subscribers so that there are
        // no index problems if one subscriber removes another.
        var subs = this.subscribers.slice();

        for (i=0; i<len; ++i) {
            var s = subs[i];
            if (!s) {
                rebuild=true;
            } else {

                ret = this.notify(s, args);

                if (false === ret) {
                    if (!this.silent) {
                    }

                    break;
                }
            }
        }

        return (ret !== false);
    },

    notify: function(s, args) {

        var ret, param=null, scope = s.getScope(this.scope),
                 throwErrors = YAHOO.util.Event.throwErrors;

        if (!this.silent) {
        }

        if (this.signature == YAHOO.util.CustomEvent.FLAT) {

            if (args.length > 0) {
                param = args[0];
            }

            try {
                ret = s.fn.call(scope, param, s.obj);
            } catch(e) {
                this.lastError = e;
                // errors.push(e);
                if (throwErrors) {
                    throw e;
                }
            }
        } else {
            try {
                ret = s.fn.call(scope, this.type, args, s.obj);
            } catch(ex) {
                this.lastError = ex;
                if (throwErrors) {
                    throw ex;
                }
            }
        }

        return ret;
    },

    
    unsubscribeAll: function() {
        var l = this.subscribers.length, i;
        for (i=l-1; i>-1; i--) {
            this._delete(i);
        }

        this.subscribers=[];

        return l;
    },

    
    _delete: function(index) {
        var s = this.subscribers[index];
        if (s) {
            delete s.fn;
            delete s.obj;
        }

        // this.subscribers[index]=null;
        this.subscribers.splice(index, 1);
    },

    
    toString: function() {
         return "CustomEvent: " + "'" + this.type  + "', " + 
             "context: " + this.scope;

    }
};

/////////////////////////////////////////////////////////////////////


YAHOO.util.Subscriber = function(fn, obj, overrideContext) {

    
    this.fn = fn;

    
    this.obj = YAHOO.lang.isUndefined(obj) ? null : obj;

    
    this.overrideContext = overrideContext;

};


YAHOO.util.Subscriber.prototype.getScope = function(defaultScope) {
    if (this.overrideContext) {
        if (this.overrideContext === true) {
            return this.obj;
        } else {
            return this.overrideContext;
        }
    }
    return defaultScope;
};


YAHOO.util.Subscriber.prototype.contains = function(fn, obj) {
    if (obj) {
        return (this.fn == fn && this.obj == obj);
    } else {
        return (this.fn == fn);
    }
};


YAHOO.util.Subscriber.prototype.toString = function() {
    return "Subscriber { obj: " + this.obj  + 
           ", overrideContext: " +  (this.overrideContext || "no") + " }";
};



// The first instance of Event will win if it is loaded more than once.
// @TODO this needs to be changed so that only the state data that needs to
// be preserved is kept, while methods are overwritten/added as needed.
// This means that the module pattern can't be used.
if (!YAHOO.util.Event) {


    YAHOO.util.Event = function() {

        
        var loadComplete =  false,

        
        listeners = [],


        
        unloadListeners = [],

        
        retryCount = 0,

        
        onAvailStack = [],

        
        counter = 0,
        
        
         webkitKeymap = {
            63232: 38, // up
            63233: 40, // down
            63234: 37, // left
            63235: 39, // right
            63276: 33, // page up
            63277: 34, // page down
            25: 9      // SHIFT-TAB (Safari provides a different key code in
                       // this case, even though the shiftKey modifier is set)
        },

		isIE = YAHOO.env.ua.ie,

        // String constants used by the addFocusListener and removeFocusListener methods
		
       	FOCUSIN = "focusin",
       	FOCUSOUT = "focusout";

        return {

            
            POLL_RETRYS: 500,

            
            POLL_INTERVAL: 40,

            
            EL: 0,

            
            TYPE: 1,

            
            FN: 2,

            
            WFN: 3,

            
            UNLOAD_OBJ: 3,

            
            ADJ_SCOPE: 4,

            
            OBJ: 5,

            
            OVERRIDE: 6,

            
			CAPTURE: 7,

            
            lastError: null,

            
            isSafari: YAHOO.env.ua.webkit,
            
            
            webkit: YAHOO.env.ua.webkit,
            
            
            isIE: isIE,

            
            _interval: null,

            
             _dri: null,


            
			_specialTypes: {
				focusin: (isIE ? "focusin" : "focus"),
				focusout: (isIE ? "focusout" : "blur")
			},


            
            DOMReady: false,

            
            throwErrors: false,


            
            startInterval: function() {
                if (!this._interval) {
                    // var self = this;
                    // var callback = function() { self._tryPreloadAttach(); };
                    // this._interval = setInterval(callback, this.POLL_INTERVAL);
                    this._interval = YAHOO.lang.later(this.POLL_INTERVAL, this, this._tryPreloadAttach, null, true);
                }
            },

            
            onAvailable: function(id, fn, obj, overrideContext, checkContent) {

                var a = (YAHOO.lang.isString(id)) ? [id] : id;

                for (var i=0; i<a.length; i=i+1) {
                    onAvailStack.push({id:         a[i], 
                                       fn:         fn, 
                                       obj:        obj, 
                                       overrideContext:   overrideContext, 
                                       checkReady: checkContent });
                }

                retryCount = this.POLL_RETRYS;

                this.startInterval();
            },

            
            onContentReady: function(id, fn, obj, overrideContext) {
                this.onAvailable(id, fn, obj, overrideContext, true);
            },

            
            // onDOMReady: function(fn, obj, overrideContext) {
            onDOMReady: function() {
                this.DOMReadyEvent.subscribe.apply(this.DOMReadyEvent, arguments);
            },


            
            _addListener: function(el, sType, fn, obj, overrideContext, bCapture) {

                if (!fn || !fn.call) {
                    return false;
                }

                // The el argument can be an array of elements or element ids.
                if ( this._isValidCollection(el)) {
                    var ok = true;
                    for (var i=0,len=el.length; i<len; ++i) {
                        ok = this.on(el[i], 
                                       sType, 
                                       fn, 
                                       obj, 
                                       overrideContext) && ok;
                    }
                    return ok;

                } else if (YAHOO.lang.isString(el)) {
                    var oEl = this.getEl(el);
                    // If the el argument is a string, we assume it is 
                    // actually the id of the element.  If the page is loaded
                    // we convert el to the actual element, otherwise we 
                    // defer attaching the event until onload event fires

                    // check to see if we need to delay hooking up the event 
                    // until after the page loads.
                    if (oEl) {
                        el = oEl;
                    } else {
                        // defer adding the event until the element is available
                        this.onAvailable(el, function() {
                           YAHOO.util.Event._addListener(el, sType, fn, obj, overrideContext, bCapture);
                        });

                        return true;
                    }
                }

                // Element should be an html element or an array if we get 
                // here.
                if (!el) {
                    return false;
                }

                // we need to make sure we fire registered unload events 
                // prior to automatically unhooking them.  So we hang on to 
                // these instead of attaching them to the window and fire the
                // handles explicitly during our one unload event.
                if ("unload" == sType && obj !== this) {
                    unloadListeners[unloadListeners.length] =
                            [el, sType, fn, obj, overrideContext];
                    return true;
                }


                // if the user chooses to override the context, we use the custom
                // object passed in, otherwise the executing context will be the
                // HTML element that the event is registered on
                var context = el;
                if (overrideContext) {
                    if (overrideContext === true) {
                        context = obj;
                    } else {
                        context = overrideContext;
                    }
                }

                // wrap the function so we can return the obj object when
                // the event fires;
                var wrappedFn = function(e) {
                        return fn.call(context, YAHOO.util.Event.getEvent(e, el), 
                                obj);
                    };

                var li = [el, sType, fn, wrappedFn, context, obj, overrideContext, bCapture];
                var index = listeners.length;
                // cache the listener so we can try to automatically unload
                listeners[index] = li;

                try {
                    this._simpleAdd(el, sType, wrappedFn, bCapture);
                } catch(ex) {
                    // handle an error trying to attach an event.  If it fails
                    // we need to clean up the cache
                    this.lastError = ex;
                    this.removeListener(el, sType, fn);
                    return false;
                }

                return true;
                
            },

            
			_getType: function (type) {
			
				return this._specialTypes[type] || type;
				
			},


            
            addListener: function (el, sType, fn, obj, overrideContext) {

				var capture = ((sType == FOCUSIN || sType == FOCUSOUT) && !YAHOO.env.ua.ie) ? true : false;

                return this._addListener(el, this._getType(sType), fn, obj, overrideContext, capture);

        	},


            
            addFocusListener: function (el, fn, obj, overrideContext) {
                return this.on(el, FOCUSIN, fn, obj, overrideContext);
            },          


            
            removeFocusListener: function (el, fn) { 
                return this.removeListener(el, FOCUSIN, fn);
            },

            
            addBlurListener: function (el, fn, obj, overrideContext) {
                return this.on(el, FOCUSOUT, fn, obj, overrideContext);
            },          

            
            removeBlurListener: function (el, fn) { 
                return this.removeListener(el, FOCUSOUT, fn);
            },

            
            removeListener: function(el, sType, fn) {
                var i, len, li;

				sType = this._getType(sType);

                // The el argument can be a string
                if (typeof el == "string") {
                    el = this.getEl(el);
                // The el argument can be an array of elements or element ids.
                } else if ( this._isValidCollection(el)) {
                    var ok = true;
                    for (i=el.length-1; i>-1; i--) {
                        ok = ( this.removeListener(el[i], sType, fn) && ok );
                    }
                    return ok;
                }

                if (!fn || !fn.call) {
                    //return false;
                    return this.purgeElement(el, false, sType);
                }

                if ("unload" == sType) {

                    for (i=unloadListeners.length-1; i>-1; i--) {
                        li = unloadListeners[i];
                        if (li && 
                            li[0] == el && 
                            li[1] == sType && 
                            li[2] == fn) {
                                unloadListeners.splice(i, 1);
                                // unloadListeners[i]=null;
                                return true;
                        }
                    }

                    return false;
                }

                var cacheItem = null;

                // The index is a hidden parameter; needed to remove it from
                // the method signature because it was tempting users to
                // try and take advantage of it, which is not possible.
                var index = arguments[3];
  
                if ("undefined" === typeof index) {
                    index = this._getCacheIndex(listeners, el, sType, fn);
                }

                if (index >= 0) {
                    cacheItem = listeners[index];
                }

                if (!el || !cacheItem) {
                    return false;
                }


				var bCapture = cacheItem[this.CAPTURE] === true ? true : false;

                try {
                    this._simpleRemove(el, sType, cacheItem[this.WFN], bCapture);
                } catch(ex) {
                    this.lastError = ex;
                    return false;
                }

                // removed the wrapped handler
                delete listeners[index][this.WFN];
                delete listeners[index][this.FN];
                listeners.splice(index, 1);
                // listeners[index]=null;

                return true;

            },

            
            getTarget: function(ev, resolveTextNode) {
                var t = ev.target || ev.srcElement;
                return this.resolveTextNode(t);
            },

            
            resolveTextNode: function(n) {
                try {
                    if (n && 3 == n.nodeType) {
                        return n.parentNode;
                    }
                } catch(e) { }

                return n;
            },

            
            getPageX: function(ev) {
                var x = ev.pageX;
                if (!x && 0 !== x) {
                    x = ev.clientX || 0;

                    if ( this.isIE ) {
                        x += this._getScrollLeft();
                    }
                }

                return x;
            },

            
            getPageY: function(ev) {
                var y = ev.pageY;
                if (!y && 0 !== y) {
                    y = ev.clientY || 0;

                    if ( this.isIE ) {
                        y += this._getScrollTop();
                    }
                }


                return y;
            },

            
            getXY: function(ev) {
                return [this.getPageX(ev), this.getPageY(ev)];
            },

            
            getRelatedTarget: function(ev) {
                var t = ev.relatedTarget;
                if (!t) {
                    if (ev.type == "mouseout") {
                        t = ev.toElement;
                    } else if (ev.type == "mouseover") {
                        t = ev.fromElement;
                    }
                }

                return this.resolveTextNode(t);
            },

            
            getTime: function(ev) {
                if (!ev.time) {
                    var t = new Date().getTime();
                    try {
                        ev.time = t;
                    } catch(ex) { 
                        this.lastError = ex;
                        return t;
                    }
                }

                return ev.time;
            },

            
            stopEvent: function(ev) {
                this.stopPropagation(ev);
                this.preventDefault(ev);
            },

            
            stopPropagation: function(ev) {
                if (ev.stopPropagation) {
                    ev.stopPropagation();
                } else {
                    ev.cancelBubble = true;
                }
            },

            
            preventDefault: function(ev) {
                if (ev.preventDefault) {
                    ev.preventDefault();
                } else {
                    ev.returnValue = false;
                }
            },
             
            
            getEvent: function(e, boundEl) {
                var ev = e || window.event;

                if (!ev) {
                    var c = this.getEvent.caller;
                    while (c) {
                        ev = c.arguments[0];
                        if (ev && Event == ev.constructor) {
                            break;
                        }
                        c = c.caller;
                    }
                }

                return ev;
            },

            
            getCharCode: function(ev) {
                var code = ev.keyCode || ev.charCode || 0;

                // webkit key normalization
                if (YAHOO.env.ua.webkit && (code in webkitKeymap)) {
                    code = webkitKeymap[code];
                }
                return code;
            },

            
            _getCacheIndex: function(a, el, sType, fn) {
                for (var i=0, l=a.length; i<l; i=i+1) {
                    var li = a[i];
                    if ( li                 && 
                         li[this.FN] == fn  && 
                         li[this.EL] == el  && 
                         li[this.TYPE] == sType ) {
                        return i;
                    }
                }

                return -1;
            },

            
            generateId: function(el) {
                var id = el.id;

                if (!id) {
                    id = "yuievtautoid-" + counter;
                    ++counter;
                    el.id = id;
                }

                return id;
            },


            
            _isValidCollection: function(o) {
                try {
                    return ( o                     && // o is something
                             typeof o !== "string" && // o is not a string
                             o.length              && // o is indexed
                             !o.tagName            && // o is not an HTML element
                             !o.alert              && // o is not a window
                             typeof o[0] !== "undefined" );
                } catch(ex) {
                    return false;
                }

            },

            
            elCache: {},

            
            getEl: function(id) {
                return (typeof id === "string") ? document.getElementById(id) : id;
            },

            
            clearCache: function() { },

            
            DOMReadyEvent: new YAHOO.util.CustomEvent("DOMReady", YAHOO, 0, 0, 1),

            
            _load: function(e) {

                if (!loadComplete) {
                    loadComplete = true;
                    var EU = YAHOO.util.Event;

                    // Just in case DOMReady did not go off for some reason
                    EU._ready();

                    // Available elements may not have been detected before the
                    // window load event fires. Try to find them now so that the
                    // the user is more likely to get the onAvailable notifications
                    // before the window load notification
                    EU._tryPreloadAttach();

                }
            },

            
            _ready: function(e) {
                var EU = YAHOO.util.Event;
                if (!EU.DOMReady) {
                    EU.DOMReady=true;

                    // Fire the content ready custom event
                    EU.DOMReadyEvent.fire();

                    // Remove the DOMContentLoaded (FF/Opera)
                    EU._simpleRemove(document, "DOMContentLoaded", EU._ready);
                }
            },

            
            _tryPreloadAttach: function() {

                if (onAvailStack.length === 0) {
                    retryCount = 0;
                    if (this._interval) {
                        // clearInterval(this._interval);
                        this._interval.cancel();
                        this._interval = null;
                    } 
                    return;
                }

                if (this.locked) {
                    return;
                }

                if (this.isIE) {
                    // Hold off if DOMReady has not fired and check current
                    // readyState to protect against the IE operation aborted
                    // issue.
                    if (!this.DOMReady) {
                        this.startInterval();
                        return;
                    }
                }

                this.locked = true;


                // keep trying until after the page is loaded.  We need to 
                // check the page load state prior to trying to bind the 
                // elements so that we can be certain all elements have been 
                // tested appropriately
                var tryAgain = !loadComplete;
                if (!tryAgain) {
                    tryAgain = (retryCount > 0 && onAvailStack.length > 0);
                }

                // onAvailable
                var notAvail = [];

                var executeItem = function (el, item) {
                    var context = el;
                    if (item.overrideContext) {
                        if (item.overrideContext === true) {
                            context = item.obj;
                        } else {
                            context = item.overrideContext;
                        }
                    }
                    item.fn.call(context, item.obj);
                };

                var i, len, item, el, ready=[];

                // onAvailable onContentReady
                for (i=0, len=onAvailStack.length; i<len; i=i+1) {
                    item = onAvailStack[i];
                    if (item) {
                        el = this.getEl(item.id);
                        if (el) {
                            if (item.checkReady) {
                                if (loadComplete || el.nextSibling || !tryAgain) {
                                    ready.push(item);
                                    onAvailStack[i] = null;
                                }
                            } else {
                                executeItem(el, item);
                                onAvailStack[i] = null;
                            }
                        } else {
                            notAvail.push(item);
                        }
                    }
                }
                
                // make sure onContentReady fires after onAvailable
                for (i=0, len=ready.length; i<len; i=i+1) {
                    item = ready[i];
                    executeItem(this.getEl(item.id), item);
                }


                retryCount--;

                if (tryAgain) {
                    for (i=onAvailStack.length-1; i>-1; i--) {
                        item = onAvailStack[i];
                        if (!item || !item.id) {
                            onAvailStack.splice(i, 1);
                        }
                    }

                    this.startInterval();
                } else {
                    if (this._interval) {
                        // clearInterval(this._interval);
                        this._interval.cancel();
                        this._interval = null;
                    }
                }

                this.locked = false;

            },

            
            purgeElement: function(el, recurse, sType) {
                var oEl = (YAHOO.lang.isString(el)) ? this.getEl(el) : el;
                var elListeners = this.getListeners(oEl, sType), i, len;
                if (elListeners) {
                    for (i=elListeners.length-1; i>-1; i--) {
                        var l = elListeners[i];
                        this.removeListener(oEl, l.type, l.fn);
                    }
                }

                if (recurse && oEl && oEl.childNodes) {
                    for (i=0,len=oEl.childNodes.length; i<len ; ++i) {
                        this.purgeElement(oEl.childNodes[i], recurse, sType);
                    }
                }
            },

                       
            getListeners: function(el, sType) {
                var results=[], searchLists;
                if (!sType) {
                    searchLists = [listeners, unloadListeners];
                } else if (sType === "unload") {
                    searchLists = [unloadListeners];
                } else {
					sType = this._getType(sType);
                    searchLists = [listeners];
                }

                var oEl = (YAHOO.lang.isString(el)) ? this.getEl(el) : el;

                for (var j=0;j<searchLists.length; j=j+1) {
                    var searchList = searchLists[j];
                    if (searchList) {
                        for (var i=0,len=searchList.length; i<len ; ++i) {
                            var l = searchList[i];
                            if ( l  && l[this.EL] === oEl && 
                                    (!sType || sType === l[this.TYPE]) ) {
                                results.push({
                                    type:   l[this.TYPE],
                                    fn:     l[this.FN],
                                    obj:    l[this.OBJ],
                                    adjust: l[this.OVERRIDE],
                                    scope:  l[this.ADJ_SCOPE],
                                    index:  i
                                });
                            }
                        }
                    }
                }

                return (results.length) ? results : null;
            },

            
            _unload: function(e) {

                var EU = YAHOO.util.Event, i, j, l, len, index,
                         ul = unloadListeners.slice(), context;

                // execute and clear stored unload listeners
                for (i=0, len=unloadListeners.length; i<len; ++i) {
                    l = ul[i];
                    if (l) {
                        context = window;
                        if (l[EU.ADJ_SCOPE]) {
                            if (l[EU.ADJ_SCOPE] === true) {
                                context = l[EU.UNLOAD_OBJ];
                            } else {
                                context = l[EU.ADJ_SCOPE];
                            }
                        }
                        l[EU.FN].call(context, EU.getEvent(e, l[EU.EL]), l[EU.UNLOAD_OBJ] );
                        ul[i] = null;
                    }
                }

                l = null;
                context = null;
                unloadListeners = null;

                // Remove listeners to handle IE memory leaks
                // 2.5.0 listeners are removed for all browsers again.  FireFox preserves
                // at least some listeners between page refreshes, potentially causing
                // errors during page load (mouseover listeners firing before they
                // should if the user moves the mouse at the correct moment).
                if (listeners) {
                    for (j=listeners.length-1; j>-1; j--) {
                        l = listeners[j];
                        if (l) {
                            EU.removeListener(l[EU.EL], l[EU.TYPE], l[EU.FN], j);
                        } 
                    }
                    l=null;
                }

                EU._simpleRemove(window, "unload", EU._unload);

            },

            
            _getScrollLeft: function() {
                return this._getScroll()[1];
            },

            
            _getScrollTop: function() {
                return this._getScroll()[0];
            },

            
            _getScroll: function() {
                var dd = document.documentElement, db = document.body;
                if (dd && (dd.scrollTop || dd.scrollLeft)) {
                    return [dd.scrollTop, dd.scrollLeft];
                } else if (db) {
                    return [db.scrollTop, db.scrollLeft];
                } else {
                    return [0, 0];
                }
            },
            
            
            regCE: function() {},

            
            _simpleAdd: function () {
                if (window.addEventListener) {
                    return function(el, sType, fn, capture) {
                        el.addEventListener(sType, fn, (capture));
                    };
                } else if (window.attachEvent) {
                    return function(el, sType, fn, capture) {
                        el.attachEvent("on" + sType, fn);
                    };
                } else {
                    return function(){};
                }
            }(),

            
            _simpleRemove: function() {
                if (window.removeEventListener) {
                    return function (el, sType, fn, capture) {
                        el.removeEventListener(sType, fn, (capture));
                    };
                } else if (window.detachEvent) {
                    return function (el, sType, fn) {
                        el.detachEvent("on" + sType, fn);
                    };
                } else {
                    return function(){};
                }
            }()
        };

    }();

    (function() {
        var EU = YAHOO.util.Event;

        
        EU.on = EU.addListener;

        
        EU.onFocus = EU.addFocusListener;

             
        EU.onBlur = EU.addBlurListener;



        // Internet Explorer: use the readyState of a defered script.
        // This isolates what appears to be a safe moment to manipulate
        // the DOM prior to when the document's readyState suggests
        // it is safe to do so.
        if (EU.isIE) {
            if (self !== self.top) {
                document.onreadystatechange = function() {
                    if (document.readyState == 'complete') {
                        document.onreadystatechange = null;
                        EU._ready();
                    }
                };
            } else {

                // Process onAvailable/onContentReady items when the 
                // DOM is ready.
                YAHOO.util.Event.onDOMReady(
                        YAHOO.util.Event._tryPreloadAttach,
                        YAHOO.util.Event, true);
                
                var n = document.createElement('p');  

                EU._dri = setInterval(function() {
                    try {
                        // throws an error if doc is not ready
                        n.doScroll('left');
                        clearInterval(EU._dri);
                        EU._dri = null;
                        EU._ready();
                        n = null;
                    } catch (ex) { 
                    }
                }, EU.POLL_INTERVAL); 
            }

        // The document's readyState in Safari currently will
        // change to loaded/complete before images are loaded.
        } else if (EU.webkit && EU.webkit < 525) {

            EU._dri = setInterval(function() {
                var rs=document.readyState;
                if ("loaded" == rs || "complete" == rs) {
                    clearInterval(EU._dri);
                    EU._dri = null;
                    EU._ready();
                }
            }, EU.POLL_INTERVAL); 

        // FireFox and Opera: These browsers provide a event for this
        // moment.  The latest WebKit releases now support this event.
        } else {

            EU._simpleAdd(document, "DOMContentLoaded", EU._ready);

        }
        /////////////////////////////////////////////////////////////


        EU._simpleAdd(window, "load", EU._load);
        EU._simpleAdd(window, "unload", EU._unload);
        EU._tryPreloadAttach();
    })();

}

YAHOO.util.EventProvider = function() { };

YAHOO.util.EventProvider.prototype = {

    
    __yui_events: null,

    
    __yui_subscribers: null,
    
    
    subscribe: function(p_type, p_fn, p_obj, overrideContext) {

        this.__yui_events = this.__yui_events || {};
        var ce = this.__yui_events[p_type];

        if (ce) {
            ce.subscribe(p_fn, p_obj, overrideContext);
        } else {
            this.__yui_subscribers = this.__yui_subscribers || {};
            var subs = this.__yui_subscribers;
            if (!subs[p_type]) {
                subs[p_type] = [];
            }
            subs[p_type].push(
                { fn: p_fn, obj: p_obj, overrideContext: overrideContext } );
        }
    },

    
    unsubscribe: function(p_type, p_fn, p_obj) {
        this.__yui_events = this.__yui_events || {};
        var evts = this.__yui_events;
        if (p_type) {
            var ce = evts[p_type];
            if (ce) {
                return ce.unsubscribe(p_fn, p_obj);
            }
        } else {
            var ret = true;
            for (var i in evts) {
                if (YAHOO.lang.hasOwnProperty(evts, i)) {
                    ret = ret && evts[i].unsubscribe(p_fn, p_obj);
                }
            }
            return ret;
        }

        return false;
    },
    
    
    unsubscribeAll: function(p_type) {
        return this.unsubscribe(p_type);
    },

    
    createEvent: function(p_type, p_config) {

        this.__yui_events = this.__yui_events || {};
        var opts = p_config || {},
            events = this.__yui_events, ce;

        if (events[p_type]) {
        } else {

            ce = new YAHOO.util.CustomEvent(p_type, opts.scope || this, opts.silent,
                         YAHOO.util.CustomEvent.FLAT, opts.fireOnce);

            events[p_type] = ce;

            if (opts.onSubscribeCallback) {
                ce.subscribeEvent.subscribe(opts.onSubscribeCallback);
            }

            this.__yui_subscribers = this.__yui_subscribers || {};
            var qs = this.__yui_subscribers[p_type];

            if (qs) {
                for (var i=0; i<qs.length; ++i) {
                    ce.subscribe(qs[i].fn, qs[i].obj, qs[i].overrideContext);
                }
            }
        }

        return events[p_type];
    },


   
    fireEvent: function(p_type) {

        this.__yui_events = this.__yui_events || {};
        var ce = this.__yui_events[p_type];

        if (!ce) {
            return null;
        }

        var args = [];
        for (var i=1; i<arguments.length; ++i) {
            args.push(arguments[i]);
        }
        return ce.fire.apply(ce, args);
    },

    
    hasEvent: function(type) {
        if (this.__yui_events) {
            if (this.__yui_events[type]) {
                return true;
            }
        }
        return false;
    }

};

(function() {

    var Event = YAHOO.util.Event, Lang = YAHOO.lang;


YAHOO.util.KeyListener = function(attachTo, keyData, handler, event) {
    if (!attachTo) {
    } else if (!keyData) {
    } else if (!handler) {
    } 
    
    if (!event) {
        event = YAHOO.util.KeyListener.KEYDOWN;
    }

    
    var keyEvent = new YAHOO.util.CustomEvent("keyPressed");
    
    
    this.enabledEvent = new YAHOO.util.CustomEvent("enabled");

    
    this.disabledEvent = new YAHOO.util.CustomEvent("disabled");

    if (Lang.isString(attachTo)) {
        attachTo = document.getElementById(attachTo); // No Dom util
    }

    if (Lang.isFunction(handler)) {
        keyEvent.subscribe(handler);
    } else {
        keyEvent.subscribe(handler.fn, handler.scope, handler.correctScope);
    }

    
    function handleKeyPress(e, obj) {
        if (! keyData.shift) {  
            keyData.shift = false; 
        }
        if (! keyData.alt) {    
            keyData.alt = false;
        }
        if (! keyData.ctrl) {
            keyData.ctrl = false;
        }

        // check held down modifying keys first
        if (e.shiftKey == keyData.shift && 
            e.altKey   == keyData.alt &&
            e.ctrlKey  == keyData.ctrl) { // if we pass this, all modifiers match
            
            var dataItem, keys = keyData.keys, key;

            if (YAHOO.lang.isArray(keys)) {
                for (var i=0;i<keys.length;i++) {
                    dataItem = keys[i];
                    key = Event.getCharCode(e);

                    if (dataItem == key) {
                        keyEvent.fire(key, e);
                        break;
                    }
                }
            } else {
                key = Event.getCharCode(e);
                if (keys == key ) {
                    keyEvent.fire(key, e);
                }
            }
        }
    }

    
    this.enable = function() {
        if (! this.enabled) {
            Event.on(attachTo, event, handleKeyPress);
            this.enabledEvent.fire(keyData);
        }
        
        this.enabled = true;
    };

    
    this.disable = function() {
        if (this.enabled) {
            Event.removeListener(attachTo, event, handleKeyPress);
            this.disabledEvent.fire(keyData);
        }
        this.enabled = false;
    };

     
    this.toString = function() {
        return "KeyListener [" + keyData.keys + "] " + attachTo.tagName + 
                (attachTo.id ? "[" + attachTo.id + "]" : "");
    };

};

var KeyListener = YAHOO.util.KeyListener;


KeyListener.KEYDOWN = "keydown";


KeyListener.KEYUP = "keyup";


KeyListener.KEY = {
    ALT          : 18,
    BACK_SPACE   : 8,
    CAPS_LOCK    : 20,
    CONTROL      : 17,
    DELETE       : 46,
    DOWN         : 40,
    END          : 35,
    ENTER        : 13,
    ESCAPE       : 27,
    HOME         : 36,
    LEFT         : 37,
    META         : 224,
    NUM_LOCK     : 144,
    PAGE_DOWN    : 34,
    PAGE_UP      : 33, 
    PAUSE        : 19,
    PRINTSCREEN  : 44,
    RIGHT        : 39,
    SCROLL_LOCK  : 145,
    SHIFT        : 16,
    SPACE        : 32,
    TAB          : 9,
    UP           : 38
};

})();
YAHOO.register("event", YAHOO.util.Event, {version: "2.8.1", build: "19"});


(function () {
    var Dom = YAHOO.util.Dom,
        Event = YAHOO.util.Event,
        Lang = YAHOO.lang,
        Widget = YAHOO.widget;
        
    




YAHOO.widget.TreeView = function(id, oConfig) {
    if (id) { this.init(id); }
    if (oConfig) {
        this.buildTreeFromObject(oConfig);
    } else if (Lang.trim(this._el.innerHTML)) {
        this.buildTreeFromMarkup(id);
    }
};

var TV = Widget.TreeView;

TV.prototype = {

    
    id: null,

    
    _el: null,

     
    _nodes: null,

    
    locked: false,

    
    _expandAnim: null,

    
    _collapseAnim: null,

    
    _animCount: 0,

    
    maxAnim: 2,

    
    _hasDblClickSubscriber: false,
    
    
    _dblClickTimer: null,

  
    currentFocus: null,
    
    
    
    singleNodeHighlight: false,
    
    
    
    _currentlyHighlighted: null,

    
    setExpandAnim: function(type) {
        this._expandAnim = (Widget.TVAnim.isValid(type)) ? type : null;
    },

    
    setCollapseAnim: function(type) {
        this._collapseAnim = (Widget.TVAnim.isValid(type)) ? type : null;
    },

    
    animateExpand: function(el, node) {

        if (this._expandAnim && this._animCount < this.maxAnim) {
            // this.locked = true;
            var tree = this;
            var a = Widget.TVAnim.getAnim(this._expandAnim, el, 
                            function() { tree.expandComplete(node); });
            if (a) { 
                ++this._animCount;
                this.fireEvent("animStart", {
                        "node": node, 
                        "type": "expand"
                    });
                a.animate();
            }

            return true;
        }

        return false;
    },

    
    animateCollapse: function(el, node) {

        if (this._collapseAnim && this._animCount < this.maxAnim) {
            // this.locked = true;
            var tree = this;
            var a = Widget.TVAnim.getAnim(this._collapseAnim, el, 
                            function() { tree.collapseComplete(node); });
            if (a) { 
                ++this._animCount;
                this.fireEvent("animStart", {
                        "node": node, 
                        "type": "collapse"
                    });
                a.animate();
            }

            return true;
        }

        return false;
    },

    
    expandComplete: function(node) {
        --this._animCount;
        this.fireEvent("animComplete", {
                "node": node, 
                "type": "expand"
            });
        // this.locked = false;
    },

    
    collapseComplete: function(node) {
        --this._animCount;
        this.fireEvent("animComplete", {
                "node": node, 
                "type": "collapse"
            });
        // this.locked = false;
    },

    
    init: function(id) {
        this._el = Dom.get(id);
        this.id = Dom.generateId(this._el,"yui-tv-auto-id-");

    
        this.createEvent("animStart", this);

        
        this.createEvent("animComplete", this);

        
        this.createEvent("collapse", this);

        
        this.createEvent("collapseComplete", this);

        
        this.createEvent("expand", this);

        
        this.createEvent("expandComplete", this);

    
        this.createEvent("enterKeyPressed", this);
        
    
        this.createEvent("clickEvent", this);
        
    
        
        this.createEvent('focusChanged',this);

    
        var self = this;
        this.createEvent("dblClickEvent", {
            scope:this,
            onSubscribeCallback: function() {
                self._hasDblClickSubscriber = true;
            }
        });
        
    
        this.createEvent("labelClick", this);
        
    
        this.createEvent("highlightEvent",this);
     


        this._nodes = [];

        // store a global reference
        TV.trees[this.id] = this;

        // Set up the root node
        this.root = new Widget.RootNode(this);

        var LW = Widget.LogWriter;


		
		if (this._initEditor) {
			this._initEditor();
		}
        
        // YAHOO.util.Event.onContentReady(this.id, this.handleAvailable, this, true);
        // YAHOO.util.Event.on(this.id, "click", this.handleClick, this, true);
    },

    //handleAvailable: function() {
        //var Event = YAHOO.util.Event;
        //Event.on(this.id, 
    //},
 
    buildTreeFromObject: function (oConfig) {
        var build = function (parent, oConfig) {
            var i, item, node, children, type, NodeType, ThisType;
            for (i = 0; i < oConfig.length; i++) {
                item = oConfig[i];
                if (Lang.isString(item)) {
                    node = new Widget.TextNode(item, parent);
                } else if (Lang.isObject(item)) {
                    children = item.children;
                    delete item.children;
                    type = item.type || 'text';
                    delete item.type;
                    switch (Lang.isString(type) && type.toLowerCase()) {
                        case 'text':
                            node = new Widget.TextNode(item, parent);
                            break;
                        case 'menu':
                            node = new Widget.MenuNode(item, parent);
                            break;
                        case 'html':
                            node = new Widget.HTMLNode(item, parent);
                            break;
                        default:
                            if (Lang.isString(type)) {
                                NodeType = Widget[type];
                            } else {
                                NodeType = type;
                            }
                            if (Lang.isObject(NodeType)) {
                                for (ThisType = NodeType; ThisType && ThisType !== Widget.Node; ThisType = ThisType.superclass.constructor) {}
                                if (ThisType) {
                                    node = new NodeType(item, parent);
                                } else {
                                }
                            } else {
                            }
                    }
                    if (children) {
                        build(node,children);
                    }
                } else {
                }
            }
        };
        if (!Lang.isArray(oConfig)) {
            oConfig = [oConfig];
        }

                    
        build(this.root,oConfig);
    },

    buildTreeFromMarkup: function (id) {
        var build = function (markup) {
            var el, child, branch = [], config = {}, label, yuiConfig;
            // Dom's getFirstChild and getNextSibling skip over text elements
            for (el = Dom.getFirstChild(markup); el; el = Dom.getNextSibling(el)) {
                switch (el.tagName.toUpperCase()) {
                    case 'LI':
                        label = '';
                        config = {
                            expanded: Dom.hasClass(el,'expanded'),
                            title: el.title || el.alt || null,
                            className: Lang.trim(el.className.replace(/\bexpanded\b/,'')) || null
                        };
                        // I cannot skip over text elements here because I want them for labels
                        child = el.firstChild;
                        if (child.nodeType == 3) {
                            // nodes with only whitespace, tabs and new lines don't count, they are probably just formatting.
                            label = Lang.trim(child.nodeValue.replace(/[\n\t\r]*/g,''));
                            if (label) {
                                config.type = 'text';
                                config.label = label;
                            } else {
                                child = Dom.getNextSibling(child);
                            }
                        }
                        if (!label) {
                            if (child.tagName.toUpperCase() == 'A') {
                                config.type = 'text';
                                config.label = child.innerHTML;
                                config.href = child.href;
                                config.target = child.target;
                                config.title = child.title || child.alt || config.title;
                            } else {
                                config.type = 'html';
                                var d = document.createElement('div');
                                d.appendChild(child.cloneNode(true));
                                config.html = d.innerHTML;
                                config.hasIcon = true;
                            }
                        }
                        // see if after the label it has a further list which will become children of this node.
                        child = Dom.getNextSibling(child);
                        switch (child && child.tagName.toUpperCase()) {
                            case 'UL':
                            case 'OL':
                                config.children = build(child);
                                break;
                        }
                        // if there are further elements or text, it will be ignored.
                        
                        if (YAHOO.lang.JSON) {
                            yuiConfig = el.getAttribute('yuiConfig');
                            if (yuiConfig) {
                                yuiConfig = YAHOO.lang.JSON.parse(yuiConfig);
                                config = YAHOO.lang.merge(config,yuiConfig);
                            }
                        }
                        
                        branch.push(config);
                        break;
                    case 'UL':
                    case 'OL':
                        config = {
                            type: 'text',
                            label: '',
                            children: build(child)
                        };
                        branch.push(config);
                        break;
                }
            }
            return branch;
        };

        var markup = Dom.getChildrenBy(Dom.get(id),function (el) { 
            var tag = el.tagName.toUpperCase();
            return  tag == 'UL' || tag == 'OL';
        });
        if (markup.length) {
            this.buildTreeFromObject(build(markup[0]));
        } else {
        }
    },
  
    _getEventTargetTdEl: function (ev) {
        var target = Event.getTarget(ev); 
        // go up looking for a TD with a className with a ygtv prefix
        while (target && !(target.tagName.toUpperCase() == 'TD' && Dom.hasClass(target.parentNode,'ygtvrow'))) { 
            target = Dom.getAncestorByTagName(target,'td'); 
        }
        if (Lang.isNull(target)) { return null; }
        // If it is a spacer cell, do nothing
        if (/\bygtv(blank)?depthcell/.test(target.className)) { return null;}
        // If it has an id, search for the node number and see if it belongs to a node in this tree.
        if (target.id) {
            var m = target.id.match(/\bygtv([^\d]*)(.*)/);
            if (m && m[2] && this._nodes[m[2]]) {
                return target;
            }
        }
        return null;
    },
  
    _onClickEvent: function (ev) {
        var self = this,
            td = this._getEventTargetTdEl(ev),
            node,
            target,
            toggle = function (force) {
                node.focus();
				if (force || !node.href) {
					node.toggle();
					try {
						Event.preventDefault(ev);
					} catch (e) {
	                    // @TODO
	                    // For some reason IE8 is providing an event object with
	                    // most of the fields missing, but only when clicking on
	                    // the node's label, and only when working with inline
	                    // editing.  This generates a "Member not found" error
	                    // in that browser.  Determine if this is a browser
	                    // bug, or a problem with this code.  Already checked to
	                    // see if the problem has to do with access the event
	                    // in the outer scope, and that isn't the problem.
	                    // Maybe the markup for inline editing is broken.
					}
                }
            };

        if (!td) {
            return; 
        }

        node = this.getNodeByElement(td);
        if (!node) { 
            return; 
        }
        
        // exception to handle deprecated event labelClick
        // @TODO take another look at this deprecation.  It is common for people to
        // only be interested in the label click, so why make them have to test
        // the node type to figure out whether the click was on the label?
        target = Event.getTarget(ev);
        if (Dom.hasClass(target, node.labelStyle) || Dom.getAncestorByClassName(target,node.labelStyle)) {
            this.fireEvent('labelClick',node);
        }
        
        //  If it is a toggle cell, toggle
        if (/\bygtv[tl][mp]h?h?/.test(td.className)) {
            toggle(true);
        } else {
            if (this._dblClickTimer) {
                window.clearTimeout(this._dblClickTimer);
                this._dblClickTimer = null;
            } else {
                if (this._hasDblClickSubscriber) {
                    this._dblClickTimer = window.setTimeout(function () {
                        self._dblClickTimer = null;
                        if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) { 
                            toggle();
                        }
                    }, 200);
                } else {
                    if (self.fireEvent('clickEvent', {event:ev,node:node}) !== false) { 
                        toggle();
                    }
                }
            }
        }
    },

  
    _onDblClickEvent: function (ev) {
        if (!this._hasDblClickSubscriber) { return; }
        var td = this._getEventTargetTdEl(ev);
        if (!td) {return;}

        if (!(/\bygtv[tl][mp]h?h?/.test(td.className))) {
            this.fireEvent('dblClickEvent', {event:ev, node:this.getNodeByElement(td)}); 
            if (this._dblClickTimer) {
                window.clearTimeout(this._dblClickTimer);
                this._dblClickTimer = null;
            }
        }
    },
  
    _onMouseOverEvent:function (ev) {
        var target;
        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
            target.className = target.className.replace(/\bygtv([lt])([mp])\b/gi,'ygtv$1$2h');
        }
    },
  
    _onMouseOutEvent: function (ev) {
        var target;
        if ((target = this._getEventTargetTdEl(ev)) && (target = this.getNodeByElement(target)) && (target = target.getToggleEl())) {
            target.className = target.className.replace(/\bygtv([lt])([mp])h\b/gi,'ygtv$1$2');
        }
    },
  
    _onKeyDownEvent: function (ev) {
        var target = Event.getTarget(ev),
            node = this.getNodeByElement(target),
            newNode = node,
            KEY = YAHOO.util.KeyListener.KEY;

        switch(ev.keyCode) {
            case KEY.UP:
                do {
                    if (newNode.previousSibling) {
                        newNode = newNode.previousSibling;
                    } else {
                        newNode = newNode.parent;
                    }
                } while (newNode && !newNode._canHaveFocus());
                if (newNode) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case KEY.DOWN:
                do {
                    if (newNode.nextSibling) {
                        newNode = newNode.nextSibling;
                    } else {
                        newNode.expand();
                        newNode = (newNode.children.length || null) && newNode.children[0];
                    }
                } while (newNode && !newNode._canHaveFocus);
                if (newNode) { newNode.focus();}
                Event.preventDefault(ev);
                break;
            case KEY.LEFT:
                do {
                    if (newNode.parent) {
                        newNode = newNode.parent;
                    } else {
                        newNode = newNode.previousSibling;
                    }
                } while (newNode && !newNode._canHaveFocus());
                if (newNode) { newNode.focus();}
                Event.preventDefault(ev);
                break;
			case KEY.RIGHT:
				var self = this,
					moveFocusRight,
					focusOnExpand = function (newNode) {
						self.unsubscribe('expandComplete',focusOnExpand);
						moveFocusRight(newNode);
					};
				moveFocusRight = function (newNode) {
					do {
						if (newNode.isDynamic() && !newNode.childrenRendered) {
							self.subscribe('expandComplete',focusOnExpand);
							newNode.expand();
							newNode = null;
							break;
						} else {
							newNode.expand();
							if (newNode.children.length) {
								newNode = newNode.children[0];
							} else {
								newNode = newNode.nextSibling;
							}
						}
					} while (newNode && !newNode._canHaveFocus());
					if (newNode) { newNode.focus();}
				};
					
				moveFocusRight(newNode);
				Event.preventDefault(ev);
				break;
            case KEY.ENTER:
                if (node.href) {
                    if (node.target) {
                        window.open(node.href,node.target);
                    } else {
                        window.location(node.href);
                    }
                } else {
                    node.toggle();
                }
                this.fireEvent('enterKeyPressed',node);
                Event.preventDefault(ev);
                break;
            case KEY.HOME:
                newNode = this.getRoot();
                if (newNode.children.length) {newNode = newNode.children[0];}
                if (newNode._canHaveFocus()) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            case KEY.END:
                newNode = newNode.parent.children;
                newNode = newNode[newNode.length -1];
                if (newNode._canHaveFocus()) { newNode.focus(); }
                Event.preventDefault(ev);
                break;
            // case KEY.PAGE_UP:
                // break;
            // case KEY.PAGE_DOWN:
                // break;
            case 107:  // plus key
                if (ev.shiftKey) {
                    node.parent.expandAll();
                } else {
                    node.expand();
                }
                break;
            case 109: // minus key
                if (ev.shiftKey) {
                    node.parent.collapseAll();
                } else {
                    node.collapse();
                }
                break;
            default:
                break;
        }
    },
    
    render: function() {
        var html = this.root.getHtml(),
            el = this.getEl();
        el.innerHTML = html;
        if (!this._hasEvents) {
            Event.on(el, 'click', this._onClickEvent, this, true);
            Event.on(el, 'dblclick', this._onDblClickEvent, this, true);
            Event.on(el, 'mouseover', this._onMouseOverEvent, this, true);
            Event.on(el, 'mouseout', this._onMouseOutEvent, this, true);
            Event.on(el, 'keydown', this._onKeyDownEvent, this, true);
        }

        // support buttons for treeTable
        if(this.root.children[0] && this.root.children[0].treeControl && this.root.children[0].treeControl.config['controlType']=='table'){
        	var buttons = Ext.query('.treeTable .button', this.root.children[0].getDivEl());
        	for(var k=0; k<buttons.length; k++){
        		
        		var button = buttons[k];
        		var cell = button.parentElement.parentElement;
        		var row = cell.parentElement;
        		
        		// IE6 cannot add an ID to a text node			
        		if (valueExists(button) && button.nodeType != 3) {
        			var fieldIndex =  button.id.replace('button', '');				
        			var listenerName = this.id + '_on' + capitalizeFirst(this.root.children[0].treeControl._levels[0].visibleFields[fieldIndex].name);
        			
        			var panel = this.root.children[0].treeControl._panelsData[0];
        			var levels = row.id.split('_');
        			var index = levels[levels.length-1];
        			var node = this._nodes[index];
        			this.attachListenerToElement(listenerName, button, row, panel, node);			
        		}	
        	}
        }        
        this._hasEvents = true;
    },
    
  
    getEl: function() {
        if (! this._el) {
            this._el = Dom.get(this.id);
        }
        return this._el;
    },

    
    regNode: function(node) {
        this._nodes[node.index] = node;
    },

    
    getRoot: function() {
        return this.root;
    },

    
    setDynamicLoad: function(fnDataLoader, iconMode) { 
        this.root.setDynamicLoad(fnDataLoader, iconMode);
    },

    
    expandAll: function() { 
        if (!this.locked) {
            this.root.expandAll(); 
        }
    },

    
    collapseAll: function() { 
        if (!this.locked) {
            this.root.collapseAll(); 
        }
    },

    
    getNodeByIndex: function(nodeIndex) {
        var n = this._nodes[nodeIndex];
        return (n) ? n : null;
    },

    
    getNodeByProperty: function(property, value) {
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
                    return n;
                }
            }
        }

        return null;
    },

    
    getNodesByProperty: function(property, value) {
        var values = [];
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if ((property in n && n[property] == value) || (n.data && value == n.data[property])) {
                    values.push(n);
                }
            }
        }

        return (values.length) ? values : null;
    },


    
    getNodesBy: function(fn) {
        var values = [];
        for (var i in this._nodes) {
            if (this._nodes.hasOwnProperty(i)) {
                var n = this._nodes[i];
                if (fn(n)) {
                    values.push(n);
                }
            }
        }
        return (values.length) ? values : null;
    },
    
    getNodeByElement: function(el) {

        var p=el, m, re=/ygtv([^\d]*)(.*)/;

        do {

            if (p && p.id) {
                m = p.id.match(re);
                if (m && m[2]) {
                    return this.getNodeByIndex(m[2]);
                }
            }

            p = p.parentNode;

            if (!p || !p.tagName) {
                break;
            }

        } 
        while (p.id !== this.id && p.tagName.toLowerCase() !== "body");

        return null;
    },
	
    
	getHighlightedNode: function() {
		return this._currentlyHighlighted;
	},


    
    removeNode: function(node, autoRefresh) { 

        // Don't delete the root node
        if (node.isRoot()) {
            return false;
        }

        // Get the branch that we may need to refresh
        var p = node.parent;
        if (p.parent) {
            p = p.parent;
        }

        // Delete the node and its children
        this._deleteNode(node);

        // Refresh the parent of the parent
        if (autoRefresh && p && p.childrenRendered) {
            p.refresh();
        }

        return true;
    },

    
    _removeChildren_animComplete: function(o) {
        this.unsubscribe(this._removeChildren_animComplete);
        this.removeChildren(o.node);
    },

    
    removeChildren: function(node) { 

        if (node.expanded) {
            // wait until the animation is complete before deleting to
            // avoid javascript errors
            if (this._collapseAnim) {
                this.subscribe("animComplete", 
                        this._removeChildren_animComplete, this, true);
                Widget.Node.prototype.collapse.call(node);
                return;
            }

            node.collapse();
        }

        while (node.children.length) {
            this._deleteNode(node.children[0]);
        }

        if (node.isRoot()) {
            Widget.Node.prototype.expand.call(node);
        }

        node.childrenRendered = false;
        node.dynamicLoadComplete = false;

        node.updateIcon();
    },

    
    _deleteNode: function(node) { 
        // Remove all the child nodes first
        this.removeChildren(node);

        // Remove the node from the tree
        this.popNode(node);
    },

    
    popNode: function(node) { 
        var p = node.parent;

        // Update the parent's collection of children
        var a = [];

        for (var i=0, len=p.children.length;i<len;++i) {
            if (p.children[i] != node) {
                a[a.length] = p.children[i];
            }
        }

        p.children = a;

        // reset the childrenRendered flag for the parent
        p.childrenRendered = false;

         // Update the sibling relationship
        if (node.previousSibling) {
            node.previousSibling.nextSibling = node.nextSibling;
        }

        if (node.nextSibling) {
            node.nextSibling.previousSibling = node.previousSibling;
        }

		if (this.currentFocus == node) {
			this.currentFocus = null;
		}
		if (this._currentlyHighlighted == node) {
			this._currentlyHighlighted = null;
		}

        node.parent = null;
        node.previousSibling = null;
        node.nextSibling = null;
        node.tree = null;

        // Update the tree's node collection 
        delete this._nodes[node.index];
    },

    
    destroy : function() {
        // Since the label editor can be separated from the main TreeView control
        // the destroy method for it might not be there.
        if (this._destroyEditor) { this._destroyEditor(); }
        var el = this.getEl();
        Event.removeListener(el,'click');
        Event.removeListener(el,'dblclick');
        Event.removeListener(el,'mouseover');
        Event.removeListener(el,'mouseout');
        Event.removeListener(el,'keydown');
        for (var i = 0 ; i < this._nodes.length; i++) {
            var node = this._nodes[i];
            if (node && node.destroy) {node.destroy(); }
        }
        el.innerHTML = '';
        this._hasEvents = false;
    },
        
            


    
    toString: function() {
        return "TreeView " + this.id;
    },

    
    getNodeCount: function() {
        return this.getRoot().getNodeCount();
    },

    
    getTreeDefinition: function() {
        return this.getRoot().getNodeDefinition();
    },

    
    onExpand: function(node) { },

    
    onCollapse: function(node) { },
    
    
    setNodesProperty: function(name, value, refresh) {
        this.root.setNodesProperty(name,value);
        if (refresh) {
            this.root.refresh();
        }
    },
    
    onEventToggleHighlight: function (oArgs) {
        var node;
        if ('node' in oArgs && oArgs.node instanceof Widget.Node) {
            node = oArgs.node;
        } else if (oArgs instanceof Widget.Node) {
            node = oArgs;
        } else {
            return false;
        }
        node.toggleHighlight();
        return false;
    }
        

};


var PROT = TV.prototype;
 
PROT.draw = PROT.render;



YAHOO.augment(TV, YAHOO.util.EventProvider);


TV.nodeCount = 0;


TV.trees = [];


TV.getTree = function(treeId) {
    var t = TV.trees[treeId];
    return (t) ? t : null;
};



TV.getNode = function(treeId, nodeIndex) {
    var t = TV.getTree(treeId);
    return (t) ? t.getNodeByIndex(nodeIndex) : null;
};


 
TV.FOCUS_CLASS_NAME = 'ygtvfocus';



})();

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;

YAHOO.widget.Node = function(oData, oParent, expanded) {
    if (oData) { this.init(oData, oParent, expanded); }
};

YAHOO.widget.Node.prototype = {

    
    index: 0,

    
    children: null,

    
    tree: null,

    
    data: null,

    
    parent: null,

    
    depth: -1,

    
    expanded: false,

    
    multiExpand: true,

    
    renderHidden: false,

    
    childrenRendered: false,

    
    dynamicLoadComplete: false,

    
    previousSibling: null,

    
    nextSibling: null,

    
    _dynLoad: false,

    
    dataLoader: null,

    
    isLoading: false,

    
    hasIcon: true,

    
    iconMode: 0,

    
    nowrap: false,

 
    isLeaf: false,


    contentStyle: "",


    
    contentElId: null,
    

    enableHighlight: true,
    

 
 highlightState: 0,
 
 
 
 propagateHighlightUp: false,
 
 
 
 propagateHighlightDown: false,
 
 
 
 className: null,
 
 
    _type: "Node",

    

    
    init: function(oData, oParent, expanded) {

        this.data = {};
        this.children   = [];
        this.index      = YAHOO.widget.TreeView.nodeCount;
        ++YAHOO.widget.TreeView.nodeCount;
        this.contentElId = "ygtvcontentel" + this.index;
        
        if (Lang.isObject(oData)) {
            for (var property in oData) {
                if (oData.hasOwnProperty(property)) {
                    if (property.charAt(0) != '_'  && !Lang.isUndefined(this[property]) && !Lang.isFunction(this[property]) ) {
                        this[property] = oData[property];
                    } else {
                        this.data[property] = oData[property];
                    }
                }
            }
        }
        if (!Lang.isUndefined(expanded) ) { this.expanded  = expanded;  }
        

        
        this.createEvent("parentChange", this);

        // oParent should never be null except when we create the root node.
        if (oParent) {
            oParent.appendChild(this);
        }
    },

    
    applyParent: function(parentNode) {
        if (!parentNode) {
            return false;
        }

        this.tree   = parentNode.tree;
        this.parent = parentNode;
        this.depth  = parentNode.depth + 1;

        // @todo why was this put here.  This causes new nodes added at the
        // root level to lose the menu behavior.
        // if (! this.multiExpand) {
            // this.multiExpand = parentNode.multiExpand;
        // }

        this.tree.regNode(this);
        parentNode.childrenRendered = false;

        // cascade update existing children
        for (var i=0, len=this.children.length;i<len;++i) {
            this.children[i].applyParent(this);
        }

        this.fireEvent("parentChange");

        return true;
    },

    
    appendChild: function(childNode) {
        if (this.hasChildren()) {
            var sib = this.children[this.children.length - 1];
            sib.nextSibling = childNode;
            childNode.previousSibling = sib;
        }
        this.children[this.children.length] = childNode;
        childNode.applyParent(this);

        // part of the IE display issue workaround. If child nodes
        // are added after the initial render, and the node was
        // instantiated with expanded = true, we need to show the
        // children div now that the node has a child.
        if (this.childrenRendered && this.expanded) {
            this.getChildrenEl().style.display = "";
        }

        return childNode;
    },

    
    appendTo: function(parentNode) {
        return parentNode.appendChild(this);
    },

    
    insertBefore: function(node) {
        var p = node.parent;
        if (p) {

            if (this.tree) {
                this.tree.popNode(this);
            }

            var refIndex = node.isChildOf(p);
            p.children.splice(refIndex, 0, this);
            if (node.previousSibling) {
                node.previousSibling.nextSibling = this;
            }
            this.previousSibling = node.previousSibling;
            this.nextSibling = node;
            node.previousSibling = this;

            this.applyParent(p);
        }

        return this;
    },
 
    
    insertAfter: function(node) {
        var p = node.parent;
        if (p) {

            if (this.tree) {
                this.tree.popNode(this);
            }

            var refIndex = node.isChildOf(p);

            if (!node.nextSibling) {
                this.nextSibling = null;
                return this.appendTo(p);
            }

            p.children.splice(refIndex + 1, 0, this);

            node.nextSibling.previousSibling = this;
            this.previousSibling = node;
            this.nextSibling = node.nextSibling;
            node.nextSibling = this;

            this.applyParent(p);
        }

        return this;
    },

    
    isChildOf: function(parentNode) {
        if (parentNode && parentNode.children) {
            for (var i=0, len=parentNode.children.length; i<len ; ++i) {
                if (parentNode.children[i] === this) {
                    return i;
                }
            }
        }

        return -1;
    },

    
    getSiblings: function() {
        var sib =  this.parent.children.slice(0);
        for (var i=0;i < sib.length && sib[i] != this;i++) {}
        sib.splice(i,1);
        if (sib.length) { return sib; }
        return null;
    },

    
    showChildren: function() {
        if (!this.tree.animateExpand(this.getChildrenEl(), this)) {
            if (this.hasChildren()) {
                this.getChildrenEl().style.display = "";
            }
        }
    },

    
    hideChildren: function() {

        if (!this.tree.animateCollapse(this.getChildrenEl(), this)) {
            this.getChildrenEl().style.display = "none";
        }
    },

    
    getElId: function() {
        return "ygtv" + this.index;
    },

    
    getChildrenElId: function() {
        return "ygtvc" + this.index;
    },

    
    getToggleElId: function() {
        return "ygtvt" + this.index;
    },


    
    

    
    getEl: function() {
        return Dom.get(this.getElId());
    },

    
    getChildrenEl: function() {
        return Dom.get(this.getChildrenElId());
    },

    
    getToggleEl: function() {
        return Dom.get(this.getToggleElId());
    },
    
    getContentEl: function() { 
        return Dom.get(this.contentElId);
    },


    
    

    

  
    collapse: function() {
        // Only collapse if currently expanded
        if (!this.expanded) { return; }

        // fire the collapse event handler
        var ret = this.tree.onCollapse(this);

        if (false === ret) {
            return;
        }

        ret = this.tree.fireEvent("collapse", this);

        if (false === ret) {
            return;
        }


        if (!this.getEl()) {
            this.expanded = false;
        } else {
            // hide the child div
            this.hideChildren();
            this.expanded = false;

            this.updateIcon();
        }

        // this.getSpacer().title = this.getStateText();

        ret = this.tree.fireEvent("collapseComplete", this);

    },

    
    expand: function(lazySource) {
        // Only expand if currently collapsed.
        if (this.isLoading || (this.expanded && !lazySource)) { 
            return; 
        }

        var ret = true;

        // When returning from the lazy load handler, expand is called again
        // in order to render the new children.  The "expand" event already
        // fired before fething the new data, so we need to skip it now.
        if (!lazySource) {
            // fire the expand event handler
            ret = this.tree.onExpand(this);

            if (false === ret) {
                return;
            }
            
            ret = this.tree.fireEvent("expand", this);
        }

        if (false === ret) {
            return;
        }

        if (!this.getEl()) {
            this.expanded = true;
            return;
        }

        if (!this.childrenRendered) {
            this.getChildrenEl().innerHTML = this.renderChildren();
        } else {
        }

        this.expanded = true;

        this.updateIcon();

        // this.getSpacer().title = this.getStateText();

        // We do an extra check for children here because the lazy
        // load feature can expose nodes that have no children.

        // if (!this.hasChildren()) {
        if (this.isLoading) {
            this.expanded = false;
            return;
        }

        if (! this.multiExpand) {
            var sibs = this.getSiblings();
            for (var i=0; sibs && i<sibs.length; ++i) {
                if (sibs[i] != this && sibs[i].expanded) { 
                    sibs[i].collapse(); 
                }
            }
        }

        this.showChildren();

        ret = this.tree.fireEvent("expandComplete", this);
    },

    updateIcon: function() {
        if (this.hasIcon) {
            var el = this.getToggleEl();
            if (el) {
                el.className = el.className.replace(/\bygtv(([tl][pmn]h?)|(loading))\b/gi,this.getStyle());
            }
        }
    },

    
    getStyle: function() {
        if (this.isLoading) {
            return "ygtvloading";
        } else {
            // location top or bottom, middle nodes also get the top style
            var loc = (this.nextSibling) ? "t" : "l";

            // type p=plus(expand), m=minus(collapase), n=none(no children)
            var type = "n";
            if (this.hasChildren(true) || (this.isDynamic() && !this.getIconMode())) {
            // if (this.hasChildren(true)) {
                type = (this.expanded) ? "m" : "p";
            }

            return "ygtv" + loc + type;
        }
    },

    
    getHoverStyle: function() { 
        var s = this.getStyle();
        if (this.hasChildren(true) && !this.isLoading) { 
            s += "h"; 
        }
        return s;
    },

    
    expandAll: function() { 
        var l = this.children.length;
        for (var i=0;i<l;++i) {
            var c = this.children[i];
            if (c.isDynamic()) {
                break;
            } else if (! c.multiExpand) {
                break;
            } else {
                c.expand();
                c.expandAll();
            }
        }
    },

    
    collapseAll: function() { 
        for (var i=0;i<this.children.length;++i) {
            this.children[i].collapse();
            this.children[i].collapseAll();
        }
    },

    
    setDynamicLoad: function(fnDataLoader, iconMode) { 
        if (fnDataLoader) {
            this.dataLoader = fnDataLoader;
            this._dynLoad = true;
        } else {
            this.dataLoader = null;
            this._dynLoad = false;
        }

        if (iconMode) {
            this.iconMode = iconMode;
        }
    },

    
    isRoot: function() { 
        return (this == this.tree.root);
    },

    
    isDynamic: function() { 
        if (this.isLeaf) {
            return false;
        } else {
            return (!this.isRoot() && (this._dynLoad || this.tree.root._dynLoad));
            // return lazy;
        }
    },

    
    getIconMode: function() {
        return (this.iconMode || this.tree.root.iconMode);
    },

    
    hasChildren: function(checkForLazyLoad) { 
        if (this.isLeaf) {
            return false;
        } else {
            return ( this.children.length > 0 || 
				(checkForLazyLoad && this.isDynamic() && !this.dynamicLoadComplete) 
			);
        }
    },

    
    toggle: function() {
        if (!this.tree.locked && ( this.hasChildren(true) || this.isDynamic()) ) {
            if (this.expanded) { this.collapse(); } else { this.expand(); }
        }
    },

    
    getHtml: function() {

        this.childrenRendered = false;

        return ['<div class="ygtvitem" id="' , this.getElId() , '">' ,this.getNodeHtml() , this.getChildrenHtml() ,'</div>'].join("");
    },

    
    getChildrenHtml: function() {


        var sb = [];
        sb[sb.length] = '<div class="ygtvchildren" id="' + this.getChildrenElId() + '"';

        // This is a workaround for an IE rendering issue, the child div has layout
        // in IE, creating extra space if a leaf node is created with the expanded
        // property set to true.
        if (!this.expanded || !this.hasChildren()) {
            sb[sb.length] = ' style="display:none;"';
        }
        sb[sb.length] = '>';


        // Don't render the actual child node HTML unless this node is expanded.
        if ( (this.hasChildren(true) && this.expanded) ||
                (this.renderHidden && !this.isDynamic()) ) {
            sb[sb.length] = this.renderChildren();
        }

        sb[sb.length] = '</div>';

        return sb.join("");
    },

    
    renderChildren: function() {


        var node = this;

        if (this.isDynamic() && !this.dynamicLoadComplete) {
            this.isLoading = true;
            this.tree.locked = true;

            if (this.dataLoader) {

                setTimeout( 
                    function() {
                        node.dataLoader(node, 
                            function() { 
                                node.loadComplete(); 
                            });
                    }, 10);
                
            } else if (this.tree.root.dataLoader) {

                setTimeout( 
                    function() {
                        node.tree.root.dataLoader(node, 
                            function() { 
                                node.loadComplete(); 
                            });
                    }, 10);

            } else {
                return "Error: data loader not found or not specified.";
            }

            return "";

        } else {
            return this.completeRender();
        }
    },

    
    completeRender: function() {
        var sb = [];

        for (var i=0; i < this.children.length; ++i) {
            // this.children[i].childrenRendered = false;
            sb[sb.length] = this.children[i].getHtml();
        }
        
        this.childrenRendered = true;

        return sb.join("");
    },

    
    loadComplete: function() {
        this.getChildrenEl().innerHTML = this.completeRender();
		if (this.propagateHighlightDown) {
			if (this.highlightState === 1 && !this.tree.singleNodeHighlight) {
				for (var i = 0; i < this.children.length; i++) {
				this.children[i].highlight(true);
			}
			} else if (this.highlightState === 0 || this.tree.singleNodeHighlight) {
				for (i = 0; i < this.children.length; i++) {
					this.children[i].unhighlight(true);
				}
			} // if (highlighState == 2) leave child nodes with whichever highlight state they are set
		}
				
        this.dynamicLoadComplete = true;
        this.isLoading = false;
        this.expand(true);
        this.tree.locked = false;
    },

    
    getAncestor: function(depth) {
        if (depth >= this.depth || depth < 0)  {
            return null;
        }

        var p = this.parent;
        
        while (p.depth > depth) {
            p = p.parent;
        }

        return p;
    },

    
    getDepthStyle: function(depth) {
        return (this.getAncestor(depth).nextSibling) ? 
            "ygtvdepthcell" : "ygtvblankdepthcell";
    },

    
    getNodeHtml: function() { 
        var sb = [];

        sb[sb.length] = '<table id="ygtvtableel' + this.index + '" border="0" cellpadding="0" cellspacing="0" class="ygtvtable ygtvdepth' + this.depth;
        if (this.enableHighlight) {
            sb[sb.length] = ' ygtv-highlight' + this.highlightState;
        }
        if (this.className) {
            sb[sb.length] = ' ' + this.className;
        }           
        sb[sb.length] = '"><tr class="ygtvrow">';
        
        for (var i=0;i<this.depth;++i) {
            sb[sb.length] = '<td class="ygtvcell ' + this.getDepthStyle(i) + '"><div class="ygtvspacer"></div></td>';
        }

        if (this.hasIcon) {
            sb[sb.length] = '<td id="' + this.getToggleElId();
            sb[sb.length] = '" class="ygtvcell ';
            sb[sb.length] = this.getStyle() ;
            sb[sb.length] = '"><a href="#" class="ygtvspacer">&#160;</a></td>';
        }

        sb[sb.length] = '<td id="' + this.contentElId; 
        sb[sb.length] = '" class="ygtvcell ';
        sb[sb.length] = this.contentStyle  + ' ygtvcontent" ';
        sb[sb.length] = (this.nowrap) ? ' nowrap="nowrap" ' : '';
        sb[sb.length] = ' >';
        sb[sb.length] = this.getContentHtml();
        sb[sb.length] = '</td></tr></table>';

        return sb.join("");

    },
    
    getContentHtml: function () {
        return "";
    },

    
    refresh: function() {
        // this.loadComplete();
        this.getChildrenEl().innerHTML = this.completeRender();

        if (this.hasIcon) {
            var el = this.getToggleEl();
            if (el) {
                el.className = el.className.replace(/\bygtv[lt][nmp]h*\b/gi,this.getStyle());
            }
        }
    },

    
    toString: function() {
        return this._type + " (" + this.index + ")";
    },
    
    _focusHighlightedItems: [],
    
    _focusedItem: null,
    
    
    _canHaveFocus: function() {
        return this.getEl().getElementsByTagName('a').length > 0;
    },
    
    _removeFocus:function () {
        if (this._focusedItem) {
            Event.removeListener(this._focusedItem,'blur');
            this._focusedItem = null;
        }
        var el;
        while ((el = this._focusHighlightedItems.shift())) {  // yes, it is meant as an assignment, really
            Dom.removeClass(el,YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
        }
    },
    
    focus: function () {
        var focused = false, self = this;

        if (this.tree.currentFocus) {
            this.tree.currentFocus._removeFocus();
        }
    
        var  expandParent = function (node) {
            if (node.parent) {
                expandParent(node.parent);
                node.parent.expand();
            } 
        };
        expandParent(this);
        //YS: check if self.getEl() is null to avoid JS error
        var firstChild = null;
        if(self.getEl()!=null){
        	firstChild = self.getEl().firstChild;
        }
        Dom.getElementsBy  ( 
            function (el) {
                return (/ygtv(([tl][pmn]h?)|(content))/).test(el.className);
            } ,
            'td' , 
            firstChild, 
            function (el) {
                Dom.addClass(el, YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
                if (!focused) { 
                    var aEl = el.getElementsByTagName('a');
                    if (aEl.length) {
                        aEl = aEl[0];
                        aEl.focus();
                        self._focusedItem = aEl;
                        Event.on(aEl,'blur',function () {
                            //console.log('f1');
                            self.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
                            self.tree.currentFocus = null;
                            self._removeFocus();
                        });
                        focused = true;
                    }
                }
                self._focusHighlightedItems.push(el);
            }
        );
        if (focused) { 
                            //console.log('f2');
            this.tree.fireEvent('focusChanged',{oldNode:this.tree.currentFocus,newNode:this});
            this.tree.currentFocus = this;
        } else {
                            //console.log('f3');
            this.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
            this.tree.currentFocus = null;
            this._removeFocus(); 
        }
        return focused;
    },

  
    getNodeCount: function() {
        for (var i = 0, count = 0;i< this.children.length;i++) {
            count += this.children[i].getNodeCount();
        }
        return count + 1;
    },
    
      
    getNodeDefinition: function() {
    
        if (this.isDynamic()) { return false; }
        
        var def, defs = Lang.merge(this.data), children = []; 
        
        

        if (this.expanded) {defs.expanded = this.expanded; }
        if (!this.multiExpand) { defs.multiExpand = this.multiExpand; }
        if (!this.renderHidden) { defs.renderHidden = this.renderHidden; }
        if (!this.hasIcon) { defs.hasIcon = this.hasIcon; }
        if (this.nowrap) { defs.nowrap = this.nowrap; }
        if (this.className) { defs.className = this.className; }
        if (this.editable) { defs.editable = this.editable; }
        if (this.enableHighlight) { defs.enableHighlight = this.enableHighlight; }
        if (this.highlightState) { defs.highlightState = this.highlightState; }
        if (this.propagateHighlightUp) { defs.propagateHighlightUp = this.propagateHighlightUp; }
        if (this.propagateHighlightDown) { defs.propagateHighlightDown = this.propagateHighlightDown; }
        defs.type = this._type;
        
        
        
        for (var i = 0; i < this.children.length;i++) {
            def = this.children[i].getNodeDefinition();
            if (def === false) { return false;}
            children.push(def);
        }
        if (children.length) { defs.children = children; }
        return defs;
    },


    
    getToggleLink: function() {
        return 'return false;';
    },
    
    
    setNodesProperty: function(name, value, refresh) {
        if (name.charAt(0) != '_'  && !Lang.isUndefined(this[name]) && !Lang.isFunction(this[name]) ) {
            this[name] = value;
        } else {
            this.data[name] = value;
        }
        for (var i = 0; i < this.children.length;i++) {
            this.children[i].setNodesProperty(name,value);
        }
        if (refresh) {
            this.refresh();
        }
    },
    
    toggleHighlight: function() {
        if (this.enableHighlight) {
            // unhighlights only if fully highligthed.  For not or partially highlighted it will highlight
            if (this.highlightState == 1) {
                this.unhighlight();
            } else {
                this.highlight();
            }
        }
    },
    
    
    highlight: function(_silent) {
        if (this.enableHighlight) {
            if (this.tree.singleNodeHighlight) {
                if (this.tree._currentlyHighlighted) {
                    this.tree._currentlyHighlighted.unhighlight(_silent);
                }
                this.tree._currentlyHighlighted = this;
            }
            this.highlightState = 1;
            this._setHighlightClassName();
            if (!this.tree.singleNodeHighlight) {
				if (this.propagateHighlightDown) {
					for (var i = 0;i < this.children.length;i++) {
						this.children[i].highlight(true);
					}
				}
				if (this.propagateHighlightUp) {
					if (this.parent) {
						this.parent._childrenHighlighted();
					}
				}
			}
            if (!_silent) {
                this.tree.fireEvent('highlightEvent',this);
            }
        }
    },
    
    unhighlight: function(_silent) {
        if (this.enableHighlight) {
			// might have checked singleNodeHighlight but it wouldn't really matter either way
            this.tree._currentlyHighlighted = null;
            this.highlightState = 0;
            this._setHighlightClassName();
            if (!this.tree.singleNodeHighlight) {
				if (this.propagateHighlightDown) {
					for (var i = 0;i < this.children.length;i++) {
						this.children[i].unhighlight(true);
					}
				}
				if (this.propagateHighlightUp) {
					if (this.parent) {
						this.parent._childrenHighlighted();
					}
				}
			}
            if (!_silent) {
                this.tree.fireEvent('highlightEvent',this);
            }
        }
    },
    
    _childrenHighlighted: function() {
        var yes = false, no = false;
        if (this.enableHighlight) {
            for (var i = 0;i < this.children.length;i++) {
                switch(this.children[i].highlightState) {
                    case 0:
                        no = true;
                        break;
                    case 1:
                        yes = true;
                        break;
                    case 2:
                        yes = no = true;
                        break;
                }
            }
            if (yes && no) {
                this.highlightState = 2;
            } else if (yes) {
                this.highlightState = 1;
            } else {
                this.highlightState = 0;
            }
            this._setHighlightClassName();
            if (this.propagateHighlightUp) {
                if (this.parent) {
                    this.parent._childrenHighlighted();
                }
            }
        }
    },
    
    
    _setHighlightClassName: function() {
        var el = Dom.get('ygtvtableel' + this.index);
        if (el) {
            el.className = el.className.replace(/\bygtv-highlight\d\b/gi,'ygtv-highlight' + this.highlightState);
        }
    }
    
};

YAHOO.augment(YAHOO.widget.Node, YAHOO.util.EventProvider);
})();


YAHOO.widget.RootNode = function(oTree) {
    // Initialize the node with null params.  The root node is a
    // special case where the node has no presentation.  So we have
    // to alter the standard properties a bit.
    this.init(null, null, true);
    
    
    this.tree = oTree;
};

YAHOO.extend(YAHOO.widget.RootNode, YAHOO.widget.Node, {
    
   
    _type: "RootNode",
    
    // overrides YAHOO.widget.Node
    getNodeHtml: function() { 
        return ""; 
    },

    toString: function() { 
        return this._type;
    },

    loadComplete: function() { 
        this.tree.draw();
    },
    
   
    getNodeCount: function() {
        for (var i = 0, count = 0;i< this.children.length;i++) {
            count += this.children[i].getNodeCount();
        }
        return count;
    },

  
    getNodeDefinition: function() {
        
        for (var def, defs = [], i = 0; i < this.children.length;i++) {
            def = this.children[i].getNodeDefinition();
            if (def === false) { return false;}
            defs.push(def);
        }
        return defs;
    },

    collapse: function() {},
    expand: function() {},
    getSiblings: function() { return null; },
    focus: function () {}

});

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;

YAHOO.widget.TextNode = function(oData, oParent, expanded) {

    if (oData) { 
        if (Lang.isString(oData)) {
            oData = { label: oData };
        }
        this.init(oData, oParent, expanded);
        this.setUpLabel(oData);
    }

};

YAHOO.extend(YAHOO.widget.TextNode, YAHOO.widget.Node, {
    
    
    labelStyle: "ygtvlabel",

    
    labelElId: null,

    
    label: null,

    
    title: null,
    
    
    href: null,

    
    target: "_self",
    
    
    _type: "TextNode",


    
    setUpLabel: function(oData) { 
        
        if (Lang.isString(oData)) {
            oData = { 
                label: oData 
            };
        } else {
            if (oData.style) {
                this.labelStyle = oData.style;
            }
        }

        this.label = oData.label;

        this.labelElId = "ygtvlabelel" + this.index;
        
    },

    
    getLabelEl: function() { 
        return Dom.get(this.labelElId);
    },

    // overrides YAHOO.widget.Node
    getContentHtml: function() { 
        var sb = [];
        sb[sb.length] = this.href?'<a':'<span';
        sb[sb.length] = ' id="' + this.labelElId + '"';
        sb[sb.length] = ' class="' + this.labelStyle  + '"';
        if (this.href) {
            sb[sb.length] = ' href="' + this.href + '"';
            sb[sb.length] = ' target="' + this.target + '"';
        } 
        if (this.title) {
            sb[sb.length] = ' title="' + this.title + '"';
        }
        sb[sb.length] = ' >';
        sb[sb.length] = this.label;
        sb[sb.length] = this.href?'</a>':'</span>';
        return sb.join("");
    },



  
    getNodeDefinition: function() {
        var def = YAHOO.widget.TextNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }

        // Node specific properties
        def.label = this.label;
        if (this.labelStyle != 'ygtvlabel') { def.style = this.labelStyle; }
        if (this.title) { def.title = this.title; }
        if (this.href) { def.href = this.href; }
        if (this.target != '_self') { def.target = this.target; }       

        return def;
    
    },

    toString: function() { 
        return YAHOO.widget.TextNode.superclass.toString.call(this) + ": " + this.label;
    },

    // deprecated
    onLabelClick: function() {
        return false;
    },
    refresh: function() {
        YAHOO.widget.TextNode.superclass.refresh.call(this);
        var label = this.getLabelEl();
        label.innerHTML = this.label;
        if (label.tagName.toUpperCase() == 'A') {
            label.href = this.href;
            label.target = this.target;
        }
    }
        
    

    
});
})();


YAHOO.widget.MenuNode = function(oData, oParent, expanded) {
    YAHOO.widget.MenuNode.superclass.constructor.call(this,oData,oParent,expanded);

   
    this.multiExpand = false;

};

YAHOO.extend(YAHOO.widget.MenuNode, YAHOO.widget.TextNode, {

    
    _type: "MenuNode"

});

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event;


YAHOO.widget.HTMLNode = function(oData, oParent, expanded, hasIcon) {
    if (oData) { 
        this.init(oData, oParent, expanded);
        this.initContent(oData, hasIcon);
    }
};

YAHOO.extend(YAHOO.widget.HTMLNode, YAHOO.widget.Node, {

    
    contentStyle: "ygtvhtml",


    
    html: null,
    

    _type: "HTMLNode",

    
    initContent: function(oData, hasIcon) { 
        this.setHtml(oData);
        this.contentElId = "ygtvcontentel" + this.index;
        if (!Lang.isUndefined(hasIcon)) { this.hasIcon  = hasIcon; }
        
    },

    
    setHtml: function(o) {

        this.html = (typeof o === "string") ? o : o.html;

        var el = this.getContentEl();
        if (el) {
            el.innerHTML = this.html;
        }

    },

    // overrides YAHOO.widget.Node
    getContentHtml: function() { 
        return this.html;
    },
    
      
    getNodeDefinition: function() {
        var def = YAHOO.widget.HTMLNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }
        def.html = this.html;
        return def;
    
    }
});
})();

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang,
        Event = YAHOO.util.Event,
        Calendar = YAHOO.widget.Calendar;
        

YAHOO.widget.DateNode = function(oData, oParent, expanded) {
    YAHOO.widget.DateNode.superclass.constructor.call(this,oData, oParent, expanded);
};

YAHOO.extend(YAHOO.widget.DateNode, YAHOO.widget.TextNode, {

    
    _type: "DateNode",
    
    
    calendarConfig: null,
    
    
    
    
    fillEditorContainer: function (editorData) {
    
        var cal, container = editorData.inputContainer;
        
        if (Lang.isUndefined(Calendar)) {
            Dom.replaceClass(editorData.editorPanel,'ygtv-edit-DateNode','ygtv-edit-TextNode');
            YAHOO.widget.DateNode.superclass.fillEditorContainer.call(this, editorData);
            return;
        }
            
        if (editorData.nodeType != this._type) {
            editorData.nodeType = this._type;
            editorData.saveOnEnter = false;
            
            editorData.node.destroyEditorContents(editorData);

            editorData.inputObject = cal = new Calendar(container.appendChild(document.createElement('div')));
            if (this.calendarConfig) { 
                cal.cfg.applyConfig(this.calendarConfig,true); 
                cal.cfg.fireQueue();
            }
            cal.selectEvent.subscribe(function () {
                this.tree._closeEditor(true);
            },this,true);
        } else {
            cal = editorData.inputObject;
        }

		editorData.oldValue = this.label;
        cal.cfg.setProperty("selected",this.label, false); 

        var delim = cal.cfg.getProperty('DATE_FIELD_DELIMITER');
        var pageDate = this.label.split(delim);
        cal.cfg.setProperty('pagedate',pageDate[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] + delim + pageDate[cal.cfg.getProperty('MDY_YEAR_POSITION') -1]);
        cal.cfg.fireQueue();

        cal.render();
        cal.oDomContainer.focus();
    },
     

	getEditorValue: function (editorData) {
        if (Lang.isUndefined(Calendar)) {
            return editorData.inputElement.value;
        } else {
            var cal = editorData.inputObject,
                date = cal.getSelectedDates()[0],
                dd = [];
                
            dd[cal.cfg.getProperty('MDY_DAY_POSITION') -1] = date.getDate();
            dd[cal.cfg.getProperty('MDY_MONTH_POSITION') -1] = date.getMonth() + 1;
            dd[cal.cfg.getProperty('MDY_YEAR_POSITION') -1] = date.getFullYear();
            return dd.join(cal.cfg.getProperty('DATE_FIELD_DELIMITER'));
        }
	},

	
	displayEditedValue: function (value,editorData) {
		var node = editorData.node;
		node.label = value;
		node.getLabelEl().innerHTML = value;
	},
   
    getNodeDefinition: function() {
        var def = YAHOO.widget.DateNode.superclass.getNodeDefinition.call(this);
        if (def === false) { return false; }
        if (this.calendarConfig) { def.calendarConfig = this.calendarConfig; }
        return def;
    }


});
})();

(function () {
    var Dom = YAHOO.util.Dom,
        Lang = YAHOO.lang, 
        Event = YAHOO.util.Event,
        TV = YAHOO.widget.TreeView,
        TVproto = TV.prototype;

    
    TV.editorData = {
        active:false,
        whoHasIt:null, // which TreeView has it
        nodeType:null,
        editorPanel:null,
        inputContainer:null,
        buttonsContainer:null,
        node:null, // which Node is being edited
        saveOnEnter:true,
		oldValue:undefined
        // Each node type is free to add its own properties to this as it sees fit.
    };
    
    
    TVproto.validator = null;
    
    

	TVproto._initEditor = function () {
		 
	 	this.createEvent("editorSaveEvent", this); 
		
		 
	 	this.createEvent("editorCancelEvent", this); 

	};

    
	
    
    
    TVproto._nodeEditing = function (node) {
        if (node.fillEditorContainer && node.editable) {
            var ed, topLeft, buttons, button, editorData = TV.editorData;
            editorData.active = true;
            editorData.whoHasIt = this;
            if (!editorData.nodeType) {
                editorData.editorPanel = ed = document.body.appendChild(document.createElement('div'));
                Dom.addClass(ed,'ygtv-label-editor');

                buttons = editorData.buttonsContainer = ed.appendChild(document.createElement('div'));
                Dom.addClass(buttons,'ygtv-button-container');
                button = buttons.appendChild(document.createElement('button'));
                Dom.addClass(button,'ygtvok');
                button.innerHTML = ' ';
                button = buttons.appendChild(document.createElement('button'));
                Dom.addClass(button,'ygtvcancel');
                button.innerHTML = ' ';
                Event.on(buttons, 'click', function (ev) {
                    var target = Event.getTarget(ev);
                    var node = TV.editorData.node;
                    if (Dom.hasClass(target,'ygtvok')) {
                        Event.stopEvent(ev);
                        this._closeEditor(true);
                    }
                    if (Dom.hasClass(target,'ygtvcancel')) {
                        Event.stopEvent(ev);
                        this._closeEditor(false);
                    }
                }, this, true);

                editorData.inputContainer = ed.appendChild(document.createElement('div'));
                Dom.addClass(editorData.inputContainer,'ygtv-input');
                
                Event.on(ed,'keydown',function (ev) {
                    var editorData = TV.editorData,
                        KEY = YAHOO.util.KeyListener.KEY;
                    switch (ev.keyCode) {
                        case KEY.ENTER:
                            Event.stopEvent(ev);
                            if (editorData.saveOnEnter) { 
                                this._closeEditor(true);
                            }
                            break;
                        case KEY.ESCAPE:
                            Event.stopEvent(ev);
                            this._closeEditor(false);
                            break;
                    }
                },this,true);


                
            } else {
                ed = editorData.editorPanel;
            }
            editorData.node = node;
            if (editorData.nodeType) {
                Dom.removeClass(ed,'ygtv-edit-' + editorData.nodeType);
            }
            Dom.addClass(ed,' ygtv-edit-' + node._type);
            topLeft = Dom.getXY(node.getContentEl());
            Dom.setStyle(ed,'left',topLeft[0] + 'px');
            Dom.setStyle(ed,'top',topLeft[1] + 'px');
            Dom.setStyle(ed,'display','block');
            ed.focus();
            node.fillEditorContainer(editorData);

            return true;  // If inline editor available, don't do anything else.
        }
    };
    
    

    TVproto.onEventEditNode = function (oArgs) {
        if (oArgs instanceof YAHOO.widget.Node) {
            oArgs.editNode();
        } else if (oArgs.node instanceof YAHOO.widget.Node) {
            oArgs.node.editNode();
        }
    };
    
    
    
    TVproto._closeEditor = function (save) {
        var ed = TV.editorData, 
            node = ed.node,
            close = true;
        if (save) { 
            close = ed.node.saveEditorValue(ed) !== false; 
        } else {
			this.fireEvent( 'editorCancelEvent', node); 
		}
			
        if (close) {
            Dom.setStyle(ed.editorPanel,'display','none');  
            ed.active = false;
            node.focus();
        }
    };
    
    
    TVproto._destroyEditor = function() {
        var ed = TV.editorData;
        if (ed && ed.nodeType && (!ed.active || ed.whoHasIt === this)) {
            Event.removeListener(ed.editorPanel,'keydown');
            Event.removeListener(ed.buttonContainer,'click');
            ed.node.destroyEditorContents(ed);
            document.body.removeChild(ed.editorPanel);
            ed.nodeType = ed.editorPanel = ed.inputContainer = ed.buttonsContainer = ed.whoHasIt = ed.node = null;
            ed.active = false;
        }
    };
    
    var Nproto = YAHOO.widget.Node.prototype;
    
    
    Nproto.editable = false;
    
    
    
    Nproto.editNode = function () {
        this.tree._nodeEditing(this);
    };
    
    


    
    Nproto.fillEditorContainer = null;

    
    
    Nproto.destroyEditorContents = function (editorData) {
        // In the worst case, if the input editor (such as the Calendar) has no destroy method
        // we can only try to remove all possible events on it.
        Event.purgeElement(editorData.inputContainer,true);
        editorData.inputContainer.innerHTML = '';
    };

    
    Nproto.saveEditorValue = function (editorData) {
        var node = editorData.node, 
			value,
            validator = node.tree.validator;
			
		value = this.getEditorValue(editorData);
        
        if (Lang.isFunction(validator)) {
            value = validator(value,editorData.oldValue,node);
            if (Lang.isUndefined(value)) { 
				return false; 
			}
        }

		if (this.tree.fireEvent( 'editorSaveEvent', {
			newValue:value,
			oldValue:editorData.oldValue,
			node:node
		}) !== false) {
			this.displayEditedValue(value,editorData);
		}
	};
	
	
    

	 Nproto.getEditorValue = function (editorData) {
	};

	
	Nproto.displayEditedValue = function (value,editorData) {
	};
    
    var TNproto = YAHOO.widget.TextNode.prototype;
    


    
    TNproto.fillEditorContainer = function (editorData) {
    
        var input;
        // If last node edited is not of the same type as this one, delete it and fill it with our editor
        if (editorData.nodeType != this._type) {
            editorData.nodeType = this._type;
            editorData.saveOnEnter = true;
            editorData.node.destroyEditorContents(editorData);

            editorData.inputElement = input = editorData.inputContainer.appendChild(document.createElement('input'));
            
        } else {
            // if the last node edited was of the same time, reuse the input element.
            input = editorData.inputElement;
        }
		editorData.oldValue = this.label;
        input.value = this.label;
        input.focus();
        input.select();
    };
    
    

    TNproto.getEditorValue = function (editorData) {
        return editorData.inputElement.value;
	};

	
	TNproto.displayEditedValue = function (value,editorData) {
		var node = editorData.node;
		node.label = value;
		node.getLabelEl().innerHTML = value;
	};

    
    TNproto.destroyEditorContents = function (editorData) {
        editorData.inputContainer.innerHTML = '';
    };
})();


YAHOO.widget.TVAnim = function() {
    return {
        
        FADE_IN: "TVFadeIn",

        
        FADE_OUT: "TVFadeOut",

        
        getAnim: function(type, el, callback) {
            if (YAHOO.widget[type]) {
                return new YAHOO.widget[type](el, callback);
            } else {
                return null;
            }
        },

        
        isValid: function(type) {
            return (YAHOO.widget[type]);
        }
    };
} ();


YAHOO.widget.TVFadeIn = function(el, callback) {
    
    this.el = el;

    
    this.callback = callback;

};

YAHOO.widget.TVFadeIn.prototype = {
    
    animate: function() {
        var tvanim = this;

        var s = this.el.style;
        s.opacity = 0.1;
        s.filter = "alpha(opacity=10)";
        s.display = "";

        var dur = 0.4; 
        var a = new YAHOO.util.Anim(this.el, {opacity: {from: 0.1, to: 1, unit:""}}, dur);
        a.onComplete.subscribe( function() { tvanim.onComplete(); } );
        a.animate();
    },

    
    onComplete: function() {
        this.callback();
    },

    
    toString: function() {
        return "TVFadeIn";
    }
};


YAHOO.widget.TVFadeOut = function(el, callback) {
    
    this.el = el;

    
    this.callback = callback;

};

YAHOO.widget.TVFadeOut.prototype = {
    
    animate: function() {
        var tvanim = this;
        var dur = 0.4;
        var a = new YAHOO.util.Anim(this.el, {opacity: {from: 1, to: 0.1, unit:""}}, dur);
        a.onComplete.subscribe( function() { tvanim.onComplete(); } );
        a.animate();
    },

    
    onComplete: function() {
        var s = this.el.style;
        s.display = "none";
        s.opacity = 1;
        s.filter = "alpha(opacity=100)";
        this.callback();
    },

    
    toString: function() {
        return "TVFadeOut";
    }
};

YAHOO.register("treeview", YAHOO.widget.TreeView, {version: "2.8.1", build: "19"});







YAHOO.widget.LogMsg = function(oConfigs) {
    // Parse configs
    
    this.msg =
    
    this.time =

    
    this.category =

    
    this.source =

    
    this.sourceDetail = null;

    if (oConfigs && (oConfigs.constructor == Object)) {
        for(var param in oConfigs) {
            if (oConfigs.hasOwnProperty(param)) {
                this[param] = oConfigs[param];
            }
        }
    }
};





YAHOO.widget.LogWriter = function(sSource) {
    if(!sSource) {
        YAHOO.log("Could not instantiate LogWriter due to invalid source.",
            "error", "LogWriter");
        return;
    }
    this._source = sSource;
 };

/////////////////////////////////////////////////////////////////////////////
//
// Public methods
//
/////////////////////////////////////////////////////////////////////////////

 
YAHOO.widget.LogWriter.prototype.toString = function() {
    return "LogWriter " + this._sSource;
};


YAHOO.widget.LogWriter.prototype.log = function(sMsg, sCategory) {
    YAHOO.widget.Logger.log(sMsg, sCategory, this._source);
};


YAHOO.widget.LogWriter.prototype.getSource = function() {
    return this._source;
};


YAHOO.widget.LogWriter.prototype.setSource = function(sSource) {
    if(!sSource) {
        YAHOO.log("Could not set source due to invalid source.", "error", this.toString());
        return;
    }
    else {
        this._source = sSource;
    }
};

/////////////////////////////////////////////////////////////////////////////
//
// Private member variables
//
/////////////////////////////////////////////////////////////////////////////


YAHOO.widget.LogWriter.prototype._source = null;



 





// Define once
if(!YAHOO.widget.Logger) {
    
    YAHOO.widget.Logger = {
        // Initialize properties
        loggerEnabled: true,
        _browserConsoleEnabled: false,
        categories: ["info","warn","error","time","window"],
        sources: ["global"],
        _stack: [], // holds all log msgs
        maxStackEntries: 2500,
        _startTime: new Date().getTime(), // static start timestamp
        _lastTime: null, // timestamp of last logged message
        _windowErrorsHandled: false,
        _origOnWindowError: null
    };

    /////////////////////////////////////////////////////////////////////////////
    //
    // Public properties
    //
    /////////////////////////////////////////////////////////////////////////////
    

    

    

    

    /////////////////////////////////////////////////////////////////////////////
    //
    // Private properties
    //
    /////////////////////////////////////////////////////////////////////////////
    

    
    
    
    /////////////////////////////////////////////////////////////////////////////
    //
    // Public methods
    //
    /////////////////////////////////////////////////////////////////////////////
    
    YAHOO.widget.Logger.log = function(sMsg, sCategory, sSource) {
        if(this.loggerEnabled) {
            if(!sCategory) {
                sCategory = "info"; // default category
            }
            else {
                sCategory = sCategory.toLocaleLowerCase();
                if(this._isNewCategory(sCategory)) {
                    this._createNewCategory(sCategory);
                }
            }
            var sClass = "global"; // default source
            var sDetail = null;
            if(sSource) {
                var spaceIndex = sSource.indexOf(" ");
                if(spaceIndex > 0) {
                    // Substring until first space
                    sClass = sSource.substring(0,spaceIndex);
                    // The rest of the source
                    sDetail = sSource.substring(spaceIndex,sSource.length);
                }
                else {
                    sClass = sSource;
                }
                if(this._isNewSource(sClass)) {
                    this._createNewSource(sClass);
                }
            }

            var timestamp = new Date();
            var logEntry = new YAHOO.widget.LogMsg({
                msg: sMsg,
                time: timestamp,
                category: sCategory,
                source: sClass,
                sourceDetail: sDetail
            });

            var stack = this._stack;
            var maxStackEntries = this.maxStackEntries;
            if(maxStackEntries && !isNaN(maxStackEntries) &&
                (stack.length >= maxStackEntries)) {
                stack.shift();
            }
            stack.push(logEntry);
            this.newLogEvent.fire(logEntry);

            if(this._browserConsoleEnabled) {
                this._printToBrowserConsole(logEntry);
            }
            return true;
        }
        else {
            return false;
        }
    };

    
    YAHOO.widget.Logger.reset = function() {
        this._stack = [];
        this._startTime = new Date().getTime();
        this.loggerEnabled = true;
        this.log("Logger reset");
        this.logResetEvent.fire();
    };

    
    YAHOO.widget.Logger.getStack = function() {
        return this._stack;
    };

    
    YAHOO.widget.Logger.getStartTime = function() {
        return this._startTime;
    };

    
    YAHOO.widget.Logger.disableBrowserConsole = function() {
        YAHOO.log("Logger output to the function console.log() has been disabled.");
        this._browserConsoleEnabled = false;
    };

    
    YAHOO.widget.Logger.enableBrowserConsole = function() {
        this._browserConsoleEnabled = true;
        YAHOO.log("Logger output to the function console.log() has been enabled.");
    };

    
    YAHOO.widget.Logger.handleWindowErrors = function() {
        if(!YAHOO.widget.Logger._windowErrorsHandled) {
            // Save any previously defined handler to call
            if(window.error) {
                YAHOO.widget.Logger._origOnWindowError = window.onerror;
            }
            window.onerror = YAHOO.widget.Logger._onWindowError;
            YAHOO.widget.Logger._windowErrorsHandled = true;
            YAHOO.log("Logger handling of window.onerror has been enabled.");
        }
        else {
            YAHOO.log("Logger handling of window.onerror had already been enabled.");
        }
    };

    
    YAHOO.widget.Logger.unhandleWindowErrors = function() {
        if(YAHOO.widget.Logger._windowErrorsHandled) {
            // Revert to any previously defined handler to call
            if(YAHOO.widget.Logger._origOnWindowError) {
                window.onerror = YAHOO.widget.Logger._origOnWindowError;
                YAHOO.widget.Logger._origOnWindowError = null;
            }
            else {
                window.onerror = null;
            }
            YAHOO.widget.Logger._windowErrorsHandled = false;
            YAHOO.log("Logger handling of window.onerror has been disabled.");
        }
        else {
            YAHOO.log("Logger handling of window.onerror had already been disabled.");
        }
    };
    
    /////////////////////////////////////////////////////////////////////////////
    //
    // Public events
    //
    /////////////////////////////////////////////////////////////////////////////

     
    YAHOO.widget.Logger.categoryCreateEvent =
        new YAHOO.util.CustomEvent("categoryCreate", this, true);

     
    YAHOO.widget.Logger.sourceCreateEvent =
        new YAHOO.util.CustomEvent("sourceCreate", this, true);

     
    YAHOO.widget.Logger.newLogEvent = new YAHOO.util.CustomEvent("newLog", this, true);

    
    YAHOO.widget.Logger.logResetEvent = new YAHOO.util.CustomEvent("logReset", this, true);

    /////////////////////////////////////////////////////////////////////////////
    //
    // Private methods
    //
    /////////////////////////////////////////////////////////////////////////////

    
    YAHOO.widget.Logger._createNewCategory = function(sCategory) {
        this.categories.push(sCategory);
        this.categoryCreateEvent.fire(sCategory);
    };

    
    YAHOO.widget.Logger._isNewCategory = function(sCategory) {
        for(var i=0; i < this.categories.length; i++) {
            if(sCategory == this.categories[i]) {
                return false;
            }
        }
        return true;
    };

    
    YAHOO.widget.Logger._createNewSource = function(sSource) {
        this.sources.push(sSource);
        this.sourceCreateEvent.fire(sSource);
    };

    
    YAHOO.widget.Logger._isNewSource = function(sSource) {
        if(sSource) {
            for(var i=0; i < this.sources.length; i++) {
                if(sSource == this.sources[i]) {
                    return false;
                }
            }
            return true;
        }
    };

    
    YAHOO.widget.Logger._printToBrowserConsole = function(oEntry) {
        if(window.console && console.log) {
            var category = oEntry.category;
            var label = oEntry.category.substring(0,4).toUpperCase();

            var time = oEntry.time;
            var localTime;
            if (time.toLocaleTimeString) {
                localTime  = time.toLocaleTimeString();
            }
            else {
                localTime = time.toString();
            }

            var msecs = time.getTime();
            var elapsedTime = (YAHOO.widget.Logger._lastTime) ?
                (msecs - YAHOO.widget.Logger._lastTime) : 0;
            YAHOO.widget.Logger._lastTime = msecs;

            var output =
                localTime + " (" +
                elapsedTime + "ms): " +
                oEntry.source + ": ";

            // for bug 1987607
            if (YAHOO.env.ua.webkit) {
                output += oEntry.msg;
            }

            console.log(output, oEntry.msg);
        }
    };

    /////////////////////////////////////////////////////////////////////////////
    //
    // Private event handlers
    //
    /////////////////////////////////////////////////////////////////////////////

    
    YAHOO.widget.Logger._onWindowError = function(sMsg,sUrl,sLine) {
        // Logger is not in scope of this event handler
        try {
            YAHOO.widget.Logger.log(sMsg+' ('+sUrl+', line '+sLine+')', "window");
            if(YAHOO.widget.Logger._origOnWindowError) {
                YAHOO.widget.Logger._origOnWindowError();
            }
        }
        catch(e) {
            return false;
        }
    };

    /////////////////////////////////////////////////////////////////////////////
    //
    // First log
    //
    /////////////////////////////////////////////////////////////////////////////

    YAHOO.widget.Logger.log("Logger initialized");
}




(function () {
var Logger = YAHOO.widget.Logger,
    u      = YAHOO.util,
    Dom    = u.Dom,
    Event  = u.Event,
    d      = document;

function make(el,props) {
    el = d.createElement(el);
    if (props) {
        for (var p in props) {
            if (props.hasOwnProperty(p)) {
                el[p] = props[p];
            }
        }
    }
    return el;
}


function LogReader(elContainer, oConfigs) {
    this._sName = LogReader._index;
    LogReader._index++;
    
    this._init.apply(this,arguments);

    
    if (this.autoRender !== false) {
        this.render();
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Static member variables
//
/////////////////////////////////////////////////////////////////////////////
YAHOO.lang.augmentObject(LogReader, {
    
    _index : 0,

    
    ENTRY_TEMPLATE : (function () {
        return make('pre',{ className: 'yui-log-entry' });
    })(),

    
    VERBOSE_TEMPLATE : "<p><span class='{category}'>{label}</span> {totalTime}ms (+{elapsedTime}) {localTime}:</p><p>{sourceAndDetail}</p><p>{message}</p>",

    
    BASIC_TEMPLATE : "<p><span class='{category}'>{label}</span> {totalTime}ms (+{elapsedTime}) {localTime}: {sourceAndDetail}: {message}</p>"
});

/////////////////////////////////////////////////////////////////////////////
//
// Public member variables
//
/////////////////////////////////////////////////////////////////////////////

LogReader.prototype = {
    
    logReaderEnabled : true,

    
    width : null,

    
    height : null,

    
    top : null,

    
    left : null,

    
    right : null,

    
    bottom : null,

    
    fontSize : null,

    
    footerEnabled : true,

    
    verboseOutput : true,

    
    entryFormat : null,

    
    newestOnTop : true,

    
    outputBuffer : 100,

    
    thresholdMax : 500,

    
    thresholdMin : 100,

    
    isCollapsed : false,

    
    isPaused : false,

    
    draggable : true,

    /////////////////////////////////////////////////////////////////////////////
    //
    // Public methods
    //
    /////////////////////////////////////////////////////////////////////////////

     
    toString : function() {
        return "LogReader instance" + this._sName;
    },
    
    pause : function() {
        this.isPaused = true;
        this._timeout = null;
        this.logReaderEnabled = false;
        if (this._btnPause) {
            this._btnPause.value = "Resume";
        }
    },

    
    resume : function() {
        this.isPaused = false;
        this.logReaderEnabled = true;
        this._printBuffer();
        if (this._btnPause) {
            this._btnPause.value = "Pause";
        }
    },

    
    render : function () {
        if (this.rendered) {
            return;
        }

        this._initContainerEl();
        
        this._initHeaderEl();
        this._initConsoleEl();
        this._initFooterEl();

        this._initCategories();
        this._initSources();

        this._initDragDrop();

        // Subscribe to Logger custom events
        Logger.newLogEvent.subscribe(this._onNewLog, this);
        Logger.logResetEvent.subscribe(this._onReset, this);

        Logger.categoryCreateEvent.subscribe(this._onCategoryCreate, this);
        Logger.sourceCreateEvent.subscribe(this._onSourceCreate, this);

        this.rendered = true;

        this._filterLogs();
    },

    
    destroy : function () {
        Event.purgeElement(this._elContainer,true);
        this._elContainer.innerHTML = '';
        this._elContainer.parentNode.removeChild(this._elContainer);

        this.rendered = false;
    },

    
    hide : function() {
        this._elContainer.style.display = "none";
    },

    
    show : function() {
        this._elContainer.style.display = "block";
    },

    
    collapse : function() {
        this._elConsole.style.display = "none";
        if(this._elFt) {
            this._elFt.style.display = "none";
        }
        this._btnCollapse.value = "Expand";
        this.isCollapsed = true;
    },

    
    expand : function() {
        this._elConsole.style.display = "block";
        if(this._elFt) {
            this._elFt.style.display = "block";
        }
        this._btnCollapse.value = "Collapse";
        this.isCollapsed = false;
    },

    
    getCheckbox : function(filter) {
        return this._filterCheckboxes[filter];
    },

    
    getCategories : function() {
        return this._categoryFilters;
    },

    
    showCategory : function(sCategory) {
        var filtersArray = this._categoryFilters;
        // Don't do anything if category is already enabled
        // Use Array.indexOf if available...
        if(filtersArray.indexOf) {
             if(filtersArray.indexOf(sCategory) >  -1) {
                return;
            }
        }
        // ...or do it the old-fashioned way
        else {
            for(var i=0; i<filtersArray.length; i++) {
               if(filtersArray[i] === sCategory){
                    return;
                }
            }
        }

        this._categoryFilters.push(sCategory);
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sCategory);
        if(elCheckbox) {
            elCheckbox.checked = true;
        }
    },

    
    hideCategory : function(sCategory) {
        var filtersArray = this._categoryFilters;
        for(var i=0; i<filtersArray.length; i++) {
            if(sCategory == filtersArray[i]) {
                filtersArray.splice(i, 1);
                break;
            }
        }
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sCategory);
        if(elCheckbox) {
            elCheckbox.checked = false;
        }
    },

    
    getSources : function() {
        return this._sourceFilters;
    },

    
    showSource : function(sSource) {
        var filtersArray = this._sourceFilters;
        // Don't do anything if category is already enabled
        // Use Array.indexOf if available...
        if(filtersArray.indexOf) {
             if(filtersArray.indexOf(sSource) >  -1) {
                return;
            }
        }
        // ...or do it the old-fashioned way
        else {
            for(var i=0; i<filtersArray.length; i++) {
               if(sSource == filtersArray[i]){
                    return;
                }
            }
        }
        filtersArray.push(sSource);
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sSource);
        if(elCheckbox) {
            elCheckbox.checked = true;
        }
    },

    
    hideSource : function(sSource) {
        var filtersArray = this._sourceFilters;
        for(var i=0; i<filtersArray.length; i++) {
            if(sSource == filtersArray[i]) {
                filtersArray.splice(i, 1);
                break;
            }
        }
        this._filterLogs();
        var elCheckbox = this.getCheckbox(sSource);
        if(elCheckbox) {
            elCheckbox.checked = false;
        }
    },

    
    clearConsole : function() {
        // Clear the buffer of any pending messages
        this._timeout = null;
        this._buffer = [];
        this._consoleMsgCount = 0;

        var elConsole = this._elConsole;
        elConsole.innerHTML = '';
    },

    
    setTitle : function(sTitle) {
        this._title.innerHTML = this.html2Text(sTitle);
    },

    
    getLastTime : function() {
        return this._lastTime;
    },

    formatMsg : function (entry) {
        var entryFormat = this.entryFormat || (this.verboseOutput ?
                          LogReader.VERBOSE_TEMPLATE : LogReader.BASIC_TEMPLATE),
            info        = {
                category : entry.category,

                // Label for color-coded display
                label : entry.category.substring(0,4).toUpperCase(),

                sourceAndDetail : entry.sourceDetail ?
                                  entry.source + " " + entry.sourceDetail :
                                  entry.source,

                // Escape HTML entities in the log message itself for output
                // to console
                message : this.html2Text(entry.msg || entry.message || '')
            };

        // Add time info
        if (entry.time && entry.time.getTime) {
            info.localTime = entry.time.toLocaleTimeString ?
                             entry.time.toLocaleTimeString() :
                             entry.time.toString();

            // Calculate the elapsed time to be from the last item that
            // passed through the filter, not the absolute previous item
            // in the stack
            info.elapsedTime = entry.time.getTime() - this.getLastTime();

            info.totalTime = entry.time.getTime() - Logger.getStartTime();
        }

        var msg = LogReader.ENTRY_TEMPLATE.cloneNode(true);
        if (this.verboseOutput) {
            msg.className += ' yui-log-verbose';
        }

        // Bug 2061169: Workaround for YAHOO.lang.substitute()
        msg.innerHTML = entryFormat.replace(/\{(\w+)\}/g,
            function (x, placeholder) {
                return (placeholder in info) ? info[placeholder] : '';
            });

        return msg;
    },

    
    html2Text : function(sHtml) {
        if(sHtml) {
            sHtml += "";
            return sHtml.replace(/&/g, "&#38;").
                         replace(/</g, "&#60;").
                         replace(/>/g, "&#62;");
        }
        return "";
    },

/////////////////////////////////////////////////////////////////////////////
//
// Private member variables
//
/////////////////////////////////////////////////////////////////////////////

    
    _sName : null,

    //TODO: remove
    
    //YAHOO.widget.LogReader._elDefaultContainer = null;

    
    _buffer : null,

    
    _consoleMsgCount : 0,

    
    _lastTime : null,

    
    _timeout : null,

    
    _filterCheckboxes : null,

    
    _categoryFilters : null,

    
    _sourceFilters : null,

    
    _elContainer : null,

    
    _elHd : null,

    
    _elCollapse : null,

    
    _btnCollapse : null,

    
    _title : null,

    
    _elConsole : null,

    
    _elFt : null,

    
    _elBtns : null,

    
    _elCategoryFilters : null,

    
    _elSourceFilters : null,

    
    _btnPause : null,

    
    _btnClear : null,

    /////////////////////////////////////////////////////////////////////////////
    //
    // Private methods
    //
    /////////////////////////////////////////////////////////////////////////////

    
    _init : function (container, config) {
        // Internal vars
        this._buffer = []; // output buffer
        this._filterCheckboxes = {}; // pointers to checkboxes
        this._lastTime = Logger.getStartTime(); // timestamp of last log message to console

        // Parse config vars here
        if (config && (config.constructor == Object)) {
            for(var param in config) {
                if (config.hasOwnProperty(param)) {
                    this[param] = config[param];
                }
            }
        }

        this._elContainer = Dom.get(container);

        YAHOO.log("LogReader initialized", null, this.toString());
    },

    
    _initContainerEl : function() {

        // Default the container if unset or not a div
        if(!this._elContainer || !/div$/i.test(this._elContainer.tagName)) {
            this._elContainer = d.body.insertBefore(make("div"),d.body.firstChild);
            // Only position absolutely if an in-DOM element is not supplied
            Dom.addClass(this._elContainer,"yui-log-container");
        }

        Dom.addClass(this._elContainer,"yui-log");

        // If implementer has provided container values, trust and set those
        var style = this._elContainer.style,
            styleProps = ['width','right','top','fontSize'],
            prop,i;

        for (i = styleProps.length - 1; i >= 0; --i) {
            prop = styleProps[i];
            if (this[prop]){ 
                style[prop] = this[prop];
            }
        }

        if(this.left) {
            style.left  = this.left;
            style.right = "auto";
        }
        if(this.bottom) {
            style.bottom = this.bottom;
            style.top    = "auto";
        }

        // Opera needs a little prodding to reflow sometimes
        if (YAHOO.env.ua.opera) {
            d.body.style += '';
        }

    },

    
    _initHeaderEl : function() {
        // Destroy header if present
        if(this._elHd) {
            // Unhook DOM events
            Event.purgeElement(this._elHd, true);

            // Remove DOM elements
            this._elHd.innerHTML = "";
        }
        
        // Create header
        // TODO: refactor this into an innerHTML
        this._elHd = make("div",{
            id: 'yui-log-hd' + this._sName,
            className: "yui-log-hd"
        });

        this._elCollapse = make("div",{ className: 'yui-log-btns' });

        this._btnCollapse = make("input",{
            type: 'button',
            className: 'yui-log-button',
            value: 'Collapse'
        });
        Event.on(this._btnCollapse,'click',this._onClickCollapseBtn,this);


        this._title = make("h4",{ innerHTML : "Logger Console" });

        this._elCollapse.appendChild(this._btnCollapse);
        this._elHd.appendChild(this._elCollapse);
        this._elHd.appendChild(this._title);
        this._elContainer.appendChild(this._elHd);
    },

    
    _initConsoleEl : function() {
        // Destroy console
        if(this._elConsole) {
            // Unhook DOM events
            Event.purgeElement(this._elConsole, true);

            // Remove DOM elements
            this._elConsole.innerHTML = "";
        }

        // Ceate console
        this._elConsole = make("div", { className: "yui-log-bd" });

        // If implementer has provided console, trust and set those
        if(this.height) {
            this._elConsole.style.height = this.height;
        }

        this._elContainer.appendChild(this._elConsole);
    },

    
    _initFooterEl : function() {
        // Don't create footer elements if footer is disabled
        if(this.footerEnabled) {
            // Destroy console
            if(this._elFt) {
                // Unhook DOM events
                Event.purgeElement(this._elFt, true);

                // Remove DOM elements
                this._elFt.innerHTML = "";
            }

            // TODO: use innerHTML
            this._elFt = make("div",{ className: "yui-log-ft" });
            this._elBtns = make("div", { className: "yui-log-btns" });
            this._btnPause = make("input", {
                type: "button",
                className: "yui-log-button",
                value: "Pause"
            });

            Event.on(this._btnPause,'click',this._onClickPauseBtn,this);

            this._btnClear = make("input", {
                type: "button",
                className: "yui-log-button",
                value: "Clear"
            });

            Event.on(this._btnClear,'click',this._onClickClearBtn,this);

            this._elCategoryFilters = make("div", { className: "yui-log-categoryfilters" });
            this._elSourceFilters = make("div", { className: "yui-log-sourcefilters" });

            this._elBtns.appendChild(this._btnPause);
            this._elBtns.appendChild(this._btnClear);
            this._elFt.appendChild(this._elBtns);
            this._elFt.appendChild(this._elCategoryFilters);
            this._elFt.appendChild(this._elSourceFilters);
            this._elContainer.appendChild(this._elFt);
        }
    },

    
    _initDragDrop : function() {
        // If Drag and Drop utility is available...
        // ...and draggable is true...
        // ...then make the header draggable
        if(u.DD && this.draggable && this._elHd) {
            var ylog_dd = new u.DD(this._elContainer);
            ylog_dd.setHandleElId(this._elHd.id);
            //TODO: use class name
            this._elHd.style.cursor = "move";
        }
    },

    
    _initCategories : function() {
        // Initialize category filters
        this._categoryFilters = [];
        var aInitialCategories = Logger.categories;

        for(var j=0; j < aInitialCategories.length; j++) {
            var sCategory = aInitialCategories[j];

            // Add category to the internal array of filters
            this._categoryFilters.push(sCategory);

            // Add checkbox element if UI is enabled
            if(this._elCategoryFilters) {
                this._createCategoryCheckbox(sCategory);
            }
        }
    },

    
    _initSources : function() {
        // Initialize source filters
        this._sourceFilters = [];
        var aInitialSources = Logger.sources;

        for(var j=0; j < aInitialSources.length; j++) {
            var sSource = aInitialSources[j];

            // Add source to the internal array of filters
            this._sourceFilters.push(sSource);

            // Add checkbox element if UI is enabled
            if(this._elSourceFilters) {
                this._createSourceCheckbox(sSource);
            }
        }
    },

    
    _createCategoryCheckbox : function(sCategory) {
        if(this._elFt) {
            var filter = make("span",{ className: "yui-log-filtergrp" }),
                check  = make("input", {
                    id: "yui-log-filter-" + sCategory + this._sName,
                    className: "yui-log-filter-" + sCategory,
                    type: "checkbox",
                    category: sCategory
                }),
                label  = make("label", {
                    htmlFor: check.id,
                    className: sCategory,
                    innerHTML: sCategory
                });
            

            // Subscribe to the click event
            Event.on(check,'click',this._onCheckCategory,this);

            this._filterCheckboxes[sCategory] = check;

            // Append el at the end so IE 5.5 can set "type" attribute
            // and THEN set checked property
            filter.appendChild(check);
            filter.appendChild(label);
            this._elCategoryFilters.appendChild(filter);
            check.checked = true;
        }
    },

    
    _createSourceCheckbox : function(sSource) {
        if(this._elFt) {
            var filter = make("span",{ className: "yui-log-filtergrp" }),
                check  = make("input", {
                    id: "yui-log-filter-" + sSource + this._sName,
                    className: "yui-log-filter-" + sSource,
                    type: "checkbox",
                    source: sSource
                }),
                label  = make("label", {
                    htmlFor: check.id,
                    className: sSource,
                    innerHTML: sSource
                });
            

            // Subscribe to the click event
            Event.on(check,'click',this._onCheckSource,this);

            this._filterCheckboxes[sSource] = check;

            // Append el at the end so IE 5.5 can set "type" attribute
            // and THEN set checked property
            filter.appendChild(check);
            filter.appendChild(label);
            this._elSourceFilters.appendChild(filter);
            check.checked = true;
        }
    },

    
    _filterLogs : function() {
        // Reprint stack with new filters
        if (this._elConsole !== null) {
            this.clearConsole();
            this._printToConsole(Logger.getStack());
        }
    },

    
    _printBuffer : function() {
        this._timeout = null;

        if(this._elConsole !== null) {
            var thresholdMax = this.thresholdMax;
            thresholdMax = (thresholdMax && !isNaN(thresholdMax)) ? thresholdMax : 500;
            if(this._consoleMsgCount < thresholdMax) {
                var entries = [];
                for (var i=0; i<this._buffer.length; i++) {
                    entries[i] = this._buffer[i];
                }
                this._buffer = [];
                this._printToConsole(entries);
            }
            else {
                this._filterLogs();
            }
            
            if(!this.newestOnTop) {
                this._elConsole.scrollTop = this._elConsole.scrollHeight;
            }
        }
    },

    
    _printToConsole : function(aEntries) {
        // Manage the number of messages displayed in the console
        var entriesLen         = aEntries.length,
            df                 = d.createDocumentFragment(),
            msgHTML            = [],
            thresholdMin       = this.thresholdMin,
            sourceFiltersLen   = this._sourceFilters.length,
            categoryFiltersLen = this._categoryFilters.length,
            entriesStartIndex,
            i, j, msg, before;

        if(isNaN(thresholdMin) || (thresholdMin > this.thresholdMax)) {
            thresholdMin = 0;
        }
        entriesStartIndex = (entriesLen > thresholdMin) ? (entriesLen - thresholdMin) : 0;
        
        // Iterate through all log entries 
        for(i=entriesStartIndex; i<entriesLen; i++) {
            // Print only the ones that filter through
            var okToPrint = false,
                okToFilterCats = false,
                entry = aEntries[i],
                source = entry.source,
                category = entry.category;

            for(j=0; j<sourceFiltersLen; j++) {
                if(source == this._sourceFilters[j]) {
                    okToFilterCats = true;
                    break;
                }
            }
            if(okToFilterCats) {
                for(j=0; j<categoryFiltersLen; j++) {
                    if(category == this._categoryFilters[j]) {
                        okToPrint = true;
                        break;
                    }
                }
            }
            if(okToPrint) {
                // Start from 0ms elapsed time
                if (this._consoleMsgCount === 0) {
                    this._lastTime = entry.time.getTime();
                }

                msg = this.formatMsg(entry);
                if (typeof msg === 'string') {
                    msgHTML[msgHTML.length] = msg;
                } else {
                    df.insertBefore(msg, this.newestOnTop ?
                        df.firstChild || null : null);
                }
                this._consoleMsgCount++;
                this._lastTime = entry.time.getTime();
            }
        }

        if (msgHTML.length) {
            msgHTML.splice(0,0,this._elConsole.innerHTML);
            this._elConsole.innerHTML = this.newestOnTop ?
                                            msgHTML.reverse().join('') :
                                            msgHTML.join('');
        } else if (df.firstChild) {
            this._elConsole.insertBefore(df, this.newestOnTop ?
                        this._elConsole.firstChild || null : null);
        }
    },

/////////////////////////////////////////////////////////////////////////////
//
// Private event handlers
//
/////////////////////////////////////////////////////////////////////////////

    
    _onCategoryCreate : function(sType, aArgs, oSelf) {
        var category = aArgs[0];
        
        // Add category to the internal array of filters
        oSelf._categoryFilters.push(category);

        if(oSelf._elFt) {
            oSelf._createCategoryCheckbox(category);
        }
    },

    
    _onSourceCreate : function(sType, aArgs, oSelf) {
        var source = aArgs[0];
        
        // Add source to the internal array of filters
        oSelf._sourceFilters.push(source);

        if(oSelf._elFt) {
            oSelf._createSourceCheckbox(source);
        }
    },

    
    _onCheckCategory : function(v, oSelf) {
        var category = this.category;
        if(!this.checked) {
            oSelf.hideCategory(category);
        }
        else {
            oSelf.showCategory(category);
        }
    },

    
    _onCheckSource : function(v, oSelf) {
        var source = this.source;
        if(!this.checked) {
            oSelf.hideSource(source);
        }
        else {
            oSelf.showSource(source);
        }
    },

    
    _onClickCollapseBtn : function(v, oSelf) {
        if(!oSelf.isCollapsed) {
            oSelf.collapse();
        }
        else {
            oSelf.expand();
        }
    },

    
    _onClickPauseBtn : function(v, oSelf) {
        if(!oSelf.isPaused) {
            oSelf.pause();
        }
        else {
            oSelf.resume();
        }
    },

    
    _onClickClearBtn : function(v, oSelf) {
        oSelf.clearConsole();
    },

    
    _onNewLog : function(sType, aArgs, oSelf) {
        var logEntry = aArgs[0];
        oSelf._buffer.push(logEntry);

        if (oSelf.logReaderEnabled === true && oSelf._timeout === null) {
            oSelf._timeout = setTimeout(function(){oSelf._printBuffer();}, oSelf.outputBuffer);
        }
    },

    
    _onReset : function(sType, aArgs, oSelf) {
        oSelf._filterLogs();
    }
};

YAHOO.widget.LogReader = LogReader;

})();
YAHOO.register("logger", YAHOO.widget.Logger, {version: "2.8.1", build: "19"});


(function(a,b){function G(a){var b=F[a]={};return p.each(a.split(s),function(a,c){b[c]=!0}),b}function J(a,c,d){if(d===b&&a.nodeType===1){var e="data-"+c.replace(I,"-$1").toLowerCase();d=a.getAttribute(e);if(typeof d=="string"){try{d=d==="true"?!0:d==="false"?!1:d==="null"?null:+d+""===d?+d:H.test(d)?p.parseJSON(d):d}catch(f){}p.data(a,c,d)}else d=b}return d}function K(a){var b;for(b in a){if(b==="data"&&p.isEmptyObject(a[b]))continue;if(b!=="toJSON")return!1}return!0}function ba(){return!1}function bb(){return!0}function bh(a){return!a||!a.parentNode||a.parentNode.nodeType===11}function bi(a,b){do a=a[b];while(a&&a.nodeType!==1);return a}function bj(a,b,c){b=b||0;if(p.isFunction(b))return p.grep(a,function(a,d){var e=!!b.call(a,d,a);return e===c});if(b.nodeType)return p.grep(a,function(a,d){return a===b===c});if(typeof b=="string"){var d=p.grep(a,function(a){return a.nodeType===1});if(be.test(b))return p.filter(b,d,!c);b=p.filter(b,d)}return p.grep(a,function(a,d){return p.inArray(a,b)>=0===c})}function bk(a){var b=bl.split("|"),c=a.createDocumentFragment();if(c.createElement)while(b.length)c.createElement(b.pop());return c}function bC(a,b){return a.getElementsByTagName(b)[0]||a.appendChild(a.ownerDocument.createElement(b))}function bD(a,b){if(b.nodeType!==1||!p.hasData(a))return;var c,d,e,f=p._data(a),g=p._data(b,f),h=f.events;if(h){delete g.handle,g.events={};for(c in h)for(d=0,e=h[c].length;d<e;d++)p.event.add(b,c,h[c][d])}g.data&&(g.data=p.extend({},g.data))}function bE(a,b){var c;if(b.nodeType!==1)return;b.clearAttributes&&b.clearAttributes(),b.mergeAttributes&&b.mergeAttributes(a),c=b.nodeName.toLowerCase(),c==="object"?(b.parentNode&&(b.outerHTML=a.outerHTML),p.support.html5Clone&&a.innerHTML&&!p.trim(b.innerHTML)&&(b.innerHTML=a.innerHTML)):c==="input"&&bv.test(a.type)?(b.defaultChecked=b.checked=a.checked,b.value!==a.value&&(b.value=a.value)):c==="option"?b.selected=a.defaultSelected:c==="input"||c==="textarea"?b.defaultValue=a.defaultValue:c==="script"&&b.text!==a.text&&(b.text=a.text),b.removeAttribute(p.expando)}function bF(a){return typeof a.getElementsByTagName!="undefined"?a.getElementsByTagName("*"):typeof a.querySelectorAll!="undefined"?a.querySelectorAll("*"):[]}function bG(a){bv.test(a.type)&&(a.defaultChecked=a.checked)}function bX(a,b){if(b in a)return b;var c=b.charAt(0).toUpperCase()+b.slice(1),d=b,e=bV.length;while(e--){b=bV[e]+c;if(b in a)return b}return d}function bY(a,b){return a=b||a,p.css(a,"display")==="none"||!p.contains(a.ownerDocument,a)}function bZ(a,b){var c,d,e=[],f=0,g=a.length;for(;f<g;f++){c=a[f];if(!c.style)continue;e[f]=p._data(c,"olddisplay"),b?(!e[f]&&c.style.display==="none"&&(c.style.display=""),c.style.display===""&&bY(c)&&(e[f]=p._data(c,"olddisplay",cb(c.nodeName)))):(d=bH(c,"display"),!e[f]&&d!=="none"&&p._data(c,"olddisplay",d))}for(f=0;f<g;f++){c=a[f];if(!c.style)continue;if(!b||c.style.display==="none"||c.style.display==="")c.style.display=b?e[f]||"":"none"}return a}function b$(a,b,c){var d=bO.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function b_(a,b,c,d){var e=c===(d?"border":"content")?4:b==="width"?1:0,f=0;for(;e<4;e+=2)c==="margin"&&(f+=p.css(a,c+bU[e],!0)),d?(c==="content"&&(f-=parseFloat(bH(a,"padding"+bU[e]))||0),c!=="margin"&&(f-=parseFloat(bH(a,"border"+bU[e]+"Width"))||0)):(f+=parseFloat(bH(a,"padding"+bU[e]))||0,c!=="padding"&&(f+=parseFloat(bH(a,"border"+bU[e]+"Width"))||0));return f}function ca(a,b,c){var d=b==="width"?a.offsetWidth:a.offsetHeight,e=!0,f=p.support.boxSizing&&p.css(a,"boxSizing")==="border-box";if(d<=0){d=bH(a,b);if(d<0||d==null)d=a.style[b];if(bP.test(d))return d;e=f&&(p.support.boxSizingReliable||d===a.style[b]),d=parseFloat(d)||0}return d+b_(a,b,c||(f?"border":"content"),e)+"px"}function cb(a){if(bR[a])return bR[a];var b=p("<"+a+">").appendTo(e.body),c=b.css("display");b.remove();if(c==="none"||c===""){bI=e.body.appendChild(bI||p.extend(e.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!bJ||!bI.createElement)bJ=(bI.contentWindow||bI.contentDocument).document,bJ.write("<!doctype html><html><body>"),bJ.close();b=bJ.body.appendChild(bJ.createElement(a)),c=bH(b,"display"),e.body.removeChild(bI)}return bR[a]=c,c}function ch(a,b,c,d){var e;if(p.isArray(b))p.each(b,function(b,e){c||cd.test(a)?d(a,e):ch(a+"["+(typeof e=="object"?b:"")+"]",e,c,d)});else if(!c&&p.type(b)==="object")for(e in b)ch(a+"["+e+"]",b[e],c,d);else d(a,b)}function cy(a){return function(b,c){typeof b!="string"&&(c=b,b="*");var d,e,f,g=b.toLowerCase().split(s),h=0,i=g.length;if(p.isFunction(c))for(;h<i;h++)d=g[h],f=/^\+/.test(d),f&&(d=d.substr(1)||"*"),e=a[d]=a[d]||[],e[f?"unshift":"push"](c)}}function cz(a,c,d,e,f,g){f=f||c.dataTypes[0],g=g||{},g[f]=!0;var h,i=a[f],j=0,k=i?i.length:0,l=a===cu;for(;j<k&&(l||!h);j++)h=i[j](c,d,e),typeof h=="string"&&(!l||g[h]?h=b:(c.dataTypes.unshift(h),h=cz(a,c,d,e,h,g)));return(l||!h)&&!g["*"]&&(h=cz(a,c,d,e,"*",g)),h}function cA(a,c){var d,e,f=p.ajaxSettings.flatOptions||{};for(d in c)c[d]!==b&&((f[d]?a:e||(e={}))[d]=c[d]);e&&p.extend(!0,a,e)}function cB(a,c,d){var e,f,g,h,i=a.contents,j=a.dataTypes,k=a.responseFields;for(f in k)f in d&&(c[k[f]]=d[f]);while(j[0]==="*")j.shift(),e===b&&(e=a.mimeType||c.getResponseHeader("content-type"));if(e)for(f in i)if(i[f]&&i[f].test(e)){j.unshift(f);break}if(j[0]in d)g=j[0];else{for(f in d){if(!j[0]||a.converters[f+" "+j[0]]){g=f;break}h||(h=f)}g=g||h}if(g)return g!==j[0]&&j.unshift(g),d[g]}function cC(a,b){var c,d,e,f,g=a.dataTypes.slice(),h=g[0],i={},j=0;a.dataFilter&&(b=a.dataFilter(b,a.dataType));if(g[1])for(c in a.converters)i[c.toLowerCase()]=a.converters[c];for(;e=g[++j];)if(e!=="*"){if(h!=="*"&&h!==e){c=i[h+" "+e]||i["* "+e];if(!c)for(d in i){f=d.split(" ");if(f[1]===e){c=i[h+" "+f[0]]||i["* "+f[0]];if(c){c===!0?c=i[d]:i[d]!==!0&&(e=f[0],g.splice(j--,0,e));break}}}if(c!==!0)if(c&&a["throws"])b=c(b);else try{b=c(b)}catch(k){return{state:"parsererror",error:c?k:"No conversion from "+h+" to "+e}}}h=e}return{state:"success",data:b}}function cK(){try{return new a.XMLHttpRequest}catch(b){}}function cL(){try{return new a.ActiveXObject("Microsoft.XMLHTTP")}catch(b){}}function cT(){return setTimeout(function(){cM=b},0),cM=p.now()}function cU(a,b){p.each(b,function(b,c){var d=(cS[b]||[]).concat(cS["*"]),e=0,f=d.length;for(;e<f;e++)if(d[e].call(a,b,c))return})}function cV(a,b,c){var d,e=0,f=0,g=cR.length,h=p.Deferred().always(function(){delete i.elem}),i=function(){var b=cM||cT(),c=Math.max(0,j.startTime+j.duration-b),d=1-(c/j.duration||0),e=0,f=j.tweens.length;for(;e<f;e++)j.tweens[e].run(d);return h.notifyWith(a,[j,d,c]),d<1&&f?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:p.extend({},b),opts:p.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:cM||cT(),duration:c.duration,tweens:[],createTween:function(b,c,d){var e=p.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(e),e},stop:function(b){var c=0,d=b?j.tweens.length:0;for(;c<d;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;cW(k,j.opts.specialEasing);for(;e<g;e++){d=cR[e].call(j,a,k,j.opts);if(d)return d}return cU(j,k),p.isFunction(j.opts.start)&&j.opts.start.call(a,j),p.fx.timer(p.extend(i,{anim:j,queue:j.opts.queue,elem:a})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}function cW(a,b){var c,d,e,f,g;for(c in a){d=p.camelCase(c),e=b[d],f=a[c],p.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=p.cssHooks[d];if(g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}}function cX(a,b,c){var d,e,f,g,h,i,j,k,l=this,m=a.style,n={},o=[],q=a.nodeType&&bY(a);c.queue||(j=p._queueHooks(a,"fx"),j.unqueued==null&&(j.unqueued=0,k=j.empty.fire,j.empty.fire=function(){j.unqueued||k()}),j.unqueued++,l.always(function(){l.always(function(){j.unqueued--,p.queue(a,"fx").length||j.empty.fire()})})),a.nodeType===1&&("height"in b||"width"in b)&&(c.overflow=[m.overflow,m.overflowX,m.overflowY],p.css(a,"display")==="inline"&&p.css(a,"float")==="none"&&(!p.support.inlineBlockNeedsLayout||cb(a.nodeName)==="inline"?m.display="inline-block":m.zoom=1)),c.overflow&&(m.overflow="hidden",p.support.shrinkWrapBlocks||l.done(function(){m.overflow=c.overflow[0],m.overflowX=c.overflow[1],m.overflowY=c.overflow[2]}));for(d in b){f=b[d];if(cO.exec(f)){delete b[d];if(f===(q?"hide":"show"))continue;o.push(d)}}g=o.length;if(g){h=p._data(a,"fxshow")||p._data(a,"fxshow",{}),q?p(a).show():l.done(function(){p(a).hide()}),l.done(function(){var b;p.removeData(a,"fxshow",!0);for(b in n)p.style(a,b,n[b])});for(d=0;d<g;d++)e=o[d],i=l.createTween(e,q?h[e]:0),n[e]=h[e]||p.style(a,e),e in h||(h[e]=i.start,q&&(i.end=i.start,i.start=e==="width"||e==="height"?1:0))}}function cY(a,b,c,d,e){return new cY.prototype.init(a,b,c,d,e)}function cZ(a,b){var c,d={height:a},e=0;for(;e<4;e+=2-b)c=bU[e],d["margin"+c]=d["padding"+c]=a;return b&&(d.opacity=d.width=a),d}function c_(a){return p.isWindow(a)?a:a.nodeType===9?a.defaultView||a.parentWindow:!1}var c,d,e=a.document,f=a.location,g=a.navigator,h=a.jQuery,i=a.$,j=Array.prototype.push,k=Array.prototype.slice,l=Array.prototype.indexOf,m=Object.prototype.toString,n=Object.prototype.hasOwnProperty,o=String.prototype.trim,p=function(a,b){return new p.fn.init(a,b,c)},q=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,r=/\S/,s=/\s+/,t=r.test(" ")?/^[\s\xA0]+|[\s\xA0]+$/g:/^\s+|\s+$/g,u=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^[\],:{}\s]*$/,x=/(?:^|:|,)(?:\s*\[)+/g,y=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,z=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,A=/^-ms-/,B=/-([\da-z])/gi,C=function(a,b){return(b+"").toUpperCase()},D=function(){e.addEventListener?(e.removeEventListener("DOMContentLoaded",D,!1),p.ready()):e.readyState==="complete"&&(e.detachEvent("onreadystatechange",D),p.ready())},E={};p.fn=p.prototype={constructor:p,init:function(a,c,d){var f,g,h,i;if(!a)return this;if(a.nodeType)return this.context=this[0]=a,this.length=1,this;if(typeof a=="string"){a.charAt(0)==="<"&&a.charAt(a.length-1)===">"&&a.length>=3?f=[null,a,null]:f=u.exec(a);if(f&&(f[1]||!c)){if(f[1])return c=c instanceof p?c[0]:c,i=c&&c.nodeType?c.ownerDocument||c:e,a=p.parseHTML(f[1],i,!0),v.test(f[1])&&p.isPlainObject(c)&&this.attr.call(a,c,!0),p.merge(this,a);g=e.getElementById(f[2]);if(g&&g.parentNode){if(g.id!==f[2])return d.find(a);this.length=1,this[0]=g}return this.context=e,this.selector=a,this}return!c||c.jquery?(c||d).find(a):this.constructor(c).find(a)}return p.isFunction(a)?d.ready(a):(a.selector!==b&&(this.selector=a.selector,this.context=a.context),p.makeArray(a,this))},selector:"",jquery:"1.8.0",length:0,size:function(){return this.length},toArray:function(){return k.call(this)},get:function(a){return a==null?this.toArray():a<0?this[this.length+a]:this[a]},pushStack:function(a,b,c){var d=p.merge(this.constructor(),a);return d.prevObject=this,d.context=this.context,b==="find"?d.selector=this.selector+(this.selector?" ":"")+c:b&&(d.selector=this.selector+"."+b+"("+c+")"),d},each:function(a,b){return p.each(this,a,b)},ready:function(a){return p.ready.promise().done(a),this},eq:function(a){return a=+a,a===-1?this.slice(a):this.slice(a,a+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(k.apply(this,arguments),"slice",k.call(arguments).join(","))},map:function(a){return this.pushStack(p.map(this,function(b,c){return a.call(b,c,b)}))},end:function(){return this.prevObject||this.constructor(null)},push:j,sort:[].sort,splice:[].splice},p.fn.init.prototype=p.fn,p.extend=p.fn.extend=function(){var a,c,d,e,f,g,h=arguments[0]||{},i=1,j=arguments.length,k=!1;typeof h=="boolean"&&(k=h,h=arguments[1]||{},i=2),typeof h!="object"&&!p.isFunction(h)&&(h={}),j===i&&(h=this,--i);for(;i<j;i++)if((a=arguments[i])!=null)for(c in a){d=h[c],e=a[c];if(h===e)continue;k&&e&&(p.isPlainObject(e)||(f=p.isArray(e)))?(f?(f=!1,g=d&&p.isArray(d)?d:[]):g=d&&p.isPlainObject(d)?d:{},h[c]=p.extend(k,g,e)):e!==b&&(h[c]=e)}return h},p.extend({noConflict:function(b){return a.$===p&&(a.$=i),b&&a.jQuery===p&&(a.jQuery=h),p},isReady:!1,readyWait:1,holdReady:function(a){a?p.readyWait++:p.ready(!0)},ready:function(a){if(a===!0?--p.readyWait:p.isReady)return;if(!e.body)return setTimeout(p.ready,1);p.isReady=!0;if(a!==!0&&--p.readyWait>0)return;d.resolveWith(e,[p]),p.fn.trigger&&p(e).trigger("ready").off("ready")},isFunction:function(a){return p.type(a)==="function"},isArray:Array.isArray||function(a){return p.type(a)==="array"},isWindow:function(a){return a!=null&&a==a.window},isNumeric:function(a){return!isNaN(parseFloat(a))&&isFinite(a)},type:function(a){return a==null?String(a):E[m.call(a)]||"object"},isPlainObject:function(a){if(!a||p.type(a)!=="object"||a.nodeType||p.isWindow(a))return!1;try{if(a.constructor&&!n.call(a,"constructor")&&!n.call(a.constructor.prototype,"isPrototypeOf"))return!1}catch(c){return!1}var d;for(d in a);return d===b||n.call(a,d)},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},error:function(a){throw new Error(a)},parseHTML:function(a,b,c){var d;return!a||typeof a!="string"?null:(typeof b=="boolean"&&(c=b,b=0),b=b||e,(d=v.exec(a))?[b.createElement(d[1])]:(d=p.buildFragment([a],b,c?null:[]),p.merge([],(d.cacheable?p.clone(d.fragment):d.fragment).childNodes)))},parseJSON:function(b){if(!b||typeof b!="string")return null;b=p.trim(b);if(a.JSON&&a.JSON.parse)return a.JSON.parse(b);if(w.test(b.replace(y,"@").replace(z,"]").replace(x,"")))return(new Function("return "+b))();p.error("Invalid JSON: "+b)},parseXML:function(c){var d,e;if(!c||typeof c!="string")return null;try{a.DOMParser?(e=new DOMParser,d=e.parseFromString(c,"text/xml")):(d=new ActiveXObject("Microsoft.XMLDOM"),d.async="false",d.loadXML(c))}catch(f){d=b}return(!d||!d.documentElement||d.getElementsByTagName("parsererror").length)&&p.error("Invalid XML: "+c),d},noop:function(){},globalEval:function(b){b&&r.test(b)&&(a.execScript||function(b){a.eval.call(a,b)})(b)},camelCase:function(a){return a.replace(A,"ms-").replace(B,C)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toUpperCase()===b.toUpperCase()},each:function(a,c,d){var e,f=0,g=a.length,h=g===b||p.isFunction(a);if(d){if(h){for(e in a)if(c.apply(a[e],d)===!1)break}else for(;f<g;)if(c.apply(a[f++],d)===!1)break}else if(h){for(e in a)if(c.call(a[e],e,a[e])===!1)break}else for(;f<g;)if(c.call(a[f],f,a[f++])===!1)break;return a},trim:o?function(a){return a==null?"":o.call(a)}:function(a){return a==null?"":a.toString().replace(t,"")},makeArray:function(a,b){var c,d=b||[];return a!=null&&(c=p.type(a),a.length==null||c==="string"||c==="function"||c==="regexp"||p.isWindow(a)?j.call(d,a):p.merge(d,a)),d},inArray:function(a,b,c){var d;if(b){if(l)return l.call(b,a,c);d=b.length,c=c?c<0?Math.max(0,d+c):c:0;for(;c<d;c++)if(c in b&&b[c]===a)return c}return-1},merge:function(a,c){var d=c.length,e=a.length,f=0;if(typeof d=="number")for(;f<d;f++)a[e++]=c[f];else while(c[f]!==b)a[e++]=c[f++];return a.length=e,a},grep:function(a,b,c){var d,e=[],f=0,g=a.length;c=!!c;for(;f<g;f++)d=!!b(a[f],f),c!==d&&e.push(a[f]);return e},map:function(a,c,d){var e,f,g=[],h=0,i=a.length,j=a instanceof p||i!==b&&typeof i=="number"&&(i>0&&a[0]&&a[i-1]||i===0||p.isArray(a));if(j)for(;h<i;h++)e=c(a[h],h,d),e!=null&&(g[g.length]=e);else for(f in a)e=c(a[f],f,d),e!=null&&(g[g.length]=e);return g.concat.apply([],g)},guid:1,proxy:function(a,c){var d,e,f;return typeof c=="string"&&(d=a[c],c=a,a=d),p.isFunction(a)?(e=k.call(arguments,2),f=function(){return a.apply(c,e.concat(k.call(arguments)))},f.guid=a.guid=a.guid||f.guid||p.guid++,f):b},access:function(a,c,d,e,f,g,h){var i,j=d==null,k=0,l=a.length;if(d&&typeof d=="object"){for(k in d)p.access(a,c,k,d[k],1,g,e);f=1}else if(e!==b){i=h===b&&p.isFunction(e),j&&(i?(i=c,c=function(a,b,c){return i.call(p(a),c)}):(c.call(a,e),c=null));if(c)for(;k<l;k++)c(a[k],d,i?e.call(a[k],k,c(a[k],d)):e,h);f=1}return f?a:j?c.call(a):l?c(a[0],d):g},now:function(){return(new Date).getTime()}}),p.ready.promise=function(b){if(!d){d=p.Deferred();if(e.readyState==="complete"||e.readyState!=="loading"&&e.addEventListener)setTimeout(p.ready,1);else if(e.addEventListener)e.addEventListener("DOMContentLoaded",D,!1),a.addEventListener("load",p.ready,!1);else{e.attachEvent("onreadystatechange",D),a.attachEvent("onload",p.ready);var c=!1;try{c=a.frameElement==null&&e.documentElement}catch(f){}c&&c.doScroll&&function g(){if(!p.isReady){try{c.doScroll("left")}catch(a){return setTimeout(g,50)}p.ready()}}()}}return d.promise(b)},p.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(a,b){E["[object "+b+"]"]=b.toLowerCase()}),c=p(e);var F={};p.Callbacks=function(a){a=typeof a=="string"?F[a]||G(a):p.extend({},a);var c,d,e,f,g,h,i=[],j=!a.once&&[],k=function(b){c=a.memory&&b,d=!0,h=f||0,f=0,g=i.length,e=!0;for(;i&&h<g;h++)if(i[h].apply(b[0],b[1])===!1&&a.stopOnFalse){c=!1;break}e=!1,i&&(j?j.length&&k(j.shift()):c?i=[]:l.disable())},l={add:function(){if(i){var b=i.length;(function d(b){p.each(b,function(b,c){p.isFunction(c)&&(!a.unique||!l.has(c))?i.push(c):c&&c.length&&d(c)})})(arguments),e?g=i.length:c&&(f=b,k(c))}return this},remove:function(){return i&&p.each(arguments,function(a,b){var c;while((c=p.inArray(b,i,c))>-1)i.splice(c,1),e&&(c<=g&&g--,c<=h&&h--)}),this},has:function(a){return p.inArray(a,i)>-1},empty:function(){return i=[],this},disable:function(){return i=j=c=b,this},disabled:function(){return!i},lock:function(){return j=b,c||l.disable(),this},locked:function(){return!j},fireWith:function(a,b){return b=b||[],b=[a,b.slice?b.slice():b],i&&(!d||j)&&(e?j.push(b):k(b)),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!d}};return l},p.extend({Deferred:function(a){var b=[["resolve","done",p.Callbacks("once memory"),"resolved"],["reject","fail",p.Callbacks("once memory"),"rejected"],["notify","progress",p.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return p.Deferred(function(c){p.each(b,function(b,d){var f=d[0],g=a[b];e[d[1]](p.isFunction(g)?function(){var a=g.apply(this,arguments);a&&p.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f+"With"](this===e?c:this,[a])}:c[f])}),a=null}).promise()},promise:function(a){return typeof a=="object"?p.extend(a,d):d}},e={};return d.pipe=d.then,p.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[a^1][2].disable,b[2][2].lock),e[f[0]]=g.fire,e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=k.call(arguments),d=c.length,e=d!==1||a&&p.isFunction(a.promise)?d:0,f=e===1?a:p.Deferred(),g=function(a,b,c){return function(d){b[a]=this,c[a]=arguments.length>1?k.call(arguments):d,c===h?f.notifyWith(b,c):--e||f.resolveWith(b,c)}},h,i,j;if(d>1){h=new Array(d),i=new Array(d),j=new Array(d);for(;b<d;b++)c[b]&&p.isFunction(c[b].promise)?c[b].promise().done(g(b,j,c)).fail(f.reject).progress(g(b,i,h)):--e}return e||f.resolveWith(j,c),f.promise()}}),p.support=function(){var b,c,d,f,g,h,i,j,k,l,m,n=e.createElement("div");n.setAttribute("className","t"),n.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",c=n.getElementsByTagName("*"),d=n.getElementsByTagName("a")[0],d.style.cssText="top:1px;float:left;opacity:.5";if(!c||!c.length||!d)return{};f=e.createElement("select"),g=f.appendChild(e.createElement("option")),h=n.getElementsByTagName("input")[0],b={leadingWhitespace:n.firstChild.nodeType===3,tbody:!n.getElementsByTagName("tbody").length,htmlSerialize:!!n.getElementsByTagName("link").length,style:/top/.test(d.getAttribute("style")),hrefNormalized:d.getAttribute("href")==="/a",opacity:/^0.5/.test(d.style.opacity),cssFloat:!!d.style.cssFloat,checkOn:h.value==="on",optSelected:g.selected,getSetAttribute:n.className!=="t",enctype:!!e.createElement("form").enctype,html5Clone:e.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:e.compatMode==="CSS1Compat",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},h.checked=!0,b.noCloneChecked=h.cloneNode(!0).checked,f.disabled=!0,b.optDisabled=!g.disabled;try{delete n.test}catch(o){b.deleteExpando=!1}!n.addEventListener&&n.attachEvent&&n.fireEvent&&(n.attachEvent("onclick",m=function(){b.noCloneEvent=!1}),n.cloneNode(!0).fireEvent("onclick"),n.detachEvent("onclick",m)),h=e.createElement("input"),h.value="t",h.setAttribute("type","radio"),b.radioValue=h.value==="t",h.setAttribute("checked","checked"),h.setAttribute("name","t"),n.appendChild(h),i=e.createDocumentFragment(),i.appendChild(n.lastChild),b.checkClone=i.cloneNode(!0).cloneNode(!0).lastChild.checked,b.appendChecked=h.checked,i.removeChild(h),i.appendChild(n);if(n.attachEvent)for(k in{submit:!0,change:!0,focusin:!0})j="on"+k,l=j in n,l||(n.setAttribute(j,"return;"),l=typeof n[j]=="function"),b[k+"Bubbles"]=l;return p(function(){var c,d,f,g,h="padding:0;margin:0;border:0;display:block;overflow:hidden;",i=e.getElementsByTagName("body")[0];if(!i)return;c=e.createElement("div"),c.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px",i.insertBefore(c,i.firstChild),d=e.createElement("div"),c.appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",f=d.getElementsByTagName("td"),f[0].style.cssText="padding:0;margin:0;border:0;display:none",l=f[0].offsetHeight===0,f[0].style.display="",f[1].style.display="none",b.reliableHiddenOffsets=l&&f[0].offsetHeight===0,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",b.boxSizing=d.offsetWidth===4,b.doesNotIncludeMarginInBodyOffset=i.offsetTop!==1,a.getComputedStyle&&(b.pixelPosition=(a.getComputedStyle(d,null)||{}).top!=="1%",b.boxSizingReliable=(a.getComputedStyle(d,null)||{width:"4px"}).width==="4px",g=e.createElement("div"),g.style.cssText=d.style.cssText=h,g.style.marginRight=g.style.width="0",d.style.width="1px",d.appendChild(g),b.reliableMarginRight=!parseFloat((a.getComputedStyle(g,null)||{}).marginRight)),typeof d.style.zoom!="undefined"&&(d.innerHTML="",d.style.cssText=h+"width:1px;padding:1px;display:inline;zoom:1",b.inlineBlockNeedsLayout=d.offsetWidth===3,d.style.display="block",d.style.overflow="visible",d.innerHTML="<div></div>",d.firstChild.style.width="5px",b.shrinkWrapBlocks=d.offsetWidth!==3,c.style.zoom=1),i.removeChild(c),c=d=f=g=null}),i.removeChild(n),c=d=f=g=h=i=n=null,b}();var H=/^(?:\{.*\}|\[.*\])$/,I=/([A-Z])/g;p.extend({cache:{},deletedIds:[],uuid:0,expando:"jQuery"+(p.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(a){return a=a.nodeType?p.cache[a[p.expando]]:a[p.expando],!!a&&!K(a)},data:function(a,c,d,e){if(!p.acceptData(a))return;var f,g,h=p.expando,i=typeof c=="string",j=a.nodeType,k=j?p.cache:a,l=j?a[h]:a[h]&&h;if((!l||!k[l]||!e&&!k[l].data)&&i&&d===b)return;l||(j?a[h]=l=p.deletedIds.pop()||++p.uuid:l=h),k[l]||(k[l]={},j||(k[l].toJSON=p.noop));if(typeof c=="object"||typeof c=="function")e?k[l]=p.extend(k[l],c):k[l].data=p.extend(k[l].data,c);return f=k[l],e||(f.data||(f.data={}),f=f.data),d!==b&&(f[p.camelCase(c)]=d),i?(g=f[c],g==null&&(g=f[p.camelCase(c)])):g=f,g},removeData:function(a,b,c){if(!p.acceptData(a))return;var d,e,f,g=a.nodeType,h=g?p.cache:a,i=g?a[p.expando]:p.expando;if(!h[i])return;if(b){d=c?h[i]:h[i].data;if(d){p.isArray(b)||(b in d?b=[b]:(b=p.camelCase(b),b in d?b=[b]:b=b.split(" ")));for(e=0,f=b.length;e<f;e++)delete d[b[e]];if(!(c?K:p.isEmptyObject)(d))return}}if(!c){delete h[i].data;if(!K(h[i]))return}g?p.cleanData([a],!0):p.support.deleteExpando||h!=h.window?delete h[i]:h[i]=null},_data:function(a,b,c){return p.data(a,b,c,!0)},acceptData:function(a){var b=a.nodeName&&p.noData[a.nodeName.toLowerCase()];return!b||b!==!0&&a.getAttribute("classid")===b}}),p.fn.extend({data:function(a,c){var d,e,f,g,h,i=this[0],j=0,k=null;if(a===b){if(this.length){k=p.data(i);if(i.nodeType===1&&!p._data(i,"parsedAttrs")){f=i.attributes;for(h=f.length;j<h;j++)g=f[j].name,g.indexOf("data-")===0&&(g=p.camelCase(g.substring(5)),J(i,g,k[g]));p._data(i,"parsedAttrs",!0)}}return k}return typeof a=="object"?this.each(function(){p.data(this,a)}):(d=a.split(".",2),d[1]=d[1]?"."+d[1]:"",e=d[1]+"!",p.access(this,function(c){if(c===b)return k=this.triggerHandler("getData"+e,[d[0]]),k===b&&i&&(k=p.data(i,a),k=J(i,a,k)),k===b&&d[1]?this.data(d[0]):k;d[1]=c,this.each(function(){var b=p(this);b.triggerHandler("setData"+e,d),p.data(this,a,c),b.triggerHandler("changeData"+e,d)})},null,c,arguments.length>1,null,!1))},removeData:function(a){return this.each(function(){p.removeData(this,a)})}}),p.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=p._data(a,b),c&&(!d||p.isArray(c)?d=p._data(a,b,p.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=p.queue(a,b),d=c.shift(),e=p._queueHooks(a,b),f=function(){p.dequeue(a,b)};d==="inprogress"&&(d=c.shift()),d&&(b==="fx"&&c.unshift("inprogress"),delete e.stop,d.call(a,f,e)),!c.length&&e&&e.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return p._data(a,c)||p._data(a,c,{empty:p.Callbacks("once memory").add(function(){p.removeData(a,b+"queue",!0),p.removeData(a,c,!0)})})}}),p.fn.extend({queue:function(a,c){var d=2;return typeof a!="string"&&(c=a,a="fx",d--),arguments.length<d?p.queue(this[0],a):c===b?this:this.each(function(){var b=p.queue(this,a,c);p._queueHooks(this,a),a==="fx"&&b[0]!=="inprogress"&&p.dequeue(this,a)})},dequeue:function(a){return this.each(function(){p.dequeue(this,a)})},delay:function(a,b){return a=p.fx?p.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,c){var d,e=1,f=p.Deferred(),g=this,h=this.length,i=function(){--e||f.resolveWith(g,[g])};typeof a!="string"&&(c=a,a=b),a=a||"fx";while(h--)(d=p._data(g[h],a+"queueHooks"))&&d.empty&&(e++,d.empty.add(i));return i(),f.promise(c)}});var L,M,N,O=/[\t\r\n]/g,P=/\r/g,Q=/^(?:button|input)$/i,R=/^(?:button|input|object|select|textarea)$/i,S=/^a(?:rea|)$/i,T=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,U=p.support.getSetAttribute;p.fn.extend({attr:function(a,b){return p.access(this,p.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){p.removeAttr(this,a)})},prop:function(a,b){return p.access(this,p.prop,a,b,arguments.length>1)},removeProp:function(a){return a=p.propFix[a]||a,this.each(function(){try{this[a]=b,delete this[a]}catch(c){}})},addClass:function(a){var b,c,d,e,f,g,h;if(p.isFunction(a))return this.each(function(b){p(this).addClass(a.call(this,b,this.className))});if(a&&typeof a=="string"){b=a.split(s);for(c=0,d=this.length;c<d;c++){e=this[c];if(e.nodeType===1)if(!e.className&&b.length===1)e.className=a;else{f=" "+e.className+" ";for(g=0,h=b.length;g<h;g++)~f.indexOf(" "+b[g]+" ")||(f+=b[g]+" ");e.className=p.trim(f)}}}return this},removeClass:function(a){var c,d,e,f,g,h,i;if(p.isFunction(a))return this.each(function(b){p(this).removeClass(a.call(this,b,this.className))});if(a&&typeof a=="string"||a===b){c=(a||"").split(s);for(h=0,i=this.length;h<i;h++){e=this[h];if(e.nodeType===1&&e.className){d=(" "+e.className+" ").replace(O," ");for(f=0,g=c.length;f<g;f++)while(d.indexOf(" "+c[f]+" ")>-1)d=d.replace(" "+c[f]+" "," ");e.className=a?p.trim(d):""}}}return this},toggleClass:function(a,b){var c=typeof a,d=typeof b=="boolean";return p.isFunction(a)?this.each(function(c){p(this).toggleClass(a.call(this,c,this.className,b),b)}):this.each(function(){if(c==="string"){var e,f=0,g=p(this),h=b,i=a.split(s);while(e=i[f++])h=d?h:!g.hasClass(e),g[h?"addClass":"removeClass"](e)}else if(c==="undefined"||c==="boolean")this.className&&p._data(this,"__className__",this.className),this.className=this.className||a===!1?"":p._data(this,"__className__")||""})},hasClass:function(a){var b=" "+a+" ",c=0,d=this.length;for(;c<d;c++)if(this[c].nodeType===1&&(" "+this[c].className+" ").replace(O," ").indexOf(b)>-1)return!0;return!1},val:function(a){var c,d,e,f=this[0];if(!arguments.length){if(f)return c=p.valHooks[f.type]||p.valHooks[f.nodeName.toLowerCase()],c&&"get"in c&&(d=c.get(f,"value"))!==b?d:(d=f.value,typeof d=="string"?d.replace(P,""):d==null?"":d);return}return e=p.isFunction(a),this.each(function(d){var f,g=p(this);if(this.nodeType!==1)return;e?f=a.call(this,d,g.val()):f=a,f==null?f="":typeof f=="number"?f+="":p.isArray(f)&&(f=p.map(f,function(a){return a==null?"":a+""})),c=p.valHooks[this.type]||p.valHooks[this.nodeName.toLowerCase()];if(!c||!("set"in c)||c.set(this,f,"value")===b)this.value=f})}}),p.extend({valHooks:{option:{get:function(a){var b=a.attributes.value;return!b||b.specified?a.value:a.text}},select:{get:function(a){var b,c,d,e,f=a.selectedIndex,g=[],h=a.options,i=a.type==="select-one";if(f<0)return null;c=i?f:0,d=i?f+1:h.length;for(;c<d;c++){e=h[c];if(e.selected&&(p.support.optDisabled?!e.disabled:e.getAttribute("disabled")===null)&&(!e.parentNode.disabled||!p.nodeName(e.parentNode,"optgroup"))){b=p(e).val();if(i)return b;g.push(b)}}return i&&!g.length&&h.length?p(h[f]).val():g},set:function(a,b){var c=p.makeArray(b);return p(a).find("option").each(function(){this.selected=p.inArray(p(this).val(),c)>=0}),c.length||(a.selectedIndex=-1),c}}},attrFn:{},attr:function(a,c,d,e){var f,g,h,i=a.nodeType;if(!a||i===3||i===8||i===2)return;if(e&&p.isFunction(p.fn[c]))return p(a)[c](d);if(typeof a.getAttribute=="undefined")return p.prop(a,c,d);h=i!==1||!p.isXMLDoc(a),h&&(c=c.toLowerCase(),g=p.attrHooks[c]||(T.test(c)?M:L));if(d!==b){if(d===null){p.removeAttr(a,c);return}return g&&"set"in g&&h&&(f=g.set(a,d,c))!==b?f:(a.setAttribute(c,""+d),d)}return g&&"get"in g&&h&&(f=g.get(a,c))!==null?f:(f=a.getAttribute(c),f===null?b:f)},removeAttr:function(a,b){var c,d,e,f,g=0;if(b&&a.nodeType===1){d=b.split(s);for(;g<d.length;g++)e=d[g],e&&(c=p.propFix[e]||e,f=T.test(e),f||p.attr(a,e,""),a.removeAttribute(U?e:c),f&&c in a&&(a[c]=!1))}},attrHooks:{type:{set:function(a,b){if(Q.test(a.nodeName)&&a.parentNode)p.error("type property can't be changed");else if(!p.support.radioValue&&b==="radio"&&p.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}},value:{get:function(a,b){return L&&p.nodeName(a,"button")?L.get(a,b):b in a?a.value:null},set:function(a,b,c){if(L&&p.nodeName(a,"button"))return L.set(a,b,c);a.value=b}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(a,c,d){var e,f,g,h=a.nodeType;if(!a||h===3||h===8||h===2)return;return g=h!==1||!p.isXMLDoc(a),g&&(c=p.propFix[c]||c,f=p.propHooks[c]),d!==b?f&&"set"in f&&(e=f.set(a,d,c))!==b?e:a[c]=d:f&&"get"in f&&(e=f.get(a,c))!==null?e:a[c]},propHooks:{tabIndex:{get:function(a){var c=a.getAttributeNode("tabindex");return c&&c.specified?parseInt(c.value,10):R.test(a.nodeName)||S.test(a.nodeName)&&a.href?0:b}}}}),M={get:function(a,c){var d,e=p.prop(a,c);return e===!0||typeof e!="boolean"&&(d=a.getAttributeNode(c))&&d.nodeValue!==!1?c.toLowerCase():b},set:function(a,b,c){var d;return b===!1?p.removeAttr(a,c):(d=p.propFix[c]||c,d in a&&(a[d]=!0),a.setAttribute(c,c.toLowerCase())),c}},U||(N={name:!0,id:!0,coords:!0},L=p.valHooks.button={get:function(a,c){var d;return d=a.getAttributeNode(c),d&&(N[c]?d.value!=="":d.specified)?d.value:b},set:function(a,b,c){var d=a.getAttributeNode(c);return d||(d=e.createAttribute(c),a.setAttributeNode(d)),d.value=b+""}},p.each(["width","height"],function(a,b){p.attrHooks[b]=p.extend(p.attrHooks[b],{set:function(a,c){if(c==="")return a.setAttribute(b,"auto"),c}})}),p.attrHooks.contenteditable={get:L.get,set:function(a,b,c){b===""&&(b="false"),L.set(a,b,c)}}),p.support.hrefNormalized||p.each(["href","src","width","height"],function(a,c){p.attrHooks[c]=p.extend(p.attrHooks[c],{get:function(a){var d=a.getAttribute(c,2);return d===null?b:d}})}),p.support.style||(p.attrHooks.style={get:function(a){return a.style.cssText.toLowerCase()||b},set:function(a,b){return a.style.cssText=""+b}}),p.support.optSelected||(p.propHooks.selected=p.extend(p.propHooks.selected,{get:function(a){var b=a.parentNode;return b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex),null}})),p.support.enctype||(p.propFix.enctype="encoding"),p.support.checkOn||p.each(["radio","checkbox"],function(){p.valHooks[this]={get:function(a){return a.getAttribute("value")===null?"on":a.value}}}),p.each(["radio","checkbox"],function(){p.valHooks[this]=p.extend(p.valHooks[this],{set:function(a,b){if(p.isArray(b))return a.checked=p.inArray(p(a).val(),b)>=0}})});var V=/^(?:textarea|input|select)$/i,W=/^([^\.]*|)(?:\.(.+)|)$/,X=/(?:^|\s)hover(\.\S+|)\b/,Y=/^key/,Z=/^(?:mouse|contextmenu)|click/,$=/^(?:focusinfocus|focusoutblur)$/,_=function(a){return p.event.special.hover?a:a.replace(X,"mouseenter$1 mouseleave$1")};p.event={add:function(a,c,d,e,f){var g,h,i,j,k,l,m,n,o,q,r;if(a.nodeType===3||a.nodeType===8||!c||!d||!(g=p._data(a)))return;d.handler&&(o=d,d=o.handler,f=o.selector),d.guid||(d.guid=p.guid++),i=g.events,i||(g.events=i={}),h=g.handle,h||(g.handle=h=function(a){return typeof p!="undefined"&&(!a||p.event.triggered!==a.type)?p.event.dispatch.apply(h.elem,arguments):b},h.elem=a),c=p.trim(_(c)).split(" ");for(j=0;j<c.length;j++){k=W.exec(c[j])||[],l=k[1],m=(k[2]||"").split(".").sort(),r=p.event.special[l]||{},l=(f?r.delegateType:r.bindType)||l,r=p.event.special[l]||{},n=p.extend({type:l,origType:k[1],data:e,handler:d,guid:d.guid,selector:f,namespace:m.join(".")},o),q=i[l];if(!q){q=i[l]=[],q.delegateCount=0;if(!r.setup||r.setup.call(a,e,m,h)===!1)a.addEventListener?a.addEventListener(l,h,!1):a.attachEvent&&a.attachEvent("on"+l,h)}r.add&&(r.add.call(a,n),n.handler.guid||(n.handler.guid=d.guid)),f?q.splice(q.delegateCount++,0,n):q.push(n),p.event.global[l]=!0}a=null},global:{},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,q,r=p.hasData(a)&&p._data(a);if(!r||!(m=r.events))return;b=p.trim(_(b||"")).split(" ");for(f=0;f<b.length;f++){g=W.exec(b[f])||[],h=i=g[1],j=g[2];if(!h){for(h in m)p.event.remove(a,h+b[f],c,d,!0);continue}n=p.event.special[h]||{},h=(d?n.delegateType:n.bindType)||h,o=m[h]||[],k=o.length,j=j?new RegExp("(^|\\.)"+j.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(l=0;l<o.length;l++)q=o[l],(e||i===q.origType)&&(!c||c.guid===q.guid)&&(!j||j.test(q.namespace))&&(!d||d===q.selector||d==="**"&&q.selector)&&(o.splice(l--,1),q.selector&&o.delegateCount--,n.remove&&n.remove.call(a,q));o.length===0&&k!==o.length&&((!n.teardown||n.teardown.call(a,j,r.handle)===!1)&&p.removeEvent(a,h,r.handle),delete m[h])}p.isEmptyObject(m)&&(delete r.handle,p.removeData(a,"events",!0))},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(c,d,f,g){if(!f||f.nodeType!==3&&f.nodeType!==8){var h,i,j,k,l,m,n,o,q,r,s=c.type||c,t=[];if($.test(s+p.event.triggered))return;s.indexOf("!")>=0&&(s=s.slice(0,-1),i=!0),s.indexOf(".")>=0&&(t=s.split("."),s=t.shift(),t.sort());if((!f||p.event.customEvent[s])&&!p.event.global[s])return;c=typeof c=="object"?c[p.expando]?c:new p.Event(s,c):new p.Event(s),c.type=s,c.isTrigger=!0,c.exclusive=i,c.namespace=t.join("."),c.namespace_re=c.namespace?new RegExp("(^|\\.)"+t.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,m=s.indexOf(":")<0?"on"+s:"";if(!f){h=p.cache;for(j in h)h[j].events&&h[j].events[s]&&p.event.trigger(c,d,h[j].handle.elem,!0);return}c.result=b,c.target||(c.target=f),d=d!=null?p.makeArray(d):[],d.unshift(c),n=p.event.special[s]||{};if(n.trigger&&n.trigger.apply(f,d)===!1)return;q=[[f,n.bindType||s]];if(!g&&!n.noBubble&&!p.isWindow(f)){r=n.delegateType||s,k=$.test(r+s)?f:f.parentNode;for(l=f;k;k=k.parentNode)q.push([k,r]),l=k;l===(f.ownerDocument||e)&&q.push([l.defaultView||l.parentWindow||a,r])}for(j=0;j<q.length&&!c.isPropagationStopped();j++)k=q[j][0],c.type=q[j][1],o=(p._data(k,"events")||{})[c.type]&&p._data(k,"handle"),o&&o.apply(k,d),o=m&&k[m],o&&p.acceptData(k)&&o.apply(k,d)===!1&&c.preventDefault();return c.type=s,!g&&!c.isDefaultPrevented()&&(!n._default||n._default.apply(f.ownerDocument,d)===!1)&&(s!=="click"||!p.nodeName(f,"a"))&&p.acceptData(f)&&m&&f[s]&&(s!=="focus"&&s!=="blur"||c.target.offsetWidth!==0)&&!p.isWindow(f)&&(l=f[m],l&&(f[m]=null),p.event.triggered=s,f[s](),p.event.triggered=b,l&&(f[m]=l)),c.result}return},dispatch:function(c){c=p.event.fix(c||a.event);var d,e,f,g,h,i,j,k,l,m,n,o=(p._data(this,"events")||{})[c.type]||[],q=o.delegateCount,r=[].slice.call(arguments),s=!c.exclusive&&!c.namespace,t=p.event.special[c.type]||{},u=[];r[0]=c,c.delegateTarget=this;if(t.preDispatch&&t.preDispatch.call(this,c)===!1)return;if(q&&(!c.button||c.type!=="click")){g=p(this),g.context=this;for(f=c.target;f!=this;f=f.parentNode||this)if(f.disabled!==!0||c.type!=="click"){i={},k=[],g[0]=f;for(d=0;d<q;d++)l=o[d],m=l.selector,i[m]===b&&(i[m]=g.is(m)),i[m]&&k.push(l);k.length&&u.push({elem:f,matches:k})}}o.length>q&&u.push({elem:this,matches:o.slice(q)});for(d=0;d<u.length&&!c.isPropagationStopped();d++){j=u[d],c.currentTarget=j.elem;for(e=0;e<j.matches.length&&!c.isImmediatePropagationStopped();e++){l=j.matches[e];if(s||!c.namespace&&!l.namespace||c.namespace_re&&c.namespace_re.test(l.namespace))c.data=l.data,c.handleObj=l,h=((p.event.special[l.origType]||{}).handle||l.handler).apply(j.elem,r),h!==b&&(c.result=h,h===!1&&(c.preventDefault(),c.stopPropagation()))}}return t.postDispatch&&t.postDispatch.call(this,c),c.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return a.which==null&&(a.which=b.charCode!=null?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,c){var d,f,g,h=c.button,i=c.fromElement;return a.pageX==null&&c.clientX!=null&&(d=a.target.ownerDocument||e,f=d.documentElement,g=d.body,a.pageX=c.clientX+(f&&f.scrollLeft||g&&g.scrollLeft||0)-(f&&f.clientLeft||g&&g.clientLeft||0),a.pageY=c.clientY+(f&&f.scrollTop||g&&g.scrollTop||0)-(f&&f.clientTop||g&&g.clientTop||0)),!a.relatedTarget&&i&&(a.relatedTarget=i===a.target?c.toElement:i),!a.which&&h!==b&&(a.which=h&1?1:h&2?3:h&4?2:0),a}},fix:function(a){if(a[p.expando])return a;var b,c,d=a,f=p.event.fixHooks[a.type]||{},g=f.props?this.props.concat(f.props):this.props;a=p.Event(d);for(b=g.length;b;)c=g[--b],a[c]=d[c];return a.target||(a.target=d.srcElement||e),a.target.nodeType===3&&(a.target=a.target.parentNode),a.metaKey=!!a.metaKey,f.filter?f.filter(a,d):a},special:{ready:{setup:p.bindReady},load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(a,b,c){p.isWindow(this)&&(this.onbeforeunload=c)},teardown:function(a,b){this.onbeforeunload===b&&(this.onbeforeunload=null)}}},simulate:function(a,b,c,d){var e=p.extend(new p.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?p.event.trigger(e,null,b):p.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},p.event.handle=p.event.dispatch,p.removeEvent=e.removeEventListener?function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)}:function(a,b,c){var d="on"+b;a.detachEvent&&(typeof a[d]=="undefined"&&(a[d]=null),a.detachEvent(d,c))},p.Event=function(a,b){if(this instanceof p.Event)a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||a.returnValue===!1||a.getPreventDefault&&a.getPreventDefault()?bb:ba):this.type=a,b&&p.extend(this,b),this.timeStamp=a&&a.timeStamp||p.now(),this[p.expando]=!0;else return new p.Event(a,b)},p.Event.prototype={preventDefault:function(){this.isDefaultPrevented=bb;var a=this.originalEvent;if(!a)return;a.preventDefault?a.preventDefault():a.returnValue=!1},stopPropagation:function(){this.isPropagationStopped=bb;var a=this.originalEvent;if(!a)return;a.stopPropagation&&a.stopPropagation(),a.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=bb,this.stopPropagation()},isDefaultPrevented:ba,isPropagationStopped:ba,isImmediatePropagationStopped:ba},p.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(a,b){p.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj,g=f.selector;if(!e||e!==d&&!p.contains(d,e))a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b;return c}}}),p.support.submitBubbles||(p.event.special.submit={setup:function(){if(p.nodeName(this,"form"))return!1;p.event.add(this,"click._submit keypress._submit",function(a){var c=a.target,d=p.nodeName(c,"input")||p.nodeName(c,"button")?c.form:b;d&&!p._data(d,"_submit_attached")&&(p.event.add(d,"submit._submit",function(a){a._submit_bubble=!0}),p._data(d,"_submit_attached",!0))})},postDispatch:function(a){a._submit_bubble&&(delete a._submit_bubble,this.parentNode&&!a.isTrigger&&p.event.simulate("submit",this.parentNode,a,!0))},teardown:function(){if(p.nodeName(this,"form"))return!1;p.event.remove(this,"._submit")}}),p.support.changeBubbles||(p.event.special.change={setup:function(){if(V.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")p.event.add(this,"propertychange._change",function(a){a.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),p.event.add(this,"click._change",function(a){this._just_changed&&!a.isTrigger&&(this._just_changed=!1),p.event.simulate("change",this,a,!0)});return!1}p.event.add(this,"beforeactivate._change",function(a){var b=a.target;V.test(b.nodeName)&&!p._data(b,"_change_attached")&&(p.event.add(b,"change._change",function(a){this.parentNode&&!a.isSimulated&&!a.isTrigger&&p.event.simulate("change",this.parentNode,a,!0)}),p._data(b,"_change_attached",!0))})},handle:function(a){var b=a.target;if(this!==b||a.isSimulated||a.isTrigger||b.type!=="radio"&&b.type!=="checkbox")return a.handleObj.handler.apply(this,arguments)},teardown:function(){return p.event.remove(this,"._change"),V.test(this.nodeName)}}),p.support.focusinBubbles||p.each({focus:"focusin",blur:"focusout"},function(a,b){var c=0,d=function(a){p.event.simulate(b,a.target,p.event.fix(a),!0)};p.event.special[b]={setup:function(){c++===0&&e.addEventListener(a,d,!0)},teardown:function(){--c===0&&e.removeEventListener(a,d,!0)}}}),p.fn.extend({on:function(a,c,d,e,f){var g,h;if(typeof a=="object"){typeof c!="string"&&(d=d||c,c=b);for(h in a)this.on(h,c,d,a[h],f);return this}d==null&&e==null?(e=c,d=c=b):e==null&&(typeof c=="string"?(e=d,d=b):(e=d,d=c,c=b));if(e===!1)e=ba;else if(!e)return this;return f===1&&(g=e,e=function(a){return p().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=p.guid++)),this.each(function(){p.event.add(this,a,e,d,c)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,c,d){var e,f;if(a&&a.preventDefault&&a.handleObj)return e=a.handleObj,p(a.delegateTarget).off(e.namespace?e.origType+"."+e.namespace:e.origType,e.selector,e.handler),this;if(typeof a=="object"){for(f in a)this.off(f,c,a[f]);return this}if(c===!1||typeof c=="function")d=c,c=b;return d===!1&&(d=ba),this.each(function(){p.event.remove(this,a,d,c)})},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},live:function(a,b,c){return p(this.context).on(a,this.selector,b,c),this},die:function(a,b){return p(this.context).off(a,this.selector||"**",b),this},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return arguments.length==1?this.off(a,"**"):this.off(b,a||"**",c)},trigger:function(a,b){return this.each(function(){p.event.trigger(a,b,this)})},triggerHandler:function(a,b){if(this[0])return p.event.trigger(a,b,this[0],!0)},toggle:function(a){var b=arguments,c=a.guid||p.guid++,d=0,e=function(c){var e=(p._data(this,"lastToggle"+a.guid)||0)%d;return p._data(this,"lastToggle"+a.guid,e+1),c.preventDefault(),b[e].apply(this,arguments)||!1};e.guid=c;while(d<b.length)b[d++].guid=c;return this.click(e)},hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),p.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){p.fn[b]=function(a,c){return c==null&&(c=a,a=null),arguments.length>0?this.on(b,null,a,c):this.trigger(b)},Y.test(b)&&(p.event.fixHooks[b]=p.event.keyHooks),Z.test(b)&&(p.event.fixHooks[b]=p.event.mouseHooks)}),function(a,b){function bd(a,b,c,d){var e=0,f=b.length;for(;e<f;e++)Z(a,b[e],c,d)}function be(a,b,c,d,e,f){var g,h=$.setFilters[b.toLowerCase()];return h||Z.error(b),(a||!(g=e))&&bd(a||"*",d,g=[],e),g.length>0?h(g,c,f):[]}function bf(a,c,d,e,f){var g,h,i,j,k,l,m,n,p=0,q=f.length,s=L.POS,t=new RegExp("^"+s.source+"(?!"+r+")","i"),u=function(){var a=1,c=arguments.length-2;for(;a<c;a++)arguments[a]===b&&(g[a]=b)};for(;p<q;p++){s.exec(""),a=f[p],j=[],i=0,k=e;while(g=s.exec(a)){n=s.lastIndex=g.index+g[0].length;if(n>i){m=a.slice(i,g.index),i=n,l=[c],B.test(m)&&(k&&(l=k),k=e);if(h=H.test(m))m=m.slice(0,-5).replace(B,"$&*");g.length>1&&g[0].replace(t,u),k=be(m,g[1],g[2],l,k,h)}}k?(j=j.concat(k),(m=a.slice(i))&&m!==")"?B.test(m)?bd(m,j,d,e):Z(m,c,d,e?e.concat(k):k):o.apply(d,j)):Z(a,c,d,e)}return q===1?d:Z.uniqueSort(d)}function bg(a,b,c){var d,e,f,g=[],i=0,j=D.exec(a),k=!j.pop()&&!j.pop(),l=k&&a.match(C)||[""],m=$.preFilter,n=$.filter,o=!c&&b!==h;for(;(e=l[i])!=null&&k;i++){g.push(d=[]),o&&(e=" "+e);while(e){k=!1;if(j=B.exec(e))e=e.slice(j[0].length),k=d.push({part:j.pop().replace(A," "),captures:j});for(f in n)(j=L[f].exec(e))&&(!m[f]||(j=m[f](j,b,c)))&&(e=e.slice(j.shift().length),k=d.push({part:f,captures:j}));if(!k)break}}return k||Z.error(a),g}function bh(a,b,e){var f=b.dir,g=m++;return a||(a=function(a){return a===e}),b.first?function(b,c){while(b=b[f])if(b.nodeType===1)return a(b,c)&&b}:function(b,e){var h,i=g+"."+d,j=i+"."+c;while(b=b[f])if(b.nodeType===1){if((h=b[q])===j)return b.sizset;if(typeof h=="string"&&h.indexOf(i)===0){if(b.sizset)return b}else{b[q]=j;if(a(b,e))return b.sizset=!0,b;b.sizset=!1}}}}function bi(a,b){return a?function(c,d){var e=b(c,d);return e&&a(e===!0?c:e,d)}:b}function bj(a,b,c){var d,e,f=0;for(;d=a[f];f++)$.relative[d.part]?e=bh(e,$.relative[d.part],b):(d.captures.push(b,c),e=bi(e,$.filter[d.part].apply(null,d.captures)));return e}function bk(a){return function(b,c){var d,e=0;for(;d=a[e];e++)if(d(b,c))return!0;return!1}}var c,d,e,f,g,h=a.document,i=h.documentElement,j="undefined",k=!1,l=!0,m=0,n=[].slice,o=[].push,q=("sizcache"+Math.random()).replace(".",""),r="[\\x20\\t\\r\\n\\f]",s="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",t=s.replace("w","w#"),u="([*^$|!~]?=)",v="\\["+r+"*("+s+")"+r+"*(?:"+u+r+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+t+")|)|)"+r+"*\\]",w=":("+s+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|((?:[^,]|\\\\,|(?:,(?=[^\\[]*\\]))|(?:,(?=[^\\(]*\\))))*))\\)|)",x=":(nth|eq|gt|lt|first|last|even|odd)(?:\\((\\d*)\\)|)(?=[^-]|$)",y=r+"*([\\x20\\t\\r\\n\\f>+~])"+r+"*",z="(?=[^\\x20\\t\\r\\n\\f])(?:\\\\.|"+v+"|"+w.replace(2,7)+"|[^\\\\(),])+",A=new RegExp("^"+r+"+|((?:^|[^\\\\])(?:\\\\.)*)"+r+"+$","g"),B=new RegExp("^"+y),C=new RegExp(z+"?(?="+r+"*,|$)","g"),D=new RegExp("^(?:(?!,)(?:(?:^|,)"+r+"*"+z+")*?|"+r+"*(.*?))(\\)|$)"),E=new RegExp(z.slice(19,-6)+"\\x20\\t\\r\\n\\f>+~])+|"+y,"g"),F=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,G=/[\x20\t\r\n\f]*[+~]/,H=/:not\($/,I=/h\d/i,J=/input|select|textarea|button/i,K=/\\(?!\\)/g,L={ID:new RegExp("^#("+s+")"),CLASS:new RegExp("^\\.("+s+")"),NAME:new RegExp("^\\[name=['\"]?("+s+")['\"]?\\]"),TAG:new RegExp("^("+s.replace("[-","[-\\*")+")"),ATTR:new RegExp("^"+v),PSEUDO:new RegExp("^"+w),CHILD:new RegExp("^:(only|nth|last|first)-child(?:\\("+r+"*(even|odd|(([+-]|)(\\d*)n|)"+r+"*(?:([+-]|)"+r+"*(\\d+)|))"+r+"*\\)|)","i"),POS:new RegExp(x,"ig"),needsContext:new RegExp("^"+r+"*[>+~]|"+x,"i")},M={},N=[],O={},P=[],Q=function(a){return a.sizzleFilter=!0,a},R=function(a){return function(b){return b.nodeName.toLowerCase()==="input"&&b.type===a}},S=function(a){return function(b){var c=b.nodeName.toLowerCase();return(c==="input"||c==="button")&&b.type===a}},T=function(a){var b=!1,c=h.createElement("div");try{b=a(c)}catch(d){}return c=null,b},U=T(function(a){a.innerHTML="<select></select>";var b=typeof a.lastChild.getAttribute("multiple");return b!=="boolean"&&b!=="string"}),V=T(function(a){a.id=q+0,a.innerHTML="<a name='"+q+"'></a><div name='"+q+"'></div>",i.insertBefore(a,i.firstChild);var b=h.getElementsByName&&h.getElementsByName(q).length===2+h.getElementsByName(q+0).length;return g=!h.getElementById(q),i.removeChild(a),b}),W=T(function(a){return a.appendChild(h.createComment("")),a.getElementsByTagName("*").length===0}),X=T(function(a){return a.innerHTML="<a href='#'></a>",a.firstChild&&typeof a.firstChild.getAttribute!==j&&a.firstChild.getAttribute("href")==="#"}),Y=T(function(a){return a.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!a.getElementsByClassName||a.getElementsByClassName("e").length===0?!1:(a.lastChild.className="e",a.getElementsByClassName("e").length!==1)}),Z=function(a,b,c,d){c=c||[],b=b||h;var e,f,g,i,j=b.nodeType;if(j!==1&&j!==9)return[];if(!a||typeof a!="string")return c;g=ba(b);if(!g&&!d)if(e=F.exec(a))if(i=e[1]){if(j===9){f=b.getElementById(i);if(!f||!f.parentNode)return c;if(f.id===i)return c.push(f),c}else if(b.ownerDocument&&(f=b.ownerDocument.getElementById(i))&&bb(b,f)&&f.id===i)return c.push(f),c}else{if(e[2])return o.apply(c,n.call(b.getElementsByTagName(a),0)),c;if((i=e[3])&&Y&&b.getElementsByClassName)return o.apply(c,n.call(b.getElementsByClassName(i),0)),c}return bm(a,b,c,d,g)},$=Z.selectors={cacheLength:50,match:L,order:["ID","TAG"],attrHandle:{},createPseudo:Q,find:{ID:g?function(a,b,c){if(typeof b.getElementById!==j&&!c){var d=b.getElementById(a);return d&&d.parentNode?[d]:[]}}:function(a,c,d){if(typeof c.getElementById!==j&&!d){var e=c.getElementById(a);return e?e.id===a||typeof e.getAttributeNode!==j&&e.getAttributeNode("id").value===a?[e]:b:[]}},TAG:W?function(a,b){if(typeof b.getElementsByTagName!==j)return b.getElementsByTagName(a)}:function(a,b){var c=b.getElementsByTagName(a);if(a==="*"){var d,e=[],f=0;for(;d=c[f];f++)d.nodeType===1&&e.push(d);return e}return c}},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(K,""),a[3]=(a[4]||a[5]||"").replace(K,""),a[2]==="~="&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),a[1]==="nth"?(a[2]||Z.error(a[0]),a[3]=+(a[3]?a[4]+(a[5]||1):2*(a[2]==="even"||a[2]==="odd")),a[4]=+(a[6]+a[7]||a[2]==="odd")):a[2]&&Z.error(a[0]),a},PSEUDO:function(a){var b,c=a[4];return L.CHILD.test(a[0])?null:(c&&(b=D.exec(c))&&b.pop()&&(a[0]=a[0].slice(0,b[0].length-c.length-1),c=b[0].slice(0,-1)),a.splice(2,3,c||a[3]),a)}},filter:{ID:g?function(a){return a=a.replace(K,""),function(b){return b.getAttribute("id")===a}}:function(a){return a=a.replace(K,""),function(b){var c=typeof b.getAttributeNode!==j&&b.getAttributeNode("id");return c&&c.value===a}},TAG:function(a){return a==="*"?function(){return!0}:(a=a.replace(K,"").toLowerCase(),function(b){return b.nodeName&&b.nodeName.toLowerCase()===a})},CLASS:function(a){var b=M[a];return b||(b=M[a]=new RegExp("(^|"+r+")"+a+"("+r+"|$)"),N.push(a),N.length>$.cacheLength&&delete M[N.shift()]),function(a){return b.test(a.className||typeof a.getAttribute!==j&&a.getAttribute("class")||"")}},ATTR:function(a,b,c){return b?function(d){var e=Z.attr(d,a),f=e+"";if(e==null)return b==="!=";switch(b){case"=":return f===c;case"!=":return f!==c;case"^=":return c&&f.indexOf(c)===0;case"*=":return c&&f.indexOf(c)>-1;case"$=":return c&&f.substr(f.length-c.length)===c;case"~=":return(" "+f+" ").indexOf(c)>-1;case"|=":return f===c||f.substr(0,c.length+1)===c+"-"}}:function(b){return Z.attr(b,a)!=null}},CHILD:function(a,b,c,d){if(a==="nth"){var e=m++;return function(a){var b,f,g=0,h=a;if(c===1&&d===0)return!0;b=a.parentNode;if(b&&(b[q]!==e||!a.sizset)){for(h=b.firstChild;h;h=h.nextSibling)if(h.nodeType===1){h.sizset=++g;if(h===a)break}b[q]=e}return f=a.sizset-d,c===0?f===0:f%c===0&&f/c>=0}}return function(b){var c=b;switch(a){case"only":case"first":while(c=c.previousSibling)if(c.nodeType===1)return!1;if(a==="first")return!0;c=b;case"last":while(c=c.nextSibling)if(c.nodeType===1)return!1;return!0}}},PSEUDO:function(a,b,c,d){var e=$.pseudos[a]||$.pseudos[a.toLowerCase()];return e||Z.error("unsupported pseudo: "+a),e.sizzleFilter?e(b,c,d):e}},pseudos:{not:Q(function(a,b,c){var d=bl(a.replace(A,"$1"),b,c);return function(a){return!d(a)}}),enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&!!a.checked||b==="option"&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},parent:function(a){return!$.pseudos.empty(a)},empty:function(a){var b;a=a.firstChild;while(a){if(a.nodeName>"@"||(b=a.nodeType)===3||b===4)return!1;a=a.nextSibling}return!0},contains:Q(function(a){return function(b){return(b.textContent||b.innerText||bc(b)).indexOf(a)>-1}}),has:Q(function(a){return function(b){return Z(a,b).length>0}}),header:function(a){return I.test(a.nodeName)},text:function(a){var b,c;return a.nodeName.toLowerCase()==="input"&&(b=a.type)==="text"&&((c=a.getAttribute("type"))==null||c.toLowerCase()===b)},radio:R("radio"),checkbox:R("checkbox"),file:R("file"),password:R("password"),image:R("image"),submit:S("submit"),reset:S("reset"),button:function(a){var b=a.nodeName.toLowerCase();return b==="input"&&a.type==="button"||b==="button"},input:function(a){return J.test(a.nodeName)},focus:function(a){var b=a.ownerDocument;return a===b.activeElement&&(!b.hasFocus||b.hasFocus())&&(!!a.type||!!a.href)},active:function(a){return a===a.ownerDocument.activeElement}},setFilters:{first:function(a,b,c){return c?a.slice(1):[a[0]]},last:function(a,b,c){var d=a.pop();return c?a:[d]},even:function(a,b,c){var d=[],e=c?1:0,f=a.length;for(;e<f;e=e+2)d.push(a[e]);return d},odd:function(a,b,c){var d=[],e=c?0:1,f=a.length;for(;e<f;e=e+2)d.push(a[e]);return d},lt:function(a,b,c){return c?a.slice(+b):a.slice(0,+b)},gt:function(a,b,c){return c?a.slice(0,+b+1):a.slice(+b+1)},eq:function(a,b,c){var d=a.splice(+b,1);return c?a:d}}};$.setFilters.nth=$.setFilters.eq,$.filters=$.pseudos,X||($.attrHandle={href:function(a){return a.getAttribute("href",2)},type:function(a){return a.getAttribute("type")}}),V&&($.order.push("NAME"),$.find.NAME=function(a,b){if(typeof b.getElementsByName!==j)return b.getElementsByName(a)}),Y&&($.order.splice(1,0,"CLASS"),$.find.CLASS=function(a,b,c){if(typeof b.getElementsByClassName!==j&&!c)return b.getElementsByClassName(a)});try{n.call(i.childNodes,0)[0].nodeType}catch(_){n=function(a){var b,c=[];for(;b=this[a];a++)c.push(b);return c}}var ba=Z.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?b.nodeName!=="HTML":!1},bb=Z.contains=i.compareDocumentPosition?function(a,b){return!!(a.compareDocumentPosition(b)&16)}:i.contains?function(a,b){var c=a.nodeType===9?a.documentElement:a,d=b.parentNode;return a===d||!!(d&&d.nodeType===1&&c.contains&&c.contains(d))}:function(a,b){while(b=b.parentNode)if(b===a)return!0;return!1},bc=Z.getText=function(a){var b,c="",d=0,e=a.nodeType;if(e){if(e===1||e===9||e===11){if(typeof a.textContent=="string")return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=bc(a)}else if(e===3||e===4)return a.nodeValue}else for(;b=a[d];d++)c+=bc(b);return c};Z.attr=function(a,b){var c,d=ba(a);return d||(b=b.toLowerCase()),$.attrHandle[b]?$.attrHandle[b](a):U||d?a.getAttribute(b):(c=a.getAttributeNode(b),c?typeof a[b]=="boolean"?a[b]?b:null:c.specified?c.value:null:null)},Z.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},[0,0].sort(function(){return l=0}),i.compareDocumentPosition?e=function(a,b){return a===b?(k=!0,0):(!a.compareDocumentPosition||!b.compareDocumentPosition?a.compareDocumentPosition:a.compareDocumentPosition(b)&4)?-1:1}:(e=function(a,b){if(a===b)return k=!0,0;if(a.sourceIndex&&b.sourceIndex)return a.sourceIndex-b.sourceIndex;var c,d,e=[],g=[],h=a.parentNode,i=b.parentNode,j=h;if(h===i)return f(a,b);if(!h)return-1;if(!i)return 1;while(j)e.unshift(j),j=j.parentNode;j=i;while(j)g.unshift(j),j=j.parentNode;c=e.length,d=g.length;for(var l=0;l<c&&l<d;l++)if(e[l]!==g[l])return f(e[l],g[l]);return l===c?f(a,g[l],-1):f(e[l],b,1)},f=function(a,b,c){if(a===b)return c;var d=a.nextSibling;while(d){if(d===b)return-1;d=d.nextSibling}return 1}),Z.uniqueSort=function(a){var b,c=1;if(e){k=l,a.sort(e);if(k)for(;b=a[c];c++)b===a[c-1]&&a.splice(c--,1)}return a};var bl=Z.compile=function(a,b,c){var d,e,f,g=O[a];if(g&&g.context===b)return g;e=bg(a,b,c);for(f=0;d=e[f];f++)e[f]=bj(d,b,c);return g=O[a]=bk(e),g.context=b,g.runs=g.dirruns=0,P.push(a),P.length>$.cacheLength&&delete O[P.shift()],g};Z.matches=function(a,b){return Z(a,null,null,b)},Z.matchesSelector=function(a,b){return Z(b,null,null,[a]).length>0};var bm=function(a,b,e,f,g){a=a.replace(A,"$1");var h,i,j,k,l,m,p,q,r,s=a.match(C),t=a.match(E),u=b.nodeType;if(L.POS.test(a))return bf(a,b,e,f,s);if(f)h=n.call(f,0);else if(s&&s.length===1){if(t.length>1&&u===9&&!g&&(s=L.ID.exec(t[0]))){b=$.find.ID(s[1],b,g)[0];if(!b)return e;a=a.slice(t.shift().length)}q=(s=G.exec(t[0]))&&!s.index&&b.parentNode||b,r=t.pop(),m=r.split(":not")[0];for(j=0,k=$.order.length;j<k;j++){p=$.order[j];if(s=L[p].exec(m)){h=$.find[p]((s[1]||"").replace(K,""),q,g);if(h==null)continue;m===r&&(a=a.slice(0,a.length-r.length)+m.replace(L[p],""),a||o.apply(e,n.call(h,0)));break}}}if(a){i=bl(a,b,g),d=i.dirruns++,h==null&&(h=$.find.TAG("*",G.test(a)&&b.parentNode||b));for(j=0;l=h[j];j++)c=i.runs++,i(l,b)&&e.push(l)}return e};h.querySelectorAll&&function(){var a,b=bm,c=/'|\\/g,d=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,e=[],f=[":active"],g=i.matchesSelector||i.mozMatchesSelector||i.webkitMatchesSelector||i.oMatchesSelector||i.msMatchesSelector;T(function(a){a.innerHTML="<select><option selected></option></select>",a.querySelectorAll("[selected]").length||e.push("\\["+r+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),a.querySelectorAll(":checked").length||e.push(":checked")}),T(function(a){a.innerHTML="<p test=''></p>",a.querySelectorAll("[test^='']").length&&e.push("[*^$]="+r+"*(?:\"\"|'')"),a.innerHTML="<input type='hidden'>",a.querySelectorAll(":enabled").length||e.push(":enabled",":disabled")}),e=e.length&&new RegExp(e.join("|")),bm=function(a,d,f,g,h){if(!g&&!h&&(!e||!e.test(a)))if(d.nodeType===9)try{return o.apply(f,n.call(d.querySelectorAll(a),0)),f}catch(i){}else if(d.nodeType===1&&d.nodeName.toLowerCase()!=="object"){var j=d.getAttribute("id"),k=j||q,l=G.test(a)&&d.parentNode||d;j?k=k.replace(c,"\\$&"):d.setAttribute("id",k);try{return o.apply(f,n.call(l.querySelectorAll(a.replace(C,"[id='"+k+"'] $&")),0)),f}catch(i){}finally{j||d.removeAttribute("id")}}return b(a,d,f,g,h)},g&&(T(function(b){a=g.call(b,"div");try{g.call(b,"[test!='']:sizzle"),f.push($.match.PSEUDO)}catch(c){}}),f=new RegExp(f.join("|")),Z.matchesSelector=function(b,c){c=c.replace(d,"='$1']");if(!ba(b)&&!f.test(c)&&(!e||!e.test(c)))try{var h=g.call(b,c);if(h||a||b.document&&b.document.nodeType!==11)return h}catch(i){}return Z(c,null,null,[b]).length>0})}(),Z.attr=p.attr,p.find=Z,p.expr=Z.selectors,p.expr[":"]=p.expr.pseudos,p.unique=Z.uniqueSort,p.text=Z.getText,p.isXMLDoc=Z.isXML,p.contains=Z.contains}(a);var bc=/Until$/,bd=/^(?:parents|prev(?:Until|All))/,be=/^.[^:#\[\.,]*$/,bf=p.expr.match.needsContext,bg={children:!0,contents:!0,next:!0,prev:!0};p.fn.extend({find:function(a){var b,c,d,e,f,g,h=this;if(typeof a!="string")return p(a).filter(function(){for(b=0,c=h.length;b<c;b++)if(p.contains(h[b],this))return!0});g=this.pushStack("","find",a);for(b=0,c=this.length;b<c;b++){d=g.length,p.find(a,this[b],g);if(b>0)for(e=d;e<g.length;e++)for(f=0;f<d;f++)if(g[f]===g[e]){g.splice(e--,1);break}}return g},has:function(a){var b,c=p(a,this),d=c.length;return this.filter(function(){for(b=0;b<d;b++)if(p.contains(this,c[b]))return!0})},not:function(a){return this.pushStack(bj(this,a,!1),"not",a)},filter:function(a){return this.pushStack(bj(this,a,!0),"filter",a)},is:function(a){return!!a&&(typeof a=="string"?bf.test(a)?p(a,this.context).index(this[0])>=0:p.filter(a,this).length>0:this.filter(a).length>0)},closest:function(a,b){var c,d=0,e=this.length,f=[],g=bf.test(a)||typeof a!="string"?p(a,b||this.context):0;for(;d<e;d++){c=this[d];while(c&&c.ownerDocument&&c!==b&&c.nodeType!==11){if(g?g.index(c)>-1:p.find.matchesSelector(c,a)){f.push(c);break}c=c.parentNode}}return f=f.length>1?p.unique(f):f,this.pushStack(f,"closest",a)},index:function(a){return a?typeof a=="string"?p.inArray(this[0],p(a)):p.inArray(a.jquery?a[0]:a,this):this[0]&&this[0].parentNode?this.prevAll().length:-1},add:function(a,b){var c=typeof a=="string"?p(a,b):p.makeArray(a&&a.nodeType?[a]:a),d=p.merge(this.get(),c);return this.pushStack(bh(c[0])||bh(d[0])?d:p.unique(d))},addBack:function(a){return this.add(a==null?this.prevObject:this.prevObject.filter(a))}}),p.fn.andSelf=p.fn.addBack,p.each({parent:function(a){var b=a.parentNode;return b&&b.nodeType!==11?b:null},parents:function(a){return p.dir(a,"parentNode")},parentsUntil:function(a,b,c){return p.dir(a,"parentNode",c)},next:function(a){return bi(a,"nextSibling")},prev:function(a){return bi(a,"previousSibling")},nextAll:function(a){return p.dir(a,"nextSibling")},prevAll:function(a){return p.dir(a,"previousSibling")},nextUntil:function(a,b,c){return p.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return p.dir(a,"previousSibling",c)},siblings:function(a){return p.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return p.sibling(a.firstChild)},contents:function(a){return p.nodeName(a,"iframe")?a.contentDocument||a.contentWindow.document:p.merge([],a.childNodes)}},function(a,b){p.fn[a]=function(c,d){var e=p.map(this,b,c);return bc.test(a)||(d=c),d&&typeof d=="string"&&(e=p.filter(d,e)),e=this.length>1&&!bg[a]?p.unique(e):e,this.length>1&&bd.test(a)&&(e=e.reverse()),this.pushStack(e,a,k.call(arguments).join(","))}}),p.extend({filter:function(a,b,c){return c&&(a=":not("+a+")"),b.length===1?p.find.matchesSelector(b[0],a)?[b[0]]:[]:p.find.matches(a,b)},dir:function(a,c,d){var e=[],f=a[c];while(f&&f.nodeType!==9&&(d===b||f.nodeType!==1||!p(f).is(d)))f.nodeType===1&&e.push(f),f=f[c];return e},sibling:function(a,b){var c=[];for(;a;a=a.nextSibling)a.nodeType===1&&a!==b&&c.push(a);return c}});var bl="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",bm=/ jQuery\d+="(?:null|\d+)"/g,bn=/^\s+/,bo=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bp=/<([\w:]+)/,bq=/<tbody/i,br=/<|&#?\w+;/,bs=/<(?:script|style|link)/i,bt=/<(?:script|object|embed|option|style)/i,bu=new RegExp("<(?:"+bl+")[\\s/>]","i"),bv=/^(?:checkbox|radio)$/,bw=/checked\s*(?:[^=]|=\s*.checked.)/i,bx=/\/(java|ecma)script/i,by=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,bz={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},bA=bk(e),bB=bA.appendChild(e.createElement("div"));bz.optgroup=bz.option,bz.tbody=bz.tfoot=bz.colgroup=bz.caption=bz.thead,bz.th=bz.td,p.support.htmlSerialize||(bz._default=[1,"X<div>","</div>"]),p.fn.extend({text:function(a){return p.access(this,function(a){return a===b?p.text(this):this.empty().append((this[0]&&this[0].ownerDocument||e).createTextNode(a))},null,a,arguments.length)},wrapAll:function(a){if(p.isFunction(a))return this.each(function(b){p(this).wrapAll(a.call(this,b))});if(this[0]){var b=p(a,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstChild&&a.firstChild.nodeType===1)a=a.firstChild;return a}).append(this)}return this},wrapInner:function(a){return p.isFunction(a)?this.each(function(b){p(this).wrapInner(a.call(this,b))}):this.each(function(){var b=p(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=p.isFunction(a);return this.each(function(c){p(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){p.nodeName(this,"body")||p(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(a){(this.nodeType===1||this.nodeType===11)&&this.appendChild(a)})},prepend:function(){return this.domManip(arguments,!0,function(a){(this.nodeType===1||this.nodeType===11)&&this.insertBefore(a,this.firstChild)})},before:function(){if(!bh(this[0]))return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this)});if(arguments.length){var a=p.clean(arguments);return this.pushStack(p.merge(a,this),"before",this.selector)}},after:function(){if(!bh(this[0]))return this.domManip(arguments,!1,function(a){this.parentNode.insertBefore(a,this.nextSibling)});if(arguments.length){var a=p.clean(arguments);return this.pushStack(p.merge(this,a),"after",this.selector)}},remove:function(a,b){var c,d=0;for(;(c=this[d])!=null;d++)if(!a||p.filter(a,[c]).length)!b&&c.nodeType===1&&(p.cleanData(c.getElementsByTagName("*")),p.cleanData([c])),c.parentNode&&c.parentNode.removeChild(c);return this},empty:function(){var a,b=0;for(;(a=this[b])!=null;b++){a.nodeType===1&&p.cleanData(a.getElementsByTagName("*"));while(a.firstChild)a.removeChild(a.firstChild)}return this},clone:function(a,b){return a=a==null?!1:a,b=b==null?a:b,this.map(function(){return p.clone(this,a,b)})},html:function(a){return p.access(this,function(a){var c=this[0]||{},d=0,e=this.length;if(a===b)return c.nodeType===1?c.innerHTML.replace(bm,""):b;if(typeof a=="string"&&!bs.test(a)&&(p.support.htmlSerialize||!bu.test(a))&&(p.support.leadingWhitespace||!bn.test(a))&&!bz[(bp.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(bo,"<$1></$2>");try{for(;d<e;d++)c=this[d]||{},c.nodeType===1&&(p.cleanData(c.getElementsByTagName("*")),c.innerHTML=a);c=0}catch(f){}}c&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(a){return bh(this[0])?this.length?this.pushStack(p(p.isFunction(a)?a():a),"replaceWith",a):this:p.isFunction(a)?this.each(function(b){var c=p(this),d=c.html();c.replaceWith(a.call(this,b,d))}):(typeof a!="string"&&(a=p(a).detach()),this.each(function(){var b=this.nextSibling,c=this.parentNode;p(this).remove(),b?p(b).before(a):p(c).append(a)}))},detach:function(a){return this.remove(a,!0)},domManip:function(a,c,d){a=[].concat.apply([],a);var e,f,g,h,i=0,j=a[0],k=[],l=this.length;if(!p.support.checkClone&&l>1&&typeof j=="string"&&bw.test(j))return this.each(function(){p(this).domManip(a,c,d)});if(p.isFunction(j))return this.each(function(e){var f=p(this);a[0]=j.call(this,e,c?f.html():b),f.domManip(a,c,d)});if(this[0]){e=p.buildFragment(a,this,k),g=e.fragment,f=g.firstChild,g.childNodes.length===1&&(g=f);if(f){c=c&&p.nodeName(f,"tr");for(h=e.cacheable||l-1;i<l;i++)d.call(c&&p.nodeName(this[i],"table")?bC(this[i],"tbody"):this[i],i===h?g:p.clone(g,!0,!0))}g=f=null,k.length&&p.each(k,function(a,b){b.src?p.ajax?p.ajax({url:b.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):p.error("no ajax"):p.globalEval((b.text||b.textContent||b.innerHTML||"").replace(by,"")),b.parentNode&&b.parentNode.removeChild(b)})}return this}}),p.buildFragment=function(a,c,d){var f,g,h,i=a[0];return c=c||e,c=(c[0]||c).ownerDocument||c[0]||c,typeof c.createDocumentFragment=="undefined"&&(c=e),a.length===1&&typeof i=="string"&&i.length<512&&c===e&&i.charAt(0)==="<"&&!bt.test(i)&&(p.support.checkClone||!bw.test(i))&&(p.support.html5Clone||!bu.test(i))&&(g=!0,f=p.fragments[i],h=f!==b),f||(f=c.createDocumentFragment(),p.clean(a,c,f,d),g&&(p.fragments[i]=h&&f)),{fragment:f,cacheable:g}},p.fragments={},p.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){p.fn[a]=function(c){var d,e=0,f=[],g=p(c),h=g.length,i=this.length===1&&this[0].parentNode;if((i==null||i&&i.nodeType===11&&i.childNodes.length===1)&&h===1)return g[b](this[0]),this;for(;e<h;e++)d=(e>0?this.clone(!0):this).get(),p(g[e])[b](d),f=f.concat(d);return this.pushStack(f,a,g.selector)}}),p.extend({clone:function(a,b,c){var d,e,f,g;p.support.html5Clone||p.isXMLDoc(a)||!bu.test("<"+a.nodeName+">")?g=a.cloneNode(!0):(bB.innerHTML=a.outerHTML,bB.removeChild(g=bB.firstChild));if((!p.support.noCloneEvent||!p.support.noCloneChecked)&&(a.nodeType===1||a.nodeType===11)&&!p.isXMLDoc(a)){bE(a,g),d=bF(a),e=bF(g);for(f=0;d[f];++f)e[f]&&bE(d[f],e[f])}if(b){bD(a,g);if(c){d=bF(a),e=bF(g);for(f=0;d[f];++f)bD(d[f],e[f])}}return d=e=null,g},clean:function(a,b,c,d){var f,g,h,i,j,k,l,m,n,o,q,r,s=0,t=[];if(!b||typeof b.createDocumentFragment=="undefined")b=e;for(g=b===e&&bA;(h=a[s])!=null;s++){typeof h=="number"&&(h+="");if(!h)continue;if(typeof h=="string")if(!br.test(h))h=b.createTextNode(h);else{g=g||bk(b),l=l||g.appendChild(b.createElement("div")),h=h.replace(bo,"<$1></$2>"),i=(bp.exec(h)||["",""])[1].toLowerCase(),j=bz[i]||bz._default,k=j[0],l.innerHTML=j[1]+h+j[2];while(k--)l=l.lastChild;if(!p.support.tbody){m=bq.test(h),n=i==="table"&&!m?l.firstChild&&l.firstChild.childNodes:j[1]==="<table>"&&!m?l.childNodes:[];for(f=n.length-1;f>=0;--f)p.nodeName(n[f],"tbody")&&!n[f].childNodes.length&&n[f].parentNode.removeChild(n[f])}!p.support.leadingWhitespace&&bn.test(h)&&l.insertBefore(b.createTextNode(bn.exec(h)[0]),l.firstChild),h=l.childNodes,l=g.lastChild}h.nodeType?t.push(h):t=p.merge(t,h)}l&&(g.removeChild(l),h=l=g=null);if(!p.support.appendChecked)for(s=0;(h=t[s])!=null;s++)p.nodeName(h,"input")?bG(h):typeof h.getElementsByTagName!="undefined"&&p.grep(h.getElementsByTagName("input"),bG);if(c){q=function(a){if(!a.type||bx.test(a.type))return d?d.push(a.parentNode?a.parentNode.removeChild(a):a):c.appendChild(a)};for(s=0;(h=t[s])!=null;s++)if(!p.nodeName(h,"script")||!q(h))c.appendChild(h),typeof h.getElementsByTagName!="undefined"&&(r=p.grep(p.merge([],h.getElementsByTagName("script")),q),t.splice.apply(t,[s+1,0].concat(r)),s+=r.length)}return t},cleanData:function(a,b){var c,d,e,f,g=0,h=p.expando,i=p.cache,j=p.support.deleteExpando,k=p.event.special;for(;(e=a[g])!=null;g++)if(b||p.acceptData(e)){d=e[h],c=d&&i[d];if(c){if(c.events)for(f in c.events)k[f]?p.event.remove(e,f):p.removeEvent(e,f,c.handle);i[d]&&(delete i[d],j?delete e[h]:e.removeAttribute?e.removeAttribute(h):e[h]=null,p.deletedIds.push(d))}}}}),function(){var a,b;p.uaMatch=function(a){a=a.toLowerCase();var b=/(chrome)[ \/]([\w.]+)/.exec(a)||/(webkit)[ \/]([\w.]+)/.exec(a)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(a)||/(msie) ([\w.]+)/.exec(a)||a.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(a)||[];return{browser:b[1]||"",version:b[2]||"0"}},a=p.uaMatch(g.userAgent),b={},a.browser&&(b[a.browser]=!0,b.version=a.version),b.webkit&&(b.safari=!0),p.browser=b,p.sub=function(){function a(b,c){return new a.fn.init(b,c)}p.extend(!0,a,this),a.superclass=this,a.fn=a.prototype=this(),a.fn.constructor=a,a.sub=this.sub,a.fn.init=function c(c,d){return d&&d instanceof p&&!(d instanceof a)&&(d=a(d)),p.fn.init.call(this,c,d,b)},a.fn.init.prototype=a.fn;var b=a(e);return a}}();var bH,bI,bJ,bK=/alpha\([^)]*\)/i,bL=/opacity=([^)]*)/,bM=/^(top|right|bottom|left)$/,bN=/^margin/,bO=new RegExp("^("+q+")(.*)$","i"),bP=new RegExp("^("+q+")(?!px)[a-z%]+$","i"),bQ=new RegExp("^([-+])=("+q+")","i"),bR={},bS={position:"absolute",visibility:"hidden",display:"block"},bT={letterSpacing:0,fontWeight:400,lineHeight:1},bU=["Top","Right","Bottom","Left"],bV=["Webkit","O","Moz","ms"],bW=p.fn.toggle;p.fn.extend({css:function(a,c){return p.access(this,function(a,c,d){return d!==b?p.style(a,c,d):p.css(a,c)},a,c,arguments.length>1)},show:function(){return bZ(this,!0)},hide:function(){return bZ(this)},toggle:function(a,b){var c=typeof a=="boolean";return p.isFunction(a)&&p.isFunction(b)?bW.apply(this,arguments):this.each(function(){(c?a:bY(this))?p(this).show():p(this).hide()})}}),p.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=bH(a,"opacity");return c===""?"1":c}}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":p.support.cssFloat?"cssFloat":"styleFloat"},style:function(a,c,d,e){if(!a||a.nodeType===3||a.nodeType===8||!a.style)return;var f,g,h,i=p.camelCase(c),j=a.style;c=p.cssProps[i]||(p.cssProps[i]=bX(j,i)),h=p.cssHooks[c]||p.cssHooks[i];if(d===b)return h&&"get"in h&&(f=h.get(a,!1,e))!==b?f:j[c];g=typeof d,g==="string"&&(f=bQ.exec(d))&&(d=(f[1]+1)*f[2]+parseFloat(p.css(a,c)),g="number");if(d==null||g==="number"&&isNaN(d))return;g==="number"&&!p.cssNumber[i]&&(d+="px");if(!h||!("set"in h)||(d=h.set(a,d,e))!==b)try{j[c]=d}catch(k){}},css:function(a,c,d,e){var f,g,h,i=p.camelCase(c);return c=p.cssProps[i]||(p.cssProps[i]=bX(a.style,i)),h=p.cssHooks[c]||p.cssHooks[i],h&&"get"in h&&(f=h.get(a,!0,e)),f===b&&(f=bH(a,c)),f==="normal"&&c in bT&&(f=bT[c]),d||e!==b?(g=parseFloat(f),d||p.isNumeric(g)?g||0:f):f},swap:function(a,b,c){var d,e,f={};for(e in b)f[e]=a.style[e],a.style[e]=b[e];d=c.call(a);for(e in b)a.style[e]=f[e];return d}}),a.getComputedStyle?bH=function(a,b){var c,d,e,f,g=getComputedStyle(a,null),h=a.style;return g&&(c=g[b],c===""&&!p.contains(a.ownerDocument.documentElement,a)&&(c=p.style(a,b)),bP.test(c)&&bN.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=c,c=g.width,h.width=d,h.minWidth=e,h.maxWidth=f)),c}:e.documentElement.currentStyle&&(bH=function(a,b){var c,d,e=a.currentStyle&&a.currentStyle[b],f=a.style;return e==null&&f&&f[b]&&(e=f[b]),bP.test(e)&&!bM.test(b)&&(c=f.left,d=a.runtimeStyle&&a.runtimeStyle.left,d&&(a.runtimeStyle.left=a.currentStyle.left),f.left=b==="fontSize"?"1em":e,e=f.pixelLeft+"px",f.left=c,d&&(a.runtimeStyle.left=d)),e===""?"auto":e}),p.each(["height","width"],function(a,b){p.cssHooks[b]={get:function(a,c,d){if(c)return a.offsetWidth!==0||bH(a,"display")!=="none"?ca(a,b,d):p.swap(a,bS,function(){return ca(a,b,d)})},set:function(a,c,d){return b$(a,c,d?b_(a,b,d,p.support.boxSizing&&p.css(a,"boxSizing")==="border-box"):0)}}}),p.support.opacity||(p.cssHooks.opacity={get:function(a,b){return bL.test((b&&a.currentStyle?a.currentStyle.filter:a.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":b?"1":""},set:function(a,b){var c=a.style,d=a.currentStyle,e=p.isNumeric(b)?"alpha(opacity="+b*100+")":"",f=d&&d.filter||c.filter||"";c.zoom=1;if(b>=1&&p.trim(f.replace(bK,""))===""&&c.removeAttribute){c.removeAttribute("filter");if(d&&!d.filter)return}c.filter=bK.test(f)?f.replace(bK,e):f+" "+e}}),p(function(){p.support.reliableMarginRight||(p.cssHooks.marginRight={get:function(a,b){return p.swap(a,{display:"inline-block"},function(){if(b)return bH(a,"marginRight")})}}),!p.support.pixelPosition&&p.fn.position&&p.each(["top","left"],function(a,b){p.cssHooks[b]={get:function(a,c){if(c){var d=bH(a,b);return bP.test(d)?p(a).position()[b]+"px":d}}}})}),p.expr&&p.expr.filters&&(p.expr.filters.hidden=function(a){return a.offsetWidth===0&&a.offsetHeight===0||!p.support.reliableHiddenOffsets&&(a.style&&a.style.display||bH(a,"display"))==="none"},p.expr.filters.visible=function(a){return!p.expr.filters.hidden(a)}),p.each({margin:"",padding:"",border:"Width"},function(a,b){p.cssHooks[a+b]={expand:function(c){var d,e=typeof c=="string"?c.split(" "):[c],f={};for(d=0;d<4;d++)f[a+bU[d]+b]=e[d]||e[d-2]||e[0];return f}},bN.test(a)||(p.cssHooks[a+b].set=b$)});var cc=/%20/g,cd=/\[\]$/,ce=/\r?\n/g,cf=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,cg=/^(?:select|textarea)/i;p.fn.extend({serialize:function(){return p.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?p.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||cg.test(this.nodeName)||cf.test(this.type))}).map(function(a,b){var c=p(this).val();return c==null?null:p.isArray(c)?p.map(c,function(a,c){return{name:b.name,value:a.replace(ce,"\r\n")}}):{name:b.name,value:c.replace(ce,"\r\n")}}).get()}}),p.param=function(a,c){var d,e=[],f=function(a,b){b=p.isFunction(b)?b():b==null?"":b,e[e.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};c===b&&(c=p.ajaxSettings&&p.ajaxSettings.traditional);if(p.isArray(a)||a.jquery&&!p.isPlainObject(a))p.each(a,function(){f(this.name,this.value)});else for(d in a)ch(d,a[d],c,f);return e.join("&").replace(cc,"+")};var ci,cj,ck=/#.*$/,cl=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,cm=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,cn=/^(?:GET|HEAD)$/,co=/^\/\//,cp=/\?/,cq=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,cr=/([?&])_=[^&]*/,cs=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,ct=p.fn.load,cu={},cv={},cw=["*/"]+["*"];try{ci=f.href}catch(cx){ci=e.createElement("a"),ci.href="",ci=ci.href}cj=cs.exec(ci.toLowerCase())||[],p.fn.load=function(a,c,d){if(typeof a!="string"&&ct)return ct.apply(this,arguments);if(!this.length)return this;var e,f,g,h=this,i=a.indexOf(" ");return i>=0&&(e=a.slice(i,a.length),a=a.slice(0,i)),p.isFunction(c)?(d=c,c=b):typeof c=="object"&&(f="POST"),p.ajax({url:a,type:f,dataType:"html",data:c,complete:function(a,b){d&&h.each(d,g||[a.responseText,b,a])}}).done(function(a){g=arguments,h.html(e?p("<div>").append(a.replace(cq,"")).find(e):a)}),this},p.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(a,b){p.fn[b]=function(a){return this.on(b,a)}}),p.each(["get","post"],function(a,c){p[c]=function(a,d,e,f){return p.isFunction(d)&&(f=f||e,e=d,d=b),p.ajax({type:c,url:a,data:d,success:e,dataType:f})}}),p.extend({getScript:function(a,c){return p.get(a,b,c,"script")},getJSON:function(a,b,c){return p.get(a,b,c,"json")},ajaxSetup:function(a,b){return b?cA(a,p.ajaxSettings):(b=a,a=p.ajaxSettings),cA(a,b),a},ajaxSettings:{url:ci,isLocal:cm.test(cj[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":cw},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":a.String,"text html":!0,"text json":p.parseJSON,"text xml":p.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:cy(cu),ajaxTransport:cy(cv),ajax:function(a,c){function y(a,c,f,i){var k,s,t,u,w,y=c;if(v===2)return;v=2,h&&clearTimeout(h),g=b,e=i||"",x.readyState=a>0?4:0,f&&(u=cB(l,x,f));if(a>=200&&a<300||a===304)l.ifModified&&(w=x.getResponseHeader("Last-Modified"),w&&(p.lastModified[d]=w),w=x.getResponseHeader("Etag"),w&&(p.etag[d]=w)),a===304?(y="notmodified",k=!0):(k=cC(l,u),y=k.state,s=k.data,t=k.error,k=!t);else{t=y;if(!y||a)y="error",a<0&&(a=0)}x.status=a,x.statusText=""+(c||y),k?o.resolveWith(m,[s,y,x]):o.rejectWith(m,[x,y,t]),x.statusCode(r),r=b,j&&n.trigger("ajax"+(k?"Success":"Error"),[x,l,k?s:t]),q.fireWith(m,[x,y]),j&&(n.trigger("ajaxComplete",[x,l]),--p.active||p.event.trigger("ajaxStop"))}typeof a=="object"&&(c=a,a=b),c=c||{};var d,e,f,g,h,i,j,k,l=p.ajaxSetup({},c),m=l.context||l,n=m!==l&&(m.nodeType||m instanceof p)?p(m):p.event,o=p.Deferred(),q=p.Callbacks("once memory"),r=l.statusCode||{},t={},u={},v=0,w="canceled",x={readyState:0,setRequestHeader:function(a,b){if(!v){var c=a.toLowerCase();a=u[c]=u[c]||a,t[a]=b}return this},getAllResponseHeaders:function(){return v===2?e:null},getResponseHeader:function(a){var c;if(v===2){if(!f){f={};while(c=cl.exec(e))f[c[1].toLowerCase()]=c[2]}c=f[a.toLowerCase()]}return c===b?null:c},overrideMimeType:function(a){return v||(l.mimeType=a),this},abort:function(a){return a=a||w,g&&g.abort(a),y(0,a),this}};o.promise(x),x.success=x.done,x.error=x.fail,x.complete=q.add,x.statusCode=function(a){if(a){var b;if(v<2)for(b in a)r[b]=[r[b],a[b]];else b=a[x.status],x.always(b)}return this},l.url=((a||l.url)+"").replace(ck,"").replace(co,cj[1]+"//"),l.dataTypes=p.trim(l.dataType||"*").toLowerCase().split(s),l.crossDomain==null&&(i=cs.exec(l.url.toLowerCase()),l.crossDomain=!(!i||i[1]==cj[1]&&i[2]==cj[2]&&(i[3]||(i[1]==="http:"?80:443))==(cj[3]||(cj[1]==="http:"?80:443)))),l.data&&l.processData&&typeof l.data!="string"&&(l.data=p.param(l.data,l.traditional)),cz(cu,l,c,x);if(v===2)return x;j=l.global,l.type=l.type.toUpperCase(),l.hasContent=!cn.test(l.type),j&&p.active++===0&&p.event.trigger("ajaxStart");if(!l.hasContent){l.data&&(l.url+=(cp.test(l.url)?"&":"?")+l.data,delete l.data),d=l.url;if(l.cache===!1){var z=p.now(),A=l.url.replace(cr,"$1_="+z);l.url=A+(A===l.url?(cp.test(l.url)?"&":"?")+"_="+z:"")}}(l.data&&l.hasContent&&l.contentType!==!1||c.contentType)&&x.setRequestHeader("Content-Type",l.contentType),l.ifModified&&(d=d||l.url,p.lastModified[d]&&x.setRequestHeader("If-Modified-Since",p.lastModified[d]),p.etag[d]&&x.setRequestHeader("If-None-Match",p.etag[d])),x.setRequestHeader("Accept",l.dataTypes[0]&&l.accepts[l.dataTypes[0]]?l.accepts[l.dataTypes[0]]+(l.dataTypes[0]!=="*"?", "+cw+"; q=0.01":""):l.accepts["*"]);for(k in l.headers)x.setRequestHeader(k,l.headers[k]);if(!l.beforeSend||l.beforeSend.call(m,x,l)!==!1&&v!==2){w="abort";for(k in{success:1,error:1,complete:1})x[k](l[k]);g=cz(cv,l,c,x);if(!g)y(-1,"No Transport");else{x.readyState=1,j&&n.trigger("ajaxSend",[x,l]),l.async&&l.timeout>0&&(h=setTimeout(function(){x.abort("timeout")},l.timeout));try{v=1,g.send(t,y)}catch(B){if(v<2)y(-1,B);else throw B}}return x}return x.abort()},active:0,lastModified:{},etag:{}});var cD=[],cE=/\?/,cF=/(=)\?(?=&|$)|\?\?/,cG=p.now();p.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=cD.pop()||p.expando+"_"+cG++;return this[a]=!0,a}}),p.ajaxPrefilter("json jsonp",function(c,d,e){var f,g,h,i=c.data,j=c.url,k=c.jsonp!==!1,l=k&&cF.test(j),m=k&&!l&&typeof i=="string"&&!(c.contentType||"").indexOf("application/x-www-form-urlencoded")&&cF.test(i);if(c.dataTypes[0]==="jsonp"||l||m)return f=c.jsonpCallback=p.isFunction(c.jsonpCallback)?c.jsonpCallback():c.jsonpCallback,g=a[f],l?c.url=j.replace(cF,"$1"+f):m?c.data=i.replace(cF,"$1"+f):k&&(c.url+=(cE.test(j)?"&":"?")+c.jsonp+"="+f),c.converters["script json"]=function(){return h||p.error(f+" was not called"),h[0]},c.dataTypes[0]="json",a[f]=function(){h=arguments},e.always(function(){a[f]=g,c[f]&&(c.jsonpCallback=d.jsonpCallback,cD.push(f)),h&&p.isFunction(g)&&g(h[0]),h=g=b}),"script"}),p.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(a){return p.globalEval(a),a}}}),p.ajaxPrefilter("script",function(a){a.cache===b&&(a.cache=!1),a.crossDomain&&(a.type="GET",a.global=!1)}),p.ajaxTransport("script",function(a){if(a.crossDomain){var c,d=e.head||e.getElementsByTagName("head")[0]||e.documentElement;return{send:function(f,g){c=e.createElement("script"),c.async="async",a.scriptCharset&&(c.charset=a.scriptCharset),c.src=a.url,c.onload=c.onreadystatechange=function(a,e){if(e||!c.readyState||/loaded|complete/.test(c.readyState))c.onload=c.onreadystatechange=null,d&&c.parentNode&&d.removeChild(c),c=b,e||g(200,"success")},d.insertBefore(c,d.firstChild)},abort:function(){c&&c.onload(0,1)}}}});var cH,cI=a.ActiveXObject?function(){for(var a in cH)cH[a](0,1)}:!1,cJ=0;p.ajaxSettings.xhr=a.ActiveXObject?function(){return!this.isLocal&&cK()||cL()}:cK,function(a){p.extend(p.support,{ajax:!!a,cors:!!a&&"withCredentials"in a})}(p.ajaxSettings.xhr()),p.support.ajax&&p.ajaxTransport(function(c){if(!c.crossDomain||p.support.cors){var d;return{send:function(e,f){var g,h,i=c.xhr();c.username?i.open(c.type,c.url,c.async,c.username,c.password):i.open(c.type,c.url,c.async);if(c.xhrFields)for(h in c.xhrFields)i[h]=c.xhrFields[h];c.mimeType&&i.overrideMimeType&&i.overrideMimeType(c.mimeType),!c.crossDomain&&!e["X-Requested-With"]&&(e["X-Requested-With"]="XMLHttpRequest");try{for(h in e)i.setRequestHeader(h,e[h])}catch(j){}i.send(c.hasContent&&c.data||null),d=function(a,e){var h,j,k,l,m;try{if(d&&(e||i.readyState===4)){d=b,g&&(i.onreadystatechange=p.noop,cI&&delete cH[g]);if(e)i.readyState!==4&&i.abort();else{h=i.status,k=i.getAllResponseHeaders(),l={},m=i.responseXML,m&&m.documentElement&&(l.xml=m);try{l.text=i.responseText}catch(a){}try{j=i.statusText}catch(n){j=""}!h&&c.isLocal&&!c.crossDomain?h=l.text?200:404:h===1223&&(h=204)}}}catch(o){e||f(-1,o)}l&&f(h,j,l,k)},c.async?i.readyState===4?setTimeout(d,0):(g=++cJ,cI&&(cH||(cH={},p(a).unload(cI)),cH[g]=d),i.onreadystatechange=d):d()},abort:function(){d&&d(0,1)}}}});var cM,cN,cO=/^(?:toggle|show|hide)$/,cP=new RegExp("^(?:([-+])=|)("+q+")([a-z%]*)$","i"),cQ=/queueHooks$/,cR=[cX],cS={"*":[function(a,b){var c,d,e,f=this.createTween(a,b),g=cP.exec(b),h=f.cur(),i=+h||0,j=1;if(g){c=+g[2],d=g[3]||(p.cssNumber[a]?"":"px");if(d!=="px"&&i){i=p.css(f.elem,a,!0)||c||1;do e=j=j||".5",i=i/j,p.style(f.elem,a,i+d),j=f.cur()/h;while(j!==1&&j!==e)}f.unit=d,f.start=i,f.end=g[1]?i+(g[1]+1)*c:c}return f}]};p.Animation=p.extend(cV,{tweener:function(a,b){p.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");var c,d=0,e=a.length;for(;d<e;d++)c=a[d],cS[c]=cS[c]||[],cS[c].unshift(b)},prefilter:function(a,b){b?cR.unshift(a):cR.push(a)}}),p.Tween=cY,cY.prototype={constructor:cY,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(p.cssNumber[c]?"":"px")},cur:function(){var a=cY.propHooks[this.prop];return a&&a.get?a.get(this):cY.propHooks._default.get(this)},run:function(a){var b,c=cY.propHooks[this.prop];return this.pos=b=p.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration),this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):cY.propHooks._default.set(this),this}},cY.prototype.init.prototype=cY.prototype,cY.propHooks={_default:{get:function(a){var b;return a.elem[a.prop]==null||!!a.elem.style&&a.elem.style[a.prop]!=null?(b=p.css(a.elem,a.prop,!1,""),!b||b==="auto"?0:b):a.elem[a.prop]},set:function(a){p.fx.step[a.prop]?p.fx.step[a.prop](a):a.elem.style&&(a.elem.style[p.cssProps[a.prop]]!=null||p.cssHooks[a.prop])?p.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},cY.propHooks.scrollTop=cY.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},p.each(["toggle","show","hide"],function(a,b){var c=p.fn[b];p.fn[b]=function(d,e,f){return d==null||typeof d=="boolean"||!a&&p.isFunction(d)&&p.isFunction(e)?c.apply(this,arguments):this.animate(cZ(b,!0),d,e,f)}}),p.fn.extend({fadeTo:function(a,b,c,d){return this.filter(bY).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=p.isEmptyObject(a),f=p.speed(b,c,d),g=function(){var b=cV(this,p.extend({},a),f);e&&b.stop(!0)};return e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,c,d){var e=function(a){var b=a.stop;delete a.stop,b(d)};return typeof a!="string"&&(d=c,c=a,a=b),c&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,c=a!=null&&a+"queueHooks",f=p.timers,g=p._data(this);if(c)g[c]&&g[c].stop&&e(g[c]);else for(c in g)g[c]&&g[c].stop&&cQ.test(c)&&e(g[c]);for(c=f.length;c--;)f[c].elem===this&&(a==null||f[c].queue===a)&&(f[c].anim.stop(d),b=!1,f.splice(c,1));(b||!d)&&p.dequeue(this,a)})}}),p.each({slideDown:cZ("show"),slideUp:cZ("hide"),slideToggle:cZ("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){p.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),p.speed=function(a,b,c){var d=a&&typeof a=="object"?p.extend({},a):{complete:c||!c&&b||p.isFunction(a)&&a,duration:a,easing:c&&b||b&&!p.isFunction(b)&&b};d.duration=p.fx.off?0:typeof d.duration=="number"?d.duration:d.duration in p.fx.speeds?p.fx.speeds[d.duration]:p.fx.speeds._default;if(d.queue==null||d.queue===!0)d.queue="fx";return d.old=d.complete,d.complete=function(){p.isFunction(d.old)&&d.old.call(this),d.queue&&p.dequeue(this,d.queue)},d},p.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},p.timers=[],p.fx=cY.prototype.init,p.fx.tick=function(){var a,b=p.timers,c=0;for(;c<b.length;c++)a=b[c],!a()&&b[c]===a&&b.splice(c--,1);b.length||p.fx.stop()},p.fx.timer=function(a){a()&&p.timers.push(a)&&!cN&&(cN=setInterval(p.fx.tick,p.fx.interval))},p.fx.interval=13,p.fx.stop=function(){clearInterval(cN),cN=null},p.fx.speeds={slow:600,fast:200,_default:400},p.fx.step={},p.expr&&p.expr.filters&&(p.expr.filters.animated=function(a){return p.grep(p.timers,function(b){return a===b.elem}).length});var c$=/^(?:body|html)$/i;p.fn.offset=function(a){if(arguments.length)return a===b?this:this.each(function(b){p.offset.setOffset(this,a,b)});var c,d,e,f,g,h,i,j,k,l,m=this[0],n=m&&m.ownerDocument;if(!n)return;return(e=n.body)===m?p.offset.bodyOffset(m):(d=n.documentElement,p.contains(d,m)?(c=m.getBoundingClientRect(),f=c_(n),g=d.clientTop||e.clientTop||0,h=d.clientLeft||e.clientLeft||0,i=f.pageYOffset||d.scrollTop,j=f.pageXOffset||d.scrollLeft,k=c.top+i-g,l=c.left+j-h,{top:k,left:l}):{top:0,left:0})},p.offset={bodyOffset:function(a){var b=a.offsetTop,c=a.offsetLeft;return p.support.doesNotIncludeMarginInBodyOffset&&(b+=parseFloat(p.css(a,"marginTop"))||0,c+=parseFloat(p.css(a,"marginLeft"))||0),{top:b,left:c}},setOffset:function(a,b,c){var d=p.css(a,"position");d==="static"&&(a.style.position="relative");var e=p(a),f=e.offset(),g=p.css(a,"top"),h=p.css(a,"left"),i=(d==="absolute"||d==="fixed")&&p.inArray("auto",[g,h])>-1,j={},k={},l,m;i?(k=e.position(),l=k.top,m=k.left):(l=parseFloat(g)||0,m=parseFloat(h)||0),p.isFunction(b)&&(b=b.call(a,c,f)),b.top!=null&&(j.top=b.top-f.top+l),b.left!=null&&(j.left=b.left-f.left+m),"using"in b?b.using.call(a,j):e.css(j)}},p.fn.extend({position:function(){if(!this[0])return;var a=this[0],b=this.offsetParent(),c=this.offset(),d=c$.test(b[0].nodeName)?{top:0,left:0}:b.offset();return c.top-=parseFloat(p.css(a,"marginTop"))||0,c.left-=parseFloat(p.css(a,"marginLeft"))||0,d.top+=parseFloat(p.css(b[0],"borderTopWidth"))||0,d.left+=parseFloat(p.css(b[0],"borderLeftWidth"))||0,{top:c.top-d.top,left:c.left-d.left}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||e.body;while(a&&!c$.test(a.nodeName)&&p.css(a,"position")==="static")a=a.offsetParent;return a||e.body})}}),p.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,c){var d=/Y/.test(c);p.fn[a]=function(e){return p.access(this,function(a,e,f){var g=c_(a);if(f===b)return g?c in g?g[c]:g.document.documentElement[e]:a[e];g?g.scrollTo(d?p(g).scrollLeft():f,d?f:p(g).scrollTop()):a[e]=f},a,e,arguments.length,null)}}),p.each({Height:"height",Width:"width"},function(a,c){p.each({padding:"inner"+a,content:c,"":"outer"+a},function(d,e){p.fn[e]=function(e,f){var g=arguments.length&&(d||typeof e!="boolean"),h=d||(e===!0||f===!0?"margin":"border");return p.access(this,function(c,d,e){var f;return p.isWindow(c)?c.document.documentElement["client"+a]:c.nodeType===9?(f=c.documentElement,Math.max(c.body["scroll"+a],f["scroll"+a],c.body["offset"+a],f["offset"+a],f["client"+a])):e===b?p.css(c,d,e,h):p.style(c,d,e,h)},c,g?e:b,g)}})}),a.jQuery=a.$=p,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return p})})(window);

(function(a,b){function c(b,c){var e=b.nodeName.toLowerCase();if("area"===e){var f=b.parentNode,g=f.name,h;return!b.href||!g||f.nodeName.toLowerCase()!=="map"?!1:(h=a("img[usemap=#"+g+"]")[0],!!h&&d(h))}return(/input|select|textarea|button|object/.test(e)?!b.disabled:"a"==e?b.href||c:c)&&d(b)}function d(b){return!a(b).parents().andSelf().filter(function(){return a.curCSS(this,"visibility")==="hidden"||a.expr.filters.hidden(this)}).length}a.ui=a.ui||{};if(a.ui.version)return;a.extend(a.ui,{version:"1.8.23",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}}),a.fn.extend({propAttr:a.fn.prop||a.fn.attr,_focus:a.fn.focus,focus:function(b,c){return typeof b=="number"?this.each(function(){var d=this;setTimeout(function(){a(d).focus(),c&&c.call(d)},b)}):this._focus.apply(this,arguments)},scrollParent:function(){var b;return a.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?b=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(a.curCSS(this,"position",1))&&/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0):b=this.parents().filter(function(){return/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0),/fixed/.test(this.css("position"))||!b.length?a(document):b},zIndex:function(c){if(c!==b)return this.css("zIndex",c);if(this.length){var d=a(this[0]),e,f;while(d.length&&d[0]!==document){e=d.css("position");if(e==="absolute"||e==="relative"||e==="fixed"){f=parseInt(d.css("zIndex"),10);if(!isNaN(f)&&f!==0)return f}d=d.parent()}}return 0},disableSelection:function(){return this.bind((a.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),a("<a>").outerWidth(1).jquery||a.each(["Width","Height"],function(c,d){function h(b,c,d,f){return a.each(e,function(){c-=parseFloat(a.curCSS(b,"padding"+this,!0))||0,d&&(c-=parseFloat(a.curCSS(b,"border"+this+"Width",!0))||0),f&&(c-=parseFloat(a.curCSS(b,"margin"+this,!0))||0)}),c}var e=d==="Width"?["Left","Right"]:["Top","Bottom"],f=d.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+d]=function(c){return c===b?g["inner"+d].call(this):this.each(function(){a(this).css(f,h(this,c)+"px")})},a.fn["outer"+d]=function(b,c){return typeof b!="number"?g["outer"+d].call(this,b):this.each(function(){a(this).css(f,h(this,b,!0,c)+"px")})}}),a.extend(a.expr[":"],{data:a.expr.createPseudo?a.expr.createPseudo(function(b){return function(c){return!!a.data(c,b)}}):function(b,c,d){return!!a.data(b,d[3])},focusable:function(b){return c(b,!isNaN(a.attr(b,"tabindex")))},tabbable:function(b){var d=a.attr(b,"tabindex"),e=isNaN(d);return(e||d>=0)&&c(b,!e)}}),a(function(){var b=document.body,c=b.appendChild(c=document.createElement("div"));c.offsetHeight,a.extend(c.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),a.support.minHeight=c.offsetHeight===100,a.support.selectstart="onselectstart"in c,b.removeChild(c).style.display="none"}),a.curCSS||(a.curCSS=a.css),a.extend(a.ui,{plugin:{add:function(b,c,d){var e=a.ui[b].prototype;for(var f in d)e.plugins[f]=e.plugins[f]||[],e.plugins[f].push([c,d[f]])},call:function(a,b,c){var d=a.plugins[b];if(!d||!a.element[0].parentNode)return;for(var e=0;e<d.length;e++)a.options[d[e][0]]&&d[e][1].apply(a.element,c)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(b,c){if(a(b).css("overflow")==="hidden")return!1;var d=c&&c==="left"?"scrollLeft":"scrollTop",e=!1;return b[d]>0?!0:(b[d]=1,e=b[d]>0,b[d]=0,e)},isOverAxis:function(a,b,c){return a>b&&a<b+c},isOver:function(b,c,d,e,f,g){return a.ui.isOverAxis(b,d,f)&&a.ui.isOverAxis(c,e,g)}})})(jQuery);;
(function(a,b){if(a.cleanData){var c=a.cleanData;a.cleanData=function(b){for(var d=0,e;(e=b[d])!=null;d++)try{a(e).triggerHandler("remove")}catch(f){}c(b)}}else{var d=a.fn.remove;a.fn.remove=function(b,c){return this.each(function(){return c||(!b||a.filter(b,[this]).length)&&a("*",this).add([this]).each(function(){try{a(this).triggerHandler("remove")}catch(b){}}),d.call(a(this),b,c)})}}a.widget=function(b,c,d){var e=b.split(".")[0],f;b=b.split(".")[1],f=e+"-"+b,d||(d=c,c=a.Widget),a.expr[":"][f]=function(c){return!!a.data(c,b)},a[e]=a[e]||{},a[e][b]=function(a,b){arguments.length&&this._createWidget(a,b)};var g=new c;g.options=a.extend(!0,{},g.options),a[e][b].prototype=a.extend(!0,g,{namespace:e,widgetName:b,widgetEventPrefix:a[e][b].prototype.widgetEventPrefix||b,widgetBaseClass:f},d),a.widget.bridge(b,a[e][b])},a.widget.bridge=function(c,d){a.fn[c]=function(e){var f=typeof e=="string",g=Array.prototype.slice.call(arguments,1),h=this;return e=!f&&g.length?a.extend.apply(null,[!0,e].concat(g)):e,f&&e.charAt(0)==="_"?h:(f?this.each(function(){var d=a.data(this,c),f=d&&a.isFunction(d[e])?d[e].apply(d,g):d;if(f!==d&&f!==b)return h=f,!1}):this.each(function(){var b=a.data(this,c);b?b.option(e||{})._init():a.data(this,c,new d(e,this))}),h)}},a.Widget=function(a,b){arguments.length&&this._createWidget(a,b)},a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:!1},_createWidget:function(b,c){a.data(c,this.widgetName,this),this.element=a(c),this.options=a.extend(!0,{},this.options,this._getCreateOptions(),b);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()}),this._create(),this._trigger("create"),this._init()},_getCreateOptions:function(){return a.metadata&&a.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName),this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled")},widget:function(){return this.element},option:function(c,d){var e=c;if(arguments.length===0)return a.extend({},this.options);if(typeof c=="string"){if(d===b)return this.options[c];e={},e[c]=d}return this._setOptions(e),this},_setOptions:function(b){var c=this;return a.each(b,function(a,b){c._setOption(a,b)}),this},_setOption:function(a,b){return this.options[a]=b,a==="disabled"&&this.widget()[b?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",b),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_trigger:function(b,c,d){var e,f,g=this.options[b];d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent;if(f)for(e in f)e in c||(c[e]=f[e]);return this.element.trigger(c,d),!(a.isFunction(g)&&g.call(this.element[0],c,d)===!1||c.isDefaultPrevented())}}})(jQuery);;
(function(a,b){a.ui=a.ui||{};var c=/left|center|right/,d=/top|center|bottom/,e="center",f={},g=a.fn.position,h=a.fn.offset;a.fn.position=function(b){if(!b||!b.of)return g.apply(this,arguments);b=a.extend({},b);var h=a(b.of),i=h[0],j=(b.collision||"flip").split(" "),k=b.offset?b.offset.split(" "):[0,0],l,m,n;return i.nodeType===9?(l=h.width(),m=h.height(),n={top:0,left:0}):i.setTimeout?(l=h.width(),m=h.height(),n={top:h.scrollTop(),left:h.scrollLeft()}):i.preventDefault?(b.at="left top",l=m=0,n={top:b.of.pageY,left:b.of.pageX}):(l=h.outerWidth(),m=h.outerHeight(),n=h.offset()),a.each(["my","at"],function(){var a=(b[this]||"").split(" ");a.length===1&&(a=c.test(a[0])?a.concat([e]):d.test(a[0])?[e].concat(a):[e,e]),a[0]=c.test(a[0])?a[0]:e,a[1]=d.test(a[1])?a[1]:e,b[this]=a}),j.length===1&&(j[1]=j[0]),k[0]=parseInt(k[0],10)||0,k.length===1&&(k[1]=k[0]),k[1]=parseInt(k[1],10)||0,b.at[0]==="right"?n.left+=l:b.at[0]===e&&(n.left+=l/2),b.at[1]==="bottom"?n.top+=m:b.at[1]===e&&(n.top+=m/2),n.left+=k[0],n.top+=k[1],this.each(function(){var c=a(this),d=c.outerWidth(),g=c.outerHeight(),h=parseInt(a.curCSS(this,"marginLeft",!0))||0,i=parseInt(a.curCSS(this,"marginTop",!0))||0,o=d+h+(parseInt(a.curCSS(this,"marginRight",!0))||0),p=g+i+(parseInt(a.curCSS(this,"marginBottom",!0))||0),q=a.extend({},n),r;b.my[0]==="right"?q.left-=d:b.my[0]===e&&(q.left-=d/2),b.my[1]==="bottom"?q.top-=g:b.my[1]===e&&(q.top-=g/2),f.fractions||(q.left=Math.round(q.left),q.top=Math.round(q.top)),r={left:q.left-h,top:q.top-i},a.each(["left","top"],function(c,e){a.ui.position[j[c]]&&a.ui.position[j[c]][e](q,{targetWidth:l,targetHeight:m,elemWidth:d,elemHeight:g,collisionPosition:r,collisionWidth:o,collisionHeight:p,offset:k,my:b.my,at:b.at})}),a.fn.bgiframe&&c.bgiframe(),c.offset(a.extend(q,{using:b.using}))})},a.ui.position={fit:{left:function(b,c){var d=a(window),e=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft();b.left=e>0?b.left-e:Math.max(b.left-c.collisionPosition.left,b.left)},top:function(b,c){var d=a(window),e=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop();b.top=e>0?b.top-e:Math.max(b.top-c.collisionPosition.top,b.top)}},flip:{left:function(b,c){if(c.at[0]===e)return;var d=a(window),f=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft(),g=c.my[0]==="left"?-c.elemWidth:c.my[0]==="right"?c.elemWidth:0,h=c.at[0]==="left"?c.targetWidth:-c.targetWidth,i=-2*c.offset[0];b.left+=c.collisionPosition.left<0?g+h+i:f>0?g+h+i:0},top:function(b,c){if(c.at[1]===e)return;var d=a(window),f=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop(),g=c.my[1]==="top"?-c.elemHeight:c.my[1]==="bottom"?c.elemHeight:0,h=c.at[1]==="top"?c.targetHeight:-c.targetHeight,i=-2*c.offset[1];b.top+=c.collisionPosition.top<0?g+h+i:f>0?g+h+i:0}}},a.offset.setOffset||(a.offset.setOffset=function(b,c){/static/.test(a.curCSS(b,"position"))&&(b.style.position="relative");var d=a(b),e=d.offset(),f=parseInt(a.curCSS(b,"top",!0),10)||0,g=parseInt(a.curCSS(b,"left",!0),10)||0,h={top:c.top-e.top+f,left:c.left-e.left+g};"using"in c?c.using.call(b,h):d.css(h)},a.fn.offset=function(b){var c=this[0];return!c||!c.ownerDocument?null:b?a.isFunction(b)?this.each(function(c){a(this).offset(b.call(this,c,a(this).offset()))}):this.each(function(){a.offset.setOffset(this,b)}):h.call(this)}),a.curCSS||(a.curCSS=a.css),function(){var b=document.getElementsByTagName("body")[0],c=document.createElement("div"),d,e,g,h,i;d=document.createElement(b?"div":"body"),g={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},b&&a.extend(g,{position:"absolute",left:"-1000px",top:"-1000px"});for(var j in g)d.style[j]=g[j];d.appendChild(c),e=b||document.documentElement,e.insertBefore(d,e.firstChild),c.style.cssText="position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;",h=a(c).offset(function(a,b){return b}).offset(),d.innerHTML="",e.removeChild(d),i=h.top+h.left+(b?2e3:0),f.fractions=i>21&&i<22}()})(jQuery);;
(function(a,b){var c=0;a.widget("ui.autocomplete",{options:{appendTo:"body",autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var b=this,c=this.element[0].ownerDocument,d;this.isMultiLine=this.element.is("textarea"),this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(b.options.disabled||b.element.propAttr("readOnly"))return;d=!1;var e=a.ui.keyCode;switch(c.keyCode){case e.PAGE_UP:b._move("previousPage",c);break;case e.PAGE_DOWN:b._move("nextPage",c);break;case e.UP:b._keyEvent("previous",c);break;case e.DOWN:b._keyEvent("next",c);break;case e.ENTER:case e.NUMPAD_ENTER:b.menu.active&&(d=!0,c.preventDefault());case e.TAB:if(!b.menu.active)return;b.menu.select(c);break;case e.ESCAPE:b.element.val(b.term),b.close(c);break;default:clearTimeout(b.searching),b.searching=setTimeout(function(){b.term!=b.element.val()&&(b.selectedItem=null,b.search(null,c))},b.options.delay)}}).bind("keypress.autocomplete",function(a){d&&(d=!1,a.preventDefault())}).bind("focus.autocomplete",function(){if(b.options.disabled)return;b.selectedItem=null,b.previous=b.element.val()}).bind("blur.autocomplete",function(a){if(b.options.disabled)return;clearTimeout(b.searching),b.closing=setTimeout(function(){b.close(a),b._change(a)},150)}),this._initSource(),this.menu=a("<ul></ul>").addClass("ui-autocomplete").appendTo(a(this.options.appendTo||"body",c)[0]).mousedown(function(c){var d=b.menu.element[0];a(c.target).closest(".ui-menu-item").length||setTimeout(function(){a(document).one("mousedown",function(c){c.target!==b.element[0]&&c.target!==d&&!a.ui.contains(d,c.target)&&b.close()})},1),setTimeout(function(){clearTimeout(b.closing)},13)}).menu({focus:function(a,c){var d=c.item.data("item.autocomplete");!1!==b._trigger("focus",a,{item:d})&&/^key/.test(a.originalEvent.type)&&b.element.val(d.value)},selected:function(a,d){var e=d.item.data("item.autocomplete"),f=b.previous;b.element[0]!==c.activeElement&&(b.element.focus(),b.previous=f,setTimeout(function(){b.previous=f,b.selectedItem=e},1)),!1!==b._trigger("select",a,{item:e})&&b.element.val(e.value),b.term=b.element.val(),b.close(a),b.selectedItem=e},blur:function(a,c){b.menu.element.is(":visible")&&b.element.val()!==b.term&&b.element.val(b.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu"),a.fn.bgiframe&&this.menu.element.bgiframe(),b.beforeunloadHandler=function(){b.element.removeAttr("autocomplete")},a(window).bind("beforeunload",b.beforeunloadHandler)},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup"),this.menu.element.remove(),a(window).unbind("beforeunload",this.beforeunloadHandler),a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments),b==="source"&&this._initSource(),b==="appendTo"&&this.menu.element.appendTo(a(c||"body",this.element[0].ownerDocument)[0]),b==="disabled"&&c&&this.xhr&&this.xhr.abort()},_initSource:function(){var b=this,c,d;a.isArray(this.options.source)?(c=this.options.source,this.source=function(b,d){d(a.ui.autocomplete.filter(c,b.term))}):typeof this.options.source=="string"?(d=this.options.source,this.source=function(c,e){b.xhr&&b.xhr.abort(),b.xhr=a.ajax({url:d,data:c,dataType:"json",success:function(a,b){e(a)},error:function(){e([])}})}):this.source=this.options.source},search:function(a,b){a=a!=null?a:this.element.val(),this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)===!1)return;return this._search(a)},_search:function(a){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.source({term:a},this._response())},_response:function(){var a=this,b=++c;return function(d){b===c&&a.__response(d),a.pending--,a.pending||a.element.removeClass("ui-autocomplete-loading")}},__response:function(a){!this.options.disabled&&a&&a.length?(a=this._normalize(a),this._suggest(a),this._trigger("open")):this.close()},close:function(a){clearTimeout(this.closing),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.deactivate(),this._trigger("close",a))},_change:function(a){this.previous!==this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(b){return b.length&&b[0].label&&b[0].value?b:a.map(b,function(b){return typeof b=="string"?{label:b,value:b}:a.extend({label:b.label||b.value,value:b.value||b.label},b)})},_suggest:function(b){var c=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(c,b),this.menu.deactivate(),this.menu.refresh(),c.show(),this._resizeMenu(),c.position(a.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(new a.Event("mouseover"))},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(b,c){var d=this;a.each(c,function(a,c){d._renderItem(b,c)})},_renderItem:function(b,c){return a("<li></li>").data("item.autocomplete",c).append(a("<a></a>").text(c.label)).appendTo(b)},_move:function(a,b){if(!this.menu.element.is(":visible")){this.search(null,b);return}if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term),this.menu.deactivate();return}this.menu[a](b)},widget:function(){return this.menu.element},_keyEvent:function(a,b){if(!this.isMultiLine||this.menu.element.is(":visible"))this._move(a,b),b.preventDefault()}}),a.extend(a.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")},filter:function(b,c){var d=new RegExp(a.ui.autocomplete.escapeRegex(c),"i");return a.grep(b,function(a){return d.test(a.label||a.value||a)})}})})(jQuery),function(a){a.widget("ui.menu",{_create:function(){var b=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(c){if(!a(c.target).closest(".ui-menu-item a").length)return;c.preventDefault(),b.select(c)}),this.refresh()},refresh:function(){var b=this,c=this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem");c.children("a").addClass("ui-corner-all").attr("tabindex",-1).mouseenter(function(c){b.activate(c,a(this).parent())}).mouseleave(function(){b.deactivate()})},activate:function(a,b){this.deactivate();if(this.hasScroll()){var c=b.offset().top-this.element.offset().top,d=this.element.scrollTop(),e=this.element.height();c<0?this.element.scrollTop(d+c):c>=e&&this.element.scrollTop(d+c-e+b.height())}this.active=b.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end(),this._trigger("focus",a,{item:b})},deactivate:function(){if(!this.active)return;this.active.children("a").removeClass("ui-state-hover").removeAttr("id"),this._trigger("blur"),this.active=null},next:function(a){this.move("next",".ui-menu-item:first",a)},previous:function(a){this.move("prev",".ui-menu-item:last",a)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(a,b,c){if(!this.active){this.activate(c,this.element.children(b));return}var d=this.active[a+"All"](".ui-menu-item").eq(0);d.length?this.activate(c,d):this.activate(c,this.element.children(b))},nextPage:function(b){if(this.hasScroll()){if(!this.active||this.last()){this.activate(b,this.element.children(".ui-menu-item:first"));return}var c=this.active.offset().top,d=this.element.height(),e=this.element.children(".ui-menu-item").filter(function(){var b=a(this).offset().top-c-d+a(this).height();return b<10&&b>-10});e.length||(e=this.element.children(".ui-menu-item:last")),this.activate(b,e)}else this.activate(b,this.element.children(".ui-menu-item").filter(!this.active||this.last()?":first":":last"))},previousPage:function(b){if(this.hasScroll()){if(!this.active||this.first()){this.activate(b,this.element.children(".ui-menu-item:last"));return}var c=this.active.offset().top,d=this.element.height(),e=this.element.children(".ui-menu-item").filter(function(){var b=a(this).offset().top-c+d-a(this).height();return b<10&&b>-10});e.length||(e=this.element.children(".ui-menu-item:first")),this.activate(b,e)}else this.activate(b,this.element.children(".ui-menu-item").filter(!this.active||this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element[a.fn.prop?"prop":"attr"]("scrollHeight")},select:function(a){this._trigger("selected",a,{item:this.active})}})}(jQuery);;
(function(a,b){var c,d,e,f,g="ui-button ui-widget ui-state-default ui-corner-all",h="ui-state-hover ui-state-active ",i="ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",j=function(){var b=a(this).find(":ui-button");setTimeout(function(){b.button("refresh")},1)},k=function(b){var c=b.name,d=b.form,e=a([]);return c&&(d?e=a(d).find("[name='"+c+"']"):e=a("[name='"+c+"']",b.ownerDocument).filter(function(){return!this.form})),e};a.widget("ui.button",{options:{disabled:null,text:!0,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",j),typeof this.options.disabled!="boolean"?this.options.disabled=!!this.element.propAttr("disabled"):this.element.propAttr("disabled",this.options.disabled),this._determineButtonType(),this.hasTitle=!!this.buttonElement.attr("title");var b=this,h=this.options,i=this.type==="checkbox"||this.type==="radio",l="ui-state-hover"+(i?"":" ui-state-active"),m="ui-state-focus";h.label===null&&(h.label=this.buttonElement.html()),this.buttonElement.addClass(g).attr("role","button").bind("mouseenter.button",function(){if(h.disabled)return;a(this).addClass("ui-state-hover"),this===c&&a(this).addClass("ui-state-active")}).bind("mouseleave.button",function(){if(h.disabled)return;a(this).removeClass(l)}).bind("click.button",function(a){h.disabled&&(a.preventDefault(),a.stopImmediatePropagation())}),this.element.bind("focus.button",function(){b.buttonElement.addClass(m)}).bind("blur.button",function(){b.buttonElement.removeClass(m)}),i&&(this.element.bind("change.button",function(){if(f)return;b.refresh()}),this.buttonElement.bind("mousedown.button",function(a){if(h.disabled)return;f=!1,d=a.pageX,e=a.pageY}).bind("mouseup.button",function(a){if(h.disabled)return;if(d!==a.pageX||e!==a.pageY)f=!0})),this.type==="checkbox"?this.buttonElement.bind("click.button",function(){if(h.disabled||f)return!1;a(this).toggleClass("ui-state-active"),b.buttonElement.attr("aria-pressed",b.element[0].checked)}):this.type==="radio"?this.buttonElement.bind("click.button",function(){if(h.disabled||f)return!1;a(this).addClass("ui-state-active"),b.buttonElement.attr("aria-pressed","true");var c=b.element[0];k(c).not(c).map(function(){return a(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")}):(this.buttonElement.bind("mousedown.button",function(){if(h.disabled)return!1;a(this).addClass("ui-state-active"),c=this,a(document).one("mouseup",function(){c=null})}).bind("mouseup.button",function(){if(h.disabled)return!1;a(this).removeClass("ui-state-active")}).bind("keydown.button",function(b){if(h.disabled)return!1;(b.keyCode==a.ui.keyCode.SPACE||b.keyCode==a.ui.keyCode.ENTER)&&a(this).addClass("ui-state-active")}).bind("keyup.button",function(){a(this).removeClass("ui-state-active")}),this.buttonElement.is("a")&&this.buttonElement.keyup(function(b){b.keyCode===a.ui.keyCode.SPACE&&a(this).click()})),this._setOption("disabled",h.disabled),this._resetButton()},_determineButtonType:function(){this.element.is(":checkbox")?this.type="checkbox":this.element.is(":radio")?this.type="radio":this.element.is("input")?this.type="input":this.type="button";if(this.type==="checkbox"||this.type==="radio"){var a=this.element.parents().filter(":last"),b="label[for='"+this.element.attr("id")+"']";this.buttonElement=a.find(b),this.buttonElement.length||(a=a.length?a.siblings():this.element.siblings(),this.buttonElement=a.filter(b),this.buttonElement.length||(this.buttonElement=a.find(b))),this.element.addClass("ui-helper-hidden-accessible");var c=this.element.is(":checked");c&&this.buttonElement.addClass("ui-state-active"),this.buttonElement.attr("aria-pressed",c)}else this.buttonElement=this.element},widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible"),this.buttonElement.removeClass(g+" "+h+" "+i).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()),this.hasTitle||this.buttonElement.removeAttr("title"),a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments);if(b==="disabled"){c?this.element.propAttr("disabled",!0):this.element.propAttr("disabled",!1);return}this._resetButton()},refresh:function(){var b=this.element.is(":disabled");b!==this.options.disabled&&this._setOption("disabled",b),this.type==="radio"?k(this.element[0]).each(function(){a(this).is(":checked")?a(this).button("widget").addClass("ui-state-active").attr("aria-pressed","true"):a(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")}):this.type==="checkbox"&&(this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false"))},_resetButton:function(){if(this.type==="input"){this.options.label&&this.element.val(this.options.label);return}var b=this.buttonElement.removeClass(i),c=a("<span></span>",this.element[0].ownerDocument).addClass("ui-button-text").html(this.options.label).appendTo(b.empty()).text(),d=this.options.icons,e=d.primary&&d.secondary,f=[];d.primary||d.secondary?(this.options.text&&f.push("ui-button-text-icon"+(e?"s":d.primary?"-primary":"-secondary")),d.primary&&b.prepend("<span class='ui-button-icon-primary ui-icon "+d.primary+"'></span>"),d.secondary&&b.append("<span class='ui-button-icon-secondary ui-icon "+d.secondary+"'></span>"),this.options.text||(f.push(e?"ui-button-icons-only":"ui-button-icon-only"),this.hasTitle||b.attr("title",c))):f.push("ui-button-text-only"),b.addClass(f.join(" "))}}),a.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(b,c){b==="disabled"&&this.buttons.button("option",b,c),a.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var b=this.element.css("direction")==="rtl";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return a(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(b?"ui-corner-right":"ui-corner-left").end().filter(":last").addClass(b?"ui-corner-left":"ui-corner-right").end().end()},destroy:function(){this.element.removeClass("ui-buttonset"),this.buttons.map(function(){return a(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy"),a.Widget.prototype.destroy.call(this)}})})(jQuery);;
//     Underscore.js 1.4.2
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.
(function(){var e=this,t=e._,n={},r=Array.prototype,i=Object.prototype,s=Function.prototype,o=r.push,u=r.slice,a=r.concat,f=r.unshift,l=i.toString,c=i.hasOwnProperty,h=r.forEach,p=r.map,d=r.reduce,v=r.reduceRight,m=r.filter,g=r.every,y=r.some,b=r.indexOf,w=r.lastIndexOf,E=Array.isArray,S=Object.keys,x=s.bind,T=function(e){if(e instanceof T)return e;if(!(this instanceof T))return new T(e);this._wrapped=e};typeof exports!="undefined"?(typeof module!="undefined"&&module.exports&&(exports=module.exports=T),exports._=T):e._=T,T.VERSION="1.4.2";var N=T.each=T.forEach=function(e,t,r){if(e==null)return;if(h&&e.forEach===h)e.forEach(t,r);else if(e.length===+e.length){for(var i=0,s=e.length;i<s;i++)if(t.call(r,e[i],i,e)===n)return}else for(var o in e)if(T.has(e,o)&&t.call(r,e[o],o,e)===n)return};T.map=T.collect=function(e,t,n){var r=[];return e==null?r:p&&e.map===p?e.map(t,n):(N(e,function(e,i,s){r[r.length]=t.call(n,e,i,s)}),r)},T.reduce=T.foldl=T.inject=function(e,t,n,r){var i=arguments.length>2;e==null&&(e=[]);if(d&&e.reduce===d)return r&&(t=T.bind(t,r)),i?e.reduce(t,n):e.reduce(t);N(e,function(e,s,o){i?n=t.call(r,n,e,s,o):(n=e,i=!0)});if(!i)throw new TypeError("Reduce of empty array with no initial value");return n},T.reduceRight=T.foldr=function(e,t,n,r){var i=arguments.length>2;e==null&&(e=[]);if(v&&e.reduceRight===v)return r&&(t=T.bind(t,r)),arguments.length>2?e.reduceRight(t,n):e.reduceRight(t);var s=e.length;if(s!==+s){var o=T.keys(e);s=o.length}N(e,function(u,a,f){a=o?o[--s]:--s,i?n=t.call(r,n,e[a],a,f):(n=e[a],i=!0)});if(!i)throw new TypeError("Reduce of empty array with no initial value");return n},T.find=T.detect=function(e,t,n){var r;return C(e,function(e,i,s){if(t.call(n,e,i,s))return r=e,!0}),r},T.filter=T.select=function(e,t,n){var r=[];return e==null?r:m&&e.filter===m?e.filter(t,n):(N(e,function(e,i,s){t.call(n,e,i,s)&&(r[r.length]=e)}),r)},T.reject=function(e,t,n){var r=[];return e==null?r:(N(e,function(e,i,s){t.call(n,e,i,s)||(r[r.length]=e)}),r)},T.every=T.all=function(e,t,r){t||(t=T.identity);var i=!0;return e==null?i:g&&e.every===g?e.every(t,r):(N(e,function(e,s,o){if(!(i=i&&t.call(r,e,s,o)))return n}),!!i)};var C=T.some=T.any=function(e,t,r){t||(t=T.identity);var i=!1;return e==null?i:y&&e.some===y?e.some(t,r):(N(e,function(e,s,o){if(i||(i=t.call(r,e,s,o)))return n}),!!i)};T.contains=T.include=function(e,t){var n=!1;return e==null?n:b&&e.indexOf===b?e.indexOf(t)!=-1:(n=C(e,function(e){return e===t}),n)},T.invoke=function(e,t){var n=u.call(arguments,2);return T.map(e,function(e){return(T.isFunction(t)?t:e[t]).apply(e,n)})},T.pluck=function(e,t){return T.map(e,function(e){return e[t]})},T.where=function(e,t){return T.isEmpty(t)?[]:T.filter(e,function(e){for(var n in t)if(t[n]!==e[n])return!1;return!0})},T.max=function(e,t,n){if(!t&&T.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.max.apply(Math,e);if(!t&&T.isEmpty(e))return-Infinity;var r={computed:-Infinity};return N(e,function(e,i,s){var o=t?t.call(n,e,i,s):e;o>=r.computed&&(r={value:e,computed:o})}),r.value},T.min=function(e,t,n){if(!t&&T.isArray(e)&&e[0]===+e[0]&&e.length<65535)return Math.min.apply(Math,e);if(!t&&T.isEmpty(e))return Infinity;var r={computed:Infinity};return N(e,function(e,i,s){var o=t?t.call(n,e,i,s):e;o<r.computed&&(r={value:e,computed:o})}),r.value},T.shuffle=function(e){var t,n=0,r=[];return N(e,function(e){t=T.random(n++),r[n-1]=r[t],r[t]=e}),r};var k=function(e){return T.isFunction(e)?e:function(t){return t[e]}};T.sortBy=function(e,t,n){var r=k(t);return T.pluck(T.map(e,function(e,t,i){return{value:e,index:t,criteria:r.call(n,e,t,i)}}).sort(function(e,t){var n=e.criteria,r=t.criteria;if(n!==r){if(n>r||n===void 0)return 1;if(n<r||r===void 0)return-1}return e.index<t.index?-1:1}),"value")};var L=function(e,t,n,r){var i={},s=k(t);return N(e,function(t,o){var u=s.call(n,t,o,e);r(i,u,t)}),i};T.groupBy=function(e,t,n){return L(e,t,n,function(e,t,n){(T.has(e,t)?e[t]:e[t]=[]).push(n)})},T.countBy=function(e,t,n){return L(e,t,n,function(e,t,n){T.has(e,t)||(e[t]=0),e[t]++})},T.sortedIndex=function(e,t,n,r){n=n==null?T.identity:k(n);var i=n.call(r,t),s=0,o=e.length;while(s<o){var u=s+o>>>1;n.call(r,e[u])<i?s=u+1:o=u}return s},T.toArray=function(e){return e?e.length===+e.length?u.call(e):T.values(e):[]},T.size=function(e){return e.length===+e.length?e.length:T.keys(e).length},T.first=T.head=T.take=function(e,t,n){return t!=null&&!n?u.call(e,0,t):e[0]},T.initial=function(e,t,n){return u.call(e,0,e.length-(t==null||n?1:t))},T.last=function(e,t,n){return t!=null&&!n?u.call(e,Math.max(e.length-t,0)):e[e.length-1]},T.rest=T.tail=T.drop=function(e,t,n){return u.call(e,t==null||n?1:t)},T.compact=function(e){return T.filter(e,function(e){return!!e})};var A=function(e,t,n){return N(e,function(e){T.isArray(e)?t?o.apply(n,e):A(e,t,n):n.push(e)}),n};T.flatten=function(e,t){return A(e,t,[])},T.without=function(e){return T.difference(e,u.call(arguments,1))},T.uniq=T.unique=function(e,t,n,r){var i=n?T.map(e,n,r):e,s=[],o=[];return N(i,function(n,r){if(t?!r||o[o.length-1]!==n:!T.contains(o,n))o.push(n),s.push(e[r])}),s},T.union=function(){return T.uniq(a.apply(r,arguments))},T.intersection=function(e){var t=u.call(arguments,1);return T.filter(T.uniq(e),function(e){return T.every(t,function(t){return T.indexOf(t,e)>=0})})},T.difference=function(e){var t=a.apply(r,u.call(arguments,1));return T.filter(e,function(e){return!T.contains(t,e)})},T.zip=function(){var e=u.call(arguments),t=T.max(T.pluck(e,"length")),n=new Array(t);for(var r=0;r<t;r++)n[r]=T.pluck(e,""+r);return n},T.object=function(e,t){var n={};for(var r=0,i=e.length;r<i;r++)t?n[e[r]]=t[r]:n[e[r][0]]=e[r][1];return n},T.indexOf=function(e,t,n){if(e==null)return-1;var r=0,i=e.length;if(n){if(typeof n!="number")return r=T.sortedIndex(e,t),e[r]===t?r:-1;r=n<0?Math.max(0,i+n):n}if(b&&e.indexOf===b)return e.indexOf(t,n);for(;r<i;r++)if(e[r]===t)return r;return-1},T.lastIndexOf=function(e,t,n){if(e==null)return-1;var r=n!=null;if(w&&e.lastIndexOf===w)return r?e.lastIndexOf(t,n):e.lastIndexOf(t);var i=r?n:e.length;while(i--)if(e[i]===t)return i;return-1},T.range=function(e,t,n){arguments.length<=1&&(t=e||0,e=0),n=arguments[2]||1;var r=Math.max(Math.ceil((t-e)/n),0),i=0,s=new Array(r);while(i<r)s[i++]=e,e+=n;return s};var O=function(){};T.bind=function(t,n){var r,i;if(t.bind===x&&x)return x.apply(t,u.call(arguments,1));if(!T.isFunction(t))throw new TypeError;return i=u.call(arguments,2),r=function(){if(this instanceof r){O.prototype=t.prototype;var e=new O,s=t.apply(e,i.concat(u.call(arguments)));return Object(s)===s?s:e}return t.apply(n,i.concat(u.call(arguments)))}},T.bindAll=function(e){var t=u.call(arguments,1);return t.length==0&&(t=T.functions(e)),N(t,function(t){e[t]=T.bind(e[t],e)}),e},T.memoize=function(e,t){var n={};return t||(t=T.identity),function(){var r=t.apply(this,arguments);return T.has(n,r)?n[r]:n[r]=e.apply(this,arguments)}},T.delay=function(e,t){var n=u.call(arguments,2);return setTimeout(function(){return e.apply(null,n)},t)},T.defer=function(e){return T.delay.apply(T,[e,1].concat(u.call(arguments,1)))},T.throttle=function(e,t){var n,r,i,s,o,u,a=T.debounce(function(){o=s=!1},t);return function(){n=this,r=arguments;var f=function(){i=null,o&&(u=e.apply(n,r)),a()};return i||(i=setTimeout(f,t)),s?o=!0:(s=!0,u=e.apply(n,r)),a(),u}},T.debounce=function(e,t,n){var r,i;return function(){var s=this,o=arguments,u=function(){r=null,n||(i=e.apply(s,o))},a=n&&!r;return clearTimeout(r),r=setTimeout(u,t),a&&(i=e.apply(s,o)),i}},T.once=function(e){var t=!1,n;return function(){return t?n:(t=!0,n=e.apply(this,arguments),e=null,n)}},T.wrap=function(e,t){return function(){var n=[e];return o.apply(n,arguments),t.apply(this,n)}},T.compose=function(){var e=arguments;return function(){var t=arguments;for(var n=e.length-1;n>=0;n--)t=[e[n].apply(this,t)];return t[0]}},T.after=function(e,t){return e<=0?t():function(){if(--e<1)return t.apply(this,arguments)}},T.keys=S||function(e){if(e!==Object(e))throw new TypeError("Invalid object");var t=[];for(var n in e)T.has(e,n)&&(t[t.length]=n);return t},T.values=function(e){var t=[];for(var n in e)T.has(e,n)&&t.push(e[n]);return t},T.pairs=function(e){var t=[];for(var n in e)T.has(e,n)&&t.push([n,e[n]]);return t},T.invert=function(e){var t={};for(var n in e)T.has(e,n)&&(t[e[n]]=n);return t},T.functions=T.methods=function(e){var t=[];for(var n in e)T.isFunction(e[n])&&t.push(n);return t.sort()},T.extend=function(e){return N(u.call(arguments,1),function(t){for(var n in t)e[n]=t[n]}),e},T.pick=function(e){var t={},n=a.apply(r,u.call(arguments,1));return N(n,function(n){n in e&&(t[n]=e[n])}),t},T.omit=function(e){var t={},n=a.apply(r,u.call(arguments,1));for(var i in e)T.contains(n,i)||(t[i]=e[i]);return t},T.defaults=function(e){return N(u.call(arguments,1),function(t){for(var n in t)e[n]==null&&(e[n]=t[n])}),e},T.clone=function(e){return T.isObject(e)?T.isArray(e)?e.slice():T.extend({},e):e},T.tap=function(e,t){return t(e),e};var M=function(e,t,n,r){if(e===t)return e!==0||1/e==1/t;if(e==null||t==null)return e===t;e instanceof T&&(e=e._wrapped),t instanceof T&&(t=t._wrapped);var i=l.call(e);if(i!=l.call(t))return!1;switch(i){case"[object String]":return e==String(t);case"[object Number]":return e!=+e?t!=+t:e==0?1/e==1/t:e==+t;case"[object Date]":case"[object Boolean]":return+e==+t;case"[object RegExp]":return e.source==t.source&&e.global==t.global&&e.multiline==t.multiline&&e.ignoreCase==t.ignoreCase}if(typeof e!="object"||typeof t!="object")return!1;var s=n.length;while(s--)if(n[s]==e)return r[s]==t;n.push(e),r.push(t);var o=0,u=!0;if(i=="[object Array]"){o=e.length,u=o==t.length;if(u)while(o--)if(!(u=M(e[o],t[o],n,r)))break}else{var a=e.constructor,f=t.constructor;if(a!==f&&!(T.isFunction(a)&&a instanceof a&&T.isFunction(f)&&f instanceof f))return!1;for(var c in e)if(T.has(e,c)){o++;if(!(u=T.has(t,c)&&M(e[c],t[c],n,r)))break}if(u){for(c in t)if(T.has(t,c)&&!(o--))break;u=!o}}return n.pop(),r.pop(),u};T.isEqual=function(e,t){return M(e,t,[],[])},T.isEmpty=function(e){if(e==null)return!0;if(T.isArray(e)||T.isString(e))return e.length===0;for(var t in e)if(T.has(e,t))return!1;return!0},T.isElement=function(e){return!!e&&e.nodeType===1},T.isArray=E||function(e){return l.call(e)=="[object Array]"},T.isObject=function(e){return e===Object(e)},N(["Arguments","Function","String","Number","Date","RegExp"],function(e){T["is"+e]=function(t){return l.call(t)=="[object "+e+"]"}}),T.isArguments(arguments)||(T.isArguments=function(e){return!!e&&!!T.has(e,"callee")}),typeof /./!="function"&&(T.isFunction=function(e){return typeof e=="function"}),T.isFinite=function(e){return T.isNumber(e)&&isFinite(e)},T.isNaN=function(e){return T.isNumber(e)&&e!=+e},T.isBoolean=function(e){return e===!0||e===!1||l.call(e)=="[object Boolean]"},T.isNull=function(e){return e===null},T.isUndefined=function(e){return e===void 0},T.has=function(e,t){return c.call(e,t)},T.noConflict=function(){return e._=t,this},T.identity=function(e){return e},T.times=function(e,t,n){for(var r=0;r<e;r++)t.call(n,r)},T.random=function(e,t){return t==null&&(t=e,e=0),e+(0|Math.random()*(t-e+1))};var _={escape:{"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","/":"&#x2F;"}};_.unescape=T.invert(_.escape);var D={escape:new RegExp("["+T.keys(_.escape).join("")+"]","g"),unescape:new RegExp("("+T.keys(_.unescape).join("|")+")","g")};T.each(["escape","unescape"],function(e){T[e]=function(t){return t==null?"":(""+t).replace(D[e],function(t){return _[e][t]})}}),T.result=function(e,t){if(e==null)return null;var n=e[t];return T.isFunction(n)?n.call(e):n},T.mixin=function(e){N(T.functions(e),function(t){var n=T[t]=e[t];T.prototype[t]=function(){var e=[this._wrapped];return o.apply(e,arguments),F.call(this,n.apply(T,e))}})};var P=0;T.uniqueId=function(e){var t=P++;return e?e+t:t},T.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var H=/(.)^/,B={"'":"'","\\":"\\","\r":"r","\n":"n","	":"t","\u2028":"u2028","\u2029":"u2029"},j=/\\|'|\r|\n|\t|\u2028|\u2029/g;T.template=function(e,t,n){n=T.defaults({},n,T.templateSettings);var r=new RegExp([(n.escape||H).source,(n.interpolate||H).source,(n.evaluate||H).source].join("|")+"|$","g"),i=0,s="__p+='";e.replace(r,function(t,n,r,o,u){s+=e.slice(i,u).replace(j,function(e){return"\\"+B[e]}),s+=n?"'+\n((__t=("+n+"))==null?'':_.escape(__t))+\n'":r?"'+\n((__t=("+r+"))==null?'':__t)+\n'":o?"';\n"+o+"\n__p+='":"",i=u+t.length}),s+="';\n",n.variable||(s="with(obj||{}){\n"+s+"}\n"),s="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+s+"return __p;\n";try{var o=new Function(n.variable||"obj","_",s)}catch(u){throw u.source=s,u}if(t)return o(t,T);var a=function(e){return o.call(this,e,T)};return a.source="function("+(n.variable||"obj")+"){\n"+s+"}",a},T.chain=function(e){return T(e).chain()};var F=function(e){return this._chain?T(e).chain():e};T.mixin(T),N(["pop","push","reverse","shift","sort","splice","unshift"],function(e){var t=r[e];T.prototype[e]=function(){var n=this._wrapped;return t.apply(n,arguments),(e=="shift"||e=="splice")&&n.length===0&&delete n[0],F.call(this,n)}}),N(["concat","join","slice"],function(e){var t=r[e];T.prototype[e]=function(){return F.call(this,t.apply(this._wrapped,arguments))}}),T.extend(T.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);
// Backbone.js 0.9.2

// (c) 2010-2012 Jeremy Ashkenas, DocumentCloud Inc.
// Backbone may be freely distributed under the MIT license.
// For all details and documentation:
// http://backbonejs.org
(function(){var l=this,y=l.Backbone,z=Array.prototype.slice,A=Array.prototype.splice,g;g="undefined"!==typeof exports?exports:l.Backbone={};g.VERSION="0.9.2";var f=l._;!f&&"undefined"!==typeof require&&(f=require("underscore"));var i=l.jQuery||l.Zepto||l.ender;g.setDomLibrary=function(a){i=a};g.noConflict=function(){l.Backbone=y;return this};g.emulateHTTP=!1;g.emulateJSON=!1;var p=/\s+/,k=g.Events={on:function(a,b,c){var d,e,f,g,j;if(!b)return this;a=a.split(p);for(d=this._callbacks||(this._callbacks=
{});e=a.shift();)f=(j=d[e])?j.tail:{},f.next=g={},f.context=c,f.callback=b,d[e]={tail:g,next:j?j.next:f};return this},off:function(a,b,c){var d,e,h,g,j,q;if(e=this._callbacks){if(!a&&!b&&!c)return delete this._callbacks,this;for(a=a?a.split(p):f.keys(e);d=a.shift();)if(h=e[d],delete e[d],h&&(b||c))for(g=h.tail;(h=h.next)!==g;)if(j=h.callback,q=h.context,b&&j!==b||c&&q!==c)this.on(d,j,q);return this}},trigger:function(a){var b,c,d,e,f,g;if(!(d=this._callbacks))return this;f=d.all;a=a.split(p);for(g=
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         z.call(arguments,1);b=a.shift();){if(c=d[b])for(e=c.tail;(c=c.next)!==e;)c.callback.apply(c.context||this,g);if(c=f){e=c.tail;for(b=[b].concat(g);(c=c.next)!==e;)c.callback.apply(c.context||this,b)}}return this}};k.bind=k.on;k.unbind=k.off;var o=g.Model=function(a,b){var c;a||(a={});b&&b.parse&&(a=this.parse(a));if(c=n(this,"defaults"))a=f.extend({},c,a);b&&b.collection&&(this.collection=b.collection);this.attributes={};this._escapedAttributes={};this.cid=f.uniqueId("c");this.changed={};this._silent=
{};this._pending={};this.set(a,{silent:!0});this.changed={};this._silent={};this._pending={};this._previousAttributes=f.clone(this.attributes);this.initialize.apply(this,arguments)};f.extend(o.prototype,k,{changed:null,_silent:null,_pending:null,idAttribute:"id",initialize:function(){},toJSON:function(){return f.clone(this.attributes)},get:function(a){return this.attributes[a]},escape:function(a){var b;if(b=this._escapedAttributes[a])return b;b=this.get(a);return this._escapedAttributes[a]=f.escape(null==
    b?"":""+b)},has:function(a){return null!=this.get(a)},set:function(a,b,c){var d,e;f.isObject(a)||null==a?(d=a,c=b):(d={},d[a]=b);c||(c={});if(!d)return this;d instanceof o&&(d=d.attributes);if(c.unset)for(e in d)d[e]=void 0;if(!this._validate(d,c))return!1;this.idAttribute in d&&(this.id=d[this.idAttribute]);var b=c.changes={},h=this.attributes,g=this._escapedAttributes,j=this._previousAttributes||{};for(e in d){a=d[e];if(!f.isEqual(h[e],a)||c.unset&&f.has(h,e))delete g[e],(c.silent?this._silent:
    b)[e]=!0;c.unset?delete h[e]:h[e]=a;!f.isEqual(j[e],a)||f.has(h,e)!=f.has(j,e)?(this.changed[e]=a,c.silent||(this._pending[e]=!0)):(delete this.changed[e],delete this._pending[e])}c.silent||this.change(c);return this},unset:function(a,b){(b||(b={})).unset=!0;return this.set(a,null,b)},clear:function(a){(a||(a={})).unset=!0;return this.set(f.clone(this.attributes),a)},fetch:function(a){var a=a?f.clone(a):{},b=this,c=a.success;a.success=function(d,e,f){if(!b.set(b.parse(d,f),a))return!1;c&&c(b,d)};
    a.error=g.wrapError(a.error,b,a);return(this.sync||g.sync).call(this,"read",this,a)},save:function(a,b,c){var d,e;f.isObject(a)||null==a?(d=a,c=b):(d={},d[a]=b);c=c?f.clone(c):{};if(c.wait){if(!this._validate(d,c))return!1;e=f.clone(this.attributes)}a=f.extend({},c,{silent:!0});if(d&&!this.set(d,c.wait?a:c))return!1;var h=this,i=c.success;c.success=function(a,b,e){b=h.parse(a,e);if(c.wait){delete c.wait;b=f.extend(d||{},b)}if(!h.set(b,c))return false;i?i(h,a):h.trigger("sync",h,a,c)};c.error=g.wrapError(c.error,
    h,c);b=this.isNew()?"create":"update";b=(this.sync||g.sync).call(this,b,this,c);c.wait&&this.set(e,a);return b},destroy:function(a){var a=a?f.clone(a):{},b=this,c=a.success,d=function(){b.trigger("destroy",b,b.collection,a)};if(this.isNew())return d(),!1;a.success=function(e){a.wait&&d();c?c(b,e):b.trigger("sync",b,e,a)};a.error=g.wrapError(a.error,b,a);var e=(this.sync||g.sync).call(this,"delete",this,a);a.wait||d();return e},url:function(){var a=n(this,"urlRoot")||n(this.collection,"url")||t();
    return this.isNew()?a:a+("/"==a.charAt(a.length-1)?"":"/")+encodeURIComponent(this.id)},parse:function(a){return a},clone:function(){return new this.constructor(this.attributes)},isNew:function(){return null==this.id},change:function(a){a||(a={});var b=this._changing;this._changing=!0;for(var c in this._silent)this._pending[c]=!0;var d=f.extend({},a.changes,this._silent);this._silent={};for(c in d)this.trigger("change:"+c,this,this.get(c),a);if(b)return this;for(;!f.isEmpty(this._pending);){this._pending=
{};this.trigger("change",this,a);for(c in this.changed)!this._pending[c]&&!this._silent[c]&&delete this.changed[c];this._previousAttributes=f.clone(this.attributes)}this._changing=!1;return this},hasChanged:function(a){return!arguments.length?!f.isEmpty(this.changed):f.has(this.changed,a)},changedAttributes:function(a){if(!a)return this.hasChanged()?f.clone(this.changed):!1;var b,c=!1,d=this._previousAttributes,e;for(e in a)if(!f.isEqual(d[e],b=a[e]))(c||(c={}))[e]=b;return c},previous:function(a){return!arguments.length||
    !this._previousAttributes?null:this._previousAttributes[a]},previousAttributes:function(){return f.clone(this._previousAttributes)},isValid:function(){return!this.validate(this.attributes)},_validate:function(a,b){if(b.silent||!this.validate)return!0;var a=f.extend({},this.attributes,a),c=this.validate(a,b);if(!c)return!0;b&&b.error?b.error(this,c,b):this.trigger("error",this,c,b);return!1}});var r=g.Collection=function(a,b){b||(b={});b.model&&(this.model=b.model);b.comparator&&(this.comparator=b.comparator);
    this._reset();this.initialize.apply(this,arguments);a&&this.reset(a,{silent:!0,parse:b.parse})};f.extend(r.prototype,k,{model:o,initialize:function(){},toJSON:function(a){return this.map(function(b){return b.toJSON(a)})},add:function(a,b){var c,d,e,g,i,j={},k={},l=[];b||(b={});a=f.isArray(a)?a.slice():[a];c=0;for(d=a.length;c<d;c++){if(!(e=a[c]=this._prepareModel(a[c],b)))throw Error("Can't add an invalid model to a collection");g=e.cid;i=e.id;j[g]||this._byCid[g]||null!=i&&(k[i]||this._byId[i])?
    l.push(c):j[g]=k[i]=e}for(c=l.length;c--;)a.splice(l[c],1);c=0;for(d=a.length;c<d;c++)(e=a[c]).on("all",this._onModelEvent,this),this._byCid[e.cid]=e,null!=e.id&&(this._byId[e.id]=e);this.length+=d;A.apply(this.models,[null!=b.at?b.at:this.models.length,0].concat(a));this.comparator&&this.sort({silent:!0});if(b.silent)return this;c=0;for(d=this.models.length;c<d;c++)if(j[(e=this.models[c]).cid])b.index=c,e.trigger("add",e,this,b);return this},remove:function(a,b){var c,d,e,g;b||(b={});a=f.isArray(a)?
    a.slice():[a];c=0;for(d=a.length;c<d;c++)if(g=this.getByCid(a[c])||this.get(a[c]))delete this._byId[g.id],delete this._byCid[g.cid],e=this.indexOf(g),this.models.splice(e,1),this.length--,b.silent||(b.index=e,g.trigger("remove",g,this,b)),this._removeReference(g);return this},push:function(a,b){a=this._prepareModel(a,b);this.add(a,b);return a},pop:function(a){var b=this.at(this.length-1);this.remove(b,a);return b},unshift:function(a,b){a=this._prepareModel(a,b);this.add(a,f.extend({at:0},b));return a},
    shift:function(a){var b=this.at(0);this.remove(b,a);return b},get:function(a){return null==a?void 0:this._byId[null!=a.id?a.id:a]},getByCid:function(a){return a&&this._byCid[a.cid||a]},at:function(a){return this.models[a]},where:function(a){return f.isEmpty(a)?[]:this.filter(function(b){for(var c in a)if(a[c]!==b.get(c))return!1;return!0})},sort:function(a){a||(a={});if(!this.comparator)throw Error("Cannot sort a set without a comparator");var b=f.bind(this.comparator,this);1==this.comparator.length?
        this.models=this.sortBy(b):this.models.sort(b);a.silent||this.trigger("reset",this,a);return this},pluck:function(a){return f.map(this.models,function(b){return b.get(a)})},reset:function(a,b){a||(a=[]);b||(b={});for(var c=0,d=this.models.length;c<d;c++)this._removeReference(this.models[c]);this._reset();this.add(a,f.extend({silent:!0},b));b.silent||this.trigger("reset",this,b);return this},fetch:function(a){a=a?f.clone(a):{};void 0===a.parse&&(a.parse=!0);var b=this,c=a.success;a.success=function(d,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               e,f){b[a.add?"add":"reset"](b.parse(d,f),a);c&&c(b,d)};a.error=g.wrapError(a.error,b,a);return(this.sync||g.sync).call(this,"read",this,a)},create:function(a,b){var c=this,b=b?f.clone(b):{},a=this._prepareModel(a,b);if(!a)return!1;b.wait||c.add(a,b);var d=b.success;b.success=function(e,f){b.wait&&c.add(e,b);d?d(e,f):e.trigger("sync",a,f,b)};a.save(null,b);return a},parse:function(a){return a},chain:function(){return f(this.models).chain()},_reset:function(){this.length=0;this.models=[];this._byId=
    {};this._byCid={}},_prepareModel:function(a,b){b||(b={});a instanceof o?a.collection||(a.collection=this):(b.collection=this,a=new this.model(a,b),a._validate(a.attributes,b)||(a=!1));return a},_removeReference:function(a){this==a.collection&&delete a.collection;a.off("all",this._onModelEvent,this)},_onModelEvent:function(a,b,c,d){("add"==a||"remove"==a)&&c!=this||("destroy"==a&&this.remove(b,d),b&&a==="change:"+b.idAttribute&&(delete this._byId[b.previous(b.idAttribute)],this._byId[b.id]=b),this.trigger.apply(this,
        arguments))}});f.each("forEach,each,map,reduce,reduceRight,find,detect,filter,select,reject,every,all,some,any,include,contains,invoke,max,min,sortBy,sortedIndex,toArray,size,first,initial,rest,last,without,indexOf,shuffle,lastIndexOf,isEmpty,groupBy".split(","),function(a){r.prototype[a]=function(){return f[a].apply(f,[this.models].concat(f.toArray(arguments)))}});var u=g.Router=function(a){a||(a={});a.routes&&(this.routes=a.routes);this._bindRoutes();this.initialize.apply(this,arguments)},B=/:\w+/g,
    C=/\*\w+/g,D=/[-[\]{}()+?.,\\^$|#\s]/g;f.extend(u.prototype,k,{initialize:function(){},route:function(a,b,c){g.history||(g.history=new m);f.isRegExp(a)||(a=this._routeToRegExp(a));c||(c=this[b]);g.history.route(a,f.bind(function(d){d=this._extractParameters(a,d);c&&c.apply(this,d);this.trigger.apply(this,["route:"+b].concat(d));g.history.trigger("route",this,b,d)},this));return this},navigate:function(a,b){g.history.navigate(a,b)},_bindRoutes:function(){if(this.routes){var a=[],b;for(b in this.routes)a.unshift([b,
    this.routes[b]]);b=0;for(var c=a.length;b<c;b++)this.route(a[b][0],a[b][1],this[a[b][1]])}},_routeToRegExp:function(a){a=a.replace(D,"\\$&").replace(B,"([^/]+)").replace(C,"(.*?)");return RegExp("^"+a+"$")},_extractParameters:function(a,b){return a.exec(b).slice(1)}});var m=g.History=function(){this.handlers=[];f.bindAll(this,"checkUrl")},s=/^[#\/]/,E=/msie [\w.]+/;m.started=!1;f.extend(m.prototype,k,{interval:50,getHash:function(a){return(a=(a?a.location:window.location).href.match(/#(.*)$/))?a[1]:
    ""},getFragment:function(a,b){if(null==a)if(this._hasPushState||b){var a=window.location.pathname,c=window.location.search;c&&(a+=c)}else a=this.getHash();a.indexOf(this.options.root)||(a=a.substr(this.options.root.length));return a.replace(s,"")},start:function(a){if(m.started)throw Error("Backbone.history has already been started");m.started=!0;this.options=f.extend({},{root:"/"},this.options,a);this._wantsHashChange=!1!==this.options.hashChange;this._wantsPushState=!!this.options.pushState;this._hasPushState=
    !(!this.options.pushState||!window.history||!window.history.pushState);var a=this.getFragment(),b=document.documentMode;if(b=E.exec(navigator.userAgent.toLowerCase())&&(!b||7>=b))this.iframe=i('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo("body")[0].contentWindow,this.navigate(a);this._hasPushState?i(window).bind("popstate",this.checkUrl):this._wantsHashChange&&"onhashchange"in window&&!b?i(window).bind("hashchange",this.checkUrl):this._wantsHashChange&&(this._checkUrlInterval=setInterval(this.checkUrl,
    this.interval));this.fragment=a;a=window.location;b=a.pathname==this.options.root;if(this._wantsHashChange&&this._wantsPushState&&!this._hasPushState&&!b)return this.fragment=this.getFragment(null,!0),window.location.replace(this.options.root+"#"+this.fragment),!0;this._wantsPushState&&this._hasPushState&&b&&a.hash&&(this.fragment=this.getHash().replace(s,""),window.history.replaceState({},document.title,a.protocol+"//"+a.host+this.options.root+this.fragment));if(!this.options.silent)return this.loadUrl()},
    stop:function(){i(window).unbind("popstate",this.checkUrl).unbind("hashchange",this.checkUrl);clearInterval(this._checkUrlInterval);m.started=!1},route:function(a,b){this.handlers.unshift({route:a,callback:b})},checkUrl:function(){var a=this.getFragment();a==this.fragment&&this.iframe&&(a=this.getFragment(this.getHash(this.iframe)));if(a==this.fragment)return!1;this.iframe&&this.navigate(a);this.loadUrl()||this.loadUrl(this.getHash())},loadUrl:function(a){var b=this.fragment=this.getFragment(a);return f.any(this.handlers,
        function(a){if(a.route.test(b))return a.callback(b),!0})},navigate:function(a,b){if(!m.started)return!1;if(!b||!0===b)b={trigger:b};var c=(a||"").replace(s,"");this.fragment!=c&&(this._hasPushState?(0!=c.indexOf(this.options.root)&&(c=this.options.root+c),this.fragment=c,window.history[b.replace?"replaceState":"pushState"]({},document.title,c)):this._wantsHashChange?(this.fragment=c,this._updateHash(window.location,c,b.replace),this.iframe&&c!=this.getFragment(this.getHash(this.iframe))&&(b.replace||
        this.iframe.document.open().close(),this._updateHash(this.iframe.location,c,b.replace))):window.location.assign(this.options.root+a),b.trigger&&this.loadUrl(a))},_updateHash:function(a,b,c){c?a.replace(a.toString().replace(/(javascript:|#).*$/,"")+"#"+b):a.hash=b}});var v=g.View=function(a){this.cid=f.uniqueId("view");this._configure(a||{});this._ensureElement();this.initialize.apply(this,arguments);this.delegateEvents()},F=/^(\S+)\s*(.*)$/,w="model,collection,el,id,attributes,className,tagName".split(",");
    f.extend(v.prototype,k,{tagName:"div",$:function(a){return this.$el.find(a)},initialize:function(){},render:function(){return this},remove:function(){this.$el.remove();return this},make:function(a,b,c){a=document.createElement(a);b&&i(a).attr(b);c&&i(a).html(c);return a},setElement:function(a,b){this.$el&&this.undelegateEvents();this.$el=a instanceof i?a:i(a);this.el=this.$el[0];!1!==b&&this.delegateEvents();return this},delegateEvents:function(a){if(a||(a=n(this,"events"))){this.undelegateEvents();
        for(var b in a){var c=a[b];f.isFunction(c)||(c=this[a[b]]);if(!c)throw Error('Method "'+a[b]+'" does not exist');var d=b.match(F),e=d[1],d=d[2],c=f.bind(c,this),e=e+(".delegateEvents"+this.cid);""===d?this.$el.bind(e,c):this.$el.delegate(d,e,c)}}},undelegateEvents:function(){this.$el.unbind(".delegateEvents"+this.cid)},_configure:function(a){this.options&&(a=f.extend({},this.options,a));for(var b=0,c=w.length;b<c;b++){var d=w[b];a[d]&&(this[d]=a[d])}this.options=a},_ensureElement:function(){if(this.el)this.setElement(this.el,
        !1);else{var a=n(this,"attributes")||{};this.id&&(a.id=this.id);this.className&&(a["class"]=this.className);this.setElement(this.make(this.tagName,a),!1)}}});o.extend=r.extend=u.extend=v.extend=function(a,b){var c=G(this,a,b);c.extend=this.extend;return c};var H={create:"POST",update:"PUT","delete":"DELETE",read:"GET"};g.sync=function(a,b,c){var d=H[a];c||(c={});var e={type:d,dataType:"json"};c.url||(e.url=n(b,"url")||t());if(!c.data&&b&&("create"==a||"update"==a))e.contentType="application/json",
        e.data=JSON.stringify(b.toJSON());g.emulateJSON&&(e.contentType="application/x-www-form-urlencoded",e.data=e.data?{model:e.data}:{});if(g.emulateHTTP&&("PUT"===d||"DELETE"===d))g.emulateJSON&&(e.data._method=d),e.type="POST",e.beforeSend=function(a){a.setRequestHeader("X-HTTP-Method-Override",d)};"GET"!==e.type&&!g.emulateJSON&&(e.processData=!1);return i.ajax(f.extend(e,c))};g.wrapError=function(a,b,c){return function(d,e){e=d===b?e:d;a?a(b,e,c):b.trigger("error",b,e,c)}};var x=function(){},G=function(a,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    b,c){var d;d=b&&b.hasOwnProperty("constructor")?b.constructor:function(){a.apply(this,arguments)};f.extend(d,a);x.prototype=a.prototype;d.prototype=new x;b&&f.extend(d.prototype,b);c&&f.extend(d,c);d.prototype.constructor=d;d.__super__=a.prototype;return d},n=function(a,b){return!a||!a[b]?null:f.isFunction(a[b])?a[b]():a[b]},t=function(){throw Error('A "url" property or function must be specified');}}).call(this);




var Placeholders = (function () {

	"use strict";

	
	var validTypes = [
			"text",
			"search",
			"url",
			"tel",
			"email",
			"password",
			"number",
			"textarea"
		],

	//Default options, can be overridden by passing object to `init`
		settings = {
			live:           false,
			hideOnFocus:    false,
			className:      'placeholderspolyfill', // placeholder class name to apply to form fields
			textColor:      '#999',                 // default placeholder text color
			styleImportant: true                    // add !important flag to placeholder style
		},

	//Keycodes that are not allowed when the placeholder is visible and `hideOnFocus` is `false`
		badKeys = [37, 38, 39, 40],

	//Used if `live` options is `true`
		interval,

	//Stores the input value on keydown (used when `hideOnFocus` option is `false`)
		valueKeyDown,

	// polyfill class name regexp
		classNameRegExp = new RegExp('\\b' + settings.className + '\\b');

	// The cursorToStart function attempts to jump the cursor to before the first character of input
	function cursorToStart(elem) {
		var range;
		if (elem.createTextRange) {
			range = elem.createTextRange();
			range.move("character", 0);
			range.select();
		} else if (elem.selectionStart) {
			elem.focus();
			elem.setSelectionRange(0, 0);
		}
	}

	
	function focusHandler() {

		var type;

		//If the placeholder is currently visible, remove it and its associated styles
        var placeholder = this.getAttribute("placeholder");
		if (this.value === placeholder ||
            (placeholder && this.value === placeholder.toUpperCase())) {

			if (!settings.hideOnFocus) {
				cursorToStart(this);
			} else {
				
				this.className = this.className.replace(classNameRegExp, "");
				this.value = "";

				// Check if we need to switch the input type (this is the case if it's a password input)
				type = this.getAttribute("data-placeholdertype");
				if (type) {
					this.type = type;
				}
			}
		}
	}

	
	function blurHandler() {

		var type;

		//If the input value is the empty string, apply the placeholder and its associated styles
		if (this.value === "") {
			this.className = this.className + " " + settings.className;
			this.value = this.getAttribute("placeholder");

			// Check if we need to switch the input type (this is the case if it's a password input)
			type = this.getAttribute("data-placeholdertype");
			if (type) {
				this.type = "text";
			}
		}
	}

	
	function submitHandler() {
		var inputs = this.getElementsByTagName("input"),
			textareas = this.getElementsByTagName("textarea"),
			numInputs = inputs.length,
			num = numInputs + textareas.length,
			element,
			placeholder,
			i;
		//Iterate over all descendant input elements and remove placeholder if necessary
		for (i = 0; i < num; i += 1) {
			element = (i < numInputs) ? inputs[i] : textareas[i - numInputs];
			placeholder = element.getAttribute("placeholder");

			//If the value of the input is equal to the value of the placeholder attribute we need to clear the value
			if (element.value === placeholder) {
				element.value = "";
			}
		}
	}

	
	function keydownHandler(event) {
		valueKeyDown = this.value;

		//Prevent the use of the arrow keys (try to keep the cursor before the placeholder)
		return !(valueKeyDown === this.getAttribute("placeholder") && badKeys.indexOf(event.keyCode) > -1);
	}

	
	function keyupHandler() {

		var type;

		if (this.value !== valueKeyDown) {

			// Remove the placeholder
			this.className = this.className.replace(classNameRegExp, "");
			this.value = this.value.replace(this.getAttribute("placeholder"), "");

			// Check if we need to switch the input type (this is the case if it's a password input)
			type = this.getAttribute("data-placeholdertype");
			if (type) {
				this.type = type;
			}
		}
		if (this.value === "") {

			blurHandler.call(this);
			cursorToStart(this);
		}
	}

	//The addEventListener function binds an event handler with the context of an element to a specific event on that element. Handles old-IE and modern browsers.
	function addEventListener(element, event, fn) {
		if (element.addEventListener) {
			return element.addEventListener(event, fn.bind(element), false);
		}
		if (element.attachEvent) {
			return element.attachEvent("on" + event, fn.bind(element));
		}
	}

	//The addEventListeners function binds the appropriate (depending on options) event listeners to the specified input or textarea element.
	function addEventListeners(element) {
		if (!settings.hideOnFocus) {
			addEventListener(element, "keydown", keydownHandler);
			addEventListener(element, "keyup", keyupHandler);
		}
		addEventListener(element, "focus", focusHandler);
		addEventListener(element, "blur", blurHandler);
	}

	
	function updatePlaceholders() {

		//Declare variables, get references to all input and textarea elements
		var inputs = document.getElementsByTagName("input"),
			textareas = document.getElementsByTagName("textarea"),
			numInputs = inputs.length,
			num = numInputs + textareas.length,
			i,
            form,
			element,
			oldPlaceholder,
			newPlaceholder;

		//Iterate over all input and textarea elements and apply/update the placeholder polyfill if necessary
		for (i = 0; i < num; i += 1) {

			//Get the next element from either the input NodeList or the textarea NodeList, depending on how many elements we've already looped through
			element = (i < numInputs) ? inputs[i] : textareas[i - numInputs];

			//Get the value of the placeholder attribute
			newPlaceholder = element.getAttribute("placeholder");

			//Check whether the current input element is of a type that supports the placeholder attribute
			if (validTypes.indexOf(element.type) > -1) {

				//The input type does support the placeholder attribute. Check whether the placeholder attribute has a value
				if (newPlaceholder) {

					//The placeholder attribute has a value. Get the value of the current placeholder data-* attribute
					oldPlaceholder = element.getAttribute("data-currentplaceholder");

					//Check whether the placeholder attribute value has changed
					if (newPlaceholder !== oldPlaceholder) {

						//The placeholder attribute value has changed so we need to update. Check whether the placeholder should currently be visible.
						if (element.value === oldPlaceholder || element.value === newPlaceholder || !element.value) {

							//The placeholder should be visible so change the element value to that of the placeholder attribute and set placeholder styles
							element.value = newPlaceholder;
							element.className = element.className + " " + settings.className;
						}

						//If the current placeholder data-* attribute has no value the element wasn't present in the DOM when event handlers were bound, so bind them now
						if (!oldPlaceholder) {
                            //If the element has a containing form bind to the submit event so we can prevent placeholder values being submitted as actual values
                            if (element.form) {

                                //Get a reference to the containing form element (if present)
                                form = element.form;

                                //The placeholdersubmit data-* attribute is set if this form has already been dealt with
                                if (!form.getAttribute("data-placeholdersubmit")) {

                                    //The placeholdersubmit attribute wasn't set, so attach a submit event handler
                                    addEventListener(form, "submit", submitHandler);

                                    //Set the placeholdersubmit attribute so we don't repeatedly bind event handlers to this form element
                                    form.setAttribute("data-placeholdersubmit", "true");
                                }
                            }
							addEventListeners(element);
						}

						//Update the value of the current placeholder data-* attribute to reflect the new placeholder value
						element.setAttribute("data-currentplaceholder", newPlaceholder);
					}
				}
			}
		}
	}

	
	function createPlaceholders() {

		//Declare variables and get references to all input and textarea elements
		var inputs = document.getElementsByTagName("input"),
			textareas = document.getElementsByTagName("textarea"),
			numInputs = inputs.length,
			num = numInputs + textareas.length,
			i,
			element,
			form,
			placeholder;

		//Iterate over all input elements and apply placeholder polyfill if necessary
		for (i = 0; i < num; i += 1) {

			//Get the next element from either the input NodeList or the textarea NodeList, depending on how many elements we've already looped through
			element = (i < numInputs) ? inputs[i] : textareas[i - numInputs];

			//Get the value of the placeholder attribute
			placeholder = element.getAttribute("placeholder");

			//Check whether or not the current element is of a type that allows the placeholder attribute
			if (validTypes.indexOf(element.type) > -1) {

				//The input type does support placeholders. Check that the placeholder attribute has been given a value
				if (placeholder) {

					// If the element type is "password", attempt to change it to "text" so we can display the placeholder value in plain text
					if (element.type === "password") {

						// The `type` property is read-only in IE < 9, so in those cases we just move on. The placeholder will be displayed masked
						try {
							element.type = "text";
							element.setAttribute("data-placeholdertype", "password");
						} catch (e) {}
					}

					//The placeholder attribute has a value. Keep track of the current placeholder value in an HTML5 data-* attribute
					element.setAttribute("data-currentplaceholder", placeholder);

					//If the value of the element is the empty string set the value to that of the placeholder attribute and apply the placeholder styles
					if (element.value === "" || element.value === placeholder) {
						element.className = element.className + " " + settings.className;
						element.value = placeholder;
					}

					//If the element has a containing form bind to the submit event so we can prevent placeholder values being submitted as actual values
					if (element.form) {

						//Get a reference to the containing form element (if present)
						form = element.form;

						//The placeholdersubmit data-* attribute is set if this form has already been dealt with
						if (!form.getAttribute("data-placeholdersubmit")) {

							//The placeholdersubmit attribute wasn't set, so attach a submit event handler
							addEventListener(form, "submit", submitHandler);

							//Set the placeholdersubmit attribute so we don't repeatedly bind event handlers to this form element
							form.setAttribute("data-placeholdersubmit", "true");
						}
					}

					//Attach event listeners to this element
					addEventListeners(element);
				}
			}
		}
	}

	
	function init(opts) {

		//Create an input element to test for the presence of the placeholder property. If the placeholder property exists, stop.
		var test = document.createElement("input"),
			opt,
			styleElem,
			styleRules,
			i,
			j;

		//Test input element for presence of placeholder property. If it doesn't exist, the browser does not support HTML5 placeholders
		if (typeof test.placeholder === "undefined") {
			//HTML5 placeholder attribute not supported.

			//Set the options (or use defaults)
			for (opt in opts) {
				if (opts.hasOwnProperty(opt)) {
					settings[opt] = opts[opt];
				}
			}

			//Create style element for placeholder styles
			styleElem = document.createElement("style");
			styleElem.type = "text/css";

			//Create style rules as text node
			var importantValue = (settings.styleImportant) ? "!important" : "";
			styleRules = document.createTextNode("." + settings.className + " { color:" + settings.textColor  + importantValue + "; }");

			//Append style rules to newly created stylesheet
			if (styleElem.styleSheet) {
				styleElem.styleSheet.cssText = styleRules.nodeValue;
			} else {
				styleElem.appendChild(styleRules);
			}

			//Append new style element to the head
			document.getElementsByTagName("head")[0].appendChild(styleElem);

			//We use Array.prototype.indexOf later, so make sure it exists
			if (!Array.prototype.indexOf) {
				Array.prototype.indexOf = function (obj, start) {
					for (i = (start || 0), j = this.length; i < j; i += 1) {
						if (this[i] === obj) { return i; }
					}
					return -1;
				};
			}

			
			if (!Function.prototype.bind) {
				Function.prototype.bind = function (oThis) {
					if (typeof this !== "function") {
						throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
					}
					var aArgs = Array.prototype.slice.call(arguments, 1),
						fToBind = this,
						FNop = function () {},
						fBound = function () {
							return fToBind.apply(this instanceof FNop
								 ? this
								 : oThis,
							    aArgs.concat(Array.prototype.slice.call(arguments)));
						};
					FNop.prototype = this.prototype;
					fBound.prototype = new FNop();
					return fBound;
				};
			}

			//Create placeholders for input elements currently part of the DOM
			createPlaceholders();

			
			if (settings.live) {
				interval = setInterval(updatePlaceholders, 100);
			}

			//Placeholder attribute was successfully polyfilled :)
			return true;
		}

		//Placeholder attribute already supported by browser :)
		return false;
	}

	//Expose public methods
	return {
		init: init,
        create: createPlaceholders,
		refresh: updatePlaceholders
	};
}());




function FABridge(target, bridgeName){
    this.target = target;
    this.remoteTypeCache = {};
    this.remoteInstanceCache = {};
    this.remoteFunctionCache = {};
    this.localFunctionCache = {};
    this.bridgeID = FABridge.nextBridgeID++;
    this.name = bridgeName;
    this.nextLocalFuncID = 0;
    FABridge.instances[this.name] = this;
    FABridge.idMap[this.bridgeID] = this;

    return this;
}

// type codes for packed values
FABridge.TYPE_ASINSTANCE =  1;
FABridge.TYPE_ASFUNCTION =  2;

FABridge.TYPE_JSFUNCTION =  3;
FABridge.TYPE_ANONYMOUS =   4;

FABridge.initCallbacks = {}

FABridge.argsToArray = function(args){
    var result = [];
    for (var i = 0; i < args.length; i++){
        result[i] = args[i];
    }
    return result;
}

function instanceFactory(objID){
    this.fb_instance_id = objID;
    return this;
}

function FABridge__invokeJSFunction(args){  
    var funcID = args[0];
    var throughArgs = args.concat();
    throughArgs.shift();
   
    var bridge = FABridge.extractBridgeFromID(funcID);
    return bridge.invokeLocalFunction(funcID, throughArgs);
}

FABridge.addInitializationCallback = function(bridgeName, callback){
    var inst = FABridge.instances[bridgeName];
    if (inst != undefined){
        callback.call(inst);
        return;
    }

    var callbackList = FABridge.initCallbacks[bridgeName];
    if(callbackList == null){
        FABridge.initCallbacks[bridgeName] = callbackList = [];
    }

    callbackList.push(callback);
}

function FABridge__bridgeInitialized(bridgeName) {
    var objects = document.getElementsByTagName("object");
    var ol = objects.length;
    var activeObjects = [];
    if (ol > 0) {
		for (var i = 0; i < ol; i++) {
			if (typeof objects[i].SetVariable != "undefined") {
				activeObjects[activeObjects.length] = objects[i];
			}
		}
	}
    var embeds = document.getElementsByTagName("embed");
    var el = embeds.length;
    var activeEmbeds = [];
    if (el > 0) {
		for (var j = 0; j < el; j++) {
			if (typeof embeds[j].SetVariable != "undefined") {
            	activeEmbeds[activeEmbeds.length] = embeds[j];
            }
        }
    }
    var aol = activeObjects.length;
    var ael = activeEmbeds.length;
    var searchStr = "bridgeName="+ bridgeName;
    if ((aol == 1 && !ael) || (aol == 1 && ael == 1)) {
    	FABridge.attachBridge(activeObjects[0], bridgeName);	 
    }else if (ael == 1 && !aol) {
    	FABridge.attachBridge(activeEmbeds[0], bridgeName);
    }else {
    	var flash_found = false;
		if (aol > 1) {
			for (var k = 0; k < aol; k++) {
				 var params = activeObjects[k].childNodes;
				 for (var l = 0; l < params.length; l++) {
					var param = params[l];
					if (param.nodeType == 1 && param.tagName.toLowerCase() == "param" && param["name"].toLowerCase() == "flashvars" && param["value"].indexOf(searchStr) >= 0) {
						FABridge.attachBridge(activeObjects[k], bridgeName);
						flash_found = true;
						break;
					}
				}
				if (flash_found) {
					break;
				}
			}
		}
		if (!flash_found && ael > 1) {
			for (var m = 0; m < ael; m++) {
				var flashVars = activeEmbeds[m].attributes.getNamedItem("flashVars").nodeValue;
				if (flashVars.indexOf(searchStr) >= 0) {
					FABridge.attachBridge(activeEmbeds[m], bridgeName);
					break;
				}
			}
		}
	}
    return true;
}

// used to track multiple bridge instances, since callbacks from AS are global across the page.
FABridge.nextBridgeID = 0;
FABridge.instances = {};
FABridge.idMap = {};
FABridge.refCount = 0;
FABridge.extractBridgeFromID = function(id){
    var bridgeID = (id >> 16);
    return FABridge.idMap[bridgeID];
}

FABridge.attachBridge = function(instance, bridgeName){
    var newBridgeInstance = new FABridge(instance, bridgeName);
    FABridge[bridgeName] = newBridgeInstance;

    var callbacks = FABridge.initCallbacks[bridgeName];
    if (callbacks == null){
        return;
    }
    for (var i = 0; i < callbacks.length; i++){
        callbacks[i].call(newBridgeInstance);
    }
    delete FABridge.initCallbacks[bridgeName]
}

// some methods can't be proxied.  You can use the explicit get,set, and call methods if necessary.
FABridge.blockedMethods = {
    toString: true,
    get: true,
    set: true,
    call: true
};

FABridge.prototype ={
// bootstrapping
    root: function(){
        return this.deserialize(this.target.getRoot());
    },

    releaseASObjects: function(){
        return this.target.releaseASObjects();
    },

    releaseNamedASObject: function(value){
        if(typeof(value) != "object"){
            return false;
        }else{
            var ret =  this.target.releaseNamedASObject(value.fb_instance_id);
            return ret;
        }
    },

    create: function(className){
        return this.deserialize(this.target.create(className));
    },


    // utilities
    makeID: function(token) {
        return (this.bridgeID << 16) + token;
    },


    // low level access to the flash object
    getPropertyFromAS: function(objRef, propName){
        if (FABridge.refCount > 0){
            throw new Error("You are trying to call recursively into the Flash Player which is not allowed. In most cases the JavaScript setTimeout function, can be used as a workaround.");
        }else{
            FABridge.refCount++;
            retVal = this.target.getPropFromAS(objRef, propName);
            retVal = this.handleError(retVal);
            FABridge.refCount--;
            return retVal;
        }
    },

    setPropertyInAS: function(objRef,propName, value){
        if (FABridge.refCount > 0) {
            throw new Error("You are trying to call recursively into the Flash Player which is not allowed. In most cases the JavaScript setTimeout function, can be used as a workaround.");
        }else{
            FABridge.refCount++;
            retVal = this.target.setPropInAS(objRef,propName, this.serialize(value));
            retVal = this.handleError(retVal);
            FABridge.refCount--;
            return retVal;
        }
    },

    callASFunction: function(funcID, args){
        if (FABridge.refCount > 0){
            throw new Error("You are trying to call recursively into the Flash Player which is not allowed. In most cases the JavaScript setTimeout function, can be used as a workaround.");
        }else{
            FABridge.refCount++;
            retVal = this.target.invokeASFunction(funcID, this.serialize(args));
            retVal = this.handleError(retVal);
            FABridge.refCount--;
            return retVal;
        }
    },

    callASMethod: function(objID, funcName, args){
        if (FABridge.refCount > 0){
            throw new Error("You are trying to call recursively into the Flash Player which is not allowed. In most cases the JavaScript setTimeout function, can be used as a workaround.");
        }else{
            FABridge.refCount++;
            args = this.serialize(args);
            retVal = this.target.invokeASMethod(objID, funcName, args);
            retVal = this.handleError(retVal);
            FABridge.refCount--;
            return retVal;
        }
    },

    // responders to remote calls from flash
    invokeLocalFunction: function(funcID, args) {
        var result;
        var func = this.localFunctionCache[funcID];

        if(func != undefined){
            result = this.serialize(func.apply(null, this.deserialize(args)));
        }

        return result;
    },

    // Object Types and Proxies
    // accepts an object reference, returns a type object matching the obj reference.
    getTypeFromName: function(objTypeName){
        return this.remoteTypeCache[objTypeName];
    },

    createProxy: function(objID, typeName){
        var objType = this.getTypeFromName(typeName);
        instanceFactory.prototype = objType;
        var instance = new instanceFactory(objID);
        this.remoteInstanceCache[objID] = instance;
        return instance;
    },

    getProxy: function(objID){
        return this.remoteInstanceCache[objID];
    },

    // accepts a type structure, returns a constructed type
    addTypeDataToCache: function(typeData){
        newType = new ASProxy(this, typeData.name);
        var accessors = typeData.accessors;
        for (var i = 0; i < accessors.length; i++){
            this.addPropertyToType(newType, accessors[i]);
        }

        var methods = typeData.methods;
        for (var i = 0; i < methods.length; i++){
            if (FABridge.blockedMethods[methods[i]] == undefined){
                this.addMethodToType(newType, methods[i]);
            }
        }


        this.remoteTypeCache[newType.typeName] = newType;
        return newType;
    },

    addPropertyToType: function(ty, propName){
        var c = propName.charAt(0);
        var setterName;
        var getterName;
        if(c >= "a" && c <= "z"){
            getterName = "get" + c.toUpperCase() + propName.substr(1);
            setterName = "set" + c.toUpperCase() + propName.substr(1);
        }else{
            getterName = "get" + propName;
            setterName = "set" + propName;
        }
        ty[setterName] = function(val){
            this.bridge.setPropertyInAS(this.fb_instance_id, propName, val);
        }
        ty[getterName] = function(){
            return this.bridge.deserialize(this.bridge.getPropertyFromAS(this.fb_instance_id, propName));
        }
    },

    addMethodToType: function(ty, methodName){
        ty[methodName] = function(){
            return this.bridge.deserialize(this.bridge.callASMethod(this.fb_instance_id ,methodName, FABridge.argsToArray(arguments)));
        }
    },

    // Function Proxies
    getFunctionProxy: function(funcID){
        var bridge = this;
        if (this.remoteFunctionCache[funcID] == null){
            this.remoteFunctionCache[funcID] = function(){
                bridge.callASFunction(funcID, FABridge.argsToArray(arguments));
            }
        }
        return this.remoteFunctionCache[funcID];
    },

    getFunctionID: function(func){
        if (func.__bridge_id__ == undefined){
            func.__bridge_id__ = this.makeID(this.nextLocalFuncID++);
            this.localFunctionCache[func.__bridge_id__] = func;
        }
        return func.__bridge_id__;
    },

    // serialization / deserialization
    serialize: function(value) {
        var result = {};

        var t = typeof(value);
        if (t == "number" || t == "string" || t == "boolean" || t == null || t == undefined){
            result = value;
        } else if (value instanceof Array){
            result = [];
            for (var i = 0; i < value.length; i++)
            {
                result[i] = this.serialize(value[i]);
            }
        } else if (t == "function"){
            result.type = FABridge.TYPE_JSFUNCTION;
            result.value = this.getFunctionID(value);
        } else if (value instanceof ASProxy){
            result.type = FABridge.TYPE_ASINSTANCE;
            result.value = value.fb_instance_id;
        } else {
            result.type = FABridge.TYPE_ANONYMOUS;
            result.value = value;
        }

        return result;
    },

    deserialize: function(packedValue){
        var result;

        var t = typeof(packedValue);
        if (t == "number" || t == "string" || t == "boolean" || packedValue == null || packedValue == undefined)  {
            result = this.handleError(packedValue);
        } else if (packedValue instanceof Array){
            result = [];
            for (var i = 0; i < packedValue.length; i++) {
                result[i] = this.deserialize(packedValue[i]);
            }
        } else if (t == "object")  {
            for(var i = 0; i < packedValue.newTypes.length; i++){
                this.addTypeDataToCache(packedValue.newTypes[i]);
            }
            for (var aRefID in packedValue.newRefs){
                this.createProxy(aRefID,packedValue.newRefs[aRefID]);
            }
            if (packedValue.type == FABridge.TYPE_PRIMITIVE){
                result = packedValue.value;
            } else if (packedValue.type == FABridge.TYPE_ASFUNCTION) {
                result = this.getFunctionProxy(packedValue.value);
            } else if (packedValue.type == FABridge.TYPE_ASINSTANCE){
                result = this.getProxy(packedValue.value);
            }else if (packedValue.type == FABridge.TYPE_ANONYMOUS) {
                result = packedValue.value;
            }
        }
        return result;
    },

    addRef: function(obj){
        this.target.incRef(obj.fb_instance_id);
    },

    release:function(obj) {
        this.target.releaseRef(obj.fb_instance_id);
    },

    handleError: function(value){
        if (typeof(value)=="string" && value.indexOf("__FLASHERROR")==0){
            var myErrorMessage = value.split("||");
            if(FABridge.refCount > 0 ){
                FABridge.refCount--;
            }
            throw new Error(myErrorMessage[1]);
            return value;
        }else {
            return value;
        }   
    }
};

// The root ASProxy class that facades a flash object
ASProxy = function(bridge, typeName){
    this.bridge = bridge;
    this.typeName = typeName;
    return this;
};

ASProxy.prototype ={
    get: function(propName){
        return this.bridge.deserialize(this.bridge.getPropertyFromAS(this.fb_instance_id, propName));
    },

    set: function(propName, value) {
        this.bridge.setPropertyInAS(this.fb_instance_id, propName, value);
    },

    call: function(funcName, args){
        this.bridge.callASMethod(this.fb_instance_id, funcName, args);
    }, 
    
    addRef: function() {
        this.bridge.addRef(this);
    }, 
    
    release: function() {
        this.bridge.release(this);
    }
};


var gAcadColorMgr = new AcadColorManager();

function AcadColorManager() 
{ 
	this.unassignedColor = '13421772';
	this.unassignedOpacity = '0.7';
	this.unassignedBorderColor = '0';
	this.unassignedBorderOpacity = '1';
	this.unassignedBorderThickness = '2';

	this.assignedColor = '65535';
	this.assignedOpacity = '0.7';
	this.assignedBorderColor = '0';
	this.assignedBorderOpacity = '1';
	this.assignedBorderThickness = '5';

	this.selectedColor = '16776960';
	this.selectedOpacity = '0.9';
	this.selectedBorderColor = '255';
	this.selectedBorderOpacity = '1';
	this.selectedBorderThickness = '10';

	this.nofillColor = '-2';
	this.nofillOpacity = '0.0';
	this.nofillBorderColor = '0';
	this.nofillBorderOpacity = '1';
	this.nofillBorderThickness = '2';
	
	this._fixedColors = new Array();
	
	this._idealLabelTextSize = '11';
	this._minimumLabelTextSize = '8';
	this._shrinkLabelTextToFit = 'true';
	
	// true if the getHighlightRGBColorEncoding() function has been called
	// false otherwise.
	this._getHighlightRGBColorEncoding = false;
	
	// the variable to record the highlight RGB color encoding from database. Default to 1.
	this._highlightRGBColorEncoding = "1";
	
	this.valueColorMap = {}; // map of values (strings) to colors (strings containing decimal values)
	if(window.localStorage){
		this.valueColorMap = window.localStorage;
	}
	//XXX: this.legendKey used by the key of this.valueColorMap to avoid global conflicting of window.localStorage???
	this.legendKey = "LEGENDKEY";
	
	// This function is to call the Server side to retrieve the HighlightRGBColorEncoding value
	// should only call the server once for gAcadColorMgr
	this.setHighlightRGBColorEncoding = function() {
	    try {
	    	var result = Workflow.call('AbCommonResources-HighlightPatternService-getHighlightRGBColorEncoding', null);
	    	if (result.code == 'executed') {
	    		this._highlightRGBColorEncoding = result.message;
	    		this._getHighlightRGBColorEncoding = true;
	    	}
		} 
	    catch (e) {
	        Workflow.handleError(e);
	    }
	}
	
	this.reset = function() {
		if(window.localStorage){
			this.valueColorMap.clear();
		}else{
			this.valueColorMap = {};
		}
		
	}
	
	this.setAutoAssignColors = function(autoAssignColors) {
		this._fixedColors = autoAssignColors;
	}
	
	this.setIdealLabelTextSize = function(idealLabelTextSize) {
		this._idealLabelTextSize = idealLabelTextSize;
	}
	
	this.setMinimumLabelTextSize = function(minimumLabelTextSize) {
		this._minimumLabelTextSize = minimumLabelTextSize;
	}
	
	this.setShrinkLabelTextToFit = function(shrinkLabelTextToFit) {
		this._shrinkLabelTextToFit = shrinkLabelTextToFit;
	}

	this.setAssignedInitConfig = function(dwgHighlightsConfig){
		if(dwgHighlightsConfig.assigned!=null && dwgHighlightsConfig.assigned.fill!=null){
			gAcadColorMgr.setAssignedColor(dwgHighlightsConfig.assigned.fill.color);
			gAcadColorMgr.setAssignedOpacity(dwgHighlightsConfig.assigned.fill.opacity);
		}
		if(dwgHighlightsConfig.assigned!=null && dwgHighlightsConfig.assigned.border!=null){
			gAcadColorMgr.setAssignedBorderColor(dwgHighlightsConfig.assigned.border.color);
			gAcadColorMgr.setAssignedBorderOpacity(dwgHighlightsConfig.assigned.border.opacity);
			gAcadColorMgr.setAssignedBorderThinkness(dwgHighlightsConfig.assigned.border.thickness);
		}
	}
	
	this.setUnassignedInitConfig = function(dwgHighlightsConfig){
		if(dwgHighlightsConfig.unassigned!=null && dwgHighlightsConfig.unassigned.fill!=null){
			gAcadColorMgr.setUnassignedColor(dwgHighlightsConfig.unassigned.fill.color);
			gAcadColorMgr.setUnassignedOpacity(dwgHighlightsConfig.unassigned.fill.opacity);
		}
		if(dwgHighlightsConfig.unassigned!=null && dwgHighlightsConfig.unassigned.border!=null){
			gAcadColorMgr.setUnassignedBorderColor(dwgHighlightsConfig.unassigned.border.color);
			gAcadColorMgr.setUnassignedBorderOpacity(dwgHighlightsConfig.unassigned.border.opacity);
			gAcadColorMgr.setUnassignedBorderThinkness(dwgHighlightsConfig.unassigned.border.thickness);
		}
	}
	
	this.setSelectedInitConfig = function(dwgHighlightsConfig){
		if(dwgHighlightsConfig.selected!=null && dwgHighlightsConfig.selected.fill!=null){
			gAcadColorMgr.setSelectedColor(dwgHighlightsConfig.selected.fill.color);
			gAcadColorMgr.setSelectedOpacity(dwgHighlightsConfig.selected.fill.opacity);
		}
		if(dwgHighlightsConfig.selected!=null && dwgHighlightsConfig.selected.border!=null){
			gAcadColorMgr.setSelectedBorderColor(dwgHighlightsConfig.selected.border.color);
			gAcadColorMgr.setSelectedBorderOpacity(dwgHighlightsConfig.selected.border.opacity);
			gAcadColorMgr.setSelectedBorderThinkness(dwgHighlightsConfig.selected.border.thickness);
		}
	}
	
	this.setNoFillInitConfig = function(dwgHighlightsConfig){		
		if(dwgHighlightsConfig.nofill!=null && dwgHighlightsConfig.nofill.fill!=null){
			gAcadColorMgr.setNoFillColor(dwgHighlightsConfig.nofill.fill.color);
			gAcadColorMgr.setNoFillOpacity(dwgHighlightsConfig.nofill.fill.opacity);
		}
		if(dwgHighlightsConfig.nofill!=null && dwgHighlightsConfig.nofill.border!=null){
			gAcadColorMgr.setNoFillBorderColor(dwgHighlightsConfig.nofill.border.color);
			gAcadColorMgr.setNoFillBorderOpacity(dwgHighlightsConfig.nofill.border.opacity);
			gAcadColorMgr.setNoFillBorderThinkness(dwgHighlightsConfig.nofill.border.thickness);
		}
	}
	
	this.getRGB = function(nColorNum, asHex, isRGB) {
		var nColorRGB = 0;

		//		---- Convert color number to true color
		if (nColorNum <= 0)
			nColorRGB = 0;
		else if ( nColorNum >= 1 && nColorNum <= 256 && isRGB != true) {
			var nRed = (Math.round(this.map[nColorNum][0] * 255)) * 256 * 256;
			var nGreen = (Math.round(this.map[nColorNum][1] * 255)) * 256;
			var nBlue = (Math.round(this.map[nColorNum][2] * 255));
			nColorRGB = nRed + nGreen + nBlue;
		}
		else //when ColorNum > 256 or the nColorNum passed in is a RGB value already
			nColorRGB = nColorNum;	
	
		return this.ensureValidColor(nColorRGB.toString(asHex == true ? 16 : 10), asHex);
	}
	
	this.getRGBFromPattern = function(pattern, asHex) {
		
		if(this._getHighlightRGBColorEncoding == false)
			this.setHighlightRGBColorEncoding();
		
		var c = new String();
		if (pattern == null || !pattern.length)
			return "-1";
		var ver = parseInt(pattern);
		var vals = new Array();
		vals = pattern.split(" ");
				
		// Note that the ver == 1 option is not currently supported
		if (ver == 0)
			c = this.getRGB(parseInt(vals[1]), asHex);
		else if (ver >= 14)	{
			// The ARCHIBUS database stores the number representing
			// an RGB the opposite how Flash needs it.  Handle this case here	
			var c1 = parseInt(vals[3], 10);
			
			//convert from Windows's Highlight pattern format to Web's format
			if(this._highlightRGBColorEncoding=="0")
				c1 = this.convertColorValueFromWindowsFormat(c1);
			
			c1 = c1.toString(16);
			
			if (c1.length < 6) {
				var i = c1.length;
				c1 = ("000000" + c1).substring(i);
			}
			
			c = c1.substr(4, 2) + c1.substr(2, 2) + c1.substr(0, 2);
			if (!asHex)
				c = parseInt(c, 16);
		}
				
		return c;
	}
	
	
	//This funtion is to handle the problem that Windows and WebC adapt different formulas to convert from RGB color 
	// into the colorValue. (KB# 3029026)
	//
	// In Windows, the (R, G, B) color is converted into colorValue using (r + g * 255 + b * 255 * 255)
	// In WebC,  the (R, G, B) color is converted into colorValue using (r * 255 * 255 + g * 255 + b)
	this.convertColorValueFromWindowsFormat = function(color) {
		var nBlue = Math.floor(color/(256*256));
		var nGreen = Math.floor((color-nBlue*256*256)/256);
		var nRed = Math.floor(color-nBlue*256*256 - nGreen*256);
		
		return (nRed*256*256 + nGreen*256 + nBlue);
	}
	
	//KB# 3027416 - solid color on set color dialog issue
	//this function is a duplicate for getRGBFromPattern except for removing the line 
	//that switch the rgb color to bgr.
	this.getRGBFromPatternForGrid = function(pattern, asHex) {
		
		if(this._getHighlightRGBColorEncoding == false)
			this.setHighlightRGBColorEncoding();
		
		var c = new String();
		if (pattern == null || !pattern.length)
			return "-1";
		var ver = parseInt(pattern);
		var vals = new Array();
		vals = pattern.split(" ");
				
		// Note that the ver == 1 option is not currently supported
		if (ver == 0)
			c = this.getRGB(parseInt(vals[1]), asHex);
		else if (ver >= 14)	{
			var c1 = parseInt(vals[3], 10);
			
			//convert from Windows's Highlight pattern format to Web's format
			if(this._highlightRGBColorEncoding=="0")
				c1 = this.convertColorValueFromWindowsFormat(c1);
			
			c1 = c1.toString(16);
			
			if (c1.length < 6) {
				var i = c1.length;
				c1 = ("000000" + c1).substring(i);
			}
			
			if (!asHex)
				c = parseInt(c1, 16);
			else 
				c = c1;	
		}
				
		return c;
	}
	
	this.getColorFromValue = function (fullfield, val, asHex) {
		//var color = valueColorMap[fullfield + val];	
		var color = this.valueColorMap[this.legendKey + val.toUpperCase()];	
		if (color == undefined){
			var i = this.valueColorMap.length; 
			if ( i < this._fixedColors.length) {
				color = this._fixedColors[i];
				// The color values stored in _fixedColors are prefixed with '0x'
				// strip that off when assigning here
				color = color.substr(2);
			} else{
				color = this.getRGB(this.unassignedColor, true, true);
			}
			
			
			this.valueColorMap[this.legendKey + val.toUpperCase()] =  color;
		}
		
		return this.getRGB(parseInt('0x' + color), asHex, true);
	}
	
		
	this.setColor = function (fullfield, val, hexColor) {
		//valueColorMap[fullfield + val] = hexColor;
		
		this.valueColorMap[this.legendKey + val.toUpperCase()] = hexColor;
	}
	
	this.setUnassignedColor = function(c) { this.unassignedColor = c; }
	this.setUnassignedOpacity = function(c) { this.unassignedOpacity = c; }
	this.setUnassignedBorderColor = function(c) { this.unassignedBorderColor = c; }
	this.setUnassignedBorderOpacity = function(c) { this.unassignedBorderOpacity = c; }
	this.setUnassignedBorderThinkness = function(c) { this.unassignedBorderThickness = c; }

	this.setAssignedColor = function(c) { this.assignedColor = c; }
	this.setAssignedOpacity = function(c) { this.assignedOpacity = c; }
	this.setAssignedBorderColor = function(c) { this.assignedBorderColor = c; }
	this.setAssignedBorderOpacity = function(c) { this.assignedBorderOpacity = c; }
	this.setAssignedBorderThinkness = function(c) { this.assignedBorderThickness = c; }
	
	this.setSelectedColor = function(c) { this.selectedColor = c; }
	this.setSelectedOpacity = function(c) { this.selectedOpacity = c; }
	this.setSelectedBorderColor = function(c) { this.selectedBorderColor = c; }
	this.setSelectedBorderOpacity = function(c) { this.selectedBorderOpacity = c; }
	this.setSelectedBorderThinkness  = function(c) { this.selectedBorderThickness = c; }

	this.setNoFillColor = function(c) { this.nofillColor = c; }
	this.setNoFillOpacity = function(c) { this.nofillOpacity = c; }
	this.setNoFillBorderColor = function(c) { this.nofillBorderColor = c; }
	this.setNoFillBorderOpacity = function(c) { this.nofillBorderOpacity = c; }
	this.setNoFillBorderThinkness  = function(c) { this.nofillBorderThickness = c; }

	this.getUnassignedColor = function(asHex) {	
		return this.formatColor(this.unassignedColor, asHex);
	}
	
	this.getAssignedColor = function(asHex) {	
		return this.formatColor(this.assignedColor, asHex);
	}
	
	this.getSelectedColor = function(asHex) {	
		return this.formatColor(this.selectedColor, asHex);
	}
	
	this.formatColor = function(c, asHex) {	
		return this.ensureValidColor(parseInt(c).toString(asHex == true ? 16 : 10).toString(), asHex);
	}
	
	this.ensureValidColor = function(c, asHex) {
		if (asHex == true && c.length < 6) {
			var i = c.length;
			c = ("000000" + c).substring(i);
		}
		
		return c;	
	}
	

	this.map = [
	[0,0,0],
	
	[1,0,0], 
	[1,1,0],
	[0,1,0],
	[0,1,1],
	[0,0,1 ],
	[1, 0, 1 ],
	[1,1,1 ],
	[0.502,0.502,0.502 ],
	[0.753,0.753,0.753 ],
	[1,0, 0 ],				// 10
	
	[1,0.5,0.5 ],
	[0.65,0,0 ],
	[0.65,0.325,0.325], 
	[0.5,0,0 ],
	[0.5,0.25,0.25 ],
	[0.3,0,0 ],
	[0.3,0.15,0.15 ],
	[0.15,0,0 ],
	[0.15,0.075,0.075], 
	[1,0.25,0 ],			// 20
	
	[1,0.625,0.5 ],
	[0.65,0.1625,0 ],
	[0.65,0.4063,0.325 ],
	[0.5,0.125,0 ],
	[0.5,0.3125,0.25 ],
	[0.3,0.075,0 ],
	[0.3,0.1875,0.15 ],
	[0.15,0.0375,0 ],
	[0.15,0.0938,0.075 ],
	[1,0.5,0 ],				// 30
	
	[1,0.75,0.5 ],
	[0.65,0.325,0 ],
	[0.65,0.4875,0.325 ],
	[0.5,0.25,0 ],
	[0.5,0.375,0.25 ],
	[0.3,0.15,0 ],
	[0.3,0.225,0.15 ],
	[0.15,0.075,0 ],
	[0.15,0.1125,0.075 ],
	[1,0.75,0 ],			// 40
	
	[1,0.875,0.5 ],
	[0.65,0.4875,0 ],
	[0.65,0.5688,0.325 ],
	[0.5,0.375,0 ],
	[0.5,0.4375,0.25 ],
	[0.3,0.225,0 ],
	[0.3,0.2625,0.15 ],
	[0.15,0.1125,0 ],
	[0.15,0.1313,0.075 ],
	[1,1,0 ],				// 50
	
	[1,1,0.5 ],
	[0.65,0.65,0 ],
	[0.65,0.65,0.325 ],
	[0.5,0.5,0 ],
	[0.5,0.5,0.25 ],
	[0.3,0.3,0 ],
	[0.3,0.3,0.15 ],
	[0.15,0.15,0 ],
	[0.15,0.15,0.075 ],
	[0.75,1,0 ],			// 60
	
	[0.875,1,0.5 ],
	[,0.4875,0.65,0 ],
	[0.5688,0.65,0.325 ],
	[0.375,0.5,0 ],
	[,0.4375,0.5,0.25 ],
	[0.225,0.3,0 ],
	[0.2625,0.3,0.15 ],
	[0.1125,0.15,0 ],
	[0.1313,0.15,0.075 ],
	[0.5,1,0 ],				// 70
	
	[0.75,1,0.5 ],
	[0.325,0.65,0 ],
	[0.4875,0.65,0.325 ],
	[0.25,0.5,0 ],
	[0.375,0.5,0.25 ],
	[0.15,0.3,0 ],
	[0.225,0.3,0.15 ],
	[0.075,0.15,0 ],
	[0.1125,0.15,0.075 ],
	[0.25,1,0 ],			// 80
	
	[0.625,1,0.5 ],
	[0.1625,0.65,0 ],
	[0.4063,0.65,0.325 ],
	[0.125,0.5,0 ],
	[0.3125,0.5,0.25 ],
	[0.075,0.3,0 ],
	[0.1875,0.3,0.15 ],
	[0.0375,0.15,0 ],
	[0.0938,0.15,0.075 ],
	[0,1,0 ],				// 90
	
	[0.5,1,0.5 ],
	[0,0.65,0 ],
	[0.325,0.65,0.325], 
	[0,0.5,0 ],
	[0.25,0.5,0.25 ],
	[0,0.3,0 ],
	[0.15,0.3,0.15 ],
	[0,0.15,0 ],
	[0.075,0.15,0.075], 
	[0,1,0.25 ],			// 100
	
	[0.5,1,0.625 ],
	[0,0.65,0.1625 ],
	[0.325,0.65,0.4063 ],
	[0,0.5,0.125 ],
	[0.25,0.5,0.3125 ],
	[0,0.3,0.075 ],
	[0.15,0.3,0.1875 ],
	[0,0.15,0.0375 ],
	[0.075,0.15,0.0938 ],
	[0,1,0.5 ],			// 110
	
	[0.5,1,0.75 ],
	[0,0.65,0.325 ],
	[0.325,0.65,0.4875 ],
	[0,0.5,0.25 ],
	[0.25,0.5,0.375 ],
	[0,0.3,0.15 ],
	[0.15,0.3,0.225 ],
	[0,0.15,0.075 ],
	[0.075,0.15,0.1125 ],
	[0,1,0.75 ],			// 120
	
	[0.5,1,0.875 ],
	[0,0.65,0.4875 ],
	[0.325,0.65,0.5688 ],
	[0,0.5,0.375 ],
	[0.25,0.5,0.4375 ],
	[0,0.3,0.225 ],
	[0.15,0.3,0.2625 ],
	[0,0.15,0.1125 ],
	[0.075,0.15,0.1313 ],
	[0,1,1 ],				// 130
	
	[0.5,1,1 ],
	[0,0.65,0.65 ],
	[0.325,0.65,0.65 ],
	[0,0.5,0.5 ],
	[0.25,0.5,0.5 ],
	[0,0.3,0.3 ],
	[0.15,0.3,0.3 ],
	[0,0.15,0.15 ],
	[0.075,0.15,0.15 ],
	[0,0.75,1 ],			// 140
	
	[0.5,0.875,1 ],
	[0,0.4875,0.65 ],
	[0.325,0.5688,0.65 ],
	[0,0.375,0.5 ],
	[0.25,0.4375,0.5 ],
	[0,0.225,0.3 ],
	[0.15,0.2625,0.3 ],
	[0,0.1125,0.15 ],
	[0.075,0.1313,0.15 ],
	[0,0.5,1 ],				//150
	
	[0.5,0.75,1 ],
	[0,0.325,0.65 ],
	[0.325,0.4875,0.65 ],
	[0,0.25,0.5 ],
	[0.25,0.375,0.5 ],
	[0,0.15,0.3 ],
	[0.15,0.225,0.3 ],
	[0,0.075,0.15 ],
	[0.075,0.1125,0.15 ],
	[0,0.25,1 ],			// 160
	
	[0.5,0.625,1 ],
	[0,0.1625,0.65 ],
	[0.325,0.4063,0.65 ],
	[0,0.125,0.5 ],
	[0.25,0.3125,0.5 ],
	[0,0.075,0.3 ],
	[0.15,0.1875,0.3 ],
	[0,0.0375,0.15 ],
	[0.075,0.0938,0.15 ],
	[0,0,1 ],				// 170
	
	[0.5,0.5,1 ],
	[0,0,0.65 ],
	[0.325,0.325,0.65 ],
	[0,0,0.5 ],
	[0.25,0.25,0.5 ],
	[0,0,0.3 ],
	[0.15,0.15,0.3 ],
	[0,0,0.15 ],
	[0.075,0.075,0.15], 
	[0.25,0,1 ],			// 180
	
	[0.625,0.5,1 ],
	[0.1625,0,0.65 ],
	[0.4063,0.325,0.65 ],
	[0.125,0,0.5 ],
	[0.3125,0.25,0.5 ],
	[0.075,0,0.3 ],
	[0.1875,0.15,0.3 ],
	[0.0375,0,0.15 ],
	[0.0938,0.075,0.15 ],
	[0.5,0,1 ],			// 190
	
	[0.75,0.5,1 ],
	[0.325,0,0.65 ],
	[0.4875,0.325,0.65 ],
	[0.25,0,0.5 ],
	[0.375,0.25,0.5 ],
	[0.15,0,0.3 ],
	[0.225,0.15,0.3 ],
	[0.075,0,0.15 ],
	[0.1125,0.075,0.15 ],
	[0.75,0,1 ],			// 200
	
	[0.875,0.5,1 ],
	[0.4875,0,0.65 ],
	[0.5688,0.325,0.65 ],
	[0.375,0,0.5 ],
	[0.4375,0.25,0.5 ],
	[0.225,0,0.3 ],
	[0.2625,0.15,0.3 ],
	[0.1125,0,0.15 ],
	[0.1313,0.075,0.15 ],
	[1,0,1 ],					// 210
	
	[1,0.5,1 ],
	[0.65,0,0.65 ],
	[0.65,0.325,0.65 ],
	[0.5,0,0.5 ],
	[0.5,0.25,0.5 ],
	[0.3,0,0.3 ],
	[0.3,0.15,0.3 ],
	[0.15,0,0.15 ],
	[0.15,0.075,0.15 ],
	[1,0,0.75 ],				// 220
	
	[1,0.5,0.875 ],
	[0.65,0,0.4875 ],
	[0.65,0.325,0.5688 ],
	[0.5,0,0.375 ],
	[0.5,0.25,0.4375 ],
	[0.3,0,0.225 ],
	[0.3,0.15,0.2625 ],
	[0.15,0,0.1125 ],
	[0.15,0.075,0.1313 ],
	[1,0,0.5 ],			// 230
	
	[1,0.5,0.75 ],
	[0.65,0,0.325 ],
	[0.65,0.325,0.4875 ],
	[0.5,0,0.25 ],
	[0.5,0.25,0.375 ],
	[0.3,0,0.15 ],
	[0.3,0.15,0.225 ],
	[0.15,0,0.075 ],
	[0.15,0.075,0.1125 ],
	[1,0,0.25 ],			// 240
	
	[1,0.5,0.625 ],
	[0.65,0,0.1625 ],
	[0.65,0.325,0.4063 ],
	[0.5,0,0.125 ],
	[0.5,0.25,0.3125 ],
	[0.3,0,0.075 ],
	[0.3,0.15,0.1875 ],
	[0.15,0,0.0375 ],
	[0.15,0.075,0.0938 ],
	[0.33,0.33,0.33 ],		// 250
	
	[0.464,0.464,0.464 ],
	[0.598,0.598,0.598 ],
	[0.732,0.732,0.732 ],
	[0.866,0.866,0.866 ],
	[1,1, 1 ]
];

};


var Ab = window.Ab || {};


Ab.namespace = function( sNameSpace ) {

    if (!sNameSpace || !sNameSpace.length) {
        return null;
    }

    var levels = sNameSpace.split(".");

    var currentNS = Ab;

    // Ab is implied, so it is ignored if it is included
    for (var i=(levels[0] == "Ab") ? 1 : 0; i<levels.length; ++i) {
        currentNS[levels[i]] = currentNS[levels[i]] || {};
        currentNS = currentNS[levels[i]];
    }

    return currentNS;
};



var afm_form_values_changed = false;


function user_form_onload() {}


var system_form_onload_handlers = [];


Ext.onReady(function() {
    if (Ext.isIE) {
        Ext.menu.Menu.prototype.minWidth = 250;
    }

    // KB 3031455: for Chrome and Safari override the CSS rule
    if (Ext.isSafari) {
        Ext.util.CSS.updateRule('.selectvalue_button', 'margin-bottom', '-6px');
    }

    if(typeof Range !== 'undefined'){ 
        if (typeof Range.prototype.createContextualFragment == "undefined") {
            Range.prototype.createContextualFragment = function (html) {
                var doc = window.document;
                var container = doc.createElement("div");
                container.innerHTML = html;
                var frag = doc.createDocumentFragment(), n;
                while ((n = container.firstChild)) {
                    frag.appendChild(n);
                }
                return frag;
            };
        }
    }

    var onLoad = function() {
        for (var i = 0; i < system_form_onload_handlers.length; i++) {
            system_form_onload_handlers[i].call();
        }
        user_form_onload();
    };

    if (system_form_onload_handlers.length == 0) {
        // in debug mode, on IE9, large dashboard views run this script before the handler is initialized
        onLoad.defer(1000);
    } else {
        onLoad();
    }
});


Ab.namespace('data');


Ab.data.FieldDef = Base.extend({
    // original config object    
    config: null,

    // field properties    
    id: '',
    fullName: '',
    title: '',
    afmType: '',
    type: '',
    format: '',
    size: 0,
    decimals: 0,
    numericFormat: '',
    hidden: false,
    readOnly: false,
    required: false,
    isEnum: false,
    isDate: false,
    isTime: false,
    isNumeric: false,
    isDocument: false,
    primaryKey: false,
    foreignKey: false,
    isEnum: false,
    enumValues: null,
    value: '',
    op: '=',
    colspan: 1,
    rowspan: 1,
    controlType: '',
    groupBy: false,
    defaultValue: '',
    
    //axvw field's manual properties to validate user's max and min inputs
    maxValue: '',
    minValue: '',
    
    
    constructor: function(config) {
        this.config = config;
        Ext.apply(this, config);
    },
    
    isUpperCase: function(){
    	var format = this.format.toUpperCase();
    	return (format === "UPPERALPHANUM" || format === "UPPERALPHA" || format === "UPPER");
    },
    
    
    formatValue: function(value, useLocalizedFormat, convertEnumValues, values) {
        if (!valueExists(value)) {
            return '';
        }

        if (!valueExists(useLocalizedFormat)) {
            useLocalizedFormat = true;
        }
        if (!valueExists(convertEnumValues)) {
            convertEnumValues = true;
        }
        if (!valueExists(values)) {
            values = {};
        }
        
        var formattedValue = value;
        if (this.isDate && value.constructor == Date) {
            formattedValue = value.format(this.getDateFormat(useLocalizedFormat));
        } else if (this.isTime && value.constructor == Date) {
            formattedValue = value.format(this.getTimeFormat(useLocalizedFormat));
        } else if (this.isEnum && useLocalizedFormat && convertEnumValues) {
            formattedValue = this.enumValues[value];
        } else if (this.isNumber()) {
        	if (useLocalizedFormat) {
        		// format numeric value using localized format, for display
	        	if (value.constructor == Number) {
	        		formattedValue = value.toFixed(this.decimals);
	        	} 
	            if (this.format.toUpperCase() != 'NOSEPARATOR') {
	           		formattedValue = formattedValue + '';
	                formattedValue = insertGroupingSeparator(formattedValue, true, useLocalizedFormat);
	            }
	            formattedValue = this.formatCurrency(formattedValue, values);
        	}
        } 
        return formattedValue;
    },
    
    
    formatCurrency: function(value, values) {
    	var currencySymbol = this.getCurrencySymbol(values);
        var formattedValue = value;
        if(currencySymbol.length > 1){
    		formattedValue = currencySymbol + " " +  formattedValue;
    	}else{
    		formattedValue = currencySymbol  +  formattedValue;
    	}	
        return formattedValue;
    },
    
    
    getCurrencySymbol: function(values){
    	var currencySymbol = "";
        if (valueExists(this.currency)) {
        	currencySymbol = View.currencySymbolFor(this.currency);
        } else if (valueExists(this.currencyField) && valueExists(values)) {
        	var currencyFieldValue = values[this.currencyField];
        	if (valueExists(currencyFieldValue)) {
        		currencySymbol = View.currencySymbolFor(currencyFieldValue);
        	}
        }
        return currencySymbol;
    },
    
    
    parseValue: function(value, useLocalizedFormat, recordValues) {
        var parsedValue = value;
        if (!valueExists(useLocalizedFormat)) {
            useLocalizedFormat = true;
        }
        if (this.isDate && value.constructor == String) {
			if (trim(value) != '') {
				parsedValue = Date.parseDate(value, this.getDateFormat(useLocalizedFormat));
				if (!valueExists(parsedValue)) {
					// hack for grid values, which use raw DB values and not ARCHIBUS neutral format
					// TODO: fix the grid data format and ViewHandlers.getDataRecords()!
					parsedValue = Date.parseDate(value + '00', 'Y-m-d H:i:s.u');
				}
			}
        } else if (this.isTime && value.constructor == String) {
  			if (trim(value) != '') {
				parsedValue = Date.parseDate(value, this.getTimeFormat(useLocalizedFormat));
				if (!valueExists(parsedValue)) {
					// hack for grid values, which use raw DB values and not ARCHIBUS neutral format
					// TODO: fix the grid data format and ViewHandlers.getDataRecords()!
					parsedValue = Date.parseDate(value, 'H:i:s');
				}
				if (!valueExists(parsedValue)) {
					parsedValue = Date.parseDate(value + '00', 'Y-m-d H:i:s.u');
				}
			}
        } else if (this.isNumber()) {
        	parsedValue = this.parseNumericValue(parsedValue, useLocalizedFormat, recordValues);
        }
        return parsedValue;
    },
    
    
    parseNumericValue: function(value, useLocalizedFormat, values){
    	var parsedValue = value + '';
        // remove group separator
        if (this.format.toUpperCase() != 'NOSEPARATOR') {
            parsedValue = removeGroupingSeparator(parsedValue, useLocalizedFormat);
        }
    	 
        // XXX:a high risk change
        // replace localized decimal separator by default separator "."
        // parsedValue = parsedValue.replace(strDecimalSeparator, ".");
    	 
        // remove currency symbol if possible
        var currencySymbol = this.getCurrencySymbol(values);
        if(valueExistsNotEmpty(currencySymbol)){
            parsedValue = trim(parsedValue.replace(currencySymbol, ''));
        }
         
        return parsedValue;
    },
    
    
    getDateFormat: function(useLocalizedFormat) {
        return useLocalizedFormat ? View.dateFormat : 'Y-m-d';
    },

    
    getTimeFormat: function(useLocalizedFormat) {
        return useLocalizedFormat ? View.timeFormat : 'H:i.s.u';
    },
    
    isNumber: function() {
        return (this.type === 'java.lang.Double' || this.type === 'java.lang.Integer' || (this.type == 'java.lang.Float' && this.format == 'Float'));
    },
    
    
    evaluateExpressions: function(ctx) {
    	if (valueExists(this.currency)) {
            this.currency = View.evaluateString(this.currency, ctx);
    	}
    }
});



Ab.data.SortFieldDef = Base.extend({
    table: '',
    name: '',
    ascending: true,
    
    
    constructor: function(config) {
        Ext.apply(this, config);
    }
});



Ab.data.Record = Base.extend({
    
    // hash of record values; each value is a JavaScript object
    values: null,
    
    // hash of old record values; each value is an ARCHIBUS neutral string
    oldValues: null,
    
    // hash of localized values; used in grid and cross-table controls 
    // to avoid on-the-fly localization of large data volumes (too slow in IE6)
    localizedValues: null, 
    
    // true if this record does not exist in the database 
    isNew: true, 

    
    constructor: function(values, isNew) {
        this.values = {};
        this.oldValues = {};
        this.localizedValues = {};
        if (valueExists(values)) {
            this.fromJSON(values);
        }
        
        if (valueExists(isNew)) {
            this.isNew = isNew;
        }
    },
    
    
    fromJSON: function(record) {
        for (var name in record) {
            var value = record[name];
            if (!valueExists(value)) {
                value = '';
            }
          
            // TODO: the grid and its WFR still use old JSON format
            if (!endsWith(name, '.key') && !endsWith(name, '.raw')) {
                var rawValue = record[name + '.raw'];
                if (valueExists(rawValue)) {
                    this.values[name] = rawValue;
                } else if (valueExists(value.n)) {
                    this.values[name] = value.n;
                    this.localizedValues[name] = value.l;
                } else {
                    this.values[name] = value;
                }
            }
        }
        if (valueExists(this.values['isNew'])) {
            this.isNew = this.values['isNew'];
        }
    },

    
    toRestriction: function() {
        return new Ab.view.Restriction(this.values);
    },
    
    
    getValue: function(fieldName) {
        return this.values[fieldName];
    },
    
    
    getLocalizedValue: function(fieldName) {
        return this.localizedValues[fieldName];
    },
    
    
    setValue: function(fieldName, value) {
        this.values[fieldName] = value;
    },
    
    
    setOldValue: function(fieldName, value) {
        this.oldValues[fieldName] = value;
    },
    
    
    removeValue: function(fieldName) {
        delete this.values[fieldName];
    },
    
    
    getValues: function(){
    	return this.values;
    },
    
    
    toString: function() {
        var s = '';
        for (var name in this.values) {
            var value = this.values[name];
            s = s + name + ': \'' + value + '\', ';
        }
        return s;
    }
});


Ab.data.DataSet = Base.extend({
    
    // data set type
    type: '',
    
    
    constructor: function(data) {
        if (valueExists(data)) {
            this.fromJSON(data);
        }
    },
    
    
    fromJSON: function(data) {}
});


Ab.data.DataSetList = Ab.data.DataSet.extend({
    // array of Ab.data.Record
    records: null,

    // whether the server could not retrieve all requested records due to a record limit    
    hasMoreRecords: false,
    
    
    constructor: function(data) {
        this.records = [];
        this.inherit(data);
        this.type = 'list';
    },
    
    
    addRecord: function(record) {
        this.records.push(record);
    },
    
    
    addRecords: function(records) {
    	for (var i = 0; i < records.length; i++) {
            this.records.push(records[i]);
    	}
    },
    
    
    fromJSON: function(data) {
        this.inherit(data);
        
        for (var i = 0; i < data.records.length; i++) {
            var dataRecord = new Ab.data.Record();
            dataRecord.fromJSON(data.records[i]);
            this.records.push(dataRecord);
        }

        if (valueExists(data.hasMoreRecords)) {
            this.hasMoreRecords = data.hasMoreRecords;
        }
    }
});


Ab.data.DataSetGrid = Ab.data.DataSetList.extend({
    
    // array of index records, each containing {value, count} properties.
    indexRecords: null,
    
    
    constructor: function(data) {
        this.indexRecords = [];
        this.inherit(data);
        this.type = 'grid';
    },
    
    
    fromJSON: function(data) {
        this.inherit(data);
        
        for (var i = 0; i < data.indexRecords.length; i++) {
            this.indexRecords.push(data.indexRecords[i]);
        }
    },
    
    
    getIndexRecord: function() {
        return this.indexRecords;
    }
});



Ab.data.DataSet1D = Ab.data.DataSetList.extend({
    // array of row dimension values
    rowValues: null,
    
    // array of row dimension records (optional)
    rowRecords: null,
    
    // array of total records
    totals: null,
    
    
    constructor: function(data) {
        this.rowValues = [];
        this.rowRecords = [];
        this.totals = [];
        this.nullValueTitle = '';
        this.inherit(data);
        this.type = '1d';

    },
    
    
    fromJSON: function(data) {
        this.inherit(data);
        
        for (var i = 0; i < data.rowValues.length; i++) {
            this.rowValues.push(data.rowValues[i]);
        }

        for (var i = 0; i < data.rowRecords.length; i++) {
            var dataRecord = new Ab.data.Record();
            dataRecord.fromJSON(data.rowRecords[i]);
            this.rowRecords.push(dataRecord);
        }

        for (var i = 0; i < data.totals.length; i++) {
            var dataRecord = new Ab.data.Record();
            dataRecord.fromJSON(data.totals[i]);
            this.totals.push(dataRecord);
        }
        
        this.nullValueTitle = data.nullValueTitle;
    },
    
    
    getRowValues: function() {
        return this.rowValues;
    }
});


Ab.data.DataSet2D = Ab.data.DataSet1D.extend({
    // array of column dimension values
    columnValues: null,
    
    // Record index. The key is a string that combines row and column values ("row.column"), and the
    // value is an index of the record in the records list.
    recordIndex: null,
    
    // array of row subtotals records
    rowSubtotals: null,
    
    nullValueTitle: null, 
    
    
    constructor: function(data) {
        this.columnValues = [];
        this.recordIndex = {};
        this.rowSubtotals = [];
        this.columnSubtotals = [];
        this.nullValueTitle = '';
        
        this.inherit(data);
        
        this.type = '2d';
    },
    
    
    fromJSON: function(data) {
        this.inherit(data);
        
        for (var i = 0; i < data.columnValues.length; i++) {
            this.columnValues.push(data.columnValues[i]);
        }
        
        this.recordIndex = data.recordIndex; 
        
        for (var i = 0; i < data.rowSubtotals.length; i++) {
            var dataRecord = new Ab.data.Record();
            dataRecord.fromJSON(data.rowSubtotals[i]);
            this.rowSubtotals.push(dataRecord);
        }

        for (var i = 0; i < data.columnSubtotals.length; i++) {
            var dataRecord = new Ab.data.Record();
            dataRecord.fromJSON(data.columnSubtotals[i]);
            this.columnSubtotals.push(dataRecord);
        }

        this.nullValueTitle = data.nullValueTitle;
    },
    
    
    getColumnValues: function() {
        return this.columnValues;
    },

        
    getRecordIndex: function(rowValue, columnValue) {
        var key = rowValue + "." + columnValue;
        return this.recordIndex[key];
    },
    
        
    getRecordForRowAndColumn: function(rowValue, columnValue) {
        var index = this.getRecordIndex(rowValue, columnValue);
        return this.records[index];
    }
});



Ab.data.DataSource = Base.extend({
    
    // data source id
    id: '',
    
    // data source type, e.q. 'grouping'
    type: '',
    
    // data source title
    title: '',
    
    // short view name without extension, such as 'ab-ex-em-grid'
    viewName: '',
    
    // main table name
    mainTableName: '',

    // array of all table names
    tableNames: null,
    
    // Ext.util.MixedCollection of Ab.data.FieldDef objects
    fieldDefs: null,
    
    // array of Ab.data.SortFieldDef objects
    sortFieldDefs: [],
    
    // DataSource query parameters
    parameters: null,
    
    // DataSource query 
    customQuery: null,
    
    // DataSource restriction 
    restriction: null,

    // record limit, 0 means no limit
    recordLimit: 0,
    
    // DataSource main table primary key field name collection
    primaryKeyFields: [],
    
    // original configuration
    config: null,
    
    
    constructor: function(id, config) {
    	this.config = config;
        this.id = id;
        this.type = config.type;
        this.title = config.title;
        this.viewName = config.viewName;
        this.mainTableName = config.mainTableName;
        this.tableNames = config.tableNames;
        this.parameters = {};

        // create field defs
        this.fieldDefs = new Ext.util.MixedCollection();
        if (valueExists(config.fieldDefs)) {
            for (var i = 0; i < config.fieldDefs.length; i++) {
                var fieldDef = new Ab.data.FieldDef(config.fieldDefs[i]);
                this.fieldDefs.add(fieldDef.id, fieldDef);
            }
        }
        this.sortFieldDefs = [];
        if (valueExists(config.sortFieldDefs)) {
            for (var i = 0; i < config.sortFieldDefs.length; i++) {
                var sortFieldDef = new Ab.data.SortFieldDef(config.sortFieldDefs[i]);
                this.sortFieldDefs[i] = sortFieldDef;
            }
        }
        this.primaryKeyFields = [];
        if (valueExists(config.primaryKeyFields)) {
            for (var i = 0, primaryKeyName; primaryKeyName = config.primaryKeyFields[i]; i++) {
                this.primaryKeyFields[i] = primaryKeyName;
            }
        }

        if (valueExists(config.customQuery)) {
			this.customQuery = config.customQuery;
        }
        if (valueExists(config.viewRestriction)) {
			this.restriction = config.viewRestriction;
        }
        
        this.evaluateExpressions();

        // register this data source in the View
        View.dataSources.add(this.id, this);
    },
    
    
    formatValue: function(fieldName, fieldValue, useLocalizedFormat, convertEnumValues, values) {
    	if (!valueExists(convertEnumValues)) {
    		convertEnumValues = true;
    	}
  	
        var formattedValue = fieldValue;
        
        var fieldDef = this.fieldDefs.get(fieldName);
        if (fieldDef) {
            formattedValue = fieldDef.formatValue(fieldValue, useLocalizedFormat, convertEnumValues, values);
        }
        
        return formattedValue;
    },
    
    
    formatCurrencyValue: function(fieldName, fieldValue, values) {
        var formattedValue = fieldValue;
        
        var fieldDef = this.fieldDefs.get(fieldName);
        if (fieldDef) {
            formattedValue = fieldDef.formatCurrency(fieldValue, values);
        } else {
        	// check for totals, min, max and average field: table_name.sum_field_name
        	fieldName = fieldName.replace('.sum_', '.');
        	fieldName = fieldName.replace('.min_', '.');
        	fieldName = fieldName.replace('.max_', '.');
        	fieldName = fieldName.replace('.avg_', '.');
            fieldDef = this.fieldDefs.get(fieldName);
            if (fieldDef) {
                formattedValue.l = fieldDef.formatCurrency(fieldValue.l, values);
            }        	
        }
        
        return formattedValue;
    },
    
    
    parseValue: function(fieldName, fieldValue, useLocalizedFormat, recordValues) {
        var parsedValue = fieldValue;
        
        var fieldDef = this.fieldDefs.get(fieldName);
        if (fieldDef) {
            parsedValue = fieldDef.parseValue(fieldValue, useLocalizedFormat, recordValues);
        }
        
        return parsedValue;
    },
    
    
    parseValues: function(values, useLocalizedFormat) {
        var parsedValues = {};
        for (var name in values) {
            var parsedValue = this.parseValue(name, values[name], useLocalizedFormat, values);
            parsedValues[name] = parsedValue;
        }
        return parsedValues;
    },
    
    
    formatValues: function(values, useLocalizedFormat, convertEnumValues) {
    	if (!valueExists(convertEnumValues)) {
    		convertEnumValues = true;
    	}
  	
        var formattedValues = {};
        for (var name in values) {
            var value = values[name];
            if (valueExistsNotEmpty(value)) {
                var formattedValue = this.formatValue(name, value, useLocalizedFormat, convertEnumValues, values);
                formattedValues[name] = formattedValue;
            } else if (!useLocalizedFormat) {
                // include empty values before sending to the server
                formattedValues[name] = value;
            }
        }
        return formattedValues;
    },
    
    
    formatCurrencyValues: function(values) {
        var formattedValues = {};
        for (var name in values) {
            var value = values[name];
            if (valueExistsNotEmpty(value)) {
                var formattedValue = this.formatCurrencyValue(name, value, values);
                formattedValues[name] = formattedValue;
            }
        }
        return formattedValues;
    },
    
    
    processInboundRecord: function(record) {
        record.oldValues = this.parseValues(record.values, false);
        record.values = this.parseValues(record.values, false);
        return record;
    },
    
    
    processOutboundRecord: function(record) {
        var processedRecord = new Ab.data.Record();
        processedRecord.values = this.formatValues(record.values, false);
        processedRecord.oldValues = this.formatValues(record.oldValues, false);
        processedRecord.isNew = record.isNew;
        return processedRecord;
    },
    
    // ----------------------- data access methods ------------------------------------------------

    
    setRestriction: function(restriction) {
        this.restriction = restriction;
    },

    
    addParameter: function(name, value) {
        this.parameters[name] = value;   
    },

    
    addParameters: function(parameters) {
        _.extend(this.parameters, parameters);
    },

    
    clearParameters: function() {
        this.parameters = {};
    },

    
    getRecords: function(restriction, config) {
        var parameters = this.getParameters(config);
        if (restriction) {
            if (restriction.addClauses) {
                restriction.addClauses(this.restriction, false);
            }
        } else {
            restriction = this.restriction;
        }
        parameters.restriction = toJSON(restriction || {});
        parameters.recordLimit = this.recordLimit;
        var result = Workflow.call('AbCommonResources-getDataRecords', parameters);
        
        // parse record values from ARCHIBUS neutral strings into JavaScript objects
        var records = [];
        for (var i = 0; i < result.dataSet.records.length; i++) {
            records.push(this.processInboundRecord(result.dataSet.records[i]));
        }
        return records;
    },
        
    
    getRecord: function(restriction, config) {
        var parameters = this.getParameters(config);
        parameters.restriction = toJSON(restriction || {});
        var result = Workflow.call('AbCommonResources-getDataRecord', parameters);
        
        // parse record values from ARCHIBUS neutral strings into JavaScript objects
        result.dataSet = this.processInboundRecord(result.dataSet);
        
        return result.dataSet;
    },
    
    
    getDefaultRecord: function(restriction, config) {
        var parameters = this.getParameters(config);
        parameters.restriction = toJSON(restriction || {});
        var result = Workflow.call('AbCommonResources-getDefaultDataRecord', parameters);
        
        // parse record values from ARCHIBUS neutral strings into JavaScript objects
        result.dataSet = this.processInboundRecord(result.dataSet);
        
        return result.dataSet;
    },
    
    
    saveRecord: function(record, config) {
        var parameters = this.getParameters(config);
        
        // format record values into ARCHIBUS neutral strings
        record = this.processOutboundRecord(record);
        
        parameters.record = toJSON(record);
        var result = Workflow.call('AbCommonResources-saveDataRecord', parameters);
		Workflow.callMethod('AbSpaceRoomInventoryBAR-SchoolHandler-writeLog',record,"INSERTED");
        return result.dataSet;
    },
    
    
    saveRecords: function(records, config) {
        var parameters = this.getParameters(config);
        
        // format record values into ARCHIBUS neutral strings
        var outboundRecords = [];
        for (var i = 0; i < records.length; i++) {
            outboundRecords.push(this.processOutboundRecord(records[i]));
        }
        
        parameters.records = toJSON(outboundRecords);
        var result = Workflow.call('AbCommonResources-saveDataRecord', parameters);
        return result.dataSet;
    },
    
    
    deleteRecord: function(record, config) {
        var parameters = this.getParameters(config);
        
        // format record values into ARCHIBUS neutral strings
        record = this.processOutboundRecord(record);
        
        parameters.record = toJSON(record);
        var result = Workflow.call('AbCommonResources-deleteDataRecords', parameters);
		Workflow.callMethod('AbSpaceRoomInventoryBAR-SchoolHandler-writeLog',record,"DELETED");
        return result.dataSet;
    },
    
    
    getParameters: function(config) {
        var parameters = config || {};
        
        parameters.viewName = this.viewName;
        parameters.dataSourceId = this.id;
        if (!valueExistsNotEmpty(this.viewName)) {
        	parameters.tableName = this.mainTableName;
            parameters.tableNames = this.tableNames;

            if (this.tableNames) {
                parameters.tableNames = toJSON(this.tableNames);
            }

        	parameters.fieldNames = [];
            this.fieldDefs.each(function(fieldDef) {
                parameters.fieldNames.push(fieldDef.id);
            });
        	parameters.fieldNames = toJSON(parameters.fieldNames);
        }
        
        Ext.apply(parameters, this.parameters);
        
        return parameters;
    },
    
    
    evaluateExpressions: function(ctx) {
        if (!valueExists(ctx)) {
            ctx = View.evaluationContext;
        }
        
        this.fieldDefs.each(function(fieldDef) {
            fieldDef.evaluateExpressions(ctx);
        });
    }
});


Ab.data.createDataSet = function(data) {
    var dataSet = null;
    if (data.type == 'record') {
        dataSet = new Ab.data.Record(data.records[0]);
    } else if (data.type == 'list') {
        dataSet = new Ab.data.DataSetList(data);
    } else if (data.type == 'grid') {
        dataSet = new Ab.data.DataSetGrid(data);
    } else if (data.type == '1d') {
        dataSet = new Ab.data.DataSet1D(data);
    } else if (data.type == '2d') {
        dataSet = new Ab.data.DataSet2D(data);
    }
    return dataSet;
};


Ab.data.createDataSourceForFields = function(options) {
	var config = {
		type: '',
        tableNames: [],
        fieldNames: [],
		fieldDefs: []
	};
    Ext.apply(config, options);

    config.mainTableName = config.tableNames[0];

	for (var f = 0; f < config.fieldNames.length; f++) {
		var fieldName = config.fieldNames[f];
		if (fieldName.indexOf('.') == -1) {
			fieldName = mainTableName + '.' + fieldName;
		}
		config.fieldDefs.push({
			id: fieldName
		});
	}
	return new Ab.data.DataSource(id, config);
};


Ab.data.HighlightPattern = Base.extend({
	
	// hpattern string
	pattern: '',
	
	// pattern parts
	patternParts: null,
	
	
	constructor: function(pattern) {
	    this.pattern = pattern;
		this.patternParts = pattern.split(' ');
    },
    
    isNewFormat: function() {
    	return (this.patternParts[0] == '14');
    },
    
    isHatched: function() {
		return (this.patternParts[this.isNewFormat() ? 1 : 0] == '1');
    },
    
    getLegendBitmapName: function(tableName, primaryKeyValues) {
    	// table name
    	var name = tableName;
    	
    	// primary key values
    	for (var i = 0; i < primaryKeyValues.length; i++) {
    		name = name + '-' + primaryKeyValues[i];
    	}
    	
    	// pattern name
    	name = name + '-' + this.patternParts[this.isNewFormat() ? 6 : 3];
    	
    	// remove spaces
    	name = name.replace(/\s/g, '');
    	
    	// convert to lower case
    	name = name.toLowerCase();
    	
    	// TODO: replace special characters in PK values?
    	
    	return name;
    }
});

Ab.namespace('workflow');


Ab.workflow.Workflow = Base.extend({
    // no instance data or methods    
},
{
    // static data and methods
    
    // default WFR call timeout: 10 seconds
    DEFAULT_TIMEOUT: 10,
    
    // DWR error message when script session has expired or is invalid
    ERROR_SCRIPT_SESSION: 'Attempt to fix script session',

    // DWR error message when the server returns no data (happens in SSO mode when script session has expired)
    ERROR_NO_DATA: 'No data received from server',

    // @begin_translatable
    z_MESSAGE_RULE_EXECUTED: 'Workflow rule executed',
    z_MESSAGE_RULE_FAILED: 'Workflow rule failed',
    z_MESSAGE_RULE_NOT_FOUND: 'Workflow rule not found',
    z_MESSAGE_RULE_NOT_PERMITTED: 'Workflow rule not permitted',
    z_MESSAGE_CONTAINER_FAILED: 'Workflow rules container failed',
    z_MESSAGE_SESSION_TIMEOUT_TITLE: 'Session Timeout',
    z_MESSAGE_SESSION_TIMEOUT: 'Your session has expired, and you have been signed out of WebCentral. To continue working, please sign in again.',
    // @end_translatable
    
    
    runRule: function(workflowRuleId, parameters, callbackFunction, callbackObject, timeout) {
        try {
            if (!valueExists(timeout)) {
                timeout = Ab.workflow.Workflow.DEFAULT_TIMEOUT;
            }
            var systemCallback = new Ab.workflow.Callback(callbackFunction, callbackObject);
            var callbackDelegate = systemCallback.afterRuleExecuted.createDelegate(systemCallback);
            var options = {
                'callback': callbackDelegate,
                'async': false,
                'timeout': timeout * 1000
            }
            this.prapareParameters(parameters);
            workflow.runWorkflowRule(workflowRuleId, parameters, options);
        } catch (e) {
            e.description = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_FAILED) + workflowRuleId;
            throw e;
        }
    },
    
    
    runRuleAndReturnResult: function(workflowRuleId, parameters, timeout) {
        try {
            if (!valueExists(timeout)) {
                timeout = Ab.workflow.Workflow.DEFAULT_TIMEOUT;
            }
            var systemCallback = new Ab.workflow.Callback(null, null);
            var callbackDelegate = systemCallback.afterRuleExecuted.createDelegate(systemCallback);
            var options = {
                'callback': callbackDelegate,
                'async': false,
                'timeout': timeout * 1000
            }
            
            this.prapareParameters(parameters);
            workflow.runWorkflowRule(workflowRuleId, parameters, null, options);
            var result = systemCallback.result;
            
            if (!valueExists(result.message)) {
                result.message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_EXECUTED) + 
                    ': ' + workflowRuleId + ' (' + result.executionTime + ' ms)';
            }
            
            return result;
        } catch (e) {
            e.description = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_FAILED) + ': ' + workflowRuleId;
            throw e;
        }
    },
    
    
    runRuleWithUpload: function(workflowRuleId, parameters, uploadElement, callbackFunction, callbackObject, timeout) {
        try {
            if (!valueExists(timeout)) {
                timeout = Ab.workflow.Workflow.DEFAULT_TIMEOUT;
            }
            var systemCallback = new Ab.workflow.Callback(callbackFunction, callbackObject);
            var callbackDelegate = systemCallback.afterRuleExecuted.createDelegate(systemCallback);
            var options = {
                'callback': callbackDelegate,
                'timeout': timeout * 1000
            }
            
            this.prapareParameters(parameters);
            workflow.runWorkflowRule(workflowRuleId, parameters, uploadElement, options);
            
        } catch (e) {
            e.description = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_FAILED) + ': ' + workflowRuleId;
            throw e;
        }
    },
    
    
    call: function(workflowRuleId, parameters, timeout) {
        if (!valueExists(parameters)) {
            parameters = {};
        }
        if (parameters.constructor == Ab.data.Record) {
            parameters = {
                record: toJSON(parameters)
            };
        } else if (parameters.constructor == Ab.data.DataSetList) {
            parameters = {
                records: toJSON(parameters)
            };
        } else if (parameters.constructor == Array) {
            parameters = {
                records: toJSON(parameters)
            };
        }
        var result = this.runRuleAndReturnResult(workflowRuleId, parameters, timeout);
        // check if there was a session timeout
        if (result.code == 'sessionTimeout') {
            this.handleSessionTimeout(result.message);
        } else if (result.code != 'executed') {
            throw result;
        }
        return result;
    },
    
    
    callMethod: function(workflowRuleId) {
        var methodParameters = [];
        for (var i = 1; i < arguments.length; i++) {
            methodParameters.push(arguments[i]);
        }
        var result = this.call(workflowRuleId, {
            methodParameters: toJSON(methodParameters)
        });
        return result;
    },
    
    
    callMethodWithParameters: function(workflowRuleId, parameters) {
        return this.call(workflowRuleId, parameters);
    },
    
    
    handleError: function(result, callback, winLocation) {
        if (result.stack) {
            View.showException(result, result.message, callback);
        } else {
            var message = this.resultCodeToMessage(result.code);
            View.log(message + ': ' + result.message, 'error', 'Workflow');
            View.showMessage('error', message + ':<br/>' + result.message, result.detailedMessage, result.data, callback, winLocation);
        }
    },
    
    
    handleSessionTimeout: function(url) {
        // set View flag to prohibit all message dialogs
        View.sessionTimeoutDetected = true;
        top.View.sessionTimeoutDetected = true;
        
        // display the timeout message
        var title = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_SESSION_TIMEOUT_TITLE);
        var message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_SESSION_TIMEOUT);
        Ext.MessageBox.alert(title, message, function() {
            // when the user clicks OK, redirect to the logout page
            top.location = View.getUrlForPath(url);
        });
    },

     
    handleDwrError: function(message, ex) {
        // DWR has its own session timeout check which may bypass our server-side timeout check
    	// KB 3029607: in SSO mode, if the security interceptor throws an exception, there is no response data 
        if (message == Workflow.ERROR_SCRIPT_SESSION || message == Workflow.ERROR_NO_DATA) {
            this.handleSessionTimeout(View.logoutView);
        } else {
            View.log(message, 'error', 'Workflow');
        }
    }, 
    
     
    handleDwrWarning: function(message, ex) {
        View.log(message, 'warn', 'Workflow');
    },
    
    resultCodeToMessage: function(code) {
        var message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_EXECUTED);
        if (code == 'ruleFailed') {
            message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_FAILED);
        } else if (code == 'ruleNotFound') {
            message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_NOT_FOUND);
        } else if (code == 'containerFailed') {
            message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_CONTAINER_FAILED);
        } else if (code == 'ruleNotPermitted') {
            message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_RULE_NOT_PERMITTED);
        } else if (code == 'sessionTimeout') {
            message = View.getLocalizedString(Ab.workflow.Workflow.z_MESSAGE_SESSION_TIMEOUT);
        }
        return message;
    } ,
    
    // ----------------------- job-related methods ------------------------------------------------

    
    startJob: function(workflowRuleId) {
        var methodParameters = [];
        for (var i = 1; i < arguments.length; i++) {
            methodParameters.push(arguments[i]);
        }
        
        methodParameters = toJSON(methodParameters);
        
        var result = this.call(workflowRuleId, {
            methodParameters: methodParameters,
            startAsJob: true
        }, null, arguments[1]);
        
        return result.message;
    },

    
    startJobWithUpload: function(workflowRuleId, uploadElement, callbackFunction, callbackObject) {
        var methodParameters = [];
        for (var i = 4; i < arguments.length; i++) {
            methodParameters.push(arguments[i]);
        }
        var result = this.runRuleWithUpload(workflowRuleId, {
            methodParameters: toJSON(methodParameters),
            startAsJob: true
        }, uploadElement, callbackFunction, callbackObject);
    },

    
    getJobStatus: function(jobId) {
        try {
            var result = Workflow.call('AbCommonResources-getJobStatus', {jobId: jobId});
            var jobStatus = result.data;
            if (valueExists(jobStatus.data)) {
                jobStatus.dataSet = Ab.data.createDataSet(jobStatus.data)
            }
            return jobStatus;
        } catch (e) {
            Workflow.handleError(e);
        }
    },
    
    
    stopJob: function(jobId){
        try {
            var result = Workflow.call('AbCommonResources-stopJob', {jobId: jobId});
            return result.data;
        } catch (e) {
            Workflow.handleError(e);
        }
    },
    
    
    terminateJob: function(jobId){
        try {
            var result = Workflow.call('AbCommonResources-terminateJob', {jobId: jobId});
            return result;
        } catch (e) {
            Workflow.handleError(e);
        }
    },
    
    
    getJobStatusesForUser: function(){
        try {
            var result = Workflow.call('AbCommonResources-getJobStatusesForUser');
            return result.data;
        } catch (e) {
            Workflow.handleError(e);
        }
    },
    
    
    prapareParameters: function(parameters) {
    	// ensure that the view version is set to 2.0 (this class can be only used by 2.0 views)
        if (valueExists(parameters) && !valueExists(parameters.version)) {
            parameters.version = '2.0';
        }
        
        // encode reserved SQL words in the SQL restriction string (but not in the parsed restriction)
        if (valueExists(parameters) && valueExists(parameters.restriction) && 
        		parameters.restriction.constructor === String &&
        		parameters.restriction.length > 0 &&
        		parameters.restriction.charAt(0) !== '{' &&
        		parameters.restriction.charAt(0) !== '[') {
        	parameters.restriction = doSecure(parameters.restriction);
        }
    }
});


Workflow = Ab.workflow.Workflow;



Ab.workflow.Callback = Base.extend({

    // user-defined callback function reference (can be global function or object method)
    callbackFunction: null,
    
    // user-defined callback object instance (undefined if the callback is a global function)
    callbackObject: null,
    
    // placeholder for the WFR result object
    result: null,

        
    constructor: function(callbackFunction, callbackObject) {
        this.callbackFunction = callbackFunction;
        this.callbackObject = callbackObject;
    },
    
    
    afterRuleExecuted: function(result) {
        this.result = result;
        
        //View.log('rule executed: [' + result.jsonExpression + ']', 'info', 'workflow');
        
        // evaluate the JSON expression and save the data into the result object
        result.data = null;
        result.dataSet = null;
        if (valueExists(result.jsonExpression) && result.jsonExpression != '') {
            result.data = eval('(' + result.jsonExpression + ')');

            //View.log('data evaluated', 'info', 'workflow');
            
            if (valueExists(result.data.type)) {
                result.dataSet = Ab.data.createDataSet(result.data);
            } else if (valueExists(result.data.records)) {
                result.dataSet = new Ab.data.DataSetList(result.data);
            }

            //View.log('data set created', 'info', 'workflow');
        }
        
        // call user-defined callback function
        var fn = this.callbackFunction;
        if (valueExists(fn)) {
            if (valueExists(this.callbackObject)) {
                fn.call(this.callbackObject, result);
            } else {
                fn.call(window, result);
            }
        }
    }
});


Ab.namespace('view');


Ab.view.Restriction = Base.extend({

    // restriction title
    title: null,

    // clauses (i.e. rm.area < 100.0)
    clauses: null,

    
    constructor: function(fieldValues) {
        this.clauses = [];
        // fix for IE: toJSON() method cannot find the constructor when called from a different tab frame
        // TODO: find out why this is happenning and whether there's a better hack
        this.clauses.constructor = Array.constructor;

        // add field values as simple = clauses
        if (valueExists(fieldValues)) {
            for (var fieldName in fieldValues) {
                var fieldValue = fieldValues[fieldName];

                // ignore empty field values
                if (valueExists(fieldValue) && fieldValue !== '') {
                    this.addClause(fieldName, fieldValue);
                }
            }
        }
    },

    
    addClause: function(name, value, op, relOp, replace) {
		if (valueExists(relOp) && relOp.constructor == Boolean) {
			replace = relOp;
			relOp = 'AND';
		}
        if (valueExists(replace) && replace) {
            this.removeClause(name);
        }
        this.clauses.push(new Ab.view.RestrictionClause(name, value, op, relOp));
    },

    
    removeClause: function(name) {
        var existingClauseIndex = this.findClauseIndex(name);
        while (existingClauseIndex > -1) {
            this.clauses.splice(existingClauseIndex, 1);
            existingClauseIndex = this.findClauseIndex(name);
        }
     },

    
    addClauses: function(restriction, replace, allowDuplicates) {
    	if (!valueExists(allowDuplicates)) {
    		allowDuplicates = false;
    	}
    	
    	if (restriction && valueExists(restriction.clauses)) {
            for (var i = 0; i < restriction.clauses.length; i++) {
                var clause = restriction.clauses[i];

                // do not add or overwrite with null/undefined clause values
                if (!valueExists(clause.value)) {
                    continue;
                }

                var existingClauseIndex= this.findClauseIndex(clause.name);

                // if we need to replace existing clause
                if (replace) {
                    // remove the existing clause if exists
                    if (existingClauseIndex > -1) {
                        this.clauses.splice(existingClauseIndex, 1);
                    }

                    // add the new clause
                    this.addClause(clause.name, clause.value, clause.op, clause.relOp);
                } else {
                    // only add the new clause when does not exist
                    if (existingClauseIndex == -1 || allowDuplicates) {
                        this.addClause(clause.name, clause.value, clause.op, clause.relOp);
                    }
                }
            }
        }
    },

    
    findClauseIndex: function(name) {

        var clauseIndex = -1;
        for (var i = 0; i < this.clauses.length; i++) {
            var c = this.clauses[i];
            if (c.name == name) {
               clauseIndex = i;

            }
        }
        return clauseIndex;
    },
    
    
    findClause: function(name) {
        var clause = null;
        var index = this.findClauseIndex(name);
        if (index != -1) {
            clause = this.clauses[index];
        }
        return clause;  
    },
    
    findClauses: function(name) {
        var clauses = [];
        var clauseIndex = -1;
        for (var i = 0; i < this.clauses.length; i++) {
            var c = this.clauses[i];
            if (c.name == name) {
            	clauses.push(c);
            }
        }
        return clauses;  
    },

    
    equals: function(restriction) {
        var result = true;

        if (this.clauses == null && restriction.clauses != null) {
            result = false;
        } else if (this.clauses != null && restriction.clauses == null) {
            result = false;
        } else if (this.clauses == null && restriction.clauses == null) {
            // no clauses means that restrictions are equal
        } else if (this.clauses.length != restriction.clauses.length) {
            result = false;
        } else {
            for (var i = 0; i < this.clauses.length; i++) {
                var clause = this.clauses[i];
                var otherClause = restriction.clauses[i];
                if (!clause.equals(otherClause)) {
                    result = false;
                    break;
                }
            }
        }

        return result;
    },

    
    getTitle: function() {
        return this.title ? this.title : this.toString(false);
    },

    
    toString: function(includeNamesAndOps) {
        var text = '';
        for (var i = 0; i < this.clauses.length; i++) {
            if (i > 0) {
                text += ', ';
            }
            text += this.clauses[i].toString(includeNamesAndOps, false);
        }

        return text;
    },

    
    isEmpty: function() {
        return this.clauses.length === 0;
    },

    
    fromJSON: function(data) {
        Ext.apply(this, data);

        this.clauses = [];
        for (var i = 0; i < data.clauses.length; i++) {
            var clause = new Ab.view.RestrictionClause();
            clause.fromJSON(data.clauses[i]);
            this.clauses.push(clause);
        }
    },

    
    toJSON: function() {
        var data = {};
        Ext.apply(data, this);

        data.clauses = [];
        for (var i = 0; i < this.clauses.length; i++) {
            data.clauses.push(this.clauses[i].toJSON());
        }

        return data;
    }
});


Ab.view.RestrictionClause = Base.extend({
    
    // full field name, i.e. wr.date_requested
    name: '',
   
    // value to compare with
    value: '',
   
    // operation: =|&gt;|&lt;|&gt;=|&lt;=|LIKE|IS NULL|IS NOT NULL|IN
    op: '=',
	
	// relop: "AND" "OR" ")AND(" ")OR("
	relOp: 'AND',
   
    
    constructor: function(name, value, op, relOp) {
        this.name = name;
        this.value = value;
        if (valueExists(op)) {
            this.op = op;
        }
        if (valueExists(relOp)) {
            this.relOp = relOp;
        }
    },
    
    
    equals: function(clause) {
        return (this.name == clause.name &&
                this.value == clause.value &&
                this.op == clause.op &&
				this.relOp == clause.relOp);
    },

    
    toString: function(includeNameAndOp, includeRelOp) {
        var text = '';

        if (includeRelOp) {
            text += (' ' + this.relOp + ' ');
        }

        if (includeNameAndOp) {
        text += (this.name + ' ' + this.op + ' ');
        }

        text += this.value;

        return text;
    },

    
    fromJSON: function(data) {
        Ext.apply(this, data);
    },

    
    toJSON: function() {
        var data = {};
        Ext.apply(data, this);
        return data;
    }
});


 
function setupUrlParameters() {
    var parameters = {};
    if (window.location.search) {
        var paramArray = window.location.search.substr(1).split('&');
        var length = paramArray.length;
        for (var index = 0; index <length; index++ ) {
            var param = paramArray[index].split('=');
            var name = param[0];
            var value = typeof param[1] == "string"
                  ? decodeURIComponent(param[1].replace(/\+/g, ' '))
                  : null;
            parameters[name] = value;
        }
    }
    window.location.parameters = parameters;
}



Ab.view.View = new (Base.extend({
    
	// Ext.util.MixedCollection of child panels
    panels: null,
    
    // optional restriction for this view
    restriction: null,
    
    // optional restriction for the dialog window
    dialogRestriction: null,
    
    // optional parameters for the dialog view data sources
    dialogParameters: null,

    // currently displayed dialog window
    dialog: null,
    
    // optional newrecord flag for this view
    newRecord: false,
    
    // optional newRecord flag for the dialog
    dialogNewRecord: false,
	
	// parameters set by the opener view
	parameters: null,
    
    // parameters for Select Value dialog
    selectValueParameters: null,
    
    // parameters for Progress Report
    progressReportParameters: null,
    
    // refresh parameters for all panels, used by the refreshPanels() method
    refreshParameters: null,
    
    // default size for dialog windows
    defaultDialogWidth: 900,
    defaultDialogHeight: 600,
    defaultSelectValueDialogWidth: 800,
    defaultSelectValueDialogHeight: 500,
    defaultMessageDialogWidth: 600,
    defaultMessageDialogHeight: 300,
    // default location for dialog windows top left corner
    defaultMessageDialogTop: 5,
    defaultMessageDialogLeft: 5,
    
    // array of layout managers defined in the view
    layoutManagers: null,
    
    // top-level layout manager
    topLevelLayoutManager: null,
    
    // default layout manager, used when layout manager name is not specified
    defaultLayoutManager: null,

    // map of nested layout managers defined in the view, keyed by name
	// nested layouts must add themselves since they have no component to do it for them
	nestedLayoutManagers: null,
	
	// Ext.Viewport for this window or frame
	viewport: null,
    
    // view format version: 1.0 (16.3 and 16.4) or 2.0 (Yalta 5)
    version: '1.0',
    
    // view title text
    originalTitle: null,
    title: '',
    titleBarId: 'viewToolbar_layoutWrapper',

	//HTML link address wrapping the title, used in main toolBar
	titleLink: '',
    
    // user home page
    mainView: '',
    
    // view to be displayed on logout
    logoutView: '',
    
    // ID of the view main panel, which should use the view restriction
    mainPanelId: null,
    
    // reference to the parent Ab.tab.Tab object, if this view is loaded inside a tab page
    parentTab: null,
	
	// reference to the parent Ab.view.ViewPanel object, if the view is loaded inside a view panel
	parentViewPanel: null,
    
    // true if the server run in development mode
    isDevelopmentMode: false,
    
    // expression evaluation context; populated when the view is loaded and all panels are created
    evaluationContext: null,
    
    // Ext.util.MixedCollection of Ab.data.DataSource objects 
    dataSources: null,
    
    // Ext.util.MixedCollection of view controllers 
    controllers: null,
    
    // web application path context, portion of url preceding /schema/
    contextPath: '',
    
    // view metaData, for viewDef Wizard 
    designInfo: {},
    
    // whether to display the progress bar on load
    showLoadProgress: false,
    
    // Ext.Window that displays the progress bar
    progressWindow: null,
    
    // Ext.ProgressBar
    progressBar: null,
	
	// number of processes requesting the progress bar to be displayed
	// while the number is greater than 0, the progress bar is not dismissed
	progressBarRequestors: 0,
    
    // view state
    state: 0,
    STATE_CREATED: 1,
    STATE_LAYOUT: 2,
    STATE_LAYOUT_COMPLETE: 3,
    STATE_INITIAL_DATA_FETCH: 4,
    STATE_READY: 5,

    // set to true when the session timeout is detected
    sessionTimeoutDetected: false,

    // selected Process Navigator or Dashboard Tabs record for this view (or null if the view was opened via a URL)
	taskRecord: null,
	
	// selected Process Navigator or Dashboard Tabs information: {activityId}
	taskInfo: null,

	// Ext.Window instance that can display any job status
	jobStatusDialog: null,

    // Backbone.Events aggregator that supports publisher-subscriber pattern
    eventAggregator: null,
	
	
	isWithinSmartClient : (typeof(window.external) != "undefined" && window.external != null && window.external.isSmartClient) ? true : false,

	z_DEFAULT_TITLE: '华南理工大学广州学院资产信息管理系统',
	// @begin_translatable    
	z_MESSAGE_VIEW_LOAD_FAILURE: 'View loading failed: ',
	z_TOOLTIP_PRINT_VIEW: '<b>Print</b> this view',
	z_TOOLTIP_ADD_FAVORITES: '<b>Add</b> this view to MyFavorites',
	z_TOOLTIP_EMAIL_VIEW_LINK:  '<b>Send</b> link to this view via email',
	z_TOOLTIP_SHOW_HELP: 'Show online <b>help</b>',
	z_MESSAGE_ERROR_IN: 'in ',
	z_MESSAGE_ERROR_LINE: 'Line ',
	z_MESSAGE_ERROR_AT: ' at ',
	z_TITLE_ERROR: 'Error',
	z_TITLE_MESSAGE: 'Message',
	z_TITLE_DETAILS: 'Details',
	z_TITLE_DATA: 'Data',
	z_TITLE_CLOSE: 'Close',
    z_TITLE_CANCEL: 'Cancel',
    z_TITLE_STOP_JOB: 'Stop Job',
    z_TITLE_JOB_COMPLETE: 'Complete',
    z_MESSAGE_LOADING: 'Loading',
    z_TOOLTIP_ALTER_VIEW: '<b>Alter</b> this view',
	z_MESSAGE_ADD_MYFAVORITE: 'Do you want to save this view to your My Favorites list?',
	z_MESSAGE_OVERWRITE_MYFAVORITE: 'This view is already on your My Favorites list. Do you want to overwrite the existing one?',
	z_MESSAGE_JOBSTATUS: 'The status for job (Job Id = jobId) is: <br><br>',
	z_MESSAGE_CONFIRM: 'Confirm',
	z_MESSAGE_OK: 'OK',
	z_MESSAGE_CANCEL: 'Cancel',
	z_MESSAGE_YES: 'Yes',
	z_MESSAGE_NO: 'No',
		
	z_MESSAGE_SELECT_VALUE_DWG_NO_RESTRICTION: 'Parent form of drawing select value must contain building and floor codes',
	z_MESSAGE_NO_TASK_MYFAVORITE: 'MyFavorites can only be created for views on the navigator or dashboard.',
	z_MESSAGE_ADD_SUCCESS_MYFAVORITE: 'MyFavorite written successfully',
	z_MESSAGE_ADD_FAIL_MYFAVORITE: 'MyFavorite write failed',
	z_TITLE_LOG_CONSOLE: 'Log Console',
	// @end_translatable


    // list of chart panel (names) to be loaded sequentially
	chartPanelIds: null,
	currentChartIndex: 0,
	currentChartPanel: null,

    
    constructor: function() {
        // change Underscore template delimiters from <%= name %> style to {{ name }} style.
        _.templateSettings = {
            interpolate : /\{\{(.+?)\}\}/g
        };

		// enable logging output to Firebug console, if Firebug is installed and enabled
        YAHOO.widget.Logger.enableBrowserConsole();
        this.log('View constructor: start');
        
        // parse URL parameters and add their collection to the window.location object
        setupUrlParameters();

        this.panels = new Ext.util.MixedCollection();
        this.controllers = new Ext.util.MixedCollection();
        this.dataSources = new Ext.util.MixedCollection();
        this.layoutManagers = [];
        this.nestedLayoutManagers = [];
        this.refreshParameters = {};
		this.taskInfo = {
			activityId: '',
			processId: '',
			taskId: ''
		};

		// find this window's or frameset's opener (if one exists)
		var openerWindow = this.getOpenerWindow();

        // copy restriction from the window's or frameset's opener view
        if (openerWindow != null && valueExists(openerWindow.View) && openerWindow != self) {
            this.restriction = openerWindow.View.dialogRestriction;
            this.newRecord = openerWindow.View.dialogNewRecord;
			this.parameters = openerWindow.View.dialogConfig;
			// copy the current navigator task from the nav controller
			var viewContentPanel = openerWindow.View.getControl('viewContent');
			if (viewContentPanel != null) {
				this.taskRecord = viewContentPanel.taskRecord;
				this.taskInfo = viewContentPanel.taskInfo;
			}
        } else {
            // try getting restriction from the URL
            var parameters = window.location.parameters;
            if (valueExists(parameters)) {
                var restriction = new Ab.view.Restriction();
                for (var name in parameters) {
                    var value = parameters[name];
                    // ignore &handler=ActionHandlerDrawing parameter and other non-restriction parameters
                    if (name !== 'handler' && name !== 'viewName' && name != 'jobId' && name != 'ruleId' 
                    	&& name != 'showResult' && name != 'resultView' ) {
                        restriction.addClause(name, value);
                    }
                }
                if (restriction.clauses.length > 0) {
                    this.restriction = restriction;
                }
            }
        }
        
        this.state = this.STATE_CREATED;

        Ext.QuickTips.init();
        
        // use cookie provider to save/restore control UI state
        // Ext 2.0 Beta 1 has random issues with the control state provider - disable temporarily
        // Ext.state.Manager.setProvider(new Ext.state.CookieProvider());

        this.eventAggregator = _.extend({}, Backbone.Events);

        this.log('View constructor: end');
    },
    
    
    beforeLoad: function() {
        this.dateFormat = this.convertJavaDateFormat(strDateShortPattern);
        this.timeFormat = this.convertJavaDateFormat(timePattern);

        // create evaluation context
        this.evaluationContext = {};
        if (valueExists(this.user)) {
            this.evaluationContext['user'] = this.user;
        }
        if (valueExists(this.project)) {
            this.evaluationContext['project'] = this.project;
        }
        this.evaluationContext['messages'] = this.messages;
        this.evaluationContext['activityParameters'] = this.activityParameters;
    },
	
	
	log: function(message, category, source) {
		var source = source || 'view';
		// KB 3019607: the view may be loaded in another frame inside /ab-system/html/url-proxy.htm
		var yahoo = top.YAHOO || self.YAHOO;
		yahoo.log(message, category, source);
	},
	
	
	clearDialogParameters: function() {
		this.dialogRestriction = null;
		this.dialogParameters = null;
        this.dialogNewRecord = false;
        this.dialogConfig = null;
	},
    
    
    init: function() {
        Ext.apply(Ext, {
            BLANK_IMAGE_URL: this.contextPath + '/schema/ab-core/libraries/ext/resources/images/default/s.gif'
        });

        // error message views do not display any content
	    // KB 3019820: if error message view is initialized, frame action targets do not work in pre-1.0 views
	    if (this.type === 'errorMessage') {
	        return;
	    }
	    
        this.log('View.init(): start');

        if (this.showLoadProgress) {
            this.openProgressBar();
        }

        dwr.engine.setErrorHandler(Workflow.handleDwrError.createDelegate(Workflow));
        dwr.engine.setWarningHandler(Workflow.handleDwrWarning.createDelegate(Workflow));

        // lay out all panels
        this.doLayout();

		//XXX: alter button visiblity
        var alterButton = Ext.get('alterButton');
        if(alterButton !=null && (typeof this.designInfo.isAlterable == "undefined" 
        	|| this.designInfo.isAlterable == "null" || this.designInfo.isAlterable=='false')){
       	 	alterButton.setVisible(false);
       	 }
            
        this.log('View.init(): end');
            
        // wait until DWR fetches the script session ID, and the deferred layout is complete
        var runner = new Ext.util.TaskRunner();
        var task = {
            run: function(){
                if (valueExists(dwr.engine._scriptSessionId) && View.state >= View.STATE_LAYOUT_COMPLETE) {
                    runner.stop(task);
                    // proceed to initial data fetch
                    View.doInitialDataFetch();
                }
            },
            interval: 100
        }
        runner.start(task);        
    },
    
    
    refresh: function(restriction, newRecord, clearRestriction) {
		this.restriction = restriction;
		this.newRecord = newRecord;
		
        this.controllers.each(function (controller) {
            controller.afterRefresh(restriction, newRecord, clearRestriction);
        });

        if (this.mainPanelId != null) {
            var mainPanel = this.getMainPanel();
            if (mainPanel.useParentRestriction) {
                mainPanel.refresh(restriction, newRecord, clearRestriction);
            } else {
                mainPanel.refresh();
            }
            mainPanel.show();
        }

        this.panels.each(function (panel) {
            panel.updateHeight();
        });
    },
	
    
    clearPanelRestrictions: function() {
        this.panels.each(function (panel) {
        	if (panel.isDataBound()) {
        	    panel.restriction = null;
        	}
        });
    },
    
    
    refreshPanels: function(restriction, consolePanel) {
        this.restriction = restriction;
		
        this.openProgressBar();
        
        try {
            var totalProgressSteps = 0;
	        this.panels.each(function (panel) {
	        	if (panel.isDataBound() && panel !== consolePanel) {
	        		totalProgressSteps++;
	        	}
	        });
            var currentProgressStep = 0;
        	
	        this.panels.each(function (panel) {
	        	if (panel.isDataBound() && panel !== consolePanel) {
	    			for (var name in View.refreshParameters) {
	    				var value = View.refreshParameters[name];
	    				panel.addParameter(name, value);
	    			}
	                panel.refresh(restriction);
	                
	                currentProgressStep++;
	                View.updateProgressBar(currentProgressStep / totalProgressSteps);
	        	}
	        });
	        
	    	this.closeProgressBar();
        } catch (e) {
        	this.closeProgressBar();
        }
    },
    
    
    addRefreshParameter: function(name, value) {
        this.refreshParameters[name] = value;   
    },
	
	
	reload: function() {
		if (this.parentViewPanel) {
			this.parentViewPanel.reloadView();
		} else if (this.parentTab) {
		    this.parentTab.loadView();
		} else if(window==top){
			window.location.reload(false);
		}
	},
	
	
	loadView: function(viewName) {
        var topViewContentPanel = top.View.panels.get('viewContent');
	    if (valueExists(topViewContentPanel)) {
	        topViewContentPanel.loadView(viewName);
	    } else {
	        window.location = viewName;
	    }
	},
    
    
    evaluateExpressions: function() {
        var ctx = {view: this, user: this.user};
        
        // evaluate view title
        var evaluatedTitle = this.evaluateString(this.originalTitle, ctx);
        if (evaluatedTitle !== this.title) {
            this.setTitle(evaluatedTitle);
        }
        
        // delegate to all child panels
        this.panels.each(function(panel) {
            panel.evaluateExpressions();
        });
    },
    
    
    evaluateString: function(strIn, ctx) {
        var strOut = strIn;
        
        if (valueExists(strIn)) {
            strIn = strIn.replace(/%{/g, "${");
            strIn = strIn.replace(/&apos;/g, "'");
            
            if (strIn.indexOf('$') >= 0 || strIn.indexOf('{if') >= 0) {
                strIn = strIn.replace(/&quot;/g, "'")
                strIn = strIn.replace(/&amp;/g, "&")
                strOut = strIn.process(ctx);
            }
        }
        return strOut;  
    },
    
    
    evaluateBoolean: function(strIn, ctx, defaultValue) {
		if (typeof(strIn) == 'boolean') {
			return strIn;
		}

		var result = defaultValue;

        if (valueExists(strIn) && typeof(strIn) == 'string') {
            strOut = this.evaluateString(strIn, ctx);
			result = (strOut == "true") ? true : false;
		}
        return result;
    },


	
    getMainPanel: function() {
    	return this.getControl('', this.mainPanelId);
    },

	
    getViewToolbar: function() {
    	return this.getControl('', 'viewToolbar');
    },
    
    
    setTitle: function(title) {
        if (!this.originalTitle) {
            this.originalTitle = title;
        }
        this.title = title;
        
        if (valueExists(title)) {
            document.title = title;
        } else {
            document.title = Ab.view.View.z_DEFAULT_TITLE;
        }
        
        if (this.hasTitle()) {
            if (this.parentTab != null) {
                this.parentTab.setTitle(this.title);
            } else {
				var viewTitlebar = Ext.get('viewToolbar_title');
				if (viewTitlebar) {
                    viewTitlebar.dom.innerHTML = title;
				} else {
                    this.createTitleBar();
				}
            }
        }
    },

	
	createTitleBar: function() {
        var buttons = [{
        	id:'alterButton',
            icon: Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-icon-alterview.png',
            tooltip: this.getLocalizedString(Ab.view.View.z_TOOLTIP_ALTER_VIEW),
            cls: 'x-btn-icon',
            handler: this.onAlterView.createDelegate(this)
        }];
		// drill-down views or popup dialog have no task and therefore can't be favorites
		if (this.taskRecord != null && (this.taskRecord.getValue('afm_ptasks.task_file') || this.taskRecord.getValue('afm_processes.dashboard_view'))) {
			buttons.push({
         	    id:'favoritesButton',
                icon: Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-icon-add-my-favorites.png',
                tooltip: this.getLocalizedString(Ab.view.View.z_TOOLTIP_ADD_FAVORITES),
                cls: 'x-btn-icon',
                handler: this.onAddFavorite.createDelegate(this)
            });
		}
		if(!this.isPaginatedReport()){
			buttons.push({
        		id:'printButton',
            	icon: Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-icon-printview.png',
            	tooltip: this.getLocalizedString(Ab.view.View.z_TOOLTIP_PRINT_VIEW),
            	cls: 'x-btn-icon',
            	handler: this.onPrintView.createDelegate(this)
        	});
			buttons.push({
        		id:'emailButton',
            	icon: Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-icon-emailview.png',
            	tooltip: this.getLocalizedString(Ab.view.View.z_TOOLTIP_EMAIL_VIEW_LINK),
            	cls: 'x-btn-icon',
            	handler: this.onEmailView.createDelegate(this)
        	});	
   		}	
        if (this.isDevelopmentMode) {
            buttons.push({
         	    id:'loggingButton',
                icon: Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/bug.png',
                tooltip: 'Open Log Console',
                cls: 'x-btn-icon',
                enableToggle: true,
                handler: this.onLogger.createDelegate(this)
            });
        }
		viewTitlebar = new Ab.view.Toolbar('viewToolbar', new Ab.view.ConfigObject({
            title: this.title,
			titleLink: this.titleLink,
            layout: 'viewLayout',
            region: 'north',
			cls: 'viewToolbar',
            buttons: buttons
        }));
	},

	
	isPaginatedReport: function() {
		return(Ab.view.View.originalRequestURL.indexOf('ab-paginated-report-job.axvw') != -1);
	},
		
	
	setToolbarButtonVisible: function(buttonId, visible) {
		var toolbar = this.getViewToolbar();
		if (!valueExists(toolbar)) {
		    return;
		}
		
		var targetButton = null;
		for (var i=0, button; button = toolbar.buttons[i]; i++) {
		    if (button.id == buttonId) {
			    targetButton = button;
				break;
            }
		}
		if (targetButton == null) {
			return;
		}

		if (!valueExists(visible)) {
			visible = true;
		}
		targetButton.setVisible(visible);
	},

	
    onAlterView: function(){
		this.openDialog(Ab.view.View.contextPath + '/schema/ab-core/system-administration/alter-view-wizard/ab-alterview-wizard.axvw',
		    null, true);
	},
    
    hasTitle: function() {
        return valueExistsNotEmpty(this.title);
    },
    
    
    isTopLevel: function() {
        return (self == top || window.name === 'viewContent_iframe' || window.name === 'myFavoriteView_iframe');
    },

    
    hasBorder: function() {
        return (self == top || 
            (window.name === 'viewContent_iframe' || window.name === 'myFavoriteView_iframe') && View.type === 'dashboard');
    },
    
    
    getParentDialog: function() {
        var dialog = null;
        var openerWindow = this.getOpenerWindow();
        if (openerWindow != null && valueExists(openerWindow.View) && openerWindow != self) {
            dialog = openerWindow.View.dialog;
        }
        return dialog;
    },
    
    
    doLayout: function() {
        this.state = this.STATE_LAYOUT;
        
        try {
	        // create default view layout with regions for view title bar and view content 
	        // north region wraps around <div id="viewToolbar_layoutWrapper"> generated by the <view> tag 
	        // center region wraps around <div id="view_layoutWrapper"> generated by the <view> tag 
	        var regions = [{
	        	region:'center', 
	        	autoScroll: true,
	        	tabPosition:'top',
	        	margins: (self == top) ? Ab.view.Layout.DEFAULT_MARGINS : ''}
	        ];
	        if (this.hasTitle() && this.parentTab == null) {
	            regions.push({
                    id: 'viewToolbarRegion',
	                region:'north', 
	                split:false, 
	                height:28, 
	                contentEl: 'viewToolbar_layoutWrapper'
	            });
	        }      
	        this.topLevelLayoutManager = new Ab.view.Layout('viewLayout', 'border', null, null, regions);
	
	        // lay out all controls
	        this.panels.each(function(panel) {
	            panel.doLayout();
	        });
	        
	        // finalize layout managers
	        for (var i = 0; i < this.layoutManagers.length; i++) {
	            this.layoutManagers[i].bindToParentLayout();
	        }

	        for (var i = 0; i < this.layoutManagers.length; i++) {
	            this.layoutManagers[i].doLayout();
	        }

	        for (var i = 0; i < this.layoutManagers.length; i++) {
	            this.layoutManagers[i].afterLayout();
	        }

            // call controllers	        
            this.controllers.each(function (controller) {
                controller.afterLayout();
            });
            
        } catch (e) {
            // signal the view loader to continue
            this.state = this.STATE_READY;
            // this is a top-level call, nobody else can handle this exception
            this.showException(e, this.getLocalizedString(Ab.view.View.z_MESSAGE_VIEW_LOAD_FAILURE) + this.viewName);
        }
    },

    
    doInitialDataFetch: function() {
        this.log('View.doInitialDataFetch(): start');

        // initialize HTML5 placeholders support for IE
        // TODO: This sets DOM element values, so the form has to check these in getFieldValue().
        // Is there a different library that displays placeholders on top of fields?
        if (Ext.isIE) {
            Placeholders.init({
                hideOnFocus: true
            });
        }

        try {
            this.afterViewLoad();

            this.state = this.STATE_INITIAL_DATA_FETCH;

			this.chartPanelIds = [];
            this.panels.each(function(panel) {
				if (View.type === 'dashboard' && panel.type === 'chart') {
					View.chartPanelIds.push(panel.id);
				}
            });
            
            this.totalProgressSteps = 0;
	        this.panels.each(function (panel) {
	        	if (panel.isDataBound()) {
	        		View.totalProgressSteps++;
	        	}
	        });
            this.totalProgressSteps += this.chartPanelIds.length;
            this.currentProgressStep = 0;
            
            this.panels.each(function(panel) {
				if (View.type === 'dashboard' && panel.type === 'chart') {
					// chart's initialDataFetch forcing showOnLoad='false'
				   	panel.loadChartSWFIntoFlash();
				}
				else {
	                panel.initialDataFetch();
				}
				
				this.currentProgressStep++;
		        if (this.showLoadProgress) {
		            this.updateProgressBar(this.currentProgressStep / this.totalProgressSteps);
		        }
            });
			
			if (this.chartPanelIds.length > 0) {
				View.chartLoader.defer(1000, View);
			} else {
				this.finishInitialDataFetch();
			}            
        } 
		catch (e) {
	        if (this.showLoadProgress) {
	            this.closeProgressBar();
	        }
            // signal the view loader to continue
            this.state = this.STATE_READY;
            // this is a top-level call, nobody else can handle this exception
            this.showException(e, this.getLocalizedString(Ab.view.View.z_MESSAGE_VIEW_LOAD_FAILURE) + this.viewName);
        }
        this.log('View.doInitialDataFetch(): end');
    },

	
	finishInitialDataFetch: function() {
        this.evaluateExpressions();

        // if the view is loaded from a tab or a dashboard frame, call the opener tab or panel back
        var openerWindow = this.getOpenerWindow();
        if (openerWindow != null && openerWindow != self && valueExists(openerWindow.View)) {
            var parentTab = this.getParentTab();
            if (parentTab) {
                // existing app code use the parentTab property
                this.parentTab = parentTab;
                parentTab.afterLoadView(this);
            } else {
                var parentViewPanel = this.getParentViewPanel();
                openerWindow.View.afterLoadDialog(this, parentViewPanel);
            }
        }

		this.state = this.STATE_READY;
		this.afterInitialDataFetch();
		
        if (this.showLoadProgress) {
            this.closeProgressBar();
        }

        // create placeholders in form controls
        if (Ext.isIE) {
            Placeholders.create();
        }
    },

    
	chartLoader: function() {
		loadChart = function() {
			View.currentChartPanel = View.panels.get(View.chartPanelIds[View.currentChartIndex]);
			if (View.currentChartPanel.showOnLoad) {
				View.currentChartPanel.refresh();
			}
			this.currentProgressStep++;
	        if (this.showLoadProgress) {
	            this.updateProgressBar(this.currentProgressStep / this.totalProgressSteps);
	        }
		};
		
		if (View.currentChartPanel == null) {
			// we have not started loading the first chart yet
			loadChart();
			View.chartLoader.defer(300, View);
			
		} else if (View.currentChartPanel.isLoadComplete || !View.currentChartPanel.showOnLoad) {
			// current chart has finished loading (or should not be loaded)
			if (View.currentChartIndex == View.chartPanelIds.length - 1) {
				// this is the last chart in the view - we are done with all charts
				View.finishInitialDataFetch();
			} else {
				// start loading the next chart
				View.currentChartIndex++;
				loadChart();
				View.chartLoader.defer(300, View);
			}
		} else {
			// current chart is still loading
			View.chartLoader.defer(300, View);
		}
	},

    
    afterViewLoad: function() {
        // if current window or frame has a global callback, call it
        if (valueExists(self.afterViewLoad)) {
            self.afterViewLoad(this);
        }
        
        this.controllers.each(function (controller) {
            controller._afterViewLoad();
        });
    },
    
    
    afterInitialDataFetch: function() {
        // if current window or frame has a global callback, call it
        if (valueExists(self.afterInitialDataFetch)) {
            self.afterInitialDataFetch(this);
        }
        
        this.panels.each(function(panel) {
            panel.afterInitialDataFetch();
        });

        this.controllers.each(function (controller) {
            controller.afterInitialDataFetch();
        });
    },
    
    
    isReady: function() {
        return (this.state === this.STATE_READY);
    },
    
    
    addLayoutManager: function(layoutManager) {
        this.layoutManagers.push(layoutManager);
        if (this.defaultLayoutManager == null) {
            this.defaultLayoutManager = layoutManager;
        } 
    },
    
    
    openDialog: function(url, restriction, newRecord, x, y, width, height) {
		var config = {};
        
        if (valueExists(x) && (x.constructor == Object || typeof(x) == 'object')) {
			config = x;
		} else {
			config.width = width;
			config.height = height;
		}
		
        this.ensureInViewport(config);
		
        // set the restriction and newRecord parameters for the dialog view
		this.dialogConfig = config;
        this.dialogRestriction = valueExists(restriction) ? restriction : null;
        this.dialogNewRecord = valueExists(newRecord) ? newRecord : false;

        
        // open Ext dialog
        this.openExtDialog(config, url);
    },
    
    
    openExtDialog: function (config, url) {
    	var dialogConfig = {
            layout: 'fit',
            height: config.height,
            width: config.width,
            modal: true,
            shadow: true,
            autoScroll: !valueExistsNotEmpty(url),
            closable: true,
            maximizable:true,
            collapsible:valueExists(config.collapsible) ? config.collapsible : true,
            buttonAlign: 'right',
            title: config.title
        };

        dialogConfig.buttons = [{
            id: 'closeButton',
            text: this.getLocalizedString(Ab.view.View.z_TITLE_CLOSE),
            handler: this.closeDialog.createDelegate(this),
            hidden: (valueExists(config.closeButton) && config.closeButton == false),
            hideMode: 'display'
        }];
        dialogConfig.defaultButton = 'closeButton';

        if (valueExistsNotEmpty(url)) {
            if (url.constructor == String) {
                // create managed iframe and load its content
                var frame = new Ext.ux.ManagedIFrame({
                    autoCreate: {
                        width: '100%',
                        height: '100%'
                    }
                });
                frame.setStyle('border', 'none');
                frame.setSrc(url, true);
                dialogConfig.contentEl = frame;
            } else {
                dialogConfig.contentEl = url;
            }
        }

        this.dialogConfig = config;
        var dialog = new Ext.Window(dialogConfig);
        dialog.show(); 
     
        if(config.useAddNewSelectVDialog == true){
        	this.addNewSelectVDialog = dialog;
        }else{
        	this.dialog = dialog;
        }
          		
  		if (valueExists(config.maximize) && config.maximize) {
  			this.dialog.maximize();
  		}
    },

    
    afterLoadDialog: function(childView, childViewPanel) {
        if (valueExists(this.dialogConfig)) {
            if (valueExists(this.dialogConfig['afterViewLoad'])) {
                this.dialogConfig.afterViewLoad(childView);
            }
            if (valueExists(this.dialogConfig['afterInitialDataFetch'])) {
                this.dialogConfig.afterInitialDataFetch(childView);
            }

        } else if (childViewPanel) {
            childViewPanel.afterViewLoad(childView);
        }
    },
    
    
    openPaginatedReportDialog: function(viewName, restrictionsForDataSources, parametersForDataSources, x, y, width, height) {
    	var config = {};
		if (valueExists(x) && x.constructor == Object) {
			config = x;
		} else {
			config.width = width;
			config.height = height;
		}

        this.ensureInViewport(config);
		
        // set the restrictions, parameters and url for the dialog view
		this.dialogConfig = config;
        this.dialogRestriction = valueExists(restrictionsForDataSources) ? restrictionsForDataSources : null;
        this.dialogParameters = valueExists(parametersForDataSources) ? parametersForDataSources : null;
        var url = 'ab-paginated-report-job.axvw?viewName=' + viewName;
      
        // open Ext dialog
        this.openExtDialog(config, url);
    },

    
    closeDialog: function() {
        if (this.dialog != null) {
    		this.dialog.close();
			this.dialog = null;
        }
    },
    
    
    closeThisDialog: function() {
        var view = this.getOpenerView();
        if (view != null) {
            view.closeDialog();
        }
    },
    
    
    addDialogParameter: function(name, value) {
    	if (this.dialogParameters == null) {
    		this.dialogParameters = {};
    	}
    	this.dialogParameters[name] = value;
    },
	
	
	ensureInViewport: function(config) {
        // if width/height is not specified, use defaults
        if (!valueExists(config.width)) {
            config.width = this.defaultDialogWidth;
        }
        if (!valueExists(config.height)) {
            config.height = this.defaultDialogHeight;
        }
        
        // adjust width/height to not exceed the viewport size
        var viewportSize = this.topLevelLayoutManager.viewport.getSize();
        if (config.width > viewportSize.width - 20) {
			config.width = viewportSize.width - 20;
		}
        
        //XXX: the dialog has a proper height so that it'll show its buttons
        if (config.height > viewportSize.height - 80) {
        	config.height = viewportSize.height - 80;
        } else if (config.height > viewportSize.height - 60) {
			config.height = viewportSize.height - 60;
		} else if (config.height > viewportSize.height - 40) {
			config.height = viewportSize.height - 40;
		} else if (config.height > viewportSize.height - 20) {
			config.height = viewportSize.height - 20;
		}

        // if x and/or y position is specified, make sure the window is fully visible		
		if (valueExists(config.x)) {
			if (config.x + config.width > viewportSize.width) {
				config.x = viewportSize.width - config.width - 25;
			}
		} else {
            config.x = viewportSize.width - config.width - 25;
        }
        if (valueExists(config.y)) {
            if (config.y + config.height > viewportSize.height) {
                config.y = viewportSize.height - config.height - 25;
            }
        } else {
            config.y = viewportSize.height - config.height - 25;
        }
	},
    
    
    showException: function(e, message, callback, winLoc) {
		var message;
		var details;
		var data;
        
        if (valueExists(e.localizedMessage)) {
            // Java exception propagated by DWR
			message = e.localizedMessage;
			if (this.isDevelopmentMode) {
				details = e.details;
			}
        } else if (valueExists(e.cause)) {
            // Java exception propagated by DWR
            message = e.cause.localizedMessage;
            if (this.isDevelopmentMode) {
                details = e.cause.details;
            }
        } else {
            // JavaScript exception
            // JavaScript exception object can have either e.message or e.description property, depending on the browser
            var description = valueExists(e.description) ? e.description: e.message;
            // concatenate the caller's message parameter with the exception description
            message = message + ':<br/>' + description;
			
			if (this.isDevelopmentMode){
				details = e.message + '<br/>' + this.getLocalizedString(Ab.view.View.z_MESSAGE_ERROR_LINE) + e.lineNumber + ' ' + this.getLocalizedString(Ab.view.View.z_MESSAGE_ERROR_AT) + ' ' + e.fileName;
                if (e.stack && e.stack.replace) {
				    data = e.stack.replace(/\s/g, "<br/>");
                }
			} 
        }

        this.showMessage('error', message, details, data, callback, winLoc);
    },
    
    
	message: function(type, message, details, data, callback, winLocation) {
		this.showMessage(type, message, details, data, callback, winLocation);
	},
    showMessage: function(type, message, details, data, callback, winLocation) {
		// no messages allowed if session timeout has been detected 
		if (this.sessionTimeoutDetected) {
			return;
		}

		this.localizeExtMessageBox();
        
        if (arguments.length == 1) {
			Ext.MessageBox.alert(this.getLocalizedString(Ab.view.View.z_TITLE_MESSAGE), type, callback);
			return;
        }
        
        // remove dialog DOM element if exists
        var dialogDiv = Ext.get('message_dialog_div');
        if (dialogDiv != null) {
            dialogDiv.remove();
        }
        
        // create new dialog DIV
        var html = '<div id="message_dialog_div" class="x-hidden">'
                 + '<div class="x-window-header"> </div>' 
                 + '<div id="message_dialog_tabs">'
                 + '</div> </div>';
        Ext.DomHelper.insertHtml('afterBegin', document.body, html);
        
        // open Ext dialog
        var tabItems = [];
        if (valueExistsNotEmpty(message)) {
        	tabItems.push({title: this.getLocalizedString(Ab.view.View.z_TITLE_MESSAGE), html: prettyPrintJson(message), fitToFrame:true, autoScroll:true, bodyStyle: 'padding:4px'});
        }
        if (valueExistsNotEmpty(details)) {
        	tabItems.push({title: this.getLocalizedString(Ab.view.View.z_TITLE_DETAILS), html: prettyPrintJson(details), fitToFrame:true, autoScroll:true, bodyStyle: 'padding:4px'});
        }
        if (valueExistsNotEmpty(data)) {
            tabItems.push({title: this.getLocalizedString(Ab.view.View.z_TITLE_DATA), html: prettyPrintJson(data), fitToFrame:true, autoScroll:true, bodyStyle: 'padding:4px'});
        }
		// The X & Y position of the top left corner of the Window on initial showing
		var windowXCoord = this.defaultMessageDialogLeft;
		var windowYCoord = this.defaultMessageDialogTop;
        if (valueExistsNotEmpty(winLocation) && valueExistsNotEmpty(winLocation.x) && valueExistsNotEmpty(winLocation.y)) {
			windowXCoord = winLocation.x;
			windowYCoord = winLocation.y;
        }
        
        var dialog = new Ext.Window({
        	el: 'message_dialog_div',
        	layout: 'fit',
			x: windowXCoord,
			y: windowYCoord,
            height: this.defaultMessageDialogHeight,
            width: this.defaultMessageDialogWidth,
            modal: true,
            shadow: false,
            autoScroll: false,
            closable: true,
            items: new Ext.TabPanel({
            	el: 'message_dialog_tabs',
            	activeTab: 0,
            	autoTabs: true,
            	border: false,
            	items: tabItems,
                style: 'padding-bottom: 8px'
            }),
            buttons: [{
                text: this.getLocalizedString(Ab.view.View.z_TITLE_CLOSE), 
                handler: function() {
                    dialog.close();
                    if (callback) {
                        callback();
                    }
                }
            }]
        });
        if (type == 'error') {
            dialog.setTitle(this.getLocalizedString(Ab.view.View.z_TITLE_ERROR));
        } else {
            dialog.setTitle(this.getLocalizedString(Ab.view.View.z_TITLE_MESSAGE));
        }
        
        dialog.show();
    },

	localizeExtMessageBox: function() {
		var messageOk = this.getLocalizedString(Ab.view.View.z_MESSAGE_OK);
		var messageCancel = this.getLocalizedString(Ab.view.View.z_MESSAGE_CANCEL);
		var messageYes = this.getLocalizedString(Ab.view.View.z_MESSAGE_YES);
		var messageNo = this.getLocalizedString(Ab.view.View.z_MESSAGE_NO);
		
		Ext.MessageBox.buttonText = {
			ok: messageOk,
			cancel: messageCancel,
			yes: messageYes,
			no: messageNo
		};
	},
				
	
	confirm: function(message, callback) {
		this.localizeExtMessageBox();
		Ext.MessageBox.confirm(this.getLocalizedString(Ab.view.View.z_MESSAGE_CONFIRM), message, callback);
	},
	
	
	prompt: function(title, text, callback) {
		this.localizeExtMessageBox();
		Ext.MessageBox.prompt(title, text, callback);
	},
    
	
	alert: function(message, callback) {
		this.localizeExtMessageBox();
		Ext.MessageBox.alert(this.getLocalizedString(Ab.view.View.z_TITLE_MESSAGE), message, callback);
	},

    
    closePanelWindows: function() {
        this.panels.each(function (panel) {
            if (panel.isShownInWindow()) {
                panel.closeWindow();
            }
        });
    },

    
    selectValue: function(configOrFormId, title, fieldNames, selectTableName, selectFieldNames, visibleFieldNames, 
                          restriction, actionListener, applyFilter, showIndex, workflowRuleId, width, height,
                          selectValueType, recordLimit, sortValues, applyVpaRestrictions, addNewDialog, showNullFilters) {

		var config = {};
		if (valueExists(configOrFormId) && configOrFormId.constructor == Object) {
			// all parameters are passed as a configuration object
			config = configOrFormId;
			// set local from config for control selection to allow 'tree' type
			selectValueType = configOrFormId.selectValueType
		} else {
	        config.formId = configOrFormId;
	        config.title = title;
	        config.fieldNames = fieldNames;
	        config.selectTableName = selectTableName;
	        config.selectFieldNames = selectFieldNames;
	        config.visibleFieldNames = visibleFieldNames;
	        config.restriction = restriction;
	        config.actionListener = actionListener;
	        config.applyFilter = getValueIfExists(applyFilter, true);
	        config.showIndex = getValueIfExists(showIndex, true);
	        config.workflowRuleId = workflowRuleId;
	        config.recordLimit = recordLimit;
	        config.width = width;
	        config.height = height;
	        config.sortValues = getValueIfExists(sortValues, null);
            config.selectValueType = getValueIfExists(selectValueType, null);
            config.applyVpaRestrictions = getValueIfExists(applyVpaRestrictions, true);
            config.addNewDialog = getValueIfExists(addNewDialog, null);
            config.showNullFilters = showNullFilters;
		}

        // add form field values entered by the user as possible restriction
        var form = this.getControl('self', config.formId);
        if (form != null) {
            config.filterValues = form.getFieldValues();
        }

        // evaluate the sort values JSON string
		if (valueExists(config.sortValues)) {
 			var evaluatedSortValues = eval('(' + config.sortValues + ')');
            config.sortValues = toJSON(evaluatedSortValues);
        }
		
		// this property will be used by the dialog
		this.selectValueParameters = config;
		
        // open Select Value window
        this.openDialog(null, restriction, false, {
            x: 100,
            y: 100,
            width: config.width,
            height: config.height
        });

        // initialize the custom control inside the dialog
        if (!valueExists(selectValueType) || selectValueType === 'grid' || selectValueType === 'multiple') {
            this.dialog.panel = new Ab.grid.SelectValue(this.dialog);
        } else {
            this.dialog.panel = new Ab.tree.SelectValueTree(this.dialog);
        }

        if (View.preferences.useScroller) {
            this.dialog.body.dom.style.overflow = 'hidden';
        }
    },


    
    selectValueFloorDrawing: function(formId, title, targetFieldNames, selectTableName, selectFieldNames) {
		var roomTable = null;

        // add form field values entered by the user as possible restriction
	    var restriction = new Ab.view.Restriction();
        var form = View.getControl('self', formId);
        if (form != null) {
           var fieldValues = form.getFieldValues();
		   for (name in fieldValues) {
			   var fullnameArray = name.split('.');
			   if (fullnameArray.length == 2) {
				   if (fullnameArray[1] == 'bl_id' || fullnameArray[1] == 'fl_id' || fullnameArray[1] == 'rm_id') {
					   restriction.addClause(name, fieldValues[name]);
					   roomTable = fullnameArray[0];
				   }
			   }
		   }
        }

		// must restrict by, at least, building and floor
		if (restriction.clauses.length < 2) {
			this.message('error', View.getLocalizedString(Ab.view.View.z_MESSAGE_SELECT_VALUE_DWG_NO_RESTRICTION)); 
			return;
		}

        var controller = this;
		controller.form = form;
		controller.roomName = roomTable + '.rm_id';

        View.openDialog('ab-select-value-floor-dwg.axvw', restriction, false, {
            callback: function(res) {
                //var clause = res.clauses[2];
                var value = res.clauses[2].value;
                controller.form.setFieldValue(controller.roomName, res.clauses[2].value);
            }
        });
	},
	

	
	showDocument: function(keys, docTableName, docFieldName, docFileName, imageElementId) {
	    var isImage = function(docFileName) {
	        var isImage = false;
	        var extension = docFileName.substring(docFileName.lastIndexOf('.') + 1);
	        if (valueExistsNotEmpty(extension)) {
	            extension = extension.toLowerCase();
	            isImage = (extension == 'bmp' || 
	                       extension == 'gif' || 
	                       extension == 'jpg' || 
	                       extension == 'png');
	        }
	        return isImage;
	    };
		
        if (isImage(docFileName)) {
            // image document, should be displayed in an image field on this form
            DocumentService.getImage(keys, docTableName, docFieldName, '1', true, {
                callback: function(image) {
                    if (valueExists(imageElementId)) {
                        dwr.util.setValue(imageElementId, image);
                    } else {
                        View.openDialog(image);
                    }
                },
                errorHandler: function(m, e) {
                    View.showException(e);
                }
            });
        } else {
            // application document, should be handled by the browser using iframe managed by DWR
            DocumentService.show(keys, docTableName, docFieldName, docFileName, '', true, 'showDocument', {
                callback: function(fileTransfer) {
                    dwr.engine.openInDownload(fileTransfer);
                },
                errorHandler: function(m, e) {
                    View.showException(e);
                }
            });
        }
	},
    
    
    openProgressBar: function(message, config) {
	    this.initializeProgressBar(message);
	    
	    if (!valueExists(config)) {
	    	config = {
	    	    interval: 500
	    	};
	    }
        this.progressBar.wait(config);
    },
    
    
    updateProgressBar: function(progress) {
    	View.progressBar.updateProgress(progress);
    },
    
    
    openJobProgressBar: function(message, jobId, resultViewName, callback, errorCallback) {
        var runner = new Ext.util.TaskRunner();

        var progressBar = this.initializeProgressBar(message, [{
            text: this.getLocalizedString(Ab.view.View.z_TITLE_STOP_JOB), 
            handler: function() {
                Workflow.stopJob(jobId);
            }
        }, {
            text: this.getLocalizedString(Ab.view.View.z_TITLE_CLOSE), 
            handler: function() {
                runner.stopAll();
                View.closeProgressBar();
            }
        }]);
        
        var task = {
            run: function() {
        	try {
                // get the latest job status
                var status = Workflow.getJobStatus(jobId);
                
                if (valueExists(progressBar)) {
                    // update the progress bar
	                var progress = 0;
	                if (status.jobTotalNumber > 0) {
	                    progress = status.jobCurrentNumber / status.jobTotalNumber;
	                }
	                progressBar.updateProgress(progress);

	                // update the dialog title
	                if (valueExistsNotEmpty(status.jobMessage)) {
	                    View.progressWindow.setTitle(message + ' - ' + status.jobMessage);
	                }
                }
                
                if (status.jobFinished) {
                    // stop updating the progress bar
                    runner.stop(task);
                    
                    if (valueExists(progressBar)) {
	                    // disable the Stop Job button
                        View.progressWindow.buttons[0].disable();
	                    
		                // update the dialog title
	                    var title = View.progressWindow.title + ' - ' + View.getLocalizedString(Ab.view.View.z_TITLE_JOB_COMPLETE);
	                    View.progressWindow.setTitle(title);
                    }
                    
                    // if result view is specified, display it
                    if (valueExistsNotEmpty(resultViewName)) {
                        View.loadView(resultViewName);
                        
                    // if callback is specified, close the dialog and pass the status to the callback
                    } else if (valueExists(callback)) {
                        // but delay closing for a second so that the user can catch the last progress reading
                        (function(){
                            View.closeProgressBar();
                            callback(status);
                        }).defer(1000);
                    }
                }
                
                if (status.jobStatusCode == 8) {
                	// job has failed
                	if (valueExists(errorCallback)) {
                        // stop updating the progress bar
                        runner.stop(task);
                        (function(){
                            View.closeProgressBar();
                            errorCallback(status);
                        }).defer(1000);
                	}
                }
        	} catch (e) {
        		runner.stop(task);
        		Workflow.handleError(e);
        	}
        	},
            interval: 1000
        }
        runner.start(task);        
    },
    
    
    initializeProgressBar: function(message, buttons) {
        this.progressBarRequestors++;
        
        if (this.progressWindow) {
            return null;
        }
        
        var windowConfig = {
            width: 500,
            height: 'auto',
            closable: false,
            modal: true,
            title: valueExists(message) ? message : this.getLocalizedString(this.z_MESSAGE_LOADING)
        };
        if (valueExists(buttons)) {
            windowConfig.buttons = buttons;
        }
        this.progressWindow = new Ext.Window(windowConfig);
        this.progressWindow.show();
        this.progressBar = new Ext.ProgressBar({
            renderTo: this.progressWindow.body
        });
        
        return this.progressBar;
    },
    
    
    closeProgressBar: function() {
		if (this.progressBarRequestors > 0) {
			this.progressBarRequestors--;
		}
		
        if (this.progressBarRequestors == 0 && this.progressWindow) {
            this.progressBar.reset();
            this.progressWindow.close();
            this.progressWindow = null;
        }        
    },

    
    getParentTab: function() {
        var parentTab = null;

        var parentView = this.getOpenerView();
        var parentFrame = window.frameElement;
        if (parentFrame && parentView) {
            var tabName = parentFrame.name;

            parentView.panels.each(function(panel) {
                if (panel.type === 'tabs') {
                    for (var i = 0; i < panel.tabs.length; i++) {
                        var tab = panel.tabs[i];
                        if (tab.name === tabName || tab.name + '_frame' === tabName) {
                            parentTab = tab;
                            break;
                        }
                    }
                }
            });
        }

        return parentTab;
    },

    
    getParentViewPanel: function() {
        var viewPanel = null;

        var parentView = this.getOpenerView();
        var parentFrame = window.frameElement;
        if (parentFrame && parentView) {
            var viewPanelId = parentFrame.name.substring(0, parentFrame.name.indexOf('_iframe'));
            viewPanel = parentView.panels.get(viewPanelId);
        }

        return viewPanel;
    },

    
    getOpenerWindow: function() {
        var openerWindow = opener;

        // if this dialog uses Ext.Dialog
        if (openerWindow == null) {
            openerWindow = parent;
        }        

        // if this dialog has frames
        if (openerWindow == null && top) {
            openerWindow = top.opener;
        }   
        //finally window object
        if(openerWindow == null){
        	openerWindow = window;
        }
        // check if the opener window belongs to the same domain
        try {
            var openerName = openerWindow.name;
        } catch (e) {
            // opener window has a different domain
            openerWindow = parent;
        }
        
        return openerWindow;
    },
    
    
    getOpenerView: function() {
        return this.getOpenerWindow().View;
    },
    
    
    getWindow: function(targetName) {
        var target = null;
        if (targetName == 'self' || targetName == '' || targetName == null) {
            target = self;
        } else if (targetName == 'parent') {
            target = parent;
        } else if (targetName == 'top') {
            target = top;
        } else if (targetName == 'opener') {
            target = opener;
            if (target == null) {
                target = parent.opener;
            }
        } else if (targetName == 'dialog') {
            target = this.dialog;
        } else {
            target = getFrameObject(parent, targetName);
            if (target == null) {
                target = getFrameObject(parent, targetName + '_iframe');
            }
        }
        if (target == null) {
            target = top;
        }
        // try target name + '_iframe' 
        if (target == null) {
        	target = this.getWindow(targetName + '_iframe');
        }
        return target;
    },
    
    
    getView: function(targetName) {
        var view = null;
        var targetWindow = this.getWindow(targetName);
        if (targetWindow != null) {
            view = targetWindow.Ab.view.View;  
        }
        return view;
    },
    
    
    getLayoutManager: function(layoutName) {
        var layoutManager = this.defaultLayoutManager;
        if (valueExistsNotEmpty(layoutName)) {
            for (var i = 0; i < this.layoutManagers.length; i++) {
                if (this.layoutManagers[i].id == layoutName) {
                    layoutManager = this.layoutManagers[i];
                    break;
                }
            }
        }
        return layoutManager;
    },

    
    getLayoutAndRegionById: function(id) {
        var result = null;
        for (var i = 0; i < this.layoutManagers.length; i++) {
            var layoutManager = this.layoutManagers[i];
            var regionName = layoutManager.getRegionNameById(id); 
            if (regionName != null) {
                result = {'layout': layoutManager.id, 'region': regionName, 'layoutManager': layoutManager};
                break;
            }
        }
        return result;
    },

    
	registerControl: function(controlId, control) {
		this.panels.add(controlId, control);
		
		// first registered control is the main panel 
		if (this.mainPanelId == null && controlId !== 'viewToolbar') {
		    this.mainPanelId = controlId;
		}
	},

    
	getControl: function(win, controlId) {
		var control = null;
		
        if (!valueExists(controlId)) {
            // the first parameter is the controlId, not the window name
            controlId = win;
            win = self;
        }
		
		if (typeof(win) == 'string') {
		    win = this.getWindow(win);
		}
		
		// non-Yalta view - no controls in here
		if (!valueExists(win.Ab) || !valueExists(win.Ab.view) || !valueExists(win.Ab.view.View)) {
            return null;
		}
		
		var targetView = win.Ab.view.View;
		control = targetView.panels.get(controlId);
        
        if (control == null && win.parent != null && win.parent != win) {
            control = this.getControl(win.parent, controlId);
        }

        // KB 3036336 when control is within a framed view
        if (control == null && targetView != null) {
            for (var i = 0, parentPanel; parentPanel = targetView.panels.items[i]; i++) {
                if (parentPanel.contentView != null) {
                    control = parentPanel.contentView.panels.get(controlId);
                    if (controlId != null) {
                        break;
                    }
                }
            }
        }

        return control;
	},
	
	
	getControlsByType: function(win, controlType) {
        var controls = [];

        if (typeof(win) == 'string') {
            win = this.getWindow(win);
        }

        var targetView = win.Ab.view.View;
        targetView.panels.each(function(panel) {
            if (panel.type == controlType || !valueExistsNotEmpty(controlType)) {
            	controls.push(panel);
            }
        });

        return controls;	
	},

	
	getLocalizedString: function(key3) {
		var localString = key3;
		if (typeof(Ab.localization) != 'undefined') {
			for (var i=0, msg; msg = Ab.localization.Localization.localizedStrings[i]; i++) {
				if (msg.key3 == key3) {
					(msg.value == '') ? localString = '*' + msg.key3 : localString = msg.value;
					return localString;
				}
			}
		}
		
		if(valueExistsNotEmpty(localString)){
			localString = convertFromXMLValue(localString);
		}
		
		return localString;
	},

	
	currencyCodeFor: function(symbol) {
		var code = '';
		for (var i = 0; i < View.project.currencies.length; i++) {
			var currency = View.project.currencies[i];
			if (currency.symbol == symbol) {
				code = currency.code;
				break;
			}
		}
		
		return code;
	},

	
	currencySymbolFor: function(code) {
		var symbol = '';
		for (var i = 0; i < View.project.currencies.length; i++) {
			var currency = View.project.currencies[i];
			if (currency.code == code) {
				symbol = currency.symbol;
				break;
			}
		}
		
		return symbol;
	},

    	
	isMemberOfGroup: function(user, group) {
		if(group === ''){
			return true;
		}
		group = group.toLowerCase();
		
		for (var i = 0; i < user.groups.length; i++) {
			var userGroup = user.groups[i];
			userGroup = userGroup.toLowerCase();
	        if (userGroup === '%') {
                return true;
	        }
	        
	        var beginsWithWildCard = (userGroup.match("^%") != null);
            var bEndsWildCard = (userGroup.match("%$") != null );
            
            if (beginsWithWildCard) {
                // exclude beginning wild card
                userGroup = userGroup.substring(1);
            }

            if (bEndsWildCard) {
                // exclude ending wild card
                userGroup = userGroup.substring(0, userGroup.length - 1);
            }
            
            var userGroupAtTheEnd = false;
            var userGroupAtTheStart = false;
            var userGroupAnywhere = false;
            if (beginsWithWildCard) {
                if (bEndsWildCard) {
                    userGroupAnywhere = true;
                } else {
                    userGroupAtTheEnd = true;
                }
            } else {
                if (bEndsWildCard) {
                    userGroupAtTheStart = true;
                }
            }

            var matches = false;
            if (userGroupAnywhere) {
                // check if user group could be found in the  group name
                matches = group.indexOf(userGroup) > -1 ? true : false;
            } else if (userGroupAtTheEnd) {
                // check if user group mathes the end of the  group name
                matches = (group.match(userGroup+"$") != null);
            } else if (userGroupAtTheStart) {
                // check if user group mathes the start of the  group name
                matches = (group.match("^"+userGroup) != null);
            } else {
                // check if the group matches the beginning of the user group name
                matches = (userGroup.match("^"+group) != null);
            }
            
            if (matches) {
                return true;
            }
			
		}
		
	    return false;
	},
	
	
	isProcessAssignedToUser: function(activitiesAndProcesses) {
		try {
			var result = Workflow.callMethod('AbSystemAdministration-ConfigHandlers-isProcessAssignedToUser', 
				activitiesAndProcesses);
			return result.value;
		} catch (e) {
			Workflow.handleError(e);
		}
	},
	
	
	convertJavaDateFormat: function(dateFormat) {
        dateFormat = dateFormat.replace(/H+/g, 'G');
        dateFormat = dateFormat.replace(/h+/g, 'g');
        dateFormat = dateFormat.replace(/m+/g, 'i');
        dateFormat = dateFormat.replace(/s+/g, 's');
        dateFormat = dateFormat.replace(/S+/g, 'u');
        dateFormat = dateFormat.replace(/a/g, 'A');
        dateFormat = dateFormat.replace(/z/g, 'T');
        dateFormat = dateFormat.replace(/Z/g, 'O');
        dateFormat = dateFormat.replace(/Y{3,}/g, 'X'); // X is a placeholder
        dateFormat = dateFormat.replace(/y{3,}/g, 'x'); // x is a placeholder
        dateFormat = dateFormat.replace(/Y{1,2}/g, 'y');
	    dateFormat = dateFormat.replace(/y{1,2}/g, 'y');
        dateFormat = dateFormat.replace(/X/g, 'Y');     // replace X placeholders
        dateFormat = dateFormat.replace(/x/g, 'Y');     // replace x placeholders
        dateFormat = dateFormat.replace(/M{4,}/g, 'F');
        dateFormat = dateFormat.replace(/M{3}/g, 'M');
        dateFormat = dateFormat.replace(/M{1,2}/g, 'm');
        dateFormat = dateFormat.replace(/D+/g, 'j');
        dateFormat = dateFormat.replace(/d+/g, 'j');
        dateFormat = dateFormat.replace(/E{4,}/g, 'l');
        dateFormat = dateFormat.replace(/E{1,3}/g, 'D');
	    return dateFormat;
	},
	
	onPrintView: function() {
        //target frame object must be focused at first
        self.focus();
        //if objFrame has frames, leave the choice that what'll be
        //printed to users 
        self.print();
	},
	
	onEmailView: function() {
		this.openDialog(Ab.view.View.contextPath + '/schema/ab-core/views/ab-system-send-view-link.axvw',
		    null, false, 0, 0, 750, 350);
	},
	

	onAddFavorite: function() {
		var result = null;
		var task = this.taskRecord;
		if (task == null) {
			View.showMessage('error', View.getLocalizedString(this.z_MESSAGE_NO_TASK_MYFAVORITE));
			return;
		}
		// source view may be an afm_ptask (PNav view) or a afm_process (Dashboard view)
		var isPtask = true;

		var viewName = task.getValue('afm_ptasks.task_file');
		if (typeof viewName == 'undefined') {
			viewName = task.getValue('afm_processes.dashboard_view');
			isPtask = false;
		}
		if (typeof viewName == 'undefined') {
			View.showMessage('error', View.getLocalizedString(this.z_MESSAGE_NO_TASK_MYFAVORITE));
			return;
		}
		var userName = this.user.name;
		var myFavoriteExists = false;
		
		// is the current view a myFavorite? if yes, reset confirm dialog message
		if (task.getValue('afm_ptasks.is_hotlist.raw') == '1' && task.getValue('afm_ptasks.hot_user_name') == userName) {
				myFavoriteExists = true;
				viewName = viewName.substring(0, viewName.indexOf('-' + userName)) + '.axvw';
		}
		else {  // does this user already have a myFavorite for the current view?
			var favViewName = viewName.substring(0, viewName.indexOf('.axvw')) + '-' + userName + '.axvw'
			result = Workflow.call('AbSystemAdministration-checkIfViewExists', { fileName: favViewName });
			if (result.data.recordExists == 'true' ) {
				myFavoriteExists = true;
			}
		}
		var message = myFavoriteExists? this.getLocalizedString(Ab.view.View.z_MESSAGE_OVERWRITE_MYFAVORITE) : this.getLocalizedString(Ab.view.View.z_MESSAGE_ADD_MYFAVORITE);

		// confirm add view to myFavorites
		View.confirm(message, function(button) {
			if (button == 'yes') {
				var parameters = new Object();
				parameters.viewName = viewName;
				parameters.isWritePtask = !myFavoriteExists;

				parameters.taskId = isPtask ? task.getValue('afm_ptasks.task_id.key') : task.getValue('afm_processes.title');
				parameters.taskIdLocalized = isPtask ? task.getValue('afm_ptasks.task_id') : task.getValue('afm_processes.title');
				parameters.processId = isPtask ? task.getValue('afm_ptasks.process_id') : task.getValue('afm_processes.process_id');
				parameters.activityId = isPtask ? task.getValue('afm_ptasks.activity_id') : task.getValue('afm_processes.activity_id');

				try {
					Workflow.call('AbSystemAdministration-addViewToMyFavorites', parameters);
					// TODO: save for localization in next release
					// message = View.getLocalizedString(viewLocal.z_MESSAGE_ADD_FAIL_MYFAVORITE);
					// View.alert(message);
				} catch (e) {
					// TODO: save for localization in next release
					// message = View.getLocalizedString(viewLocal.z_MESSAGE_ADD_FAIL_MYFAVORITE);
					// View.showMessage('error', message, e.message);
					View.showMessage('error', e.message);
				}
			}
		});
	},

    
    onLogger: function() {
        if (!this.logWindow) {
            Ext.get('logger').setStyle('font-size', '12px');
            this.logWindow = new Ext.Window({
                title: 'Log Console',
                contentEl: 'logger',
                autoScroll: true,
                collapsible: true,
				maximizable: true,
                layout: 'fit',
                width: 800,
                height: 600,
                closeAction: 'hide'
            });
            this.logReader = new YAHOO.widget.LogReader('logger', {
                newestOnTop: false,
                verboseOutput: false
            });
            Ext.get('yui-log-hd0').remove();
        }
        if (this.logWindow.isVisible()) {
            this.logWindow.hide();
        }
        else {
            this.logWindow.show();
        }
    },
    
	
	getBaseUrl: function() {
		return window.location.protocol + '//' + window.location.host + this.contextPath;
	},

    
    getUrlForPath: function(path) {
        return this.getBaseUrl() + '/' + path;
    },

    // ----------------------- support for app controllers ----------------------------------------

    
    createController: function(id, config) {
        var controllerClass = Ab.view.Controller.extend(config);
        var controller = new (controllerClass);
        controller.extend = new Base().extend;
        return this.initController(id, controller);
    },
    
    
    extendController: function(id, baseController, config) {
        var controller = new (baseController.extend(config));
        return this.initController(id, controller);
    },
    
    
    initController: function(id, controller) {
		controller.id = id;
        controller.view = this;
        this.controllers.add(id, controller);

        // set up Backbone.View properties
        controller.setElement(jQuery('body'), false);
        controller.delegateEvents(controller.events);

        if (controller.afterCreate) {
            controller.afterCreate();
        }
		
		// if controller is created after the view is fully loaded, 
		// still call the controller's lifecycle callbacks
		if (this.state === this.STATE_READY) {
			controller._afterViewLoad();
			controller.afterInitialDataFetch();
		}

        return controller;
    },

    // ----------------------- support for job progress dialog ------------------------------------
    
    
    openJobStatusDialog: function(jobId){
	
		// call the WFR to get the job status 
        var result = Workflow.getJobStatus(jobId);
        
        if (result.code == 'executed') 
	    {
			// has any result returned from WFR?
			if (valueExists(result.jsonExpression) && result.jsonExpression != '') {
				result.data = eval('(' + result.jsonExpression + ')');
				var strJobStatus= this.getLocalizedString(Ab.view.View.z_MESSAGE_JOBSTATUS);
				strJobStatus = strJobStatus.replace(/jobId/g, jobId);
				
				//check if the job status div already exist, if so, remove it
	    		var job_status_div = Ext.get('job_status_div');
       			if (job_status_div == null) {
       				// create new job status DIV
       				var html = '<div id="job_status_div" class="x-hidden">'
			                 + '<div class="x-window-header"> </div>' 
			                 + '<div id="x-window-body">' + strJobStatus + result.data.jobStatus  + '</div>'
			                 + '</div>';
			        Ext.DomHelper.insertHtml('afterBegin', document.body, html);
        		} else {
        			var html = '<div class="x-window-header"> </div>' 
			                 + '<div id="x-window-body">' + strJobStatus + result.data.jobStatus  + '</div>';
        			// reset job status DIV content
        			Ext.DomHelper.overwrite(job_status_div, html, true);
        		}
        
            	if (!this.jobStatusDialog) {
            	
            		// create a new job status dialog
		            this.jobStatusDialog = new Ext.Window({
		                title: 'Job Status',
		                contentEl: 'job_status_div',
		                autoScroll: true,
		                collapsible: true,
						maximizable: true,
		                layout: 'fit',
		                width: 400,
		                height: 200,
		                closeAction: 'hide'
		            });
		        }
		       	
		       	// show the job status dialog
		        this.jobStatusDialog.show();
			}	    	
	   	}
        
    },
    
    
    closeJobStatusDialog: function(){
    	if (!this.jobStatusDialog) {
        	this.jobStatusDialog.hide();
        }
    }
}));


View = Ab.view.View;



AFM = Ab;



Ab.view.ViewDef = Base.extend({
    // view name
    viewName: null,

	// index into tableGroups within view definition. default to first (0th)
	tableGroupIndex: 0,
    
    // main table name
    tableName: null,
    
    // array of field names to be displayed
    fieldNames: null,

	// id of the datasource within the view, for multi-datasource views
	dataSourceId: null,

        
    constructor: function(viewName, tableGroupIndex, tableName, fieldNames, dataSourceId) {
        this.viewName = viewName;
        if (typeof tableName != 'undefined') {
            this.tableName = tableName;
            this.fieldNames = fieldNames;
        }
		this.tableGroupIndex = tableGroupIndex;
		if (typeof dataSourceId != 'undefined') {
			this.dataSourceId = dataSourceId;
		}
    },
    
    
    getFields: function() {
        return this.fieldNames;
    }
});



Ab.view.Controller = Backbone.View.extend({

    
    inherit: function() {
    },

    
    _afterViewLoad: function() {
        var controller = this;

        // auto-wire references to all view panels as this controller data members
        View.panels.eachKey(function (name) {
            var panel = View.panels.get(name);
            controller.autoWirePanel(panel);
        });
        
        // auto-wire references to all view data sources
        View.dataSources.eachKey(function (name) {
            var dataSource = View.dataSources.get(name);
            controller[name] = dataSource;
        });
        
        this.afterViewLoad();
    },
    
    
    afterLayout: function() {},

    
    afterViewLoad: function() {},

    
    afterInitialDataFetch: function() {},
    
    
    afterRefresh: function(restriction, newRecord, clearRestriction) {},

    
    autoWirePanel: function(panel) {
        var controller = this;

        // auto-wire panel reference, to be used as this.panelId in controller methods
        var name = panel.id;
        controller[name] = panel;

        // auto-wire event listeners for controller functions that match "panelId_onButtonId" 
        panel.actions.each(function (action) {
            var eventHandler = controller[name + '_on' + capitalizeFirst(action.id)];
            if (valueExists(eventHandler) && eventHandler.constructor == Function) {
                panel.addActionListener(action.id, eventHandler, controller);
            }
        });

        // auto-wire event listeners for controller functions that match "panelId_onButtonId" 
        if (panel.actionbar) {
            panel.actionbar.actions.each(function (action) {
                var eventHandler = controller[name + '_on' + capitalizeFirst(action.id)];
                if (valueExists(eventHandler) && eventHandler.constructor == Function) {
                    panel.addActionbarActionListener(action.id, eventHandler, controller);
                }
            });
        }
                
        // auto-wire event listeners for controller functions that match "panelId_eventName"
        panel.eventListeners.eachKey(function (eventName) {
            controller.autoWireEventListener(panel, eventName);
        });
        this.autoWireEventListener(panel, 'onClickItem');
        this.autoWireEventListener(panel, 'onMultipleSelectionChange');

        // auto-wire drag-and-drop event listeners if defined in the controller
        var dragDropListener = controller[name + '_onDragDrop'];
        if (valueExists(dragDropListener)) {
            panel.addDragDropListener(dragDropListener, controller);
        }
        var dragOverListener = controller[name + '_onDragOver'];
        if (valueExists(dragOverListener)) {
            panel.addDragOverListener(dragOverListener, controller);
        }

        if (panel.type == 'form') {
            this.autoWireFormFields(panel);
        } else if (panel.type == 'grid') {
            this.autoWireGridRows(panel);
        }
    },

	
	autoWireFormFields: function(panel) {
        var controller = this;

        panel.fields.each(function (field) {
            field.actions.each(function (action) {
                controller.autoWireActionListener(panel, field, action);
            });
        });
        panel.fieldsets.each(function (fieldset) {
            fieldset.actions.each(function (action) {
                controller.autoWireActionListener(panel, fieldset, action);
            });
        });
    },
    
    
    autoWireGridRows: function(panel) {
        var controller = this;

        panel.gridRows.each(function (row) {
            row.actions.each(function (action) {
                controller.autoWireActionListener(panel, row, action);
            });
        });
    },

    
    autoWireEventListener: function(panel, eventName) {
        var listener = this[panel.id + '_' + eventName];
        if (valueExists(listener) && listener.constructor == Function) {
            panel.addEventListener(eventName, listener, this);
        }
    },
    
    
    autoWireActionListener: function(panel, parentObject, action) {
        var eventHandlerName = panel.id + '_on' + capitalizeFirst(action.originalId);
        var eventHandler = this[eventHandlerName];
        
        if (!valueExists(eventHandler)) {
            eventHandlerName = panel.id + '_' + action.originalId + '_onClick';
            eventHandler = this[eventHandlerName];
        }
        
        if (valueExists(eventHandler) && eventHandler.constructor == Function) {
            var listener = eventHandler.createDelegate(this, [parentObject, action]);
            action.addListener(listener);
        }
    },

    on: function(events, callback) {
        View.eventAggregator.on(events, callback, this);
    },

    trigger: function(events, parameter1, parameter2, parameter3) {
        View.eventAggregator.trigger(events, parameter1, parameter2, parameter3);
    }
});


function capitalizeFirst(s) {
    var result = s.substring(0, 1).toUpperCase() + s.substring(1, s.length);
    return result.replace('.', '_');
}


Ab.view.LocalStorageProvider = Base.extend({
    // no instance data or methods
}, {
    
    load: function(id, data) {
        if (localStorage) {
            // JSON.parse() is not supported in IE8-
            var json = eval('(' + localStorage.getItem(id) + ')');
            data.fromJSON(json);
        }
    },

    
    save: function(id, data) {
        if (localStorage) {
            // JSON.stringify() is not supported in IE8-
            localStorage.setItem(id, toJSON(data.toJSON()));
        }
    }
});


Ab.view.Sidecar = Backbone.Model.extend({
    
    defaults: {
        columns: [],
        levels: [],
        recentSearches: [],
        maxRecentSearches: 15
    },

    
    initialize: function(attributes) {
        // load from local storage
        this.load();

        // attach the add() method to the array instance to prevent duplicate or empty searches
        var max = this.get('maxRecentSearches');
        this.get('recentSearches').add = function(search) {
            var duplicate = null;
            for (var i = 0; i < this.length; i++) {
                if (this[i].equals(search)) {
                    duplicate = this[i];
                    break;
                }
            }

            if (!duplicate && search) {
                this.push(search);
            }

            if (this.length > max) {
                this.shift();
            }
        }
    },

    
    fromJSON: function(data) {
        this.set(this.defaults);

        if (data) {
            this.set(data);

            var recentSearches = [];
            for (var i = 0; i < data.recentSearches.length; i++) {
                var search = new Ab.view.Restriction();
                search.fromJSON(data.recentSearches[i]);
                recentSearches.push(search);
            }
            this.set('recentSearches', recentSearches);
        }
    },

    
    toJSON: function() {
        var data = {};

        _.each(this.attributes, function(value, key) {
            if (value instanceof Backbone.Collection) {
                data[key] = value.toJSON();
            } else {
                data[key] = _.clone(value);
            }
        });

        data.recentSearches = [];
        _.each(this.get('recentSearches'), function(search) {
            data.recentSearches.push(search.toJSON());
        });

        return data;
    },

    
    load: function() {
        Ab.view.LocalStorageProvider.load(this.get('panelId'), this);
    },

    
    save: function() {
        Ab.view.LocalStorageProvider.save(this.get('panelId'), this);
    }
});


Ab.namespace('command');



Ab.command.Command = Base.extend({
    
    // ----------------------- properties that are set automatically -------------------------------
    
    // Command type
    type: '',
    
    // ID attribute of the parent control that contains this command
    parentPanelId: '',
    
    // whether the command is enabled (active)
    enabled: true,
    
    // ----------------------- user-defined properties (from AXVW file) ----------------------------
    
    // target window (i.e. 'opener', 'self') or frame name
    target: 'self',
    
    // ID attribute of the target control
    panelId: '',
    
    // whether to apply parent panel restriction if no other restriction had been specified
    applyParentRestriction: true,
    
    // whether to apply current row restriction
    applySelectionRestriction: true,

    // whether to apply multiple selected rows restriction
    applyMultipleSelectionRestriction: true,
    
    // whether to apply a restriction containing only the primary keys 
    applyPrimaryKeyRestriction: false,

	// whether to clear the current restriction of the target panel
    clearRestriction: false,

    // ----------------------- command state variables ---------------------------------------------
    
    // command-specific restriction as an object containing primary key values
    restriction: null,
    
    // result of the command execution, true by default
    result: true,

    // context object used pass data values between commands
    context: null,
    
    
    constructor: function(commandData) {
        this.type = commandData.type;
        if (valueExists(commandData.target)) {
            this.target = commandData.target;
        }
        if (valueExists(commandData.parentPanelId)) {
            this.parentPanelId = commandData.parentPanelId;
        }
        if (valueExists(commandData.panelId)) {
            this.panelId = commandData.panelId;
        }
        if (valueExists(commandData.applyParentRestriction)) {
            this.applyParentRestriction = (commandData.applyParentRestriction == 'true');
        }
        if (valueExists(commandData.applySelectionRestriction)) {
            this.applySelectionRestriction = (commandData.applySelectionRestriction == 'true');
        }
        if (valueExists(commandData.applyMultipleSelectionRestriction)) {
            this.applyMultipleSelectionRestriction = (commandData.applyMultipleSelectionRestriction == 'true');
        }
        if (valueExists(commandData.applyPrimaryKeyRestriction)) {
            this.applyPrimaryKeyRestriction = (commandData.applyPrimaryKeyRestriction == 'true');
        }
        if (valueExists(commandData.clearRestriction)) {
            this.clearRestriction = (commandData.clearRestriction == 'true');
        }
    },
    
    
    getTargetView: function() {
        return Ab.view.View.getView(this.target);  
    },
    
    
    getParentPanel: function() {
        var panel = null;
        if (this.parentPanelId != '') {
            panel = View.getControl('self', this.parentPanelId)
        }
        return panel;  
    },
    
    
    getTargetPanel: function() {
        var panelId = this.panelId;
        if (!valueExistsNotEmpty(panelId)) {
            panelId = this.parentPanelId;
        }
        return View.getControl(this.target, panelId);
    },
    
    
    getRestriction: function() {
        var r = null;

        // if not explicitly prohibited, use this command restriction
        if (this.applySelectionRestriction) {
            r = this.restriction;
        }

        // if the restriction for this command was not explicitly set, use the parent panel restriction
        if (r == null) {
            var panel = this.getParentPanel();
            if (panel != null) {
                
                // restriction applied to the parent panel
                var panelRestriction = null;
                if (this.applyParentRestriction) {
                    panelRestriction = panel.restriction;
                }

                // restriction applied by this command, specific to the panel type
                var commandRestriction = null;
                if (panel.type == 'form') {
                    if (this.applyParentRestriction) {
                        commandRestriction = panel.getFieldRestriction(true);
                    }
					else if (this.applyPrimaryKeyRestriction) {
						commandRestriction = panel.getPrimaryKeyFieldValues(true);
					}
                } else if (panel.type == 'grid') {
                    if (this.applyMultipleSelectionRestriction && panel.multipleSelectionEnabled) {
                        commandRestriction = panel.getPrimaryKeysForSelectedRows();
						// multiple selection restriction cannot be combined with any other restriction
						panelRestriction = null;
                    }
                }
                
                if (typeof panelRestriction !="string" && panelRestriction != null && commandRestriction != null && panel.type != 'form') {
                    r = panelRestriction;
                    r.addClauses(commandRestriction);
                } else if (panelRestriction != null) {
                    r = panelRestriction;
                } else if (commandRestriction != null) {
                    r = commandRestriction;
                }
            }
        }

        return r;
    },
	
	
	trimArrayValues: function(valuesArray) {
		if (typeof valuesArray === 'object' && valuesArray && valuesArray instanceof Array) {
			for (var i = 0; i < valuesArray.length; i++) {
				valuesArray[i] = trim(valuesArray[i]);
			}
		}
		else if (typeof valuesArray === 'string') {
			valuesArray = trim(valuesArray);
		}
		
		return valuesArray;
	},
    
    
    handle: function(context) {
        if (typeof(context) != 'undefined') {
            this.context = context;
            this.context.command = this;
        }

        // result is true by default
        this.result = true;
    }
});



Ab.command.commandChain = Ab.command.Command.extend({
    
    // chained commands
    commands: null,
    
    
    constructor: function(parentPanelId, restriction) {
        this.inherit({type: 'commandChain', parentPanelId: parentPanelId});
        
        if (typeof(restriction) != 'undefined') {
            this.restriction = restriction;
        }
        
        // arrays must be allocated in the constructor
        this.commands = new Array();
    },
    
    
    addCommand: function(command) {
        command.restriction = this.restriction;
        if (this.parentPanelId != '') {
            command.parentPanelId = this.parentPanelId;
        }
        this.commands.push(command);
    },
    
    
    addCommands: function(commandsData) {
        for (var i = 0; i < commandsData.length; i++) {
            var commandData = commandsData[i];
            if (commandData != null) {
                var commandType = commandData.type;
                var commandClass = Ab.command[commandType];
                if (commandClass == null) {
                    commandClass = Ab.command.Command;
                }
                var command = new commandClass(commandData);
                this.addCommand(command);
            }
        }
    },
    
    
    handle: function(context) {
        // if this command is disabled, do not execute
        if (!this.enabled) {
            return;
        }
        
        this.inherit(context);

        // create context object that can be used by chained commands as a data billboard
        if (valueExists(context)) {
            this.context = context;
        } else {
            this.context = {};
        }
        
        // execute all chained commands
        for (var i = 0; i < this.commands.length; i++) {
            var command = this.commands[i];
            
            // do not execute disabled commands
            if (!command.enabled) {
                continue;
            }
            
			command.restriction = this.restriction;
            try {
                command.handle(this.context);
            } catch (e) {
				if (typeof View != 'undefined') {
					View.showMessage('error', e.message, 'Line ' + e.lineNumber + ' at ' + e.fileName, e.stack);
				}
                this.result = false;
                break;
            }
            
            // if any command fails, stop executing other commands
            if (!command.result) {
                this.result = false;
                break;
            }
        }
    }
});

// --------------------------- window and view commands --------------------------------------------


Ab.command.openView = Ab.command.Command.extend({

    viewName: '',

    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = commandData.viewName;
    },

    
    handle: function(context) {
        this.inherit(context);
        window.open(this.viewName);
    }
});



Ab.command.openDialog = Ab.command.Command.extend({
    
    viewName: '',
    newRecord: false,
    
    x: null,
    y: null,
    width: null,
    height: null,
    dialogTitle: '',
    closeButton: false,
    maximize: false,
  
    
    constructor: function(commandData) {
        this.inherit(commandData);

        this.viewName = commandData.viewName;
        if (valueExists(commandData.newRecord) && commandData.newRecord == 'true') {
            this.newRecord = true;
        }
        if (valueExists(commandData.width)) {
            this.width = parseInt(commandData.width);
        }
        if (valueExists(commandData.height)) {
            this.height = parseInt(commandData.height);
        }
        if (valueExists(commandData.closeButton) && commandData.closeButton == 'false') {
            this.closeButton = false;
        }
        if (valueExists(commandData.maximize) && commandData.maximize == 'true') {
            this.maximize = true;
        }
        if (valueExists(commandData.dialogTitle)) {
            this.dialogTitle = commandData.dialogTitle;
        }
    },
    
    
    handle: function(context) {
        this.inherit(context);

        if (context && context.clientX && !this.x) {
            this.x = context.clientX;
        }
        if (context && context.clientY && !this.y) {
            this.y = context.clientY;
        }

        var view = this.getTargetView();
        var panel = this.getParentPanel();
		
		if (valueExistsNotEmpty(this.viewName)) {
			// set the reference to the current panel in the view, so that the dialog can access it
			view.dialogOpenerPanel = panel;
            view.openDialog(this.viewName, this.getRestriction(), this.newRecord, this.getWindowConfig(context));
		}
		else {
            var targetPanel = this.getTargetPanel();
            targetPanel.refresh(this.getRestriction(), this.newRecord);
            targetPanel.showInWindow(this.getWindowConfig(context));
		}
    },
	
	getWindowConfig: function(context) {
		return {
            anchor: (context && context.target) || (context && context.el ? context.el.dom : null),
            x: this.x,
            y: this.y,
            width: this.width, 
            height: this.height,
            title: this.dialogTitle,
            closeButton: this.closeButton,
            maximize: this.maximize,
            collapsible: false
        };
	}
});




Ab.command.closeDialog = Ab.command.Command.extend({
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
    },
    
    
    handle: function(context) {
        this.inherit(context);
		
		var panel = this.getParentPanel();
		if (panel && panel.isShownInWindow()) {
			panel.closeWindow();
		} else if (panel && panel.parentTab && panel.parentTab.parentPanel.isShownInWindow()) {
            panel.parentTab.parentPanel.closeWindow();
        } else if(View.getOpenerView().addNewSelectVDialog){
        	View.getParentDialog().panel.refresh();
        	View.getOpenerView().addNewSelectVDialog.hide();
		} else {
			var view = View.getOpenerWindow().View;
			if (view != null) {
				view.closeDialog();
			}
		}
    }
});



Ab.command.showPanel = Ab.command.Command.extend({
   
    // whether the panel should display a new record 
    newRecord: false,
    
    // whether the panel should be shown or hidden
    show: true,
    
    // whether the panel header bar should be also shows according to the show property
    includeHeader: true,
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.newRecord) && commandData.newRecord == 'true') {
            this.newRecord = true;
        }
        if (valueExists(commandData.show) && commandData.show == 'false') {
            this.show = false;
        }
        if (valueExists(commandData.includeHeader) && commandData.includeHeader == 'true') {
            this.includeHeader = true;
        }
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var panel = this.getTargetPanel();
        if (panel != null) {
            var newRestriction = this.getRestriction();
            
            if (this.clearRestriction) {
                panel.restriction = null;
                newRestriction = null;
            } else {
                var parentPanel = this.getParentPanel();
                if (parentPanel.isConsole) {
                    if (!parentPanel.canSave()) {
                        return;
                    }
                }
            }
            
            if (this.show) {
                panel.refresh(newRestriction, this.newRecord);
            }
            
            panel.show(this.show, this.includeHeader);
        }
    }
});


Ab.command.clearPanel = Ab.command.Command.extend({

    
    constructor: function(commandData) {
        this.inherit(commandData);
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var panel = this.getTargetPanel();
        if (panel != null) {
            panel.clear();
        }
    }
});


Ab.command.loadView = Ab.command.Command.extend({
    
    fileName: '',
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.fileName = commandData.fileName;
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var panel = this.getTargetPanel();
        if (panel != null) {
            var restriction = this.getRestriction();
            panel.loadView(this.fileName, restriction);
        }
    }
});


Ab.command.showRegion = Ab.command.Command.extend({

    // layout id
    layout: 'mainLayout',
   
    // region name (north|south|east|west|center) 
    region: '',
    
    // action: show|hide|toggle
    action: 'show',
    
    
    constructor: function(config) {
        this.inherit(config);
        Ext.apply(this, config);
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var view = this.getTargetView();
        var layoutManager = view.getLayoutManager(this.layout);
        if (layoutManager) {
            if (this.action == 'show') {
                layoutManager.expandRegion(this.region);
            } else if (this.action == 'hide') {
                layoutManager.collapseRegion(this.region);
            } else {
                if (layoutManager.isRegionCollapsed(this.region)) {
                    layoutManager.expandRegion(this.region);
                } else {
                    layoutManager.collapseRegion(this.region);
                }
            }
        }
    }
});

// --------------------------- form commands -------------------------------------------------------


Ab.command.FormCommand = Ab.command.Command.extend({
    
    formId: null, 
    workflowRuleId: null,
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.formId)) {
            this.formId = commandData.formId;
        }
        if (valueExists(commandData.workflowRuleId)) {
            this.workflowRuleId = commandData.workflowRuleId;
        }
    },
    
    
    getForm: function(context) {
        var form = null;
        if (this.formId == null) {
            // if formId property is not set, return the parent form panel
            form = this.getParentPanel();
        } else {
            // otherwise return specified form panel
			form = this.getTargetPanel();
        }
        return form;
    }
});


Ab.command.saveForm = Ab.command.FormCommand.extend({
    
    constructor: function(commandData) {
        this.inherit(commandData);
    },
    
    
    handle: function(context) {
        this.inherit(context);

        var form = this.getForm();
        if (form != null) {
           this.result = form.save(this.workflowRuleId);
        }
    }
});


Ab.command.clearForm = Ab.command.FormCommand.extend({
    
    constructor: function(commandData) {
        this.inherit(commandData);
    },
    
    
    handle: function(context) {
        this.inherit(context);

        var form = this.getForm();
        if (form != null) {
           this.result = form.clear();
        }
    }
});


Ab.command.deleteRecord = Ab.command.FormCommand.extend({

	// @begin_translatable
	z_CONFIRM_DELETE_MESSAGE: 'Record [{0}] will be deleted.',
    z_MESSAGE_INVALID_PK_FIELD: 'One or more required fields need a value.',
	z_CONFIRM_DELETE_MISMATCH_MESSAGE: 'Record to delete does not match the record that was selected.',
	// @end_translatable
	
    
    constructor: function(commandData) {
        this.inherit(commandData);
    },
    
    
    handle: function(context) {
        this.inherit(context);

        var form = this.getForm();
        
        var pkeys = form.getPrimaryKeyFields();
        var oldValues = form.record;
        var curValues = form.getPrimaryKeyFieldValues();
        var bPkeysMatch = true;
        var oldPkeyValues = {};
        
        for(var i=0; i<pkeys.length; i++){        	
        	var fieldName = pkeys[i];
        	var oldValue = oldValues.getValue(fieldName);
        	var curValue = curValues[fieldName];
        	var fieldDef = form.fields.get(fieldName).fieldDef;


        	if(fieldDef.isDate && oldValue.constructor != String){
        		oldValue = oldValue.format(fieldDef.getDateFormat(false));       		
        	}
 
        	if(fieldDef.isTime && oldValue.constructor != String){
        		oldValue = oldValue.format(fieldDef.getTimeFormat(false));
        	}      	       	
 	
        	if(oldValue != curValue){
        		bPkeysMatch = false;
        	}
        	oldPkeyValues[pkeys[i]] = oldValue;
        }
        
        var record = (bPkeysMatch) ? form.getPrimaryKeyFieldValues() : oldPkeyValues;
                
        var values = '';
        for (i in record){
			if ( !valueExistsNotEmpty(record[i]) ) {
		        alert(Ab.view.View.getLocalizedString(this.z_MESSAGE_INVALID_PK_FIELD));
				this.result = false;
				return;
			}
        	values += record[i] + ' ';
        }        
        var confirmMessage = (!bPkeysMatch) ? Ab.view.View.getLocalizedString(this.z_CONFIRM_DELETE_MISMATCH_MESSAGE) + '\n' : '';
        confirmMessage += String.format(Ab.view.View.getLocalizedString(this.z_CONFIRM_DELETE_MESSAGE), trim(values));
        var confirmDlg = confirm(confirmMessage);
		
        if ((form != null) && (confirmDlg)) {
           this.result = form.deleteRecord();
        } else {
        	this.result = false;
        }
    }
});

// --------------------------- tabbed view commands ------------------------------------------------


Ab.command.TabPageCommand = Ab.command.Command.extend({
    
    tabPanelId: null,
    tabPageName: '',
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.tabPanelId)) {
            this.tabPanelId = commandData.tabPanelId;
        }
        if (valueExists(commandData.tabPageName)) {
            this.tabPageName = commandData.tabPageName;
        }
    },
    
    
    getTabs: function() {
        var tabs = null;
        var view = this.getTargetView();
        if (valueExists(this.tabPanelId)) {
            // panelId command property was specified in AXVW
            tabs = view.getControl('', this.tabPanelId);
        } else {
            // implicit tab panel - try to find any tab panel in the view
            var tabPanels = view.getControlsByType(self, 'tabs');
            if (tabPanels.length == 0) {
                tabPanels = view.getControlsByType(parent, 'tabs');
            }            
            tabs = tabPanels[0];
        }
		return tabs;
    }
});



Ab.command.selectTabPage = Ab.command.TabPageCommand.extend({
    
    newRecord: false,
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.newRecord) && commandData.newRecord == 'true') {
            this.newRecord = true;
        }
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var restriction = this.getRestriction();
        
        var tabs = this.getTabs();
        if (tabs) {
            tabs.selectTab(this.tabPageName, restriction, this.newRecord, this.clearRestriction);
        }
    }
});


Ab.command.createTabPage = Ab.command.TabPageCommand.extend({
    
    viewName: '',
    newRecord: false,
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = commandData.viewName;
        if (valueExists(commandData.newRecord) && commandData.newRecord == 'true') {
            this.newRecord = true;
        }
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var restriction = this.getRestriction();
        
        var tabs = this.getTabs();
        if (tabs) {
            tabs.createTab(this.viewName, restriction, this.newRecord);
        }
    }
});



Ab.command.closeTabPage = Ab.command.TabPageCommand.extend({
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
    },
    
    
    handle: function(context) {
        this.inherit(context);
        
        var tabs = this.getTabs();
        if (tabs) {
            tabs.closeTab(this.tabPageName);
        }
    }
});


// --------------------------- workflow rule commands ----------------------------------------------


Ab.command.workflowRule = Ab.command.Command.extend({

    ruleId: '',
    showMessageAsPopup: false,

    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (typeof(commandData.ruleId) != 'undefined') {
            this.ruleId = commandData.ruleId;
        }
        if (valueExists(commandData.showMessageAsPopup) && commandData.showMessageAsPopup == 'true') {
            this.showMessageAsPopup = true;
        }
    },

    
    getParameters: function() {
        var parameters = new Object();
        var panel = this.getParentPanel();
        if (panel != null) {
            parameters.viewName = panel.viewDef.viewName;
    	    parameters.groupIndex = (typeof panel.viewDef.tableGroupIndex == 'undefined') ? 0 : panel.viewDef.tableGroupIndex;
            parameters.controlId = (typeof panel.panelId == 'undefined') ? panel.id : panel.panelId;
			parameters.version = Ab.view.View.version;  
            parameters.dataSourceId = panel.dataSourceId;

            if (panel.type == 'form') {
                parameters.fieldValues = toJSON(panel.getFieldValues());
                parameters.oldFieldValues = toJSON(panel.getOldFieldValues());
                
            } else if (panel.type == 'grid') {
                if (this.applyMultipleSelectionRestriction && panel.multipleSelectionEnabled) {
                    parameters.records = toJSON(panel.getPrimaryKeysForSelectedRows());
                } else {
                    // per-row command?
                    var r = this.getRestriction();
                    if (r != null) {
                        parameters.fieldValues = toJSON(r);
                    }
                }
            }
        }
        return parameters;
    },

    
    handle: function(context) {
        this.inherit(context);

        var wfrResult = Ab.workflow.Workflow.runRuleAndReturnResult(
            this.ruleId,
            this.getParameters());
		if (wfrResult.code == 'executed') {
            this.result = true;
            this.context.message = wfrResult.message;
            this.context.data = wfrResult.data;
            this.context.dataSet = wfrResult.dataSet;
            
            if (this.showMessageAsPopup) {
                View.alert(wfrResult.message);
            }
        }
		else {
            this.result = false;
            Ab.workflow.Workflow.handleError(wfrResult);
		}
    }
});



Ab.command.startJob = Ab.command.workflowRule.extend({
    // @begin_translatable
    z_MESSAGE_PROGRESS_TITLE: 'Job Progress',
    // @end_translatable

     // if true, the command will display ab-paginated-report-job.axvw, otherwise it will display the job progress dialog
    useSingleJobView: false,
    
    // ID of the message used as a progress bar title
    messageId: null,
    
    // if specified, the command will display the result view after the job execution is complete
    resultView: '',

    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.useSingleJobView) && commandData.useSingleJobView == 'true') {
            this.useSingleJobView = true;
        }
        if (valueExists(commandData.messageId)) {
            this.messageId = commandData.messageId;
        }
        if (valueExists(commandData.resultView)) {
            this.resultView = commandData.resultView;
        }
    },

    
    handle: function(context) {
        var message = '';
        if (valueExists(this.messageId)) {
            message = getMessage(this.messageId);
        } else {
            message = View.getLocalizedString(this.z_PROGRESS_TITLE);
        }
        try {
            var jobId = Workflow.startJob(this.ruleId);
            
            if (this.useSingleJobView) {
                 var url = 'ab-paginated-report-job.axvw?jobId=' + jobId;
                 if (valueExistsNotEmpty(this.resultView)) {
                     url = url + '&resultView=' + this.resultView;
                 }
                 //View.loadView(url);
                 var view = this.getTargetView();
 	            view.openDialog(url, '', '', false);
            } else {
                View.openJobProgressBar(message, jobId, this.resultView);
            }
        } catch (e) {
            Workflow.handleError(e);
        }
    }
});



Ab.command.deleteSelectedRows = Ab.command.workflowRule.extend({
    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.ruleId = 'AbCommonResources-deleteDataRecords';
    }
});

// --------------------------- document commands ---------------------------------------------------


Ab.command.documentCommand = Ab.command.openDialog.extend({
    
    tableName: '',
    fieldName: '',
    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.tableName = commandData.tableName;
        this.fieldName = commandData.fieldName;
        this.closeButton = false;
		this.applyParentRestriction = false;
    },
    
    
    handle: function(context) {

        // add document parameters for the dialog
        var view = this.getTargetView();
        var panel = this.getParentPanel();

		// canonical PK field ordering needed for multi-field afm_docs PKey
		var pkFields = view.dataSources.get(panel.dataSourceId).primaryKeyFields;
        
        view.dialogDocumentParameters = {
            tableName: this.tableName,
            fieldName: this.fieldName,
            fieldValue: panel.getFieldValue(this.tableName + '.' + this.fieldName),
			primaryKeyFields: pkFields,
            panel: panel
        }
        
        this.inherit(context);
    }
});


Ab.command.checkInNewDocument = Ab.command.documentCommand.extend({

    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = 'ab-doc-checkin.axvw';
        this.width = 600;
        this.height = 400;
    }
});



Ab.command.checkInNewDocumentVersion = Ab.command.documentCommand.extend({

    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = 'ab-doc-checkin-new-version.axvw';
        this.width = 600;
        this.height = 400;
    }
});



Ab.command.checkOutDocument = Ab.command.documentCommand.extend({

    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = 'ab-doc-checkout.axvw';
    }
});


Ab.command.showDocument = Ab.command.documentCommand.extend({    
    
    // full name of an image field on this form, used to display image documents
    displayFieldName: '',    
	
    constructor: function(commandData) {
        this.inherit(commandData);
        this.displayFieldName = commandData.displayFieldName;
    },
    
    handle: function() {
        var form = this.getParentPanel();
        var fileName = form.getFieldValue(this.tableName + '.' + this.fieldName);

        var keys = this.getKeysFromForm(form);
		
		var imageElementId = valueExistsNotEmpty(this.displayFieldName) ? form.getFieldElementName(this.displayFieldName) : null;
		
		View.showDocument(keys, this.tableName, this.fieldName, fileName, imageElementId);
    },
    
    
    getKeysFromForm: function(form) {
        // add primary key values from the document table
        // the primary key of the document table must be present on the form (hidden or otherwise)
        var pkeys = [];
        var fieldNames = form.getPrimaryKeyFields();
        for (var i = 0, name; name = fieldNames[i]; i++) {
            // filter out fields from other tables
            if (name.indexOf(this.tableName + '.') == 0 &&
                name != this.tableName + '.' + this.fieldName) {
                var value = form.getFieldValue(name);
                pkeys.push({'name': name, 'value':value});
            }
        }

        var keys = {};
        for (var i=0, pkey; pkey = pkeys[i]; i++) {
            keys[pkey.name.substring(pkey.name.lastIndexOf('.') + 1)] = pkey.value;
        }

        return keys;
    }
});


Ab.command.lockDocument = Ab.command.documentCommand.extend({        
	
    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = 'ab-doc-lock.axvw';
        this.width = 500;
        this.height = 250;
    }
});


Ab.command.deleteDocument = Ab.command.documentCommand.extend({
    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.viewName = 'ab-doc-mark-deleted.axvw';
        this.width = 500;
        this.height = 250;
    }
});


// --------------------------- other commands ------------------------------------------------------


Ab.command.callFunction = Ab.command.Command.extend({

    functionName: '',

    
    constructor: function(commandData) {
        this.inherit(commandData);
        this.functionName = commandData.functionName;
    },

    
    handle: function(context) {
        this.inherit(context);

        var fn = window[this.functionName];
        if (fn && fn.call) {
            this.context.restriction = this.getRestriction();
            var result = fn(context);
            if (valueExists(result)) {
                this.result = result;
            }
        } else {
            // fallback for 16.3 compatibility - handle inline JavaScript
            var script = this.functionName.replace(/&quot;/g, "'");
            eval(script);
        }
    }
});


Ab.command.exportPanel = Ab.command.Command.extend({
   
    // @begin_translatable
    z_PROGRESS_MESSAGE: 'Exporting data, please wait',
    z_ERROR_MESSAGE: 'Export failed',
    // @end_translatable

    // format for the export: 'pdf' or 'xls' are supported in 16.3-17.2
    // format 'docx' supported in 18.1 ?
    outputType: '',
    
    // optional name of the export XSL-FO file
    file: '',
    
    //export reporting case with tab & its useFrame=false
    exportReportViewName: null,
    
    // whether the results should be immediately shown in a new dialog
    openDialog: true,

	// whether the export interaction (for dataTransfer) should occur in a dialog r.t. a new window/tab
	useDialog: false,

	// whether the export interaction (for dataTransfer) should export related document files
	isExportDocument: false,

	// whether the import interaction (for dataTransfer) should import related document files
	isImportDocument: false,
	
	//if printing out client-side passed parsed restriction
	printRestriction: false,
	
	//docx output orientation
	orientation: null,
	
	//custom report handler.
	handler: null,
	
	//export's recordLimit setting in export command
	recordLimit: null,
	
	
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.outputType)) {
            this.outputType = commandData.outputType;
        }
        if(valueExists(commandData.viewName)){
         this.exportReportViewName = commandData.viewName;
         }
        if (valueExists(commandData.file)) {
            this.file = commandData.file;
        }
        if (valueExists(commandData.openDialog) && commandData.openDialog == 'false') {
            this.openDialog = false;
        }
		if (valueExists(commandData.useDialog) && (commandData.useDialog == 'true')) {
			this.useDialog = true;
		}
        if (valueExists(commandData.isExportDocument) && commandData.isExportDocument == 'true') {
            this.isExportDocument = true;
        }
        if (valueExists(commandData.isImportDocument) && commandData.isImportDocument == 'true') {
            this.isImportDocument = true;
        }
        if (valueExists(commandData.printRestriction) && commandData.printRestriction == 'true') {
            this.printRestriction = true;
        }
        if (valueExistsNotEmpty(commandData.orientation)) {
            this.orientation = commandData.orientation;
        }
        
        if (valueExists(commandData.handler)) {
            this.handler = commandData.handler;
        }
        
        if (valueExists(commandData.recordLimit)) {
            this.recordLimit = commandData.recordLimit;
        }
        
    },
    
    
    handle: function(context) {
        this.inherit(context);
       
        var panel = this.getTargetPanel();
        if (panel != null) {
            if (this.clearRestriction) {
                panel.restriction = null;
            }

        if(this.outputType === 'xls' || this.outputType === 'docx' || this.outputType === 'pdf'){
				// XLS or DOCX, PDF output
				this.openReport(panel);
			}else if (this.outputType === 'txfr') {
				// data transfer UI
				this.openDataTransferUI(panel);
			}
		}
    },
    
    
    openReport: function(panel){
    	View.openProgressBar(View.getLocalizedString(this.z_PROGRESS_MESSAGE));  
    	 try{
    		 if(valueExists(panel) && panel.callReportJob){
    			 var reportProperties = {outputType: this.outputType, printRestriction: this.printRestriction, 
    					 orientation: this.orientation, handler:this.handler, recordLimit: this.recordLimit};
    			 
    			 var jobId = panel.callReportJob(reportProperties);
    			 
    			 this.displayReport(jobId, this.outputType);
    		 } 
    	 }catch(e){
    		 var message = View.getLocalizedString(this.z_ERROR_MESSAGE);
             View.showMessage('error', message, e.message, e.data);
    	 }
    	View.closeProgressBar();
    },
    
    
    displayReport: function(jobId, outputType){
    	if(jobId != null){
			 var jobStatus = Workflow.getJobStatus(jobId);
			 //XXX: finished or failed
			 while (jobStatus.jobFinished != true && jobStatus.jobStatusCode != 8) {
				jobStatus = Workflow.getJobStatus(jobId);
			 }
			
			 if (jobStatus.jobFinished) {
				var url  = jobStatus.jobFile.url;
				if(valueExists(outputType) && outputType === 'pdf'){
			        window.open(url);
				}else{
					window.location = url;
				}
			}
		 }
    },
	
    
    openDataTransferUI: function(panel) {
    	var reportViewName = panel.viewDef.viewName + '.axvw';
		var reportDataSourceId = panel.dataSourceId;
		var reportTitle = panel.title;
		var restriction = toJSON(panel.restriction);

		var url = 'ab-data-transfer-main.axvw?viewName=' + reportViewName + '&panelId=' + panel.id;
		if(this.isExportDocument)
			url = url + '&isExportDocument=true';
		else 
			url = url + '&isExportDocument=false';
		
		if(this.isImportDocument)
			url = url + '&isImportDocument=true';
		else 
			url = url + '&isImportDocument=false';
		
		
		var view = this.getTargetView();

		if (this.useDialog) { // for SmartClient
			view.progressReportParameters = {};
			view.progressReportParameters.viewName = reportViewName;
			view.progressReportParameters.panelId = panel.id;
			view.progressReportParameters.isExportDocument = this.isExportDocument;
			view.progressReportParameters.isImportDocument = this.isImportDocument;
			
			view.openDialog(url, '', '', false);
			this.styleInteractiveDialog(view);
		}
		else {
			window.open(url);
		}
    },
    
    
	generatePDFReport: function(panel) {
		try {
	        // set panel export parameters and render the panel
	        panel.exportType = this.outputType; 
	        panel.exportFile = this.file;    
	        if(valueExistsNotEmpty(this.orientation)){
	        	 panel.orientation = this.orientation;
	        }
	       
	        if(valueExists(this.exportReportViewName)){
	        	panel.exportReportViewName = this.exportReportViewName;
	        }        
	        panel.refresh(panel.restriction, this.newRecord);
	       
	        // reset panel export parameters
	        panel.exportType = ''; 
	        panel.exportFile = '';            
	        
	        // use panel export URL to open dialog and display the rendered file
	        var url = panel.exportURL;            
	        if (this.openDialog && url != null && url != '') {
	           var view = this.getTargetView();
	           view.openDialog(url, '', '', {collapsible:false});
	        }
	
	        panel.show(this.show);
	
	        View.closeProgressBar();
        } catch (e) {
            View.closeProgressBar();

            var message = View.getLocalizedString(this.z_ERROR_MESSAGE);
            View.showMessage('error', message, e.message, e.data);
        }
	},

	
	styleInteractiveDialog: function(view) {
		view.dialog.maximize();
		if (view.dialog.tools.restore != null)
		{
			view.dialog.tools.restore.hide();
		}		
		if (view.dialog.tools.maximize != null)
		{
			view.dialog.tools.maximize.hide();
		}
		if (view.dialog.tools.close != null)
		{
			view.dialog.tools.close.hide();
		}		
		if (view.dialog.tools.toggle != null)
		{
			view.dialog.tools.toggle.hide();
		}
		if (view.dialog.buttons != null && view.dialog.buttons.length > 0)
		{
			view.dialog.buttons[0].hide();
		}
	}

});



Ab.command.showHelp = Ab.command.Command.extend({
    // file name or path   
    file: '',
    
    // whether the results should be immediately shown in a new dialog
    openDialog: true,
    
    width: null,
        
    height: null, 
       
    
    
    constructor: function(commandData) {
        this.inherit(commandData);
        if (valueExists(commandData.file)) {
            this.file = commandData.file;
        }
        
        if (valueExists(commandData.openDialog) && commandData.openDialog == 'false') {
            this.openDialog = false;
        }        
        if (valueExists(commandData.width)) {
            this.width = parseInt(commandData.width);
        }        
        if (valueExists(commandData.height)) {
            this.height = parseInt(commandData.height);
        }
    },
    
    
    handle: function(context) {
        this.inherit(context);        

        this.normalizeLegacyHelpLinks();
        
		if (this.openDialog && this.file != '' ) {
			var view = this.getTargetView();		
			view.openDialog(this.file, '', false, '', '', this.width, this.height);
		}                   
    },
    
    
    normalizeLegacyHelpLinks: function() {
        //
        // old format:
        // <command type="showHelp" file="/help/system/Content/update_wiz/transfer_out.htm" />
        // <command type="showHelp" file="/help/user/Subsystems/webc/Content/web_user/res/reserve/timeline.htm"/>
        //
        // new format:
        // http://www.archibus.com/ai/abizfiles/v21.1_help/system_management_help/afm-sysman.htm#update_wiz/transfer_out.htm
        // http://www.archibus.com/ai/abizfiles/v21.1_help/archibus_help/archibus.htm#../Subsystems/webc/Content/web_user/res/reserve/timeline.htm
        //
        var oldUserPrefix = ('/help/user');
        var oldSystemPrefix = ('/help/system/Content/');
        var newUserPrefix = View.helpLink.replace('(user.helpExtension)', View.user.helpExtension) + '#..';
        var newSystemPrefix = View.systemAdministrationHelpLink + '#';
        if (this.file.indexOf(oldUserPrefix) === 0) {
            this.file = newUserPrefix + this.file.substring(oldUserPrefix.length);
        } else if (this.file.indexOf(oldSystemPrefix) === 0) {
            this.file = newSystemPrefix + this.file.substring(oldSystemPrefix.length);
        }
    }
});



Ab.command.selectFields = Ab.command.Command.extend({
    // panelId    
    panelId: '',

    // whether the results should be immediately shown in a new dialog
    openDialog: true,
    
    width: null,
        
    height: null, 
       
    

    constructor: function(commandData) {
        this.inherit(commandData);

        if (valueExists(commandData.panelId)) {
            this.panelId = commandData.panelId;			        
        }                
        if (valueExists(commandData.openDialog) && commandData.openDialog == 'false') {
            this.openDialog = false;
        }        
        if (valueExists(commandData.width)) {
            this.width = parseInt(commandData.width);
        }        
        if (valueExists(commandData.height)) {
            this.height = parseInt(commandData.height);
        }
    },
    
    
    handle: function(context) {
        this.inherit(context);        

		if (this.openDialog) {
			var panel = this.getTargetPanel();
			
			var dialog = View.openDialog('ab-select-fields.axvw', '', false, {
				width : 465,
				height : 430,
				isDialog : true,
				closeButton: false,
				panel: panel
			});
		}                   
    }
});



Ab.command.selectValue = Ab.command.Command.extend({
    // @begin_translatable
    z_MESSAGE_SELECT_VALUE_DWG_PARAMS: 'Command must use the fieldNames attribute',
    // @end_translatable

    fieldNames: null,
    selectFieldNames: null,
    visibleFieldNames: null,
    sortFieldNames: null,
    
    dialogTitle: '',
    dialogRestriction: null,
    actionListener: null,
    applyFilter: true, 
    showIndex: true, 
    workflowRuleId: null,
    selectValueType: 'grid',
    recordLimit: null,
    applyVpaRestrictions: true,
	showNullFilters: false,

    autoComplete: true,
    minLength: 1,
    maxResults: 0,
    dataSource: '',
    
    addNewDialog: null,
    showDialog: true,

    
    constructor: function(config) {
        this.inherit(config);

        Ext.apply(this, config);
        
        if (this.autoComplete == "false") {
            this.autoComplete = false;
        }
        if (this.showIndex == "false") {
        	this.showIndex = false;
        }
        if (this.applyFilter == "false") {
        	this.applyFilter = false;
        }
        if (this.applyVpaRestrictions == "false") {
        	this.applyVpaRestrictions = false;
        }
        if (!valueExists(this.visibleFieldNames)) {
        	this.visibleFieldNames = this.selectFieldNames;
        }
        if (this.showNullFilters == "true") {
        	this.showNullFilters = true;
        }
        if (this.showDialog == "false") {
        	this.showDialog = false;
        }
        
        this.dialogRestriction = Ext.util.Format.htmlDecode(config.restriction);
    },
    
    
    handle: function(context) {
    	if (!this.showDialog) {
    		return;
    	}
    	
    	// prepare dialog sort parameter
    	var sortValues = [];
    	if (valueExists(this.sortFieldNames)) {
    		// sort field names are specified - prepare sortValues grid parameter
	    	var sortValuesKeys = this.trimArrayValues(this.sortFieldNames.split(','));
	    	for (var i = 0; i < sortValuesKeys.length; i++) {
	    		sortValues.push({
	    			fieldName: sortValuesKeys[i],
	    			sortOrder: 1
	    		});
	    	}
    	} else if (valueExists(this.sortValues)) {
    		// sortValues are specified as text - evaluate into JS array
    		sortValues = eval(this.sortValues);
    	}
		else {
			// KB 3032695 use visble fields as sort values if none given
			var fieldArray = this.trimArrayValues(this.visibleFieldNames.split(','));
			for (var i = 0; i < fieldArray.length; i++) {
	    		sortValues.push({
	    			fieldName: fieldArray[i],
	    			sortOrder: 1
	    		});
	    	}
		}
    	
    	// if there is no title provided (customized select value command),
    	// create the title from form field titles
    	if (!valueExistsNotEmpty(this.dialogTitle)) {
    		 var targetForm = this.getParentPanel();
    		 if (targetForm != null){
    			 var title = '';
    			 var fieldDefs = targetForm.getDataSource().fieldDefs;
    			 var fieldNamesArray = this.trimArrayValues(this.fieldNames.split(','));
    			 for (var i=0; i < fieldNamesArray.length; i++) {
    				 var fieldName = fieldNamesArray[i];
    				 var fieldDef = fieldDefs.get(fieldName);		
	    			 if (fieldDef != null) {
	    				 if (title != '') {
	    					 title = title + ', ' + fieldDef.title;
	    				 } else {
	    					 title =  fieldDef.title;
	    				 }
	    			 }
    			 }
    			 this.dialogTitle = title;
    		 }
    	}
    
		if (!valueExists(this.selectValueType) || 
				this.selectValueType == 'tree' ||  
				this.selectValueType == 'hierTree' || 
				this.selectValueType == 'grid' ||
				this.selectValueType == 'multiple') {
            View.selectValue(
                this.parentPanelId,
                this.dialogTitle,
                this.trimArrayValues(this.fieldNames.split(',')),
                trim(this.selectFieldNames.split(',')[0].split('.')[0]), // table from the first select field
                this.trimArrayValues(this.selectFieldNames.split(',')),
                this.trimArrayValues(this.visibleFieldNames.split(',')),
                this.dialogRestriction,
                this.actionListener,
                this.applyFilter,
                this.showIndex,
                this.workflowRuleId,
                null,
                null,
                this.selectValueType,
                this.recordLimit,
                toJSON(sortValues),
				this.applyVpaRestrictions,
                this.addNewDialog,
				this.showNullFilters);
		}
		else if (this.selectValueType == 'floorDrawing') {
			if (this.fieldNames == null) {
				View.showMessage('error', Ab.view.View.getLocalizedString(this.z_MESSAGE_SELECT_VALUE_DWG_PARAMS));
				return;
			}
			if (this.selectFieldNames == null) {
				this.selectFieldNames="rm.rm_id";
			}
            View.selectValueFloorDrawing(
                this.parentPanelId,
                this.dialogTitle,
                this.trimArrayValues(this.fieldNames.split(',')),
                trim(this.selectFieldNames.split(',')[0].split('.')[0]), // table from the first select field
                this.trimArrayValues(this.selectFieldNames.split(','))
			);
		}
    }
});








Ab.namespace('view');


Ab.view.Component = Base.extend({

    // component type
    type: '',
    
    // unique control ID, typically the same as the parent element ID
    id: '',
	
	// type-specific presentation format
	format: '',
    
    // parent control ID, null if the panel is top-level
    isTopLevel: true,
    
    // HTML ID attribute of the parent DOM element
    parentElementId: '',
    
    // parent DOM element
    parentElement: null,
    
    // parent Ext element (DOM wrapper)
    parentEl: null,
    
    // restriction as an object containing primary key values
    restriction: null,
    
    // whether to apply the parent View restriction to the data records
    useParentRestriction: true,
    
    // whether to display data record(s) after page is loaded
    showOnLoad: true,
    
    // whether to show the panel if no data records were returned by the data source
    showIfNoData: true,
	
	// if true, the panel is not displayed and is not assigned to any layout region
	hidden: false,
    
    // whether the control is visible
    visible: false,
    
    // Ext.util.MixedCollection of actions for this control
    actions: null,
    
	// Collection of Ab.view.TranslatableDisplayString objects. 
	// Translatable strings (keys) and, after the first WFR call, their translations (values)
	// Initialize in concrete component class (e.g., ab-miniconsole.js)
	translatableDisplayStrings: [],

    // client side constructed datasource object
    datasource: null,
    
    // unique ID of the layout region, used instead of layout + region
    layoutRegion: '',

    // name of the layout object in the view where this control is displayed
    layout: '',
    
    // name of the layout region
    region: '',

    // component height, can be set in pixels (e.g. 200) or as a fraction of the layout region height (e.g. 20%)
    height: '',

    // Ext.util.MixedCollection of custom event listeners for this control
    eventListeners: null,
    
    // onDragDrop event listener; if not null, the panel accepts drop
    onDragDropListener: null,
    onDragOverListener: null,

    // custom Ext.dd.DropTarget object to accept drop over this control
    dropTarget: null,
    
    // panel title
    title: null,
    
    // original configuration object
	config: null,
	
    // panel parameters, can be sent to the WFRs
    parameters: null,
    
    // optional - ID of the data source for this panel
    dataSourceId: '',
	
	// action button position: 'top' or 'footer'
	buttonsPosition: 'top',
	
	// can the user collapse the panel?
	collapsible: false,
	
	// is the panel collapsed? 
	collapsed: false,
	
	// reference to Ext.Window that displays this panel as a dialog
	// set when the panel is displayed the first time
	window: null,

    // x, y, width, height of the Ext.Window that displays this panel as a dialog
    windowBox: null,

    // a floating overlay that displays this panel as a quick panel
    overlay: null,

    // element that invoked the overlay
    overlayAnchorEl: null,
	
	// hash of overridden config properties that should not be evaluated again (for example, when 
	// the application JS code calls appendTitle(), the config.title property is overridden)
	overriddenProperties: null,

    // panel sidecar
    sidecar: null,

    
    constructor: function (id, type, configObject) {
        this.config = configObject;
        
		this.type = type;
        this.id = id;
        this.parentElementId = this.getParentElementId();
        this.parentElement = $(this.parentElementId);
        this.parentEl = Ext.get(this.parentElement);
        this.restriction = {};
        this.parameters = {};
        this.overriddenProperties = {};
        this.sidecar = new Ab.view.Sidecar({
            panelId: id
        });
        
		Ab.view.View.registerControl(this.id, this);

        this.format = configObject.getConfigParameter('format', '');
        this.title = configObject.getConfigParameter('title', null);
        this.layoutRegion = configObject.getConfigParameter('layoutRegion', '');
        this.layout = configObject.getConfigParameter('layout', '');
        this.region = configObject.getConfigParameter('region', '');
        this.height = configObject.getConfigParameter('height', 0);
		this.isTopLevel = configObject.getConfigParameter('isTopLevel', true);
		this.showOnLoad = configObject.getConfigParameter('showOnLoad', true);
        this.showIfNoData = configObject.getConfigParameter('showIfNoData', true);
        this.hidden = configObject.getConfigParameter('hidden', false);
		this.useParentRestriction = configObject.getConfigParameter('useParentRestriction', true);
        this.dataSourceId = configObject.getConfigParameter('dataSourceId', 'dataSource');
        this.buttonsPosition = configObject.getConfigParameter('buttonsPosition', 'top');
        this.collapsible = configObject.getConfigParameterIfExists('collapsible', false);
        this.collapsed = configObject.getConfigParameterIfExists('collapsed', false);

        if (this.useParentRestriction) {
            this.restriction = Ab.view.View.restriction;
        }

		var dataSource = configObject.getConfigParameterIfExists('dataSourceObject');
		if (valueExists(dataSource)) {
		    this.datasource = new Ab.view.DataSource();
			this.datasource.mainTableName = dataSource.mainTable;

			this.datasource.tablesAndRoles.push({'role': 'main', 'tableName': dataSource.mainTable});
			if (dataSource.fieldNames != null) {
				this.datasource.fieldNames = dataSource.fieldNames.split(',');
			}
			if (dataSource.primaryKeyFields != null) {
				this.datasource.primaryKeyFields = dataSource.primaryKeyFields.split(',');
			}
		}
		
		this.actions = new Ext.util.MixedCollection();
        this.eventListeners = new Ext.util.MixedCollection(true); // allow functions to be stored
        
        var headerEl = Ext.get(this.id + '_head');
        if (headerEl !== null) {
            this.toolbar = new Ext.Toolbar({
				autoHeight: true,
				cls: 'panelToolbar',
				renderTo: headerEl
			});

            if (this.collapsible) {
            	this.toolbar.add({
            		id: this.id + '_collapse',
            		cls: 'x-btn-icon',
                    icon: View.contextPath + '/schema/ab-core/graphics/icons/tri-opened.png',
                    listeners: {
                    	'click': this.toggleCollapsed.createDelegate(this)
                    }
                });
            }
            
            var titleBarTextItem =  new Ext.Toolbar.TextItem(this.title || '');
			titleBarTextItem.getEl().id = this.id + '_title';
			this.toolbar.add(titleBarTextItem);
		    this.toolbar.addFill();
			if (this.hidden || !this.showIfNoData) {
				this.toolbar.setVisible(false);
			}
        }
        
        var instructions = configObject.getConfigParameter('instructions', null);
        if (instructions) {
            this.setInstructions(replaceHTMLPlaceholders(instructions));
        }

        this.addEventListenerFromConfig('afterResize', configObject);
        this.addEventListenerFromConfig('afterRefresh', configObject);
        this.addEventListenerFromConfig('beforeRefresh', configObject);
    },

    
    getSidecar: function() {
        return this.sidecar;
    },
    
    
    isDataBound: function() {
        return this.type === 'grid' || this.type === 'form' || this.type === 'tree' || 
               this.type === 'crossTable' || this.type === 'chart' || this.type === 'columnReport';
    },
    
    
    setParentElement: function(element) {
        this.parentElement = element;
        this.parentElementId = element.id;
    },
    
    
    getParentElementId: function() {
        return this.id;
    },
    
    
    getEl: function() {
    	return Ext.get(this.getParentElementId());
    },

    
    getHeaderEl: function() {
        return Ext.get(this.id + '_head');
    },
    
    
    getInstructionsEl: function() {
        return Ext.get(this.id + '_instructions');
    },

    
    getWrapperElementId: function() {
        return this.id + '_layoutWrapper';
    },
	
    
    setLayout: function(layout, region) {
        this.layout = layout;
        this.region = region;
    },
    
    
    hasLayout: function() {
        var layoutAndRegion = View.getLayoutAndRegionById(this.layoutRegion);
        return !this.hidden && (layoutAndRegion !== null || valueExistsNotEmpty(this.region));
    },
    
    
    doLayout: function() {
        this._handleLayoutRegion();

        if (this.hasLayout()) {
            var layoutManager = Ab.view.View.getLayoutManager(this.layout);
            layoutManager.addComponentToRegion(this.region, this.getWrapperElementId(), this);
        }
	},
    
    
    getLayoutRegion: function() {
        this._handleLayoutRegion();
        
    	var region = null;
        var layout = Ab.view.View.getLayoutManager(this.layout);
        if (layout !== null) {
            region = layout.getRegion(this.region);
        }
        return region;
    },

    
    getLayoutRegionPanel: function() {
        this._handleLayoutRegion();
        
        var panel = null;
        var layout = Ab.view.View.getLayoutManager(this.layout);
        if (layout !== null) {
            panel = layout.getRegionPanel(this.region);
        }
        return panel;
    },
    
    
    ownsLayoutRegion: function() {
    	var owns = true;
    	
    	var thisPanel = this;
    	var thisLayoutRegionPanel = this.getLayoutRegionPanel();
    	
    	View.panels.each(function (panel) {
    		if (panel !== thisPanel && !panel.hidden) {
    			var anotherLayoutRegionPanel = panel.getLayoutRegionPanel();
    			if (anotherLayoutRegionPanel === thisLayoutRegionPanel && !panel.hidden && panel.type !== 'viewPanel') {
    				owns = false;
    			}
    		}
    	});
    	
    	return owns;
    },

    
    lastInLayoutRegion: function() {
    	var thisLayoutRegionPanel = this.getLayoutRegionPanel();
        if (!thisLayoutRegionPanel) {
            return false;
        }

    	var lastPanelInRegion = null;
    	
    	View.panels.each(function (panel) {
			var anotherLayoutRegionPanel = panel.getLayoutRegionPanel();
			if (anotherLayoutRegionPanel === thisLayoutRegionPanel && !panel.hidden) {
				lastPanelInRegion = panel;
			}
    	});
    	
    	return (this === lastPanelInRegion);
    },

    
    lastInTab: function() {
        var lastPanelInTab = null;
        var thisPanelTab = this.parentTab;

        if (valueExists(thisPanelTab)) {
            View.panels.each(function (panel) {
                if (panel.parentTab === thisPanelTab && !panel.hidden) {
                    lastPanelInTab = panel;
                }
            });
        }

        return (this === lastPanelInTab);
    },

        
    singleVisibleTabPanel: function(){
        var thisPanelTab = this.parentTab;
        var numberOfVisiblePanels = 0;
        var singleVisibleTabPanel = null;

        if (valueExists(thisPanelTab)) {
            View.panels.each(function (panel) {

                if (panel.parentTab === thisPanelTab) {              
                    numberOfVisiblePanels += 1;
                                       
                    if(numberOfVisiblePanels > 1){
                    	singleVisibleTabPanel = null;
                    } else {
                    	singleVisibleTabPanel = panel;
                    }
    			}
            });
        }
        
        return singleVisibleTabPanel;
    },

        
    singleVisiblePanel: function(){
    	var numberOfVisiblePanels = 0;
    	var singleVisiblePanel = null;
    	View.panels.each(function (panel) {
    		if (!panel.hidden && panel.id !== 'viewToolbar' && panel.type !== 'viewPanel') {
    			numberOfVisiblePanels += 1;
    			
    			if (numberOfVisiblePanels > 1) {
    				singleVisiblePanel = null;
    			} else {
    				singleVisiblePanel = panel;
    			}
    		}
    	});
    	return singleVisiblePanel;
    },

        
    _handleLayoutRegion: function() {
        if (valueExistsNotEmpty(this.layoutRegion)) {
            var result = Ab.view.View.getLayoutAndRegionById(this.layoutRegion);
            if (result) {
                this.layout = result.layout;
                this.region = result.region;
            }
        }
    },

    
    resizeListenerAttached: false,

    
    afterLayout: function() {
		var regionPanel = this.getLayoutRegionPanel();
        if (this.window) {
            // attach event listeners that update the panel size when the window is re-sized
            if (!this.resizeListenerAttached) {
                this.resizeListenerAttached = true;
                this.window.addListener('resize', this.afterResize, this);
                this.window.addListener('maximize', this.afterResize, this);
                this.window.addListener('restore', this.afterResize, this);
            }

            // set the initial panel size to match the window size
            this.afterResize();

        } else if (regionPanel) {
            // attach event listeners that update the panel size when the layout region is re-sized
            if (!this.resizeListenerAttached) {
                this.resizeListenerAttached = true;
				regionPanel.addListener('resize', this.afterResize, this);
                regionPanel.addListener('expand', this.afterResize, this);
            }

            // set the initial panel size to match the layout region size
            this.afterResize();
        }
	},

    
    afterResize: function() {
        // call user-defined callback function
        var afterResizeListener = this.getEventListener('afterResize');
        if (afterResizeListener) {
            afterResizeListener(this);
        }
        this.updateHeight();
    },

    
    initialDataFetch: function() {
        this.show(this.showOnLoad);
    },
    
    
    afterInitialDataFetch: function() {
        this.addShowInfo();
    },
    
    
    clear: function() {},
    
    
    refresh: function(restriction, newRecord) {
        this.beforeRefresh(restriction, newRecord);
        this.doRefresh();
        this.afterRefresh();
    },

    
    beforeRefresh: function(restriction, newRecord) {
        var message = String.format('Before refresh: {0} = [{1}], restriction = [{2}], newRecord = [{3}]',
            this.type, this.id, restriction ? toJSON(restriction) : 'none', newRecord);
        View.log(message);

        if (valueExists(restriction) && restriction !== '') {
            this.restriction = restriction;
        }
        if (valueExists(newRecord)) {
            this.newRecord = newRecord;
        }

        this.clearScroller();

        var beforeRefreshListener = this.getEventListener('beforeRefresh');
        if (beforeRefreshListener) {
            beforeRefreshListener(this);
        }
    },

    
    doRefresh: function() {
        this.getData();
        this.show();
        this.removeErrorIndicator();
    },

    
    afterRefresh: function() {
        this.evaluateExpressions();

        var listener = this.getEventListener('afterRefresh');
        if (listener) {
            listener(this);
        }

        var message = String.format('After refresh: {0} = [{1}]', this.type, this.id);
        View.log(message);
    },

    
    getData: function() {
    },

    
    getDataSource: function() {
        return View.dataSources.get(this.dataSourceId);
    },
    
    
    addParameter: function(name, value) {
        this.parameters[name] = value;   
    },

    
    addParameters: function(parameters) {
        _.extend(this.parameters, parameters);
    },

    
    clearParameters: function() {
        this.parameters = {};
    },
    
    
    setPropertyOverridden: function(propertyName, overrideValue) {
    	if (!valueExists(overrideValue)) {
    		overrideValue = true;
    	}
    	this.overriddenProperties[propertyName] = overrideValue;
    },
    
    
    isPropertyOverridden: function(propertyName) {
    	var overrideValue = this.overriddenProperties[propertyName];
    	return (valueExists(overrideValue) && overrideValue == true);
    },
    
    
    evaluateExpressions: function(ctx) {
        if (!valueExists(ctx)) {
            ctx = this.createEvaluationContext();
        }
        
        // evaluate control title
        if (!this.isPropertyOverridden('title')) {
	        var evaluatedTitle = Ab.view.View.evaluateString(this.config.title, ctx);
	        if (valueExists(evaluatedTitle) && evaluatedTitle !== this.title) {
	            this.setTitle(evaluatedTitle);
	        }
        }

        // evaluate panel action properties
		this.actions.each(function(action) {
            action.evaluateExpressions(ctx);
        });

		// evaluate data source field titles
		var ds = this.getDataSource();
		if (ds) {
			ds.fieldDefs.each(function (fieldDef) {
		        var evaluatedTitle = View.evaluateString(fieldDef.title, ctx, false);
				if (evaluatedTitle != fieldDef.title) {
					fieldDef.title = evaluatedTitle;
				}
			});
		}

		return ctx;
    },
    
    
    createEvaluationContext: function() {
		var ctx = {
            view: Ab.view.View,
			date: this.createDateContext(),
            panel: this
        };
		
		for (name in Ab.view.View.evaluationContext) {
			ctx[name] = Ab.view.View.evaluationContext[name];
		}

        return ctx;
    },


    
	createDateContext: function(dateFormat, timeFormat) {
		var now = new Date();
		if (typeof dateFormat == 'undefined' || dateFormat == '') {
			dateFormat = View.dateFormat;
		}
		if (typeof timeFormat == 'undefined' || timeFormat == '') {
			timeFormat = View.timeFormat;
		}

		var returnObj = new Object();
		returnObj.currentDate = now.format(dateFormat);
		returnObj.currentTime = now.format(timeFormat);
		returnObj.date = now;
		return returnObj;
	},
    
    
    show: function(show, includeHeader) {
        if (!valueExists(show)) {
            show = true;
        }
        
        if (!valueExists(includeHeader)) {
            includeHeader = true;
        }

        this.updateVisible(show, includeHeader);
        this.updateHeight();
	},

    
    updateVisible: function(show, includeHeader) {
        // set new visible status
        this.visible = show;

        // show|hide the panel header
        if (includeHeader) {
            this.showHeader(show);
        }

        // show|hide the panel instructions
        if (this.getInstructionsEl()) {
            this.showElement(this.getInstructionsEl(), show);
        }

        // show|hide the panel body
        this.showElement(this.parentElement, show);

        // enable|disable action buttons based on enabled attribute to allow data binding
        var ctx = this.createEvaluationContext();
        this.actions.each(function(action) {
            var enabled = Ab.view.View.evaluateBoolean(action.enabled, ctx);
            //TODO: check forceDisable() is necessary here since after it, applications cannot call panel.enableButton('name', true) to enable the disabled button.
            action.forceDisable(!show || !enabled);
        });
    },
    
    showHeader: function(show) {
        var headerEl = Ext.get(this.id + '_head');
        if (headerEl !== null) {
			headerEl.setDisplayed(show);
		}
        if (this.toolbar) {
            this.toolbar.setVisible(show);
        }
    },
    
    
    showActions: function(visible) {
        this.actions.each(function(action) {
            action.render(visible);
        });
    },
    
    
    appendTitle: function(message) {
        this.setTitle(this.config.title + ' - ' + message);
        this.setPropertyOverridden('title');
    },
    
    
    setTitle: function(title) {
        this.title = title;
        
        var panelTitleTD = this.getTitleEl();
        if (panelTitleTD) {
            panelTitleTD.dom.innerHTML = title;
        }
    },
    
    
    getTitle: function() {
        return this.title;
    },
	
	
	getTitleEl: function() {
		return Ext.get(this.id + '_title');
	},

    
    setInstructions: function(message) {
		var instructionsEl = Ext.get(this.id + '_instructions');
		if (valueExistsNotEmpty(message)) {
			// display instructions
			
		    if (!instructionsEl) {
			    // create instructions element
				instructionsEl = Ext.DomHelper.insertBefore(this.parentEl, {
					tag: 'div', 
					id: this.id + '_instructions', 
					cls: 'instructions'
			    }, true);
                // create nested instructions text element
                Ext.DomHelper.append(instructionsEl, {
                    tag: 'div',
                    id: this.id + '_instructionsText',
                    cls: 'instructionsText'
                });
                // add collapse/expand listener to the whole instructions area
                instructionsEl.on('click', this.toggleInstructions.createDelegate(this));

                this.showElement(instructionsEl, this.visible);
			}
			
		    var instructionsTextEl = Ext.get(this.id + '_instructionsText');
			instructionsTextEl.dom.innerHTML = message;
		} else {
			// clear instructions
			if (instructionsEl) {
	            var instructionsTextEl = Ext.get(this.id + '_instructionsText');
				instructionsTextEl.dom.innerHTML = '';
			}
		}
	},
	
	
	toggleInstructions: function() {
        var instructionsTextEl = Ext.get(this.id + '_instructionsText');
        
	    if (valueExists(this.instructionsCollapsed) && this.instructionsCollapsed) {
            this.instructionsCollapsed = false;
	    } else {
	        this.instructionsCollapsed = true;
	    }

        if (this.instructionsCollapsed) {
            this.instructionsTextHeight = instructionsTextEl.getHeight();
        }

        instructionsTextEl.setVisible(!this.instructionsCollapsed);
        instructionsTextEl.setHeight(this.instructionsCollapsed ? 0 : this.instructionsTextHeight);

        if (this.isShownInWindow()) {
            this.updateWindowHeight();
        }
	},

    
    getInstructionsHeight: function() {
        var height = 0;

        var instructionsEl = Ext.get(this.id + '_instructions');
        if (instructionsEl) {
            height = instructionsEl.getHeight();
        }

        return height;
    },

    
    updateCollapsed: function() {
        if (this.collapsible) {
            this.setCollapsed(this.collapsed);
        }
    },

	
	toggleCollapsed: function() {
		this.setCollapsed(!this.collapsed);
	},
	
	
    setCollapsed: function(collapsed) {
        if (Ext.get(this.id).hasClass('panel-behind')) {
            this.showElement(this.getWrapperElementId(), !collapsed);
        }

        this.updateVisible(!collapsed, false);

		var icon = View.contextPath + '/schema/ab-core/graphics/icons/tri-opened.png';
		if (collapsed) {
			icon = View.contextPath + '/schema/ab-core/graphics/icons/tri-closed.png';
		}
		
        if (this.toolbar) {
            if (collapsed) {
                this.toolbar.el.addClass('collapsed');
            } else {
                this.toolbar.el.removeClass('collapsed');
            }

            var buttonParentEl = Ext.get(this.id + '_collapse');
            var buttonEl = buttonParentEl.child('button', true);
            buttonEl.style.backgroundImage = 'url(' + icon + ')';
        }

        this.collapsed = collapsed;
	},

    toggleHidden: function() {
        this.setHidden(!this.hidden);
    },

    setHidden: function(hidden) {
        this.showElement(this.getWrapperElementId(), !hidden);
        this.hidden = hidden;
    },

	
	getLocalizedString: function(key3) {
		return Ab.view.View.getLocalizedString(key3);
	},

    
    showElement: function(element, show) {
        if (element != null) {
            var el = Ext.get(element);
            if (el != null) {
                el.setDisplayed(show);
            }
        }
    },   

    
    syncHeight: function(el) {
    	if (valueExists(el)) {
	    	var height = this.determineHeight(el);
	        if (height > 0) {
	            el.setHeight(height - 2);
	        }
    	}
    },

    
    isScrollInLayout: function() {
        return !this.isAutoScroll();
    },

    
    isAutoScroll: function() {
        return false;
    },

    
    getScrollableEl: function() {
        return this.getEl();
    },

    
    updateHeight: function() {
        // determine the height available to show the scrollable element
        var availableHeight = this.determineAvailableHeight();

        // if the available height can be determined, set the element height and enable scrolling
        var scrollableEl = this.getScrollableEl();
        if (availableHeight > 0 && scrollableEl != null) {
            scrollableEl.setHeight(availableHeight);

            // update component's scroller
            if (this.isAutoScroll() && !this.isScrollInLayout()) {
                this.updateScroller();
            } else {
                this.updateLayoutScroller();
            }
        }

        // update the collapsed/expanded state of the panel
        this.updateCollapsed();
    },

    
    updateLayoutScroller: function() {
        if (this.isScrollInLayout() && this.hasLayout()) {
            var layout = Ab.view.View.getLayoutManager(this.layout);
            if (layout !== null && layout.isScrollContent(this.getLayoutRegion())) {
                layout.updateScroller(this.getLayoutRegionPanel());
            }
        }
    },

    
    updateScroller: function() {
        var scrollableEl = this.getScrollableEl();
        if (!View.preferences.useScroller ||
            !scrollableEl ||
            !scrollableEl.dom ||
            !scrollableEl.dom.firstChild ||
            scrollableEl.dom.firstChild.nodeType == 3) {
            // do not use custom scroller
            if (scrollableEl) {
                scrollableEl.addClass('scroll-v');
            }
            return
        }

        if (!this.scroller) {
            this.createScroller(scrollableEl);
        } else {
            this.scroller.update();
        }
    },

    
    createScroller: function(scrollableEl) {
        scrollableEl.dom.style.overflow = 'hidden';
        this.scroller = new Ab.view.Scroller(scrollableEl.dom.firstChild);
    },

    
    clearScroller: function() {
        var scrollableEl = this.getScrollableEl();
        if (View.preferences.useScroller && scrollableEl && scrollableEl.dom) {
            scrollableEl.removeClass('jssb-applied');
        }

        if (this.scroller) {
            this.scroller.detach();
            this.scroller = null;
        }
    },

    
    determineAvailableHeight: function() {
        var height = 0;

        // adjustment is required for Chrome
        var chromeAdjustment = Ext.isIE || Ext.isGecko ? 0 : 8;

        if (this.window) {
            height = this.window.body.getHeight() - this.getTitlebarHeight();
        } else if (this.ownsLayoutRegion()) {
            height = this.determineHeight();
        } else if (this.lastInLayoutRegion()) {
            height = this.determineRemainingHeight();
        } else if (this.lastInTab()) {
            height = this.determineRemainingHeight() - chromeAdjustment;
        } else if (this.singleVisibleTabPanel()) {
            height = this.determineRemainingHeight() - chromeAdjustment;
        } else if (this.singleVisiblePanel()){
        	height = this.determineRemainingHeight();
        }

        return height;
    },

    
    determineHeight: function(el) {
    	var height = 0;
        var id = this.getParentElementId();
        
        if (!valueExists(el)) {
            el = this.parentEl;
        }
        
        // get parent region panel height
        var parentRegion = this.getLayoutRegion();
        if (valueExists(parentRegion)) {
            var parentRegionHeight = Ext.get(parentRegion.contentEl).parent().getHeight();
            
            // adjust for title bar height
            var titleBarHeight = this.getTitlebarHeight();
            height = parentRegionHeight - titleBarHeight - 4;

        } else if (valueExists(el) && this.parentTab != null) {
        	if (valueExists(this.parentTab.parentPanel.tabHeight)) {
                height = this.parentTab.parentPanel.tabHeight - this.parentTab.parentPanel.getTabStripHeight();
        	} else {
        		height = this.parentTab.tabPanel.getInnerHeight();
            }
        }
        
        return height;
    },
    
    
    determineWidth: function() {
    	var width = 0;
        
        // get parent region panel width
        var parentRegion = this.getLayoutRegion();
        if (valueExists(parentRegion)) {
            width = Ext.get(parentRegion.contentEl).parent().getWidth() - 2;
        } else if (this.parentTab != null) {
            if (valueExists(this.parentTab.parentPanel.tabHeight)) {
                width = this.parentTab.parentPanel.tabWidth;
            } else {
                width = this.parentTab.tabPanel.getInnerWidth();
            }
        }
        
        return width;
    },
        
    
    determineRemainingHeight: function(el) {
        var remainingHeight = 0;

        if (!valueExists(el)) {
            el = this.parentEl;
        }

        if (valueExists(el)) {
            var totalHeight = this.determineHeight(el);
            remainingHeight = totalHeight - el.dom.offsetTop + this.getTitlebarHeight();
        }

    	return remainingHeight;
    },

    
    getTitlebarHeight: function() {
        var titleBarHeight = 0;
        var titleBarEl = Ext.get(this.getParentElementId() + '_head');
        if (titleBarEl) {
            titleBarHeight = titleBarEl.getHeight();
        }

        return titleBarHeight;
    },

    
    getActionbarHeight: function() {
        var height = 0;

        if (this.actionbar) {
            height = this.actionbar.toolbar.getSize().height;
        }

        return height;
    },

    
    addEventListener: function(eventName, listener, scope) {
        if (listener && listener.constructor == Array) {
            // create command chain from an array of command configuration objects
            var command = new Ab.command.commandChain();
            command.addCommands(listener);
            listener = command;
            
        } else {
            // if listener is a name, get global (window object) function
            if (listener && listener.constructor == String) {
                listener = window[listener];
            }
            // if scope is specified, the listener is a function that must be called in scope
            if (valueExists(scope)) {
                listener = listener.createDelegate(scope);
            }
        }
        
        if (this.eventListeners.containsKey(eventName)) {
            this.eventListeners.replace(eventName, listener);
        } else {
            this.eventListeners.add(eventName, listener);
        }
    },

    
    addEventListenerFromConfig: function(eventName, config) {
        var listener = config.getConfigParameter(eventName + 'Listener', null);
        this.addEventListener(eventName, listener);
    },
    
    
    getEventListener: function(eventName) {
        var listener = this.eventListeners.get(eventName);
        if (!valueExists(listener)) {
            listener = null;
        }
        return listener;
    },
    
    
    removeEventListener: function(eventName) {
        this.eventListeners.removeKey(eventName);  
    },
    
    
    addActionListener: function(actionId, callback, scope) {
        this.actions.get(actionId).addListener(callback, scope);
    },
    
    
    addActionbarActionListener: function(actionId, callback, scope) {
        this.actionbar.actions.get(actionId).addListener(callback, scope);
    },
        
    
    addAction: function(config) {
        config.topLevel = true;
        var action = new Ab.view.Action(this, config);
        this.actions.add(action.id, action);
    },
    
    
    removeAction: function(id) {
    	this.actions.remove(id);
    },
    
    
    addCustomAction: function(config) {
        config.useExtButton = false;
        var action = new Ab.view.Action(this, config);
        this.actions.add(action.id, action);
    },
    
    
    enableAction: function(actionId, enabled) {
        var action = this.actions.get(actionId);
        if (action) {
            action.enable(enabled);
        }
    },

    
    enableButton: function(button, enabled) {
        this.enableAction(button, enabled);
    },
    
    
    addDragDropListener: function(callback, scope) {
        if (valueExists(scope)) {
            callback = callback.createDelegate(scope);
        }
        this.onDragDropListener = callback;
        this.enableDropTarget();
    },

    
    addDragOverListener: function(callback, scope) {
        if (valueExists(scope)) {
            callback = callback.createDelegate(scope);
        }
        this.onDragOverListener = callback;
        this.enableDropTarget();
    },
    
    
    enableDropTarget: function() {
        // set the whole panel layout region as a drop target area
        if (this.dropTarget == null) {
            this.dropTarget = new Ab.view.DropTarget(this);
        }
    },
    
    
    enable: function() {
        var panel = this.getLayoutRegionPanel();
        if (panel) {
            panel.enable();
        }
    },
    
    
    disable: function() {
        var panel = this.getLayoutRegionPanel();
        if (panel) {
            panel.disable();
        }
    },
	
	
    showInWindow: function(config) {
        // the view may open multiple windows at the same time
        // View.closePanelWindows();

        if (config.anchor) {
            this.anchorEl = Ext.get(config.anchor);
        }
        if (!valueExists(config.closeButton)) {
            config.closeButton = false;
        }
        if (!valueExists(config.collapsible)) {
            config.collapsible = true;
        }
        if (!valueExists(config.maximizable)) {
            config.maximizable = true;
        }
        if (!valueExists(config.modal)) {
            config.modal = false;
        }
        if (!valueExists(config.closable)) {
            config.closable = true;
        }
        if (!valueExists(config.autoScroll)) {
            config.autoScroll = true;
        }
        if (!valueExists(config.shadow)) {
            config.shadow = true;
        }
        if (!valueExists(config.height)) {
            config.height = 400;
        }

        // create the window if it has not been created yet
        if (!this.window) {
            var buttons = [];
            if (this.actions.getCount() > 0 || config.closeButton) {
                // the Close button is only needed to create the dialog footer; it's hidden and unused
                buttons.push({
                    id: 'closeButton',
                    text: this.getLocalizedString(Ab.view.View.z_TITLE_CLOSE),
                    handler: this.closeWindow.createDelegate(this),
                    hidden: !config.closeButton,
                    hideMode: 'display'
                });
            }
            this.window = new Ext.Window({
                contentEl: this.getWrapperElementId(),
                layout: 'fit',
                modal:  config.modal,
                shadow: config.shadow,
                autoScroll: config.autoScroll,
                closable: config.closable,
                maximizable:config.maximizable,
                collapsible:config.collapsible,
                closeAction: 'hide',
                buttonAlign: 'right',
                buttons: buttons
            });
        }

        this.window.setTitle(config.title);

        // show the window outside of the visible area to make sure the panel can be rendered into DOM
        if (config.width && config.height) {
            this.window.setSize(config.width, config.height);
        }
        this.window.setPosition(10000, 10000);
        this.window.show();

        // refresh the panel
        if (config.restriction) {
            this.refresh(config.restriction, config.newRecord);
        }

        // display the panel to make sure DOM elements have height
        this.show(true, true);

        // determine the window position based on the anchor element
        var box = config;
        box.autoHeight = !valueExists(box.height);
        if (this.getAnchorEl()) {
            if (!box.x) {
                box.x = this.getAnchorEl().getLeft();
            }
            if (!box.y) {
                if (this.getAnchorEl() == this.anchorEl) {
                    box.y = this.anchorEl.getTop();
                } else {
                    box.y = this.anchorEl.getTop() + this.anchorEl.getHeight() + 1;
                }
            }
        }
        this.windowBox = box;
        this.updateWindowHeight();

        if (valueExists(config.maximize) && config.maximize) {
            this.window.maximize();
        }

        this.resizeListenerAttached = false;
        this.showActions();
        this.afterLayout();
	},

    
    updateWindowHeight: function() {
        if (this.windowBox) {
            if (this.windowBox.autoHeight) {
                this.windowBox.height = 100;
                var panelEls = [this.getHeaderEl(), this.getInstructionsEl(), this.getEl()];
                for (var i = 0; i < panelEls.length; i++) {
                    if (panelEls[i]) {
                        this.windowBox.height += panelEls[i].getHeight();
                    }
                }
            }
            View.ensureInViewport(this.windowBox);
            this.window.setPosition(this.windowBox.x, this.windowBox.y);
            this.window.setSize(this.windowBox.width, this.windowBox.height);
        }
    },

    isShownInWindow: function() {
		return this.window != null;
	},
	
	closeWindow: function() {
		if (this.window) {
			this.window.hide();
		}
	},
    
    
    getAnchorEl: function() {
        return (this.anchorEl && this.anchorEl.parent().hasClass('button')) ?
            this.anchorEl.parent() :
            this.anchorEl;
    },

    
    addShowInfo: function() {
        var actionId = this.id + '_showRestriction';
        if (View.isDevelopmentMode && this.isDataBound() && this.actions.get(actionId) == null && valueExists(this.toolbar)) {
            this.addAction({
                id: actionId,
                icon: '/schema/ab-core/graphics/icons/information.png',
                tooltip: 'Show this panel debugging information',
                listener: this.showInfo.createDelegate(this)
            });
        }
    },
    
    showInfo: function() {
        var message = this.getInfo();
        Ext.MessageBox.alert('Panel Information', message);
    },
    
    getInfo: function() {
        var message = '<pre>ID: ' + this.id + '<br/>';
        message = message + 'Type: ' + this.type + '<br/>';
        message = message + 'Restriction: ';
        if (valueExists(this.restriction)) {
            message = message + prettyPrintJson(this.restriction);
        } else {
            message = message + 'none';
        }
        message = message + '</pre>';
        return message;
    },
    
    
    lastErrorMessage: '',
    
    
    showLastError: function() {
    	View.showMessage('error', this.lastErrorMessage);
    },
    
    
    addErrorIndicator: function(errorMessage) {
    	this.lastErrorMessage = errorMessage;
    	
    	var id = this.id + '_showError';
    	var action = this.actions.get(id);
    	if (action) {
    		action.show(true);
    	} else {
	        this.addAction({
	            id: id,
	            icon: '/schema/ab-core/graphics/error.gif', 
	            cls: 'x-btn-icon', 
	            tooltip: this.getLocalizedString(Ab.view.Component.z_MESSAGE_SHOW_ERROR_TOOLTIP),
				listener: this.showLastError.createDelegate(this)
	        });
    }        
    },
    
    
    removeErrorIndicator: function() {
    	var id = this.id + '_showError';
    	var action = this.actions.get(id);
    	if (action) {
    		action.show(false);
    	}
    },

    
    handleError: function(e) {
    	// convert job status into error
    	if (valueExists(e.jobMessage)) {
    		e = {
    			message: e.jobMessage
    		};
    	}
    	
		if (View.showLoadProgress) {
			// if the view displays the progress indicator, add error to the panel and continue
		    this.addErrorIndicator(e.message);
		} else {
			// otherwise, display the error dialog
			Workflow.handleError(e);
		}
    }
}, {
	// @begin_translatable
    z_MESSAGE_SHOW_ERROR_TOOLTIP: 'Error occured, click to display details'
	// @end_translatable
});



Ab.view.DropTarget = function(panel) {
    this.panel = panel;
    Ab.view.DropTarget.superclass.constructor.call(this, panel.getLayoutRegionPanel().getEl());
};

Ext.extend(Ab.view.DropTarget, Ext.dd.DropTarget, {
    notifyDrop: function(dd, e, data) {
        if (this.panel.onDragDropListener) {
            return this.panel.onDragDropListener(dd, data, e);
		}
    },
    notifyOver: function(dd, e, data) {
        if (this.panel.onDragOverListener) {
            return (this.panel.onDragOverListener(dd, data, e) ? 'x-dd-drop-ok' : 'x-dd-drop-nodrop');
        }
    }
});



Ab.view.HtmlPanel = Ab.view.Component.extend({
    
    // reference to Ext.Panel that manages the content - optional
    contentPanel: null,
    
    
	constructor: function(id, configObject) {
        this.inherit(id, 'htmlPanel', configObject);
	},
	
	
	setContentPanel: function(panel) {
	    this.contentPanel = panel;
	    this.afterLayout();
	},
	
	
    afterLayout: function() {
        if (this.contentPanel) {
            this.syncHeight(this.contentPanel);
        }
    }
});



Ab.view.ViewPanel = Ab.view.Component.extend({
	
    // included view filename
    fileName: null,
    url: null,
    
    // whether to use iframe to display the included view
    useFrame: false,
    
	// main panel ID in the included view, if frame is not used
	childPanelId: null,
    
    // true when the child view is being loaded
    isContentLoading: false,
    
    // Ext.Panel for this panel
    panel: null,
    
    // Ext.ux.ManagedIFrame for this panel
    frame: null,
	
	// Ab.view.View instance for content view
	contentView: null,
    
    
	constructor: function(id, configObject) {
        this.inherit(id, 'viewPanel', configObject);
        
        this.fileName = configObject.getConfigParameter('fileName', null);
        this.url = configObject.getConfigParameter('url', null);
        this.useFrame = configObject.getConfigParameter('useFrame', false);
        this.childPanelId = configObject.getConfigParameter('childPanelId', null);
	},

    
    isScrollInLayout: function() {
        return false;
    },

    
    getParentElementId: function() {
        return this.id + '_iframe';
    },
	
    
    createFrame: function() {
        // create managed iframe
        this.frame = new Ext.ux.ManagedIFrame({
            autoCreate: {
                id: this.getParentElementId(),
                width:'100%', height:'100%'
            }
        });
        this.frame.setStyle('border', 'none');
		
        // load view content into iframe
        this.loadView(this.fileName);

        // create Ext.Panel with the iframe as content
        this.panel = new Ext.Panel({
            renderTo: this.getWrapperElementId(),
            contentEl: this.frame,
            autoWidth: true,
            autoHeight: true,
            border: true,
            closable: true
        });

        this.syncHeight.defer(100, this);

        // standard layout handling
        this.doLayout();
        
        // add listener to sync iframe height when the layout region is resized
        var regionPanel = this.getLayoutRegionPanel();
        regionPanel.on('bodyresize', this.syncHeight.createDelegate(this));
    },
    
    
    getContentFrame: function() {
        var iframe = null;
        if (this.useFrame) {
            iframe = this.frame.getWindow();
        }
        return iframe;        
    },
	
	
	getMainPanel: function() {
		return View.panels.get(this.childPanelId);
	},
    
    
    doLayout: function() {
        this.inherit();
        
        if (this.useFrame) {
	        var region = this.getLayoutRegion();
	        region.border = false;
        }
    },
    
    
    syncHeight: function() {
        if (this.useFrame && this.frame) {
            var parentRegion = this.getLayoutRegion();
            var parentHeight = Ext.get(parentRegion.contentEl).parent().getHeight();
            var parentWidth = Ext.get(parentRegion.contentEl).parent().getWidth();
            
            this.frame.setHeight(parentHeight - 2); // adjust for region border
            this.frame.setWidth(parentWidth - 2);
        }
    },
    
    
    initialDataFetch: function() {
    	if (this.useFrame) {
    		this.createFrame();
			if (this.url) {
				this.loadView(this.url);			
			}
    	} else {
            if (View.type === 'dashboard') {
                this.addShowAsDialog(this.getMainPanel(), this.fileName);
            }
    	}
    },

    	
	loadView: function(fileName, restriction, highlightNavigatorTask) {
		if (!valueExistsNotEmpty(fileName)) {
			return;
		}
        
        View.log('Request to load view: ' + fileName);
		this.fileName = fileName;
		
		View.clearDialogParameters();
		if (valueExists(restriction)) {
			View.dialogRestriction = restriction;
		}
		
        this.isContentLoading = true;
		this.contentView = null;
        
        // load new content
        var panel = this;
        this.frame.setSrc(fileName, true);

        // highlight the task in the Process Navigator
        if (valueExists(highlightNavigatorTask) && highlightNavigatorTask) {
            var navigatorControl = top.View.panels.get('processNavigator');
            if (valueExists(navigatorControl)) {
                navigatorControl.controller.highlightTask(fileName);
            }
        }
	},
	
	
	reloadView: function() {
		this.loadView(this.fileName);
	},
	
    	
	afterViewLoad: function(childView) {
        this.isContentLoading = false;
        this.enable();

        this.contentView = childView;
        this.contentView.parentViewPanel = this;

        if (View.type === 'dashboard') {
            var self = this;
            var afterDashboardLoad = function() {
                var mainPanel = self.contentView.getMainPanel();

                // views included into dashboard should not have Print button
                self.contentView.setToolbarButtonVisible('printButton', false);
                // add the Maximize button
                self.addShowAsDialog(mainPanel, self.fileName);

                // make panel titles smaller to match ab-view-dashboard.css
                var panelTitleEl = mainPanel.getTitleEl();
                if (panelTitleEl) {
                    panelTitleEl.dom.style.fontSize = '13px';
                }
            };
            afterDashboardLoad();
        }

        var afterLoadListener = this.getEventListener('afterLoad');
        if (afterLoadListener) {
            afterLoadListener();
        }
	},
	
	
	addShowAsDialog: function(childPanel, viewName) {
        if (childPanel != null && valueExists(childPanel.toolbar)) {
            childPanel.addAction({
                id: childPanel.id + '_showAsDialog',
                icon: '/schema/ab-core/graphics/show.gif', 
                cls: 'x-btn-icon', 
                tooltip: this.getLocalizedString(Ab.view.ViewPanel.z_MESSAGE_MAXIMIZE_VIEW),
				listener: function() {
					View.openDialog(viewName, childPanel.restriction, false, {maximize: true});
				}
            });
        }
	} 
}, {
	// @begin_translatable
    z_MESSAGE_MAXIMIZE_VIEW: 'Maximize this view',
    z_MESSAGE_LOADING: 'Loading'
	// @end_translatable
});



Ab.view.TranslatableDisplayString = Base.extend({
	// key to 'hashMap' entry - the English version of the string
	stringKey: '',
	
	// key in 'hashMap' entry - the localized version of the string
	stringValue: '',

	
	constructor: function(key, val) {
		this.stringKey = key;
		this.stringValue = val;
	}
});



Ab.view.ConfigObject = Base.extend({

	
	constructor: function(values) {
        if (valueExists(values)) {
            for (var name in values) {
                var value = values[name];
                this.setConfigParameter(name, value);
            }
        }
    },
		
    
	setConfigParameter: function(key, value) {
		var oldValue = this.getConfigParameterIfExists(key);
		this[key] = value;
		return oldValue;
	},

    
    addParameterIfNotExists: function(key, value) {
        if (!valueExists(this[key])) {
            this[key] = value;
        }
    },

    
    getConfigParameterIfExists: function(key) {
        var value = this[key];
        if (!valueExists(value)) {
            value = null;
        }
        return value;
    },

    
	getConfigParameter: function(key, defaultValue) {
        var value = this.getConfigParameterIfExists(key);
		if (!valueExists(value)) {
	        value = defaultValue;
		}
		return value;
	},
    
    
    getConfigParameterNotEmpty: function(key, defaultValue) {
        var value = this.getConfigParameterIfExists(key);
        if (!valueExistsNotEmpty(value)) {
            value = defaultValue;
        }
        return value;
    },
    
    getFunction: function(key) {
        var functionName = this.getConfigParameter(key);
        return self[functionName];
    },

    
    toJSONString: function() {
    	
    	// create a map for non-function parameters
    	var mapParams = {};
    	
		// loop through all parameters except for functions and constructors
    	for (var name in this){
			// only add to JSON string if the value exists
    		if(this.getConfigParameterIfExists(name) != null){
    			// bypass the functions and constructors
    			if(!(this[name] instanceof Function))
	    			mapParams[name] = this[name];
   			}
    	}
    	
    	return toJSON(mapParams);
    }

});



Ab.view.Action = Base.extend({
    // parent panel
    panel: null,
    
    // action ID - same as button DOM element ID
    id: '',
    
    // original action/field/column ID as defined in AXVW
    originalId: '',
    
    // Ext.util.MixedCollection of actions for this control
    actions: null,

    // reference to the parent menu Action, if this action is a child menu item
    menuAction: null,

    // the Ext.menu.Menu object if this action is a menu
    menu: null,
    
    // is the action button enabled based on its own property value?
    enabled: true,
    
    // is the action button forced to be temporarily disabled because all panel buttons are?
    forcedDisabled: false,
    
    // is the action button hidden or visible?
    hidden: false,

    // command to execute when the user clicks on the button
    command: null,

    // event listener that calls the command
    listener: null,
    
    // button Ext.Element
    button: null,
    
    // true if the button has been rendered into Ext panel
    buttonRendered: false,
    
    // initial config object
    config: null,

    // action listener that was added when the button element has not been created yet
    pendingListener: null,
    
    constructor: function(panel, config) {
        this.panel = panel;
        this.config = config;
        this.id = config.id;
        this.originalId = valueExistsNotEmpty(config.originalId) ? config.originalId : config.id;
        this.enabled = (config.enabled !== 'false');
        this.hidden = (config.hidden === 'true');
        this.type = config.type;
        this.menuAction = config.menuAction;
        
        if (valueExists(config.enabled) && config.enabled.substring(0,2) == '${' ) {
			this.enabled = config.enabled;
		}

        // create the action command
        if (valueExists(config.command)) {
            // caller provided the pre-built command chain)
            this.command = config.command;
        } else if (valueExists(config.commands) && config.commands.length > 0) {
            // caller provided an array of commands (as defined in AXVW)
            this.command = new Ab.command.commandChain(panel.id);
            this.command.addCommands(config.commands);
        } else if (valueExists(config.onclick)) {
            // caller provided the onclick event handler name
            this.command = new Ab.command.commandChain(panel.id);
            this.command.addCommand(
                new Ab.command.callFunction({functionName: config.onclick}));
        }

        if (valueExists(this.command)) {
            this.listener = this.command['handle'].createDelegate(this.command);
        } else if (valueExists(config.listener)) {
            this.listener = config.listener;
        }

        this.actions = new Ext.util.MixedCollection();
		if (valueExists(config.actions)) {
            // this is a menu
			for (var i = 0; i < config.actions.length; i++) {
                config.actions[i].menuAction = this;
		        var action = new Ab.view.Action(panel, config.actions[i]);
		        this.actions.add(action.id, action);
			}
		}

        // Create the button and attach the listener.
        // If the action is in a hidden panel, do not create the button - it will be created when the panel opens in a window.
        if (!this.panel.hidden || !this.config.topLevel) {
            this.bind();
        }
    },

    bind: function() {
        if (this.button) {
            return;
        }
        var config = this.config;

        if (valueExists(this.menuAction)) {
            // this is a menu item; do nothing - the menu item is already created by the parent menu Action

        } else if (valueExists(config.useExtButton) && config.useExtButton == false) {
            // use HTML button generated on the server
            this.button = Ext.get(this.id);
            // caller may pass localized title
            if (valueExists(config.title)) {
                this.button.dom.innerHTML = config.title;
            }
            // caller may pass localized tooltip
            if (valueExistsNotEmpty(config.tooltip)) {
                Ext.QuickTips.register({
                    target: this.id,
                    text: config.tooltip
                });            
            }
        } else {
            // create Ext.Button
            var buttonConfig = {
                id: this.id,
                text: config.text,
                renderTo: config.renderTo,
				hidden: this.hidden
            };
            if (valueExistsNotEmpty(config.tooltip)) {
                buttonConfig.tooltip = config.tooltip;
            }

            if (valueExists(config.cls)) {
                buttonConfig.cls = config.cls;
            } else {
                buttonConfig.cls = '';
            }
            
            if (valueExists(config.icon)) {
                if (valueExistsNotEmpty(config.text)) {
                    buttonConfig.cls = buttonConfig.cls + ' x-btn-text-icon';
                } else {
                    buttonConfig.cls = buttonConfig.cls + ' x-btn-icon';
                }
                buttonConfig.icon = View.contextPath + this.config.icon;
            }
            
            if (config.mainAction) {
                buttonConfig.cls = buttonConfig.cls + ' mainAction';
            } else if (this.panel.buttonsPosition === 'footer') {
                buttonConfig.cls = buttonConfig.cls + ' mediumAction';
            }

            if (this.type === 'menu') {
                var menuItems = [];
                for (var i = 0; i < this.actions.getCount(); i++) {
                    var action = this.actions.itemAt(i);
                    var actionListeners = {};
                    if (valueExists(action.listener)) {
                        actionListeners.click = action.listener;
                    }
                    var itemConfig = {
                        id: action.config.id,
                        text: action.config.text,
                        listeners: actionListeners
                    };
                    if (valueExists(action.config.checked)) {
                        itemConfig.checked = action.config.checked;
                        delete actionListeners.click;
                        actionListeners.checkchange = action.listener;
                    }
                    menuItems.push(itemConfig);
                }
                this.menu = new Ext.menu.Menu({ items: menuItems });
                buttonConfig.menu = this.menu;
            }

            if (valueExists(config.renderTo)) {
                // create a button based on the existing DOM element
                buttonConfig.template = Ab.view.Action.DEFAULT_TEMPLATE;
                this.button = new Ext.Toolbar.Button(buttonConfig);            
            } else {
                var dialog = this.panel.window || View.getParentDialog();
                if ((dialog && this.panel.buttonsPosition == 'footer') || this.panel.window) {
					// add window button
                    this.button = new Ext.Button(buttonConfig);
                    this.render();
                } else {
                    // add panel toolbar button
                    if (config.isActionbarAction) {
                        this.button = this.panel.actionbar.toolbar.addButton(buttonConfig);
                    } else if (this.panel.toolbar) {
                        this.panel.toolbar.addSpacer();
                        this.panel.toolbar.addSpacer();
                        this.button = this.panel.toolbar.addButton(buttonConfig);
                    }
                }
            }
        }

        // register command as event handler
        if (this.listener && this.button) {
            if (valueExists(this.button.dom)) {
                this.button.dom.onclick = this.listener;
            } else {
                this.button.on("click", this.listener);
            }
        }

        if (this.pendingListener) {
            this.addListener(this.pendingListener.callback, this.pendingListener.scope);
            this.pendingLisneter = null;
        }
    },
    
    
    removeListeners: function() {
        if (this.button) {
        	this.button.dom.onclick = null;
        }
    },
    
    
    render: function(visible) {
        if (!this.button) {
            this.bind();
        }

        if (!valueExists(visible)) {
            visible = true;
        }
        
        var dialog = this.panel.window || View.getParentDialog();
        if ((dialog && this.panel.buttonsPosition == 'footer') || this.panel.window) {
            if (visible) {
                if (!this.buttonRendered) {
                    this.buttonRendered = true;
                    
                    // insert button DOM <td> element into the panel footer
                    var buttonsEl = dialog.footer.child('table:first tr:first');
					// @important: because the dialog footer is outside of this iframe, 
					// use the opener window's Ext instance to create <td> element
					// this is required for IE6, not for FF
                    var extInstance = Ext;
                    var openerWindow = View.getOpenerWindow();
                    if (openerWindow && openerWindow.Ext) {
                        extInstance = openerWindow.Ext;
                    }
                    var buttonEl = extInstance.DomHelper.append(
                        buttonsEl, {tag: 'td', cls: 'x-panel-btn-td ' + this.button.cls, id: this.getButtonId()});
                    
                    // render Ext.Button into DOM (force rendering)
                    this.button.rendered = false;
                    this.button.render(buttonEl);
                }
            } else {
                if (this.buttonRendered) {
                    this.buttonRendered = false;

                    // remove this button DOM element from the parent Ext panel
                    var buttonsEl = dialog.footer.child('table:first tr:first');
                    var buttonEl = buttonsEl.child('#' + this.getButtonId());
                    buttonEl.remove();
                }
            }
        }
    },
    
    getButtonId: function() {
        return this.panel.id + '_' + this.id;  
    },
    
    
    addListener: function(callback, scope) {
        if (this.button) {
            this.button.on('click', callback, scope);
        } else {
            this.pendingListener = {
                callback: callback,
                scope: scope
            };
        }
    },
    
    
    enable: function(enabled) {
        this.enabled = enabled;
        if (!this.forcedDisabled) {
            this.enableButton(enabled);
        }
    },
    
    
    forceDisable: function(disabled) {
        this.forcedDisabled = disabled;
        if (this.forcedDisabled) {
            this.enableButton(false);
        } else {
            this.enableButton(this.enabled);
        }
    },
    
    
    enableButton: function(enabled) {
        // enable or disable button input
        if (this.button) {
            if (this.button.setDisabled) {
                this.button.setDisabled(!enabled);
            } else {
                this.button.dom.disabled = !enabled;
            }
        } else if (this.menuAction && this.menuAction.menu) {
            var menuItem = this.menuAction.menu.items.item(this.id);
            if (menuItem) {
                if (enabled) {
                    menuItem.enable();
                } else {
                    menuItem.disable();
                }
            }
        }
        
        // enable or disable button command
        if (this.command) {
            this.command.enabled = enabled;
        }
    },
    
    
    show: function(visible) {
        this.visible = visible;
        if (!this.forcedHidden && this.button) {
            this.button.setVisible(visible);
        }
    },
    
    
    forceHidden: function(hidden) {
        this.forcedHidden = hidden;
        if (this.button) {
            if (this.forcedHidden) {
                this.button.setVisible(false);
            } else {
                this.button.setVisible(this.visible);
            }
        }
    },
    
    setTitle: function(title) {
        if (this.button) {
            if (valueExists(this.config.useExtButton) && this.config.useExtButton == false) {
                if (!Ext.isIE) {
            	    this.button.dom.innerHTML = title;
                }
                this.button.dom.value = title;
            } else {
                this.button.setText(title);
            }
        } else if (this.menuAction && this.menuAction.menu) {
            var menuItem = this.menuAction.menu.items.item(this.id);
            if (menuItem) {
                menuItem.setText(title);
            }
        }
    },

    setImage: function(imageName) {
        var imagePath = View.contextPath + '/' + imageName;
        this.button.dom.src = imagePath;
    },
    
    
    evaluateExpressions: function(ctx) {
        var evaluatedEnabled = Ab.view.View.evaluateBoolean(this.config.enabled, ctx, true);
        this.enable(evaluatedEnabled);

        var evaluatedHidden = Ab.view.View.evaluateBoolean(this.config.hidden, ctx, false);
        if (evaluatedHidden != this.hidden) {
            this.hidden = evaluatedHidden;
            this.show(!evaluatedHidden);
        }

		var evaluatedTitle = Ab.view.View.evaluateString(this.config.text, ctx);
		if (evaluatedTitle != this.config.text) {
	        this.setTitle(evaluatedTitle);
		}
    },

    
    clear: function() {
        if (this.menu) {
            this.menu.removeAll();
            this.button.setDisabled(true);
        }
    },

    
    addAction: function(id, title, listener) {
        if (this.menu) {
            this.menu.addItem(new Ext.menu.Item({
                text: title,
                listeners: {
                    click: listener
                }
            }));
            this.button.setDisabled(false);
        }
    }
}, {
	CHEVRON: '&#187; ',
    DEFAULT_TEMPLATE: 
        new Ext.Template(
            '<table border="0" cellpadding="0" cellspacing="0" class="x-btn x-btn-wrap"><tbody><tr>',
            '<td class="x-btn-left"><i>&#160;</i></td><td class="x-btn-center"><em unselectable="on"><button class="x-btn-text" type="{1}">{0}</button></em></td><td class="x-btn-right"><i>&#160;</i></td>',
            "</tr></tbody></table>")
});


Ab.view.Actionbar = Ab.view.Component.extend({
    // parent panel ID
    panelId: '',

    // parent panel
    control: null,

    // child actions
    actions: null,

    // Ext.Toolbar
    toolbar: null,

    // Ext.Toolbar.TextItem
    titleItem: null,

    constructor: function(panelId, control) {
        this.panelId = panelId;
        this.control = control;
        this.actions = new Ext.util.MixedCollection();

        this.toolbar = new Ext.Toolbar({
            id: control.id + '_actionbar',
            autoHeight: true,
            cls: 'actionbar',
            renderTo: control.parentElement
        }).show();

        this.titleItem =  new Ext.Toolbar.TextItem('');
        this.titleItem.getEl().className = 'itemsSelected';
        this.toolbar.add(this.titleItem);
        this.toolbar.addSpacer();

        this.setTitle('');

        control.actionbar = this;

        this.updateSelected(0);
    },

    addAction: function(config) {
        config.cls = config.mainAction ? 'mainAction' : 'mediumAction';
        config.isActionbarAction = true;

        var action = new Ab.view.Action(this.control, config);
        action.enableButton(false);
        action.show(false);

        this.actions.add(action);
    },

    getAction: function(id) {
        return this.actions.get(id);
    },

    show: function() {
        this.toolbar.show();
    },

    hide: function() {
        this.toolbar.hide();
    },

    setTitle: function(title) {
        this.titleItem.getEl().innerHTML = title;
        this.titleItem.setVisible(title.length > 0);
    },

    updateSelected: function(numberOfSelectedItems) {
        for (var i = 0; i < this.actions.getCount(); i++) {
            var action = this.actions.get(i);
            action.enableButton(numberOfSelectedItems > 0);
        }

        this.setTitle(numberOfSelectedItems + '&nbsp;'
            + View.getLocalizedString(Ab.view.Actionbar.z_MESSAGE_ITEMS_SELECTED));
    }
}, {
    // ----------------------- constants -----------------------------------------------------------

    // @begin_translatable
    z_MESSAGE_ITEMS_SELECTED: 'selected'
    // @end_translatable
});


Ab.namespace('view');


Ab.view.Layout = Base.extend({
    // layout id
    id: '',

    // layout type: borderLayout is the only supported type
    type: 'border',
    
    // name of the containing layout (null for top-level layout)
    parentLayoutName:  '',
    
    // name of the containing region
    parentLayoutRegion: '',
    
    // array of region config objects, in Ext format
    regions: null,
    
    // map of region config objects, keyed by region name (north|south|east|west|center)
    regionsByName: null,
    
    // Ext.Viewport for the top-level layout
    viewport: null,
    
    
    constructor: function(id, type, parentLayoutName, parentLayoutRegion, regions) {
        this.id = id;
        this.type = type;
        this.parentLayoutName = parentLayoutName;
        this.parentLayoutRegion = parentLayoutRegion;

        var isStandardSize = function(str) {
            return (valueExists(str) && str.indexOf('%') == -1);
        };
        
        // store region config objects
        this.regions = regions;
        this.regionsByName = {};
        for (var i = 0; i < regions.length; i++) {
        	var region = regions[i];
        	this.regionsByName[region.region] = region;

            region.layoutManager = this;

        	if (region.region == 'north' || region.region == 'south') {
        	    if (isStandardSize(region.initialSize)) region.height = parseFloat(region.initialSize);
                if (isStandardSize(region.minSize)) region.minHeight = parseFloat(region.minSize);
                if (isStandardSize(region.maxSize)) region.maxHeight = parseFloat(region.maxSize);
        	} else if (region.region == 'west' || region.region == 'east') {
                if (isStandardSize(region.initialSize)) region.width = parseFloat(region.initialSize);
                if (isStandardSize(region.minSize)) region.minWidth = parseFloat(region.minSize);
                if (isStandardSize(region.maxSize)) region.maxWidth = parseFloat(region.maxSize);
            }
        	
            region.border = valueExists(region.id);
            
	        // create region DOM element if it does not exist
	        if (!valueExists(region.contentEl)) {
                var cls = '';
                if (!this.isTopLevel() && region.id !== 'viewContentRegion') {
                    cls = 'layoutRegion';
                }

	            region.contentEl = this.id + '_' + region.region + '_div';
	            Ext.DomHelper.append(document.body, {tag: 'div', id: region.contentEl, cls: cls});
	        }
        }
        
        View.addLayoutManager(this);
    },
    
    
    isTopLevel: function() {
        return !valueExistsNotEmpty(this.parentLayoutName);
    },
    
    
    getRegion: function(regionName) {
        return this.regionsByName[regionName];
    },  
    
    
    getRegionEl: function(regionName) {
        var region = this.regionsByName[regionName];
        return Ext.get(region.contentEl);
    },  
    
    
    getRegionPanel: function(region) {
        if (region.constructor === String) {
            region = this.getRegion(region);
        }
		
		var regionPanel = null;
		if (valueExists(region)) {
			var panelElementId = Ext.get(region.contentEl).dom.parentNode.parentNode.parentNode.id;
			regionPanel = Ext.ComponentMgr.get(panelElementId);
		}
		return regionPanel;
    },
    
    
    getRegionNameById: function(id) {
        var regionName = null;
        for (var i = 0; i < this.regions.length; i++) {
        	var region = this.regions[i];
        	if (region.id === id) {
        		regionName = region.region;
        		break;
        	}
        }
        return regionName;
    },

    
    getParentRegion: function() {
        var parentLayout = View.getLayoutManager(this.parentLayoutName);
        return parentLayout.getRegion(this.parentLayoutRegion);
    },

    
    addComponentToRegion: function(regionName, panelElementId, panel) {
        var region = this.getRegion(regionName);
        
        // regions with content panels should have these layout properties by default:
        region.border = View.hasBorder();
        region.layout = 'fit';

        if ('viewPanel' !== panel.type) {
            region.autoScroll = true;
        }
        if (this.isToolbarRegion(region)) {
            region.autoScroll = false;
            region.border = false;
        }

        // move the panel DOM element inside the region container DOM element
        if (region.contentEl !== panelElementId) {
            Ext.get(region.contentEl).appendChild(panelElementId);
        }
    },

    
    isToolbarRegion: function(region) {
        return (region.id === 'dashboardTabsRegion' || region.id == 'toolbarRegion' || region.id == 'viewToolbarRegion');
    },

        
    bindToParentLayout: function() {
        if (!this.isTopLevel()) {
            var parentRegion = this.getParentRegion();
            parentRegion.childLayout = this;
        }
    },
    
    
    getPanelsForRegion: function(region) {
    	var panels = [];

    	View.panels.each(function (panel) {
    		var panelRegion = panel.getLayoutRegion();
			if (panelRegion && panelRegion.contentEl === region.contentEl && panel.type !== 'viewPanel' && !panel.hidden) {
				panels.push(panel);
			}
    	});
    	
    	return panels;
    },
    
    
    doLayout: function() {
        // for any region that has a nested layout, create a panel with border layout
        for (var r = 0; r < this.regions.length; r++) {
            var region = this.regions[r];
            region.collapseMode = 'mini';
            region.useSplitTips = true;
            region.splitTip = View.getLocalizedString(Ab.view.Layout.z_MESSAGE_SPLIT_TIP);
            region.cmargins = region.region == 'north' || region.region == 'south' ?
                {left:5,top:5,right:5,bottom:5} :
                {left:5,top:0,right:5,bottom:0};

            // if the region has 0 or 1 panels, the panel will auto-scroll
            var panels = this.getPanelsForRegion(region);
            if (panels.length == 1 && !panels[0].isScrollInLayout()) {
                region.autoScroll = false;
            }

            if (valueExists(region.childLayout)) {
                region.items = region.childLayout.regions;
                region.layout = 'border';
            }
        }
        
        if (this.isTopLevel()) {
            // top-level layout - create a viewport based on the document body element
            this.viewport = new Ext.Viewport({
                layout: 'border',
                border: false,
				bufferResize: true,
                items: this.regions
            });
        }
        
        // when window is resized, recalculate the proportional layout
        Ext.EventManager.onWindowResize(this.recalculateLayout, this);
        
        // recalculate the proportional layout
        if (Ext.isIE) {
            this.recalculateLayout.defer(200, this);
        } else {
            this.recalculateLayout();
        }
    },
    
    
    afterLayout: function() {
        for (var i = 0, len = this.regions.length; i < len; i++) {
            var region = this.regions[i];
            if (valueExists(region) && region.collapsed) {
                this.collapseRegion(region.region);
            }
        }

        // add a listener that updates panel height when the region is resized
        var layout = this;
        for (var i = 0, len = this.regions.length; i < len; i++) {
            var region = this.regions[i];
            var regionPanel = this.getRegionPanel(region);
            if (regionPanel) {
                // KB 3038493: layout container should never show scrollbars, only regions can
                regionPanel.el.dom.parentNode.style.overflow = 'hidden';

                var scrollContent = this.isScrollContent(region);
                var panels = this.getPanelsForRegion(region);

                // KB 3038580: suppress vertical scrollbar in console regions that have no initial size in the view
                if (region.region === 'north' && !valueExists(region.initialSize) &&
                    panels.length == 1 && (panels[0].type === 'console' || panels[0].type === 'form')) {
                    regionPanel.getEl().dom.firstChild.firstChild.style.overflowY = 'hidden';
                }

                if (panels.length > 0) {
                    regionPanel.firstPanel = panels[0];
                    regionPanel.scrollContent = scrollContent;

                    regionPanel.on('resize', function() {
                        this.firstPanel.syncHeight();
                        if (this.scrollContent) {
                            layout.updateScroller(this);
                        }
                    });
                }

                if (scrollContent) {
                    // do it now to suppress old-style scroll bars
                    layout.updateScroller(regionPanel);
                    // do it again later to ensure the scroller matches DOM dimensions
                    layout.updateScroller.defer(500, layout, [regionPanel]);
                }
            }
        }
    },

    
    isScrollContent: function(region) {
        var scrollContent = false;

        if (View.preferences.useScroller && !this.isToolbarRegion(region)) {
            var regionPanel = this.getRegionPanel(region);
            if (regionPanel) {
                var panels = this.getPanelsForRegion(region);

                // the layout region should scroll content if...
                // a) there is only one panel, and it allows the layout to scroll its content, or...
                // b) there are many panels
                // ignore view panels
                if (panels.length > 0) {
                    if (panels[0].isScrollInLayout() || panels.length > 1) {
                        scrollContent = true;
                    }

                    // tab panels nested inside tab pages are assigned to the view layout's center region - do not scroll that region
                    if (valueExists(panels[0].parentTab)) {
                        scrollContent = false;
                    }
                }
            }
        }

        return scrollContent;
    },

    
    updateScroller: function(regionPanel) {
        // KB 3038522: do not create the scroller if the layout region is hidden
        if (regionPanel.el.getHeight() <= 0) {
            return;
        }

        if (!regionPanel.scroller) {
            regionPanel.scroller = new Ab.view.Scroller(regionPanel.body.dom.firstChild);
            regionPanel.body.dom.style.overflow = 'hidden';
        } else {
            regionPanel.scroller.update();
        }
    },
    
    
    recalculateLayout: function(windowWidth, windowHeight) {
    	try {
	        if (!valueExists(windowWidth)) {
	            var size = Ext.get(document.body).getViewSize();
	            windowWidth = size.width;
	            windowHeight = size.height;
	        }
	        
	        var recalculated = false;
	        
	        for(var i = 0, len = this.regions.length; i < len; i++) {
	        	var region = this.regions[i];
	        	
	        	if (valueExists(region)) {
	            	var size = region.initialSize; 
	            	if (valueExists(size) && size.constructor == String && size.search('%') != -1) {
	            	    var percent = parseInt(size.substr(0, size.length - 1));
	            	    
	            	    var panel = this.getRegionPanel(region);
	            	    if (!valueExists(panel)) {
	            	        panel = Ext.get(region.contentEl);
	            	    }
	            	    
	                    switch(region.region){
	                        case "east":
	                        case "west":
	                            size = windowWidth * percent / 100;
	                            Ext.isIE ? panel.setWidth(size) : region.width = size;
	                        break;
	                        case "north":
	                        case "south":
                                size = windowHeight * percent / 100;
                                Ext.isIE ? panel.setHeight(size) : region.height = size;
	                        break;
	                    }
	                    recalculated = true;
	            	}
	        	}
	        }
	        
	        if (this.isTopLevel()) {
	            this.viewport.doLayout();
	            
	            View.panels.each(function (panel) {
	                panel.afterLayout();
	            });
				
				//View.log(String.format('Top-level layout recalculated: w {0}, h {1}, url [{2}]', windowWidth, windowHeight, window.location));
	            View.state = View.STATE_LAYOUT_COMPLETE;
	        }
    	} catch (e) {
	        if (this.isTopLevel()) {
	            // signal the view loader to continue
	    		View.state = View.STATE_LAYOUT_COMPLETE;
	            // this is a deferred call, nobody else can handle this exception
	            View.showException(e, View.getLocalizedString(Ab.view.View.z_MESSAGE_VIEW_LOAD_FAILURE) + View.viewName);
	        }
    	}
    },
    
    
    collapseRegion: function(region) {
        var panel = this.getRegionPanel(region);
        if (panel) {
            panel.collapse(false);
        }
    },
    
    
    expandRegion: function(region) {
        var panel = this.getRegionPanel(region);
        if (panel) {
            panel.expand(false);
        }
    },
    
    
    isRegionCollapsed: function(region) {
        var collapsed = false;
        var panel = this.getRegionPanel(region);
        if (panel) {
            var region = panel.ownerCt.layout[region];
            collapsed = region.isCollapsed;
        }
        return collapsed;
    },
    
    
    setRegionSize: function(region, size) {
        var panel = this.getRegionPanel(region);
        if (panel) {
            switch(region){
	            case "east":
	            case "west":
	                panel.setWidth(size);
	            break;
	            case "north":
	            case "south":
	                panel.setHeight(size);
	            break;                
            }
            panel.afterExpand();
        }
    }
}, {
    // ----------------------- constants -----------------------------------------------------------

    // @begin_translatable
    z_MESSAGE_SPLIT_TIP: 'Drag to resize, or click the dotted area to hide.',
    // @end_translatable

	DEFAULT_MARGINS: '4 4 4 4'
});



Ab.view.Toolbar = Ab.view.Component.extend({

    // title text
    title: '',
    
    // link wrapping the title text
    titleLink: '',
    
    // Ext.Toolbar
    toolbar: null,
    
    // array of button configurations in Ext format
    buttonConfigs: null,
    
    // custom style
    style: '',
    
    // custom class
    cls: null,
    
    // array of Ext.Button controls
    buttons: null,
    
    
    constructor: function(id, configObject) {
        this.inherit(id, 'toolbar', configObject);
        
        this.title = configObject.getConfigParameter('title', '');
        this.titleLink = configObject.getConfigParameter('titleLink', '');
        this.buttonConfigs = configObject.getConfigParameter('buttons', []);
        this.style = configObject.getConfigParameter('style', '');
        this.cls = configObject.getConfigParameter('cls', null);
        
        this.buttons = [];
    },

    
    isScrollInLayout: function() {
        return false;
    },

    
    doLayout: function() {
        this.inherit();
        
        var layout = Ab.view.View.getLayoutManager(this.layout);
        var region = layout.getRegion(this.region);
        var regionEl = layout.getRegionEl(this.region);
        
        //region.border = false;
        
        this.toolbar = new Ext.Toolbar({
            renderTo: regionEl,
            style: this.style,
            cls: this.cls
        });
        
        this.beforeBuild();
        
        // add title text as a separate Element so it has a specific id
		this.toolbar.add(this.getTitleElement());
        
        // add button
        if (this.buttonConfigs.length > 0) {
	        this.toolbar.addFill();
	        for (var i = 0; i < this.buttonConfigs.length; i++) {
	            if (this.buttonConfigs[i].text === '') {
	                this.toolbar.addSeparator();
	            } else {
	                var button = this.toolbar.addButton(this.buttonConfigs[i]);
	                this.buttons.push(button);
	            }
	        }
        }
    },
	
	
	getTitleElement: function() {
		if (this.titleLink != '') {
			var linkElement = document.createElement('a');
			linkElement.setAttribute("id", this.id + '_title');
			linkElement.setAttribute("class", this.cls);
			linkElement.setAttribute("href", this.titleLink);
			linkElement.setAttribute("target", "_blank");
			linkElement.innerHTML = this.title;
			return linkElement;
		}
		else {
			var viewTitleBarTextItem =  new Ext.Toolbar.TextItem(this.title);
			viewTitleBarTextItem.getEl().id = this.id + '_title';
			return viewTitleBarTextItem;
		}
	},

        
    beforeBuild: function() {}
});

Ab.namespace('tabs');



Ab.tabs.Tabs = Ab.view.Component.extend({

    // whether workflow is free or enforced
    workflow:'free',

    // array of Ab.tab.Tab objects for all tab pages
    tabs:null,

    // name of the selected tab page
    selectedTabName:'',

    // name of the previously selected tab page
    previouslySelectedTabName:'',

    // Ext.TabPanel
    tabPanel:null,

    // whether the tabs can be scrolled left/right if they do not fit the page width
    enableTabScroll:true,

    // when tab page content should be refreshed:
    // 'refreshOnSelect': each page is refreshed when the user selects it (default)
    // 'refreshOnLoad': all pages are refreshed when the view is loaded
    // 'never': the tab control never refreshes tab pages; it is the responsibility of the application code
    tabRefreshPolicy:'refreshOnSelect',

    // counter used to assign tab names to newly created tabs
    tabCreateCounter:1,


    
    constructor:function (id, configObject) {
        // register the tab control
        this.inherit(id, 'tabs', configObject);

        this.workflow = configObject.getConfigParameter('workflow', 'free');
        this.tabRefreshPolicy = configObject.getConfigParameter('tabRefreshPolicy', 'refreshOnSelect');
        this.enableTabScroll = configObject.getConfigParameter('enableTabScroll', true);

        this.tabs = [];
    },

    
    addTab:function (tab) {
        tab.parentPanel = this;
        tab.index = this.tabs.length;
        this.tabs.push(tab);
    },

    doLayout:function () {
        // if top-level panels do not specify layout region, assign viewLayout:center by default
        if (!this.hasLayout() && this.isTopLevel) {
            this.layout = 'viewLayout';
            this.region = 'center';
        } else if (valueExistsNotEmpty(this.layoutRegion)) {
            var result = Ab.view.View.getLayoutAndRegionById(this.layoutRegion);
            this.layout = result.layout;
            this.region = result.region;
        }

        // create Ext.TabPanel with all tab pages
        var tabItems = [];
        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];

            tabItems.push({
                title:tab.title,
                contentEl:tab.name,
                autoScroll:true,
                autoWidth:true,
                autoHeight:!this.isTopLevel
            });

            // move DOM elements for all children panels inside the tab DOM element
            for (var p = 0; p < tab.childPanelIds.length; p++) {
                var childPanelId = tab.childPanelIds[p];
                Ext.get(tab.name).appendChild(childPanelId + '_layoutWrapper');
            }
        }
        this.tabPanel = new Ext.TabPanel({
            renderTo:this.getWrapperElementId(),
            activeTab:0,
            items:tabItems,
            border:false,
            enableTabScroll:this.enableTabScroll
        });

        // call Component.doLayout() to add this tab panel to the layout
        this.inherit();

        // set selected tab page name
        var selectedTabName = null;
        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];

            if (tab.selected) {
                selectedTabName = tab.name;
            }

            var tabPanelItem = this.tabPanel.getItem(i);
            tab.setTabPanel(tabPanelItem);
        }

        // fetch tab pages view content
        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];
            tab.showContent(false);

            // fetch external view content for the selected tab only
            if (tab.hasView() && tab.selected) {
                tab.loadView.defer(100, tab);
            }

            // activate each tab page, to make sure the onload event is handled
            this.tabPanel.activate(i);
        }

        // display selected tab page without refreshing it
        if (selectedTabName) {
            this.selectTab(selectedTabName, null, false, false, true);
        }

        // set tab event listeners
        this.tabPanel.on("tabchange", this.afterTabChange, this, true);
        this.tabPanel.on("beforetabchange", this.beforeTabChange, this, true);
        this.tabPanel.on('beforeremove', this.beforeTabClose, this, true);
        this.tabPanel.on('remove', this.onTabClose, this, true);
    },

    updateHeight:function () {
        this.syncHeight();
    },

    
    syncHeight:function () {
        var parentRegion = this.getLayoutRegion();
        var parentEl = Ext.get(this.getWrapperElementId());

        if (this.window) {
            this.tabHeight = this.window.getInnerHeight() - 10;
        } else if (parentRegion) {
            this.tabHeight = Ext.get(parentRegion.contentEl).parent().getHeight() - 3;
            this.tabWidth = Ext.get(parentRegion.contentEl).parent().getWidth();
        } else if (this.parentTab) {
            this.tabHeight = this.parentTab.parentPanel.tabHeight - this.getTabStripHeight();
            this.tabWidth = this.parentTab.parentPanel.tabWidth;
        }

        this.tabHeight -= parentEl.dom.offsetTop;

        if (Ext.isIE) {
            parentEl.setStyle('height', 'auto');
        } else {
            parentEl.setHeight(this.tabHeight);
            parentEl.first().setHeight(this.tabHeight);
        }

        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];
            tab.tabPanel.setHeight(this.tabHeight - this.getTabStripHeight());
            tab.syncHeight();
        }
    },

    
    getTabStripHeight:function () {
        var height = Ab.tabs.Tabs.TAB_HEIGHT;

        if (Ext.get(this.getWrapperElementId()).hasClass('tabs-light')) {
            height += 16;
        }

        return height;
    },

    
    show:function (show, includeHeader) {
        var parentEl = Ext.get(this.getWrapperElementId());
        // KB 3039173: the layout wrapper element does not have the display property in IE8
        // if tabs are nested inside tabs and both levels use frames
        if (parentEl && parentEl.dom.style.display) {
            parentEl.setDisplayed(show);
        }
        if (show) {
            this.syncHeight();
        }
    },

    
    evaluateExpressions:function (ctx) {
        if (!valueExists(ctx)) {
            ctx = this.createEvaluationContext();
        }

        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];
            tab.evaluateExpressions(ctx);
        }
    },

    
    selectFirstVisibleTab:function () {
        var selectedTabName = this.tabs[0].name;
        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];
            if (tab.selected && !tab.hidden) {
                var selectedTabName = tab.name;
            }
        }
        // display selected tab page without refreshing it
        this.selectTab(selectedTabName, null, false, false, true);
    },

    
    updateTabStates:function () {
        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];

            if (this.isWorkflowEnforced() && tab.name != this.selectedTabName) {
                this.disableTab(tab.name);
            }
            if (!tab.enabled) {
                this.disableTab(tab.name);
            }
            if (tab.hidden) {
                this.hideTab(tab.name);
            }
        }
    },

    
    isWorkflowEnforced:function () {
        return (this.workflow == 'enforced');
    },

    
    isRefreshOnLoad:function () {
        return (this.tabRefreshPolicy == 'refreshOnLoad');
    },

    
    isRefreshOnSelect:function () {
        return (this.tabRefreshPolicy == 'refreshOnSelect');
    },

    
    refresh:function (restriction) {
        //  store the restriction for all tabs
        if (valueExists(restriction)) {
            this.restriction = restriction;
        }

        if (this.isRefreshOnLoad()) {
            // if refresh policy is on load, refresh all tab pages at once
            for (var i = 0; i < this.tabs.length; i++) {
                var tab = this.tabs[i];
                this.refreshTab(tab.name);
            }
        } else if (this.isRefreshOnSelect()) {
            this.refreshTab(this.selectedTabName);
        }
    },


    
    refreshTab:function (tabName) {
        var tab = this.findTab(tabName);
        tab.refresh(this.restriction);
    },

    
    findTab:function (tabName) {
        if (tabName.constructor == Number) {
            return this.tabs[tabName];
        }

        var tab = null;
        for (var i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].name == tabName) {
                tab = this.tabs[i];
                break;
            }
        }
        return tab;
    },

    
    findTabById:function (tabItemId) {
        var tab = null;
        for (var i = 0; i < this.tabs.length; i++) {
            if (this.tabs[i].id == tabItemId) {
                tab = this.tabs[i];
                break;
            }
        }
        return tab;
    },

    
    findTabByRestriction:function (restriction) {
        var tab = null;
        for (var i = 0; i < this.tabs.length && tab == null; i++) {
            var t = this.tabs[i];

            if (valueExists(t.restriction)) {
                if (valueExists(restriction.equals)) {
                    if (restriction.equals(t.restriction)) {
                        tab = t;
                    }
                } else {
                    if (objectsEqual(restriction, t.restriction)) {
                        tab = t;
                    }
                }
            }
        }
        return tab;
    },

    
    selectTab:function (tabName, restriction, newRecord, clearRestriction, noRefresh) {
        View.log(String.format('Selecting tab [{0}], restriction [{1}]', tabName, toJSON(restriction)));

        var tab = this.findTab(tabName);

        if (valueExists(restriction)) {
            tab.restriction = restriction;
        }
        if (valueExists(newRecord)) {
            tab.newRecord = newRecord;
        }
        if (valueExists(clearRestriction)) {
            tab.clearRestriction = clearRestriction;
        }

        // enable tab page, in case it was disabled, or when the workflow is enforced
        this.enableTab(tab.name);

        // display tab page
        if (this.selectedTabName != tab.name) {
            this.selectedTabName = tab.name;
            //activate() would invoke beforeTabChange() by ExtJ
            this.tabPanel.activate(tab.index);
        } else {
            if (this.isRefreshOnSelect() || tab.mustRefresh()) {
                if (!valueExists(noRefresh) || !noRefresh) {
                    this.refreshTab(tab.name);
                }
            }
        }

        // update enabled/disabled state for all tab pages
        this.updateTabStates();

        return tab;
    },


    
    createTab:function (viewName, restriction, newRecord) {
        // if there is existing tab with the same restriction, do not create another instance
        if (valueExists(restriction)) {
            var existingTab = this.findTabByRestriction(restriction);
            if (existingTab != null) {
                this.selectTab(existingTab.name, restriction, newRecord);
                return;
            }
        }

        this.tabCreateCounter = this.tabCreateCounter + 1;
        var tabName = 'page_' + this.tabCreateCounter;
        var tabTitle = '&nbsp;&nbsp;&nbsp;&nbsp;';

        // create Tab object
        var tab = new Ab.tabs.Tab({
            name:tabName,
            title:tabTitle,
            fileName:viewName,
            selected:false,
            enabled:true,
            hidden:false,
            useParentRestriction:true,
            isDynamic:true,
            useFrame:true
        });
        this.addTab(tab);

        var tabs = this;
        tab.createTabPanel(function () {
            // when the view is fully loaded, display the new tab page and apply the restriction
            tabs.selectTab(tabName, restriction, newRecord);
        });
    },

    
    closeTab:function (tabName) {
        if (!valueExistsNotEmpty(tabName)) {
            tabName = this.selectedTabName;
        }
        var tab = this.findTab(tabName);
        this.tabPanel.remove(tab.index);
    },

    
    enableTab:function (tabName, enabled) {
        if (!valueExists(enabled)) {
            enabled = true;
        }
        this.findTab(tabName).enable(enabled);
    },

    
    disableTab:function (tabName) {
        this.findTab(tabName).enable(false);
    },

    
    showTab:function (tabName, visible) {
        if (valueExists(visible) && visible === false) {
            this.hideTab(tabName);
        } else {
            var tab = this.findTab(tabName);
            tab.forcedHidden = false;
            this.tabPanel.unhideTabStripItem(tab.index);
        }
    },

    
    hideTab:function (tabName) {
        var tab = this.findTab(tabName);
        tab.forcedHidden = true;
        this.tabPanel.hideTabStripItem(tab.index);
    },

    
    setTabRestriction:function (tabName, restriction) {
        this.findTab(tabName).restriction = restriction;
    },

    
    setTabsRestriction:function (restriction, tabName) {
        if (valueExists(tabName)) {
            this.setTabRestriction(tabName, restriction);
        } else {
            this.restriction = restriction;
        }
    },

    
    getTabsRestriction:function (tabName) {
        if (valuExists(tabName)) {
            return this.findTab(tabName).restriction;
        } else {
            return this.restriction;
        }
    },

    
    setTabEnabled:function (tabName, enabled) {
        this.enableTab(tabName, enabled);
    },

    
    setAllTabsEnabled:function (enabled) {
        for (var i = 0; i < this.tabs.length; i++) {
            var tab = this.tabs[i];
            this.enableTab(tab.name, enabled);
        }
    },

    
    setTabVisible:function (tabName, visible) {
        this.showTab(tabName, visible);
    },

    
    setTabTitle:function (tabName, title) {
        this.findTab(tabName).setTitle(title);
    },

    
    getSelectedTabName:function () {
        return this.selectedTabName;
    },

    
    addTabsEventListener:function (eventListenerCode) {
        var f = function () {
            eval(eventListenerCode);
        }
        this.addEventListener('beforeTabChange', f);
    },

    
    beforeTabChange:function (tabPanel, newTab, currentTab) {
        var canChange = true;

        var tab = this.findTabById(newTab.id);

        var currentTabObj = this.findTabById(currentTab.id);
        var currentTabName = (currentTabObj) ? currentTabObj.name : this.selectedTabName;

        // call user-deined event handler to allow the view to cancel the tab change
        var eventListener = this.getEventListener('beforeTabChange');
        if (valueExists(eventListener)) {
            if (eventListener.call) {
                canChange = eventListener(this, currentTabName, tab.name);
            } else {
                // event listener is a Command
                var context = {
                    tabPanel:this,
                    currentTab:currentTabName,
                    newTab:tab.name
                };
                eventListener.handle(context);
                canChange = context.canChange;
            }
        }

        // if tab change is allowed, check whether we should refresh the next tab page
        if (canChange) {
            if (tab.hasView() && !tab.isContentLoaded) {
                tab.loadView();
            }

            if (this.isRefreshOnSelect() || tab.mustRefresh()) {
                this.refreshTab(tab.name);
            }


            if (currentTabObj && !currentTabObj.isClosed) {
                currentTabObj.showContent(false);
            }
        }

        return canChange;
    },

    
    afterTabChange:function (tabPanel, newTab) {
        var tab = this.findTabById(newTab.id);
        tab.showContent(true);

        // update selected tab name
        this.previouslySelectedTabName = this.selectedTabName;
        this.selectedTabName = tab.name;

        // call Tab handler
        tab.afterSelect();

        // call user-defined event handler
        eventListener = this.getEventListener('afterTabChange');
        if (valueExists(eventListener)) {
            if (eventListener.call) {
                eventListener(this, this.selectedTabName);
            } else {
                // listener is a Command
                var context = {
                    tabPanel:this,
                    selectedTab:this.selectedTabName
                };
                eventListener.handle();
            }
        }
    },

    
    beforeTabClose:function (tabPanel, tabPanelItem) {
        var canClose = true;

        // call user-defined event handler to allow the view to veto the tab close
        eventListener = this.getEventListener('beforeTabClose');
        if (valueExists(eventListener)) {
            if (eventListener.call) {
                canClose = eventListener(this, tabPanelItem.id);
            } else {
                // event listener is a Command
                var context = {
                    tabPanel:this,
                    tabName:tabPanelItem.id
                };
                eventListener.handle(context);
                canClose = context.canClose;
            }
        }

        if (canClose) {
            var tab = this.findTabById(tabPanelItem.id);
            tab.isClosed = true;
        }

        return canClose;
    },

    
    onTabClose:function (tabPanel, tabPanelItem) {
        var tab = this.findTabById(tabPanelItem.id);

        this.tabs.splice(tab.index, 1);

        for (var i = 0; i < this.tabs.length; i++) {
            this.tabs[i].index = i;
        }

        if (this.previouslySelectedTabName != tab.name) {
            this.selectTab(this.previouslySelectedTabName);
        }
    }
}, {
    TAB_HEIGHT:32
});



Ab.tabs.Tab = Ab.view.Component.extend({
    // 0-based tab page index, set when tab is added to the control
    index:0,

    // Ext.TabItem ID, same as the HTML element ID of the tab panel
    id:'',

    // tab name  
    name:'',

    // tab title
    title:'',

    // tab content file name  
    fileName:'',

    // whether to use iframe to load the contnet view
    useFrame:true,

    // whether the tab should be selected by default
    selected:false,

    // whether the tab is enabled initially
    enabled:true,

    // whether the tab is hidden initially
    hidden:false,

    // set to true from the Ab.tabs.Table.hideTab()
    forcedHidden:false,

    // whether the tab panel should use the parent (tabs) restriction
    useParentRestriction:true,

    // whether the tab panel should clear the child panel retsriction
    clearRestriction:false,

    // specific restriction for this tab page; if defined, overrides the parent control restriction
    restriction:null,

    // whether the child panel should be in the new record mode
    newRecord:false,

    // array of child panels within this tab page
    childPanelIds:null,

    // true if the page was created dynamically
    isDynamic:false,

    // true if the page contains a view, and its content has been loaded
    isContentLoaded:false,

    // true if the page contains a view, and its content has being loaded at the moment
    isContentLoading:false,

    // true if the page was already refreshed at least once
    isRefreshed:false,

    // true if the page is closed by the user
    isClosed:false,

    // Ext.ux.ManagedIFrame for this tab
    frame:null,

    // Ext.Panel for this tab
    tabPanel:null,

    // Ab.tabs.Tabs parent object
    parentPanel:null,

    // initial configuration object
    config:null,

    
    constructor:function (config) {
        this.config = config;
        Ext.apply(this, config);
        this.enabled = true;
        this.hidden = false;
        this.childPanelIds = [];
        if (valueExists(this.config.title)) {
            //KB#3030009: IE displays XML encoded value from *.lang files
            this.config.title = convertFromXMLValue(this.config.title);
        }
        this.eventListeners = new Ext.util.MixedCollection(true);
    },

    
    evaluateExpressions:function (ctx) {
        if (this.forcedHidden) {
            return;
        }

        var evaluatedTitle = Ab.view.View.evaluateString(this.config.title, ctx);
        if (evaluatedTitle.indexOf('${') == -1) {
            this.tabPanel.setTitle(evaluatedTitle);
        }

        if (!this.parentPanel.isWorkflowEnforced()) {
            var evaluatedEnabled = Ab.view.View.evaluateBoolean(this.config.enabled, ctx, true);
            this.enable(evaluatedEnabled);
        }

        var evaluatedHidden = Ab.view.View.evaluateBoolean(this.config.hidden, ctx, false);
        this.show(!evaluatedHidden);
    },

    
    setTabPanel:function (tabPanel) {
        this.tabPanel = tabPanel;
        this.id = tabPanel.id;

        this.frame = new Ext.ux.ManagedIFrame(this.name);

        this.syncHeight.defer(100, this);
    },

    
    createTabPanel:function (callback) {
        // create managed iframe
        this.frame = new Ext.ux.ManagedIFrame({
            autoCreate: {
                id: this.name + '_frame',
                width:'100%', height:'100%'
            }
        });
        this.frame.setStyle('border', 'none');

        // load view content into iframe
        this.loadView(callback);

        // create Ext.Panel with the iframe as content
        var tabPanel = this.parentPanel.tabPanel.add({
            id:this.name,
            title:this.title,
            contentEl:this.frame,
            autoWidth:true,
            autoHeight:true,
            border:false,
            closable:true
        });
        this.tabPanel = tabPanel;
        this.id = this.name;
    },

    
    addChildPanelId:function (panelId) {
        this.childPanelIds.push(panelId);
    },

    
    loadView:function (callback) {
        this.log('loading view ' + this.fileName);

        if (View.showLoadProgress) {
            View.openProgressBar();
        }

        this.callback = callback;
        this.isContentLoading = true;

        this.frame.setSrc(this.fileName, true);
    },

    
    afterLoadView:function (childView) {
        this.log('Child view loaded');
        this.isContentLoading = false;
        this.syncHeight();

        // set the initial tab title from the view
        this.setTitle(childView.title);

        this.log('Before refreshing child view');

        if (valueExists(this.callback) && typeof this.callback == 'function') {
            // if the callback is specified in the Ab.tabs.Tabs.createTabPage()
            this.callback();

        } else if (valueExists(this.restriction) || this.newRecord) {
            childView.refresh(this.restriction, this.newRecord, this.clearRestriction);
        }
        this.isRefreshed = true;
        this.isContentLoaded = true;

        View.closeProgressBar();

        var listener = this.getEventListener('afterLoad');
        if (listener) {
            listener(this, childView);
        }

        this.log('After refreshing child view');
    },

    
    getContentFrame:function () {
        var iframe = null;
        if (this.hasView()) {
            iframe = this.frame.getWindow();
        }
        return iframe;
    },

    
    setTitle:function (title) {
        if (title && title.indexOf("${") == -1 && title != '') {
            this.title = title;
            this.config.title = title;
            this.tabPanel.setTitle(title);
        }
    },

    
    mustRefresh:function () {
        return (this.isDynamic && !this.isRefreshed);
    },

    
    refresh:function (restriction) {
        if (valueExists(this.restriction)) {
            restriction = this.restriction;
        }

        // apply the restriction to the first panels within the selected tab
        if (this.hasView()) {
            // apply restriction to the content View if it has been fully loaded
            if (!this.isContentLoading) {
                var iframe = this.getContentFrame();
                var childView = iframe.View;

                // child view object does not exist for pre-16.3 views (MDX) 
                if (valueExists(childView)) {
                    // refresh child view
                    childView.refresh(restriction, this.newRecord, this.clearRestriction);
                }
                this.isRefreshed = true;
            }

        } else {
            // apply restriction to the main panel
            for (var i = 0; i < this.childPanelIds.length; i++) {
                var panelId = this.childPanelIds[i];
                var panel = View.panels.get(panelId);

                if (panel.useParentRestriction) {
                    panel.refresh(restriction, this.newRecord);
                } else {
                    panel.refresh();
                }
                this.isRefreshed = true;
                // we only want to refresh the first panel in the tab;
                // presumably the tab can have many panels, but the first one must be "main"
                // and should apply restrictions to other panels as neccessary
                break;
            }
        }
    },

    
    afterSelect:function () {
        if (this.hasView()) {
            if (this.isContentLoading) {
                this.afterSelect.defer(100, this);
            }
            else {
                var iframe = this.getContentFrame();
                if (iframe != null && valueExists(iframe.View) && valueExists(iframe.user_form_afterSelect)) {
                    iframe.user_form_afterSelect();
                }

                var listener = this.getEventListener('afterSelect');
                if (listener) {
                    listener(this);
                }
                
                if (iframe != null && valueExists(iframe.View)) {
                	// 3038264
                	for(var i=0; i<iframe.View.panels.length; i++){
                		var panel = iframe.View.panels.get(i);
                		if (panel && panel.type == 'grid') {
                			panel.updateHeight();
                		}
                	}
                }
            }
        } else {
        	for(var i=0; i<this.childPanelIds.length; i++){
        		var panel = View.panels.get(this.childPanelIds[i]);
        		if (panel && panel.type == 'grid') {
        			panel.updateHeight();
        		}
        	}
        }
    },

    
    showContent:function (visible) {
        if (this.hasView()) {
            var iframe = this.getContentFrame();
            if (iframe != null && valueExists(iframe.View)) {
                var panel = iframe.View.getMainPanel();
                if (panel) {
                    panel.showActions(visible);
                }
            }
        } else {
            for (var i = 0; i < this.childPanelIds.length; i++) {
                var panelId = this.childPanelIds[i];
                var panel = View.panels.get(panelId);
                panel.showActions(visible);
            }
        }
    },

    
    syncHeight:function () {
        // adjust IFRAME height
        if (this.hasView() && !this.isContentLoading) {
            var parentRegion = this.parentPanel.getLayoutRegion();
            if (parentRegion) {
                // the parent tab panel is in the layout region
                var parentHeight = Ext.get(parentRegion.contentEl).parent().getHeight();
                this.frame.setHeight(parentHeight - this.parentPanel.getTabStripHeight() - 8);
            } else {
                // the parent tab panel is in another tab
                var parentHeight = this.parentPanel.tabHeight;
                this.frame.setHeight(parentHeight - this.parentPanel.getTabStripHeight());
                // review and test in Bali 2
                // this.frame.setHeight(parentHeight - this.parentPanel.getTabStripHeight() - (Ext.isIE ? 4 : 0));
            }
        }

        // if this tab contains panels, adjust their heights
        if (!this.hasView()) {
            for (var i = 0; i < this.childPanelIds.length; i++) {
                var panel = View.panels.get(this.childPanelIds[i]);
                if (panel) {
                    panel.parentTab = this;
                }
            }

            // the first and only panel should occupy the whole tab
            var panel = View.panels.get(this.childPanelIds[0]);
            if (panel && (panel.type === 'tabs' || panel.type === 'chart' || panel.type == 'htmlPanel')) {
                panel.syncHeight();
            }
            if (panel && panel.type === 'grid') {
                panel.updateHeight();
            }

            // the last panel should occupy the space remaining from other panels
            if (this.childPanelIds.length > 1) {
                var panel = View.panels.get(this.childPanelIds[this.childPanelIds.length - 1]);
                if (panel) {
                    panel.updateHeight();
                }
            }
        }

        // show or hide tab content
        this.showContent(this.name == this.parentPanel.selectedTabName);
    },

    
    hasView:function () {
        return this.useFrame && valueExistsNotEmpty(this.fileName);
    },

    
    hasChanges:function () {
        var hasChanges = false;
        if (this.hasView()) {
            var iframe = this.getContentFrame();
            hasChanges = iframe.afm_form_values_changed;
        }
        return hasChanges;
    },

    
    enable:function (enabled) {
        if (enabled) {
            this.tabPanel.enable();
        } else {
            this.tabPanel.disable();
        }
    },

    
    show:function (visible) {
        this.hidden = !visible;
        if (visible) {
            this.parentPanel.showTab(this.name);
        } else {
            this.parentPanel.hideTab(this.name);
            this.parentPanel.selectFirstVisibleTab();
        }
    },

    log:function (message) {
        message = String.format('Tab panel [{0}], tab [{1}]: {2}', this.parentPanel.id, this.name, message);
        View.log(message);
    }
});

Ab.namespace('form');



Ab.form.ValidationResult = Base.extend({
    
    // whether all form field values are valid
    valid: true,
    
    // validation message to be displayed
    message: '',
    
    // detailed validation message to be displayed
    detailedMessage: '',
    
    // object that contains invalid field names and associated error messages
    invalidFields: null,
    
    constructor: function() {
        this.invalidFields = {};
    }
});


Ab.form.FieldBase = Base.extend({
    // parent form panel
    panel: null,

    // original config object
    config: null,

    // Ext.util.MixedCollection of field actions
    actions: null,

    constructor: function(panel, config) {
        this.panel = panel;
        this.config = config;

        this.actions = new Ext.util.MixedCollection();
        if (valueExists(config.actions)) {
            for (var i = 0; i < config.actions.length; i++) {
                this.addAction(config.actions[i]);
            }
        }
    },

    addAction: function(config) {
        config.useExtButton = false;
        var action = new Ab.view.Action(this.panel, config);
        this.actions.add(action.id, action);
    }

});


Ab.form.Field = Ab.form.FieldBase.extend({
    // field DOM element
    dom: null,
    
    // Ab.data.FieldDef
    fieldDef: null,
	
	// true if the field is hidden
	hidden: false,

    // Ext.util.MixedCollection of custom event listeners for form field.
	// Collection holds function. Function code is from application js files
    docFieldEventListeners: null,    

    // true if the field should have focus on form load
    focus: false,

    // title before evaluation
    unevaluatedTitle: null,

    
    constructor: function(panel, config) {
        this.inherit(panel, config);

        this.focus = config.focus;
        this.fieldDef = new Ab.data.FieldDef(config);
		this.unevaluatedTitle = this.title;
        this.dom = this.panel.getFieldElement(this.getId());

        // attach mouse hover listener to the parent TD element, to reveal Select Value buttons
        var fieldCell = null;
        if (this.dom) {
            fieldCell = this.dom.parentNode;
        } else {
            fieldCell = $(panel.id + '_' + this.getId() + '_fieldCell');
        }
        if (fieldCell) {
            fieldCell.onmouseover = function() {
                Ext.get(this).addClass('hovered');
            };
            fieldCell.onmouseout = function() {
                Ext.get(this).removeClass('hovered');
            };
        }

        if (this.dom) {
            if (this.fieldDef.rowspan > 1 && this.fieldDef.format === 'Memo') {
                var labelHeight = ('top' === this.panel.labelsPosition) ? 22 : 0;
                var fieldHeight = 22;
                var cellHeight = 26;

                Ext.get(this.dom).setHeight(fieldHeight + (this.fieldDef.rowspan - 1) * (labelHeight + cellHeight));
            }
        }

        if (config.isDocument) {
            // functions ARE stored within collection, not only event name, function name
            this.docFieldEventListeners = new Ext.util.MixedCollection(true);
		}
    },

    
    evaluateExpressions: function(ctx) {
        var id = this.getId();
        
        var evaluatedReadOnly = Ab.view.View.evaluateBoolean(this.config.readOnly, ctx, false);
 		if (evaluatedReadOnly != this.fieldDef.readOnly) {
	        this.fieldDef.readOnly = evaluatedReadOnly;
			this.panel.enableField(id, !evaluatedReadOnly);
		}
       
        var evaluatedHidden = Ab.view.View.evaluateBoolean(this.config.hidden, ctx, false);
		if (evaluatedHidden != this.hidden) {
	        this.hidden = evaluatedHidden;
			this.panel.showField(id, !evaluatedHidden);
		}
        
        var evaluatedTitle = Ab.view.View.evaluateString(this.config.title, ctx, false);
		if (evaluatedTitle != this.fieldDef.title) {
			this.panel.setFieldLabel(id, evaluatedTitle);
		}

		var evaluatedValue = Ab.view.View.evaluateString(this.config.value, ctx, false);
		if (evaluatedValue != this.fieldDef.value) {
	        this.fieldDef.value = evaluatedValue;
	        this.panel.record.setValue(id, evaluatedValue);
			this.setUIValue(evaluatedValue);
		}
        
        this.actions.each(function(action) {
            action.evaluateExpressions(ctx);
        });
    },
    
    
    getId: function() {
        return this.fieldDef.id;
    },
    
    
    getFullName: function() {
        return this.fieldDef.fullName;
    },
    
    
    getInitialValue: function() {
        return this.fieldDef.value;
    },
    
    
    getStoredValue: function() {
        return this.panel.record.getValue(this.getId());
    },

        
    setStoredValue: function(value) {
        this.panel.record.setValue(this.getId(), value);
    },
    
    
    getUIValue: function() {
        return this.panel.getFieldValue(this.getId());
    },
    
    
    setUIValue: function(value, neutralValue, doValidation) {
        this.panel.setFieldValue(this.getId(), value, neutralValue, doValidation);
    },

    
    getInstructionsEl: function() {
        return Ext.get(this.panel.getFieldElementName(this.getId()) + '_instructionsText');
    },
    
    
    clear: function() {
        if (this.panel.isConsole && this.fieldDef.isEnum) {
			this.addAllToEnumFieldForConsole();
        }

        this.panel.setFieldTooltip(this.getId(), '');
        //XXX: don't doing validation since default values come from  DB schema
        this.setUIValue(this.getInitialValue(), null, false);
        
        if (this.fieldDef.controlType === 'image') {
            this.panel.clearImage(this.getId());
        }
    },
    
    
    addAllToEnumFieldForConsole: function(){
	     // if the empty label has not yet been added
	     if (this.dom && this.dom.firstChild && this.dom.firstChild.text != "") {
		     var newOption = document.createElement('option');
		     newOption.value = "";
	    	 newOption.appendChild(document.createTextNode(""));
	     	 this.dom.insertBefore(newOption, this.dom.firstChild);
		}
	},

    clearOptions: function() {
        if (this.fieldDef.controlType === 'comboBox') {
            for (var i = this.dom.length - 1; i >= 0; i--) {
                this.dom.remove(i);
            }
        }
    },

    
    addOption: function(value, title) {
        var newOption = document.createElement('option');
        newOption.value = value;
        newOption.appendChild(document.createTextNode(title));
        this.dom.appendChild(newOption);
    },

    
    removeOptions: function(values) {
        if (this.fieldDef.controlType === 'comboBox') {
        	for (var x in values) {
        		for (var i = this.dom.length - 1; i >= 0; i--) {
        			if (x == this.dom[i].value) {
        				this.dom.remove(i);
        				break;
        			}
        		}
            }
        }
    },
    
    
    syncToUI: function() {
        var value = this.getStoredValue();
        if (valueExists(value)) {
            var neutralValue = value;
            // format object value into localized string
            value = this.fieldDef.formatValue(value, true, false);
            this.setUIValue(value, neutralValue);
        }
        return value;
    },
    
    
    syncFromUI: function() {
        var value = this.getUIValue();
        if (valueExists(value)) {
            // parse localized string into object value
            value = this.fieldDef.parseValue(value, false);
            this.setStoredValue(value);
        }
        return value;
    },
    
    
    setInvalid: function(message) {
        this.panel.addInvalidField(this.getId(), message);
    },

	
    addDocumentFieldEventListener: function(eventName, listenerFunction, scope) {
		// non-document fields do not have an initialized collection
		if (!this.docFieldEventListeners) {
			return;
		}

		// eventHandler may be a function reference or a function name
		var eventHandler = null;
		if (typeof listenerFunction == 'function')
		{
			eventHandler = listenerFunction;
		}
		else {
			View.controllers.each(function (controller) {
				var func = controller[listenerFunction];
				if (valueExists(func) && func.constructor == Function) {
					eventHandler = func;
					return;
				}
			});
		}

		if (valueExists(eventHandler)) {
			// if scope is provided create a delegate within the given scope
			if (valueExists(scope)) {
                eventHandler = eventHandler.createDelegate(scope);
			}
			// insert or update
			if (this.docFieldEventListeners.containsKey(eventName)) {
				this.docFieldEventListeners.replace(eventName, eventHandler);
			} else {
				this.docFieldEventListeners.add(eventName, eventHandler);
			}
		}
		else {
			var message = 'The document field listener for event ' + eventName + ' was not found';
			View.showMessage('message', message);
		}
    },

    
    getDocumentFieldEventListener: function(eventName) {
        return this.docFieldEventListeners.get(eventName);
    },
    
    
    removeDocumentFieldEventListener: function(eventName) {
        this.docFieldEventListeners.removeKey(eventName);  
    }

});


Ab.form.FieldSet = Ab.form.FieldBase.extend({
    // Ext.util.MixedCollection of nested fields
    fields: null,

    
    constructor: function(panel, config) {
        this.inherit(panel, config);

        this.fields = new Ext.util.MixedCollection();
        for (var i = 0; i < config.fieldDefs.length; i++) {
            var fieldDef = config.fieldDefs[i];
            var field = new Ab.form.Field(panel, fieldDef);
            panel.fields.add(fieldDef.id, field);
            this.fields.add(fieldDef.id, field);
        }
    }
});


Ab.form.Form = Ab.view.Component.extend({
    
    // HTML form ID
    formId: '',
    
	// view definition to be displayed
	viewDef: null,
    
	// Ext.util.MixedCollection of Ab.form.Field objects
	fields: null,

    // Ext.util.MixedCollection of Ab.form.FieldSet objects
    fieldsets: null,

    // name of the default WFR used to get the default record
    clearWorkflowRuleId: '',
    
    // name of the default WFR used to get the record
    refreshWorkflowRuleId: '',
    
    // name of the default WFR used to get the record
    saveWorkflowRuleId: '',
    
    // name of the default WFR used to delete the current record
    deleteWorkflowRuleId: '',
    
    // validation result object
    validationResult: null,
    
    // whether this form is used to edit new (unsaved yet) record
    newRecord: false,
    
    // whether the form should display its field values on load
    showOnLoad: false,
    
    // data record retrieved from the server - Ab.data.Record
    record: null,
    
    // default field values
    defaultRecord: null,
    
    // current form is a console or a regular form
    isConsole: false,

    // position of form label element, either to 'left' in same table row or 'top' in previous table row
	labelsPosition: 'left',
    
    // number of columns 
    columns: 1,
	    
    // ----------------------- initialization ------------------------------------------------------
    
    
	constructor: function(id, configObject) {
        this.inherit(id, 'form', configObject);  
        this.viewDef = new Ab.view.ViewDef(configObject.getConfigParameter('viewDef'), configObject.getConfigParameter('groupIndex'), null, null, configObject.getConfigParameter('dataSourceId'));
        this.formId = configObject.getConfigParameter('panelId');       
                
        this.isConsole = configObject.getConfigParameter('isConsole', false);
        this.labelsPosition = configObject.getConfigParameter('labelsPosition', 'left');
        this.showOnLoad = configObject.getConfigParameter('showOnLoad', false);
        this.newRecord = configObject.getConfigParameter('newRecord', false);
        if (this.newRecord == false) {
            this.newRecord = Ab.view.View.newRecord;
        }

        // create field definitions
        this.fields = new Ext.util.MixedCollection();
        this.fieldsets = new Ext.util.MixedCollection();

        var fieldDefs = configObject.getConfigParameter('fieldDefs');
        for (var i = 0; i < fieldDefs.length; i++) {
            var fieldDef = fieldDefs[i];

        	if ('fieldset' === fieldDef.type) {
                this.fieldsets.add(fieldDef.id, new Ab.form.FieldSet(this, fieldDef));
        	} else {
                this.fields.add(fieldDef.id, new Ab.form.Field(this, fieldDef));
	        }
        }
        
        // store initial field values        
        this.record = new Ab.data.Record(this.getFieldValues());
        this.defaultRecord = new Ab.data.Record(this.getFieldValues());
        
        // add specified event listeners
        this.addEventListenerFromConfig('beforeSave', configObject);
        this.addEventListenerFromConfig('beforeDelete', configObject);
        this.addEventListenerFromConfig('onAutoCompleteClear', configObject);
        this.addEventListenerFromConfig('onAutoCompleteQuery', configObject);
        this.addEventListenerFromConfig('onAutoCompleteSelect', configObject);

        this.refreshWorkflowRuleId = configObject.getConfigParameterNotEmpty('refreshWorkflowRuleId',
            Ab.form.Form.WORKFLOW_RULE_REFRESH);        
		this.saveWorkflowRuleId = configObject.getConfigParameterNotEmpty('saveWorkflowRuleId', 
            Ab.form.Form.WORKFLOW_RULE_SAVE);
		this.deleteWorkflowRuleId = configObject.getConfigParameterNotEmpty('deleteWorkflowRuleId', 
            Ab.form.Form.WORKFLOW_RULE_DELETE);
		this.clearWorkflowRuleId = configObject.getConfigParameterNotEmpty('clearWorkflowRuleId', 
            Ab.form.Form.WORKFLOW_RULE_CLEAR);
        
        this.updateDocumentButtons();
        
        this.visible = true;
        
        this.columns = configObject.getConfigParameter('columns', 1);
    },
    
    // ------------------------ common control API methods -----------------------------------------

    
    getScrollableEl: function() {
        return null;
    },

    
    getParentElementId: function() {
        return this.id + '_body';
    },
    
    
    initialDataFetch: function() {
        if (this.isConsole) {
            this.clear();
        } else if ((this.showOnLoad || this.restriction != null || this.newRecord) && 
                    this.viewDef.dataSourceId != 'none') {
            this.refresh();
        }
        this.show(this.showOnLoad);

        var autoComplete = new Ab.form.AutoComplete();
        autoComplete.addAutoCompleteToFormFields.defer(1000, autoComplete, [this]);
    },

    
    show: function(show, includeHeader) {
        this.inherit(show, includeHeader);

        if (this.visible) {
            this.setFocusField();
        }
    },

    
    setFocusField: function() {
        var firstFocusField = this.fields.find(function(field) {
            return (field.focus);
        });

        if (firstFocusField) {
            var focusInput = this.getFieldElement(firstFocusField.getId());
            if (focusInput) {
                focusInput.focus();
            }
        }
    },

    
    clear: function() {
        this.fields.each(function(field) {
            field.clear();
        });

        this.defaultRecord = new Ab.data.Record(this.getFieldValues());
        
        this.clearValidationResult();
    },
    
    
    createEvaluationContext: function() {
        var ctx = this.inherit();
        ctx['record'] = this.record.values;
        return ctx;
    },

    
    evaluateExpressions: function(ctx) {
		this.inherit();
		if (!ctx) {
			ctx = this.createEvaluationContext();
		}

        this.fields.each(function(field) {
            field.evaluateExpressions(ctx);
        });
        
        this.updateDocumentButtons();
    },
    
    
    doRefresh: function() {
        this.clear();
        this.clearValidationResult();
        
        var workflowRuleName = (this.newRecord == true) ? this.clearWorkflowRuleId : this.refreshWorkflowRuleId;
        
        // retrieve record data from the server
        try {
            var result = Workflow.call(workflowRuleName, this.getParameters(false));
           
		    var record = this.getDataSource().processInboundRecord(result.dataSet);
			this.setRecord(record);
            
            // show the control
            this.show(true);
		} catch (e) {
		    this.validationResult.valid = false;
		    this.displayValidationResult(e);
		}

        // fill in default values
        if (this.newRecord) {
            this.fields.eachKey(function(fieldName) {
                var defaultValue = this.defaultRecord.getValue(fieldName);      
                if (valueExistsNotEmpty(defaultValue)) {	
                	var fieldDef = this.fields.get(fieldName).fieldDef;
                	if (fieldDef.isEnum) {
                        // KB 3023304: default enumerated value is always retrieved from the server
                		// KB 3024694: unless a value is explicitly set in AXVW
                		var isFirstEnumValue = true;
                		for (var enumKey in fieldDef.enumValues) {
                			// do not set the value if it matches the first enumerated value
                			// (this happens if the value is not defined in AXVW)
                		    if (enumKey === defaultValue && !isFirstEnumValue) {
                		    	this.setFieldValue(fieldName, defaultValue);
                		    	break;
                		    }
                		    isFirstEnumValue = false;
                		}
                	} else if (!fieldDef.isNumber() || defaultValue > 0) {
                        // KB 3021389, 3022631 - do not set the numeric field's default value if it is 0,
                        // as the value has been reset in setRecord(record).
                        this.setFieldValue(fieldName, defaultValue);
                    }
                }
            }, this);
        }

        if (Ext.isIE) {
            Placeholders.refresh();
        }
    },
    
    
    save: function(workflowRuleId) {
        if (!valueExists(workflowRuleId)) {
            workflowRuleId = this.saveWorkflowRuleId;
        }
        if (this.canSave()) {
            try {
                var result = Workflow.call(workflowRuleId, this.getParameters(true));
				Workflow.callMethod('AbSpaceRoomInventoryBAR-SchoolHandler-writeLog',this.getOutboundRecord(),"INSERTED");
    		    if (valueExists(result.dataSet)) {
    		    	//XXX: new record save will return result.dataSet as object
                    var record = this.getDataSource().processInboundRecord(result.dataSet);
        	        this.setRecord(record);
        	        this.newRecord = false;
        	        this.refresh(this.getPrimaryKeyRestriction());
        		    this.displayValidationResult(result);
    		    }else{
    		        this.updateOldFieldValues();
    		    	// XXX: not new record will return result.dataSet as undefined
    		    	this.newRecord = false;
    		    	// XXX: presenting result.message to UI
    		    	this.displayValidationResult(result);
    		    }
    		} catch (e) {
    		    this.validationResult.valid = false;
    		    this.displayValidationResult(e);
    		}
        }
            
        // return false (stop chained command execution) if validation or save has failed
        return this.validationResult.valid;
    },

    
    canSave: function() {
        this.clearValidationResult();
        
        var beforeSaveListener = this.getEventListener('beforeSave');
        if (beforeSaveListener) {
            var proceed = beforeSaveListener(this);
            if (valueExists(proceed) && proceed == false) {
                this.validationResult.valid = false;
                this.displayValidationResult();
                // stop chained command execution
                return false;
            }
        }
        //XXX: don't show each individual field validation message to avoid duplicated messages
        return this.validateFields(false);
    },
    
    
    
    deleteRecord: function() {
        this.clearValidationResult();
 
        // call user-defined callback function
        var beforeDeleteListener = this.getEventListener('beforeDelete');
        if (beforeDeleteListener) {
            var proceed = beforeDeleteListener(this);
            if (valueExists(proceed) && proceed == false) {
    		    this.validationResult.valid = false;
    		    this.displayValidationResult();
    		    // stop chained command execution
                return false;
            }
        }
        
        var parameters = this.getParameters(true);
        parameters.fieldValues = parameters.oldFieldValues;

        // call WFR to save form values        
        var result = Workflow.runRuleAndReturnResult(
            this.deleteWorkflowRuleId, 
            parameters,
            this.afterDelete,
            this);
		if (result.code == 'executed') {
		    this.displayValidationResult(result);
			Workflow.callMethod('AbSpaceRoomInventoryBAR-SchoolHandler-writeLog',this.getOutboundRecord(),"DELETED");
		} 
		else {
		    this.validationResult.valid = false;
		    this.displayValidationResult(result);
		}
            
        // return false (stop chained command execution) if delete has failed
        return this.validationResult.valid;
    },

    
    getRecord: function() {
        this.fields.each(function(field) {
            field.syncFromUI();
        });
        return this.record;  
    },
    
    
    setRecord: function(record) {
        this.record = record;
        this.onModelUpdate();
    },

    
    onModelUpdate: function() {
        this.fields.each(function(field) {
            field.syncToUI();
        });

        // show or hide document buttons
        this.updateDocumentButtons();

        // force view-wide expression evaluation
        //View.evaluateExpressions();
        
        // use panel-wide expression evaluation instead 
        this.evaluateExpressions(); 

        var message = String.format('Form model updated: {0}', this.id);
        View.log(message);
    },
    
    // -----------------------currency or unit text -------------------------
    
    showFieldDescription: function(fieldId, descriptionTxt) {
		var descriptionTxtElId = fieldId + '_descriptionText';
		var descriptionTxtEl = Ext.get(descriptionTxtElId);
		if(descriptionTxtEl === null){
			var fieldEl = this.getFieldElement(fieldId);
			var brEl = Ext.DomHelper.insertAfter(fieldEl, {
				tag: 'br'
		    }, true);
			
			descriptionTxtEl = Ext.DomHelper.insertAfter(brEl, {
				tag: 'span', 
				id: descriptionTxtElId, 
				cls: 'showingDateAndTimeLongFormat'
		    }, true);
		}
		
		descriptionTxtEl.dom.innerHTML = descriptionTxt;
    },
    
    // ----------------------- implementation ------------------------------------------------------
    
    
    validateFields: function(showFieldValidationMessage) {
    	if(!valueExists(showFieldValidationMessage)){
    		showFieldValidationMessage = true;
    	}
        this.fields.eachKey(function(fieldName) {
            var fieldInput = this.getFieldElement(fieldName);
            if (valueExists(fieldInput)) {
                var isValid = this.validateField(fieldName, true, showFieldValidationMessage);
                if (!isValid) {
                    this.addInvalidField(fieldName, '');
                }
            }
        }, this);
        
        if (this.validationResult.valid == false) {
            this.displayValidationResult();
        }
        return this.validationResult.valid;
    },
    
    
    addInvalidField: function(fieldName, fieldError) {
        this.validationResult.valid = false;
        this.validationResult.message = this.getLocalizedString(Ab.form.Form.z_MESSAGE_INVALID_FIELD);
        this.validationResult.invalidFields[fieldName] = fieldError;
    },
    
    
    getOutboundRecord: function() {
        var record = new Ab.data.Record();
        record.isNew = this.newRecord;
        record.values = this.getFieldValues(true);
        record.oldValues = this.getOldFieldValues();
        return this.getDataSource().processOutboundRecord(record);
    },
    
    
    getParameters: function(includeFieldValues) {
        var parameters = {
            viewName:    this.viewDef.viewName,
			groupIndex:  this.viewDef.tableGroupIndex,
            controlId:   this.id,
            isNewRecord: this.newRecord,
            version:     Ab.view.View.version
        };
        if (this.restriction != null) {
            parameters.restriction = toJSON(this.restriction);
        }
        if (this.viewDef.dataSourceId != null) {
			parameters.dataSourceId = this.viewDef.dataSourceId;
		}
		if (includeFieldValues) {
            parameters.fieldValues = toJSON(this.getFieldValues(true));
            parameters.oldFieldValues = toJSON(this.getOldFieldValues());
        }

        Ext.apply(parameters, this.parameters);

        return parameters;
    },

    
    getFieldQueryParameter: function(fieldName) {
        var queryParameter = " IS NOT NULL";

        if (this.hasFieldMultipleValues(fieldName)) {
            var values = this.getFieldMultipleValues(fieldName);
            queryParameter = " IN ('" + values.join("','") + "')";
        } else {
            var value = this.getFieldValue(fieldName);
            if (value) {
                queryParameter = " = '" + value + "'";
            }
        }

        return queryParameter;
    },

    
    getFieldRestriction: function() {
        var restriction = new Ab.view.Restriction();
        var form = this;

        this.fields.each(function(field) {
            var value = field.getUIValue();
            if (field.fieldDef.type == 'java.lang.Double'){
            	value = field.fieldDef.formatValue(value, true, false);
          	}
            if (valueExistsNotEmpty(value)) {
            	var fieldName = field.getFullName();
            	if (form.hasFieldMultipleValues(fieldName)) {
            		restriction.addClause(fieldName, form.getFieldMultipleValues(fieldName), 'IN');
            	} else {
                    if (value == 'NULL' || value == 'NOT NULL') {
                        restriction.addClause(fieldName, null, 'IS ' + value);
                    }
                    else {
                        restriction.addClause(fieldName, value, field.fieldDef.op);
                    }
            	}
            }
        });
        return restriction;
    },

    
    setFieldRestriction: function(restriction) {
        var form = this;

        this.fields.each(function(field) {
            var id = field.getId();
            var clause = restriction.findClause(id);
            if (clause) {
                form.setFieldValue(id, clause.value);
            } else {
                form.setFieldValue(id, '');
            }
        });
    },
    
    
    getFieldValues: function(includeEmptyValues) {
        includeEmptyValues = includeEmptyValues || false;
        
        var fieldValues = {};
        this.fields.each(function(field) {
            //YS: KB 3021139, 3021138, and 3019543 (to support hidden time fields, renderHiddenField() of PanelSimpleTag.java
            //is also updated to include stored-value input)
            
            	
            //KB3024142-skip special fields with controlType="..." ("link" case is ok in form???)
            if (valueExists(field.fieldDef) && valueExists(field.fieldDef.controlType) && valueExists(field.fieldDef.controlType) &&  field.fieldDef.controlType != 'image'){
            	var value = field.getUIValue();  
	            if ((includeEmptyValues && valueExists(value)) || valueExistsNotEmpty(value)) {
	                fieldValues[field.getId()] = value;
	            }
            }
        });
        return fieldValues;
    },

    
    hasFieldValues: function() {
        var result = false;
        this.fields.each(function(field) {
            var value = field.getUIValue();            
            if (valueExistsNotEmpty(value)) {
                result = true;
            }
        });
        return result;
    },
     
    
    getOldFieldValues: function() {
        var oldValues = {};
        this.fields.each(function(field) {
            var value = field.getStoredValue();
            if (value != null) {
                value = field.fieldDef.formatValue(value, false);
                oldValues[field.getId()] = value;
            }
        });
        return oldValues;
    },
    
    
    updateOldFieldValues: function() {
        this.fields.each(function(field) {
            var value = field.getUIValue();
            if (value != null) {
                value = field.fieldDef.formatValue(value, false);
                field.setStoredValue(value);
            }
        });
    },
    
    
    containsField: function(fieldName) {
    	return (this.getFieldElement(fieldName) != null);
    },
    
    
    getFieldValue: function(fieldName) {
        //XXX: JSON doesn't need encoding of five XML special characters
        //convertFromXMLValue() defined in common.js to decode XML's five special characters
        //getInputValue() defined in edit-forms.js to encode XML's five special characters
        var value = '';
        var fieldElement = this.getFieldElement(fieldName);
        if (fieldElement != null && valueExists(fieldElement.value)) {
            // do not return the placeholder value that in IE is the same as the field value
            if (fieldElement.getAttribute('placeholder') === fieldElement.value) {
                value = '';
            } else {
                value = trim(fieldElement.value);
            }

            var field = this.fields.get(fieldName);
            var type = field.fieldDef.type.toUpperCase();
            var format = field.fieldDef.format.toUpperCase();
            
            value = convertFieldValueIntoValidFormat(type, format, value);
            if (type != "JAVA.SQL.TIME") {
                value = convert2validXMLValue(value);
            } else {
                var fieldEl = this.getFieldElement(fieldName, "Stored");
                if (fieldEl) {
                    value = fieldEl.value;
                }
            }
            
            value = convertFromXMLValue(value);
        
        } else {
            // not a simple field - try getting radio buttons
            var form = document.forms[this.formId];
            var buttonGroupName = this.getFieldElementName(fieldName);
            var buttonGroup = form[buttonGroupName];
            if (buttonGroup) {
                for (var i = 0; i < buttonGroup.length; i++) {
                    if (buttonGroup[i].checked) {
                        value = buttonGroup[i].value;
                        break;
                    }
                }
            }
        }

        return value;
    },

    
    getCheckboxValues: function(fieldName) {
        var values = [];

        var form = document.forms[this.formId];
        var buttonGroupName = this.getFieldElementName(fieldName);
        var buttonGroup = form[buttonGroupName];
        if (buttonGroup) {
            for (var i = 0; i < buttonGroup.length; i++) {
                if (buttonGroup[i].checked) {
                    values.push(buttonGroup[i].value);
                }
            }
        }

        return values;
    },
    
    
    setFieldValue: function(fieldName, localizedValue, neutralValue, doValidation) {
        if (!valueExists(neutralValue)) {
            neutralValue = localizedValue;
        }
        if (!valueExists(doValidation)) {
        	doValidation = true;
        }
        // try to access edit field
        var fieldEl = this.getFieldElement(fieldName);
        if (fieldEl != null) {
            if (fieldEl.tagName == 'SELECT') {
				if (valueExistsNotEmpty(neutralValue)) {
					this.setInputValue(fieldName, neutralValue, doValidation);
				} else {
					fieldEl.selectedIndex = 0;
				}
                
            } else {
                // clear the old field value - otherwise if new value is empty, 
                // the setInputValue() will keep the old value in the field
                fieldEl.value = '';
                
                // KB 3016326, 3019254
                // for date/time field, we need to use the unformatted value 
                // and the formatting takes place in Converting Date/Time function in date-time.js file
                var field = this.fields.get(fieldName);
                var type = field.fieldDef.type.toUpperCase();
                var format = field.fieldDef.format.toUpperCase();
                if (type == 'JAVA.SQL.TIME') {
                    // unformatted value could be like "2007-11-15 18:45:46.0" => time value must like "18:45:46"
                    neutralValue = '' + neutralValue;
                    var timeValue = neutralValue.substring(neutralValue.indexOf(":")-2);
                    timeValue = timeValue.substring(0, 8);
                    this.setInputValue(fieldName, timeValue, doValidation); 
                } else {
            	    this.setInputValue(fieldName, '' + localizedValue, doValidation);
            	    //XXX: 
            	    if(format=='MEMO' && valueExistsNotEmpty(localizedValue)){
            	        localizedValue = localizedValue.replace(/\r\n/g, "<br/>");
            	        if(microsoftIEBrowser){
                            // This causes text area fields to have height of 1px in dialogs.
            	        	// fieldEl.style.height = fieldEl.offsetHeight;
            	        }
            	    }
                }
            }
        } else {
            // not a simple field - try radio buttons
            var form = document.forms[this.formId];
            var buttonGroupName = this.getFieldElementName(fieldName);
            var buttonGroup = form[buttonGroupName];
            if (buttonGroup) {
                for (var i = 0; i < buttonGroup.length; i++) {
                    buttonGroup[i].checked = (buttonGroup[i].value === neutralValue);
                }
            }
        }
      
        // try to access the text label (for date and time)
        var fieldLabel = this.getFieldElement(fieldName, 'Show');
        if (fieldLabel != null) {
            fieldLabel.innerHTML = localizedValue;
        }
        
        // try to access the read-only input
        var readOnlyField = this.getFieldElement(fieldName + '_numeric', 'Show');
        if (readOnlyField == null) {
            readOnlyField = this.getFieldElement(fieldName + '_short', 'Show');
        }
        if (readOnlyField != null) {
            readOnlyField.innerHTML = localizedValue;
        }
    },
   
    
    setInputValue: function(fieldName, fieldValue, doValidation) {
    	if (!valueExists(doValidation)) {
        	doValidation = true;
        }
        // decode special characters previously encoded by getInputValue()
        var field = this.fields.get(fieldName);
        var fieldDef = field.fieldDef;
        
        var type = fieldDef.type.toUpperCase();
        if (type != "JAVA.SQL.DATE" && type != "JAVA.SQL.TIME") {
            fieldValue = convertFromXMLValue(fieldValue);
        }
        
        var fieldEl = this.getFieldElement(fieldName);
        fieldEl.value = fieldValue;
        
        if(doValidation){
        	  this.validateField(fieldName, false);
        }
      
        if (type == "JAVA.SQL.DATE"){
            //"YYY-MM-DD"
            var dateArray = [];
            if (valueExistsNotEmpty(fieldValue)){
                //isBeingISODateFormat() in date-time.js
                if (isBeingISODateFormat(fieldValue)){
                    dateArray = fieldValue.split("-");
                } else {
                    //gettingYearMonthDayFromDate() in date-time.js
                    var temp_date_array = gettingYearMonthDayFromDate(fieldValue);
                    dateArray[0] = temp_date_array["year"];
                    dateArray[1] = temp_date_array["month"];
                    dateArray[2] = temp_date_array["day"];
                }
                validationAndConvertionDateInput(fieldEl, fieldEl.name, dateArray, fieldDef.required, true, true);
            } else {
                validationAndConvertionDateInput(fieldEl, fieldEl.name, null, "false", true, false);
            }
        } else if (type == "JAVA.SQL.TIME"){
            //"HH:MM"
            var timeArray = null;
            if (valueExistsNotEmpty(fieldValue)) {
                timeArray = fieldValue.split(":");
            }
            validationAndConvertionTimeInput(fieldEl, fieldEl.name, timeArray, "false", true, true);
        }
        return true;
    },
    
    
    hasFieldMultipleValues: function(fieldName) {
        var fieldValue = this.getFieldValue(fieldName);
        
        return (fieldValue.indexOf(Ab.form.Form.MULTIPLE_VALUES_SEPARATOR) > 0);
    },
    
    
    getFieldMultipleValues: function(fieldName) {
    	var values;
    	
    	var fieldValue = this.getFieldValue(fieldName);
    	if (this.hasFieldMultipleValues(fieldName)) {
    		values = fieldValue.split(Ab.form.Form.MULTIPLE_VALUES_SEPARATOR);
    	} else {
    		values = [];
    		values.push(fieldValue);
    	}
    	
    	return values;
    },
    
    
    setFieldMultipleValues: function(fieldName, values) {
    	var fieldValue = values.join(Ab.form.Form.MULTIPLE_VALUES_SEPARATOR);
    	this.setFieldValue(fieldName, fieldValue);
    },

    
	setFieldLabel: function(fieldName, fieldLabel) {
		var labelCell = this.getFieldLabelElement(fieldName);
		if (labelCell != null ) {
			labelCell.innerHTML = fieldLabel
			
		} else {
	        // try to access the text label (for date and time)
	        fieldEl = this.getFieldElement(fieldName, 'Show');
			if (fieldEl != null) {
				fieldEl.parentNode.parentNode.firstChild.innerHTML = fieldLabel
			}
       }
	},
	
	
	setFieldTooltip: function(fieldName, tooltipText) {
		var id = this.getFieldElementName(fieldName, '');

		// remove previous tooltip
		Ext.QuickTips.unregister(id);

        // replace multiple value separators by spaces
        // NB: if Ab.form.Form.MULTIPLE_VALUES_SEPARATOR changes, must change the following regex
        tooltipText = tooltipText.replace(/\^/g, " ");
		
		// add new tooltip, if not empty
		if (tooltipText != '') {
	        Ext.QuickTips.register({
	            target: id,
	            text: tooltipText
	        });            
		}
	},

	toUpperCase: function(fieldEl){
    	 var value = fieldEl.value;
    	 if(valueExistsNotEmpty(value)){
    		 fieldEl.value = value.toUpperCase();
    	 }
	},
	
	
    validateField: function(fieldName, bCheckRequiredFields, showValidationMessage) {
		if (!valueExists(showValidationMessage)) {
			showValidationMessage = true;
        }
        var bReturned = true;
        
        var fieldEl = this.getFieldElement(fieldName);
        if (fieldEl != null){
            var field = this.fields.get(fieldName).fieldDef;
            
            var maxsize   = field.size;
            var format    = field.format.toUpperCase();
            var type      = field.type.toUpperCase();
            var decimal   = field.decimals;
            var required  = field.required;
            var multiple  = (field.selectValueType === 'multiple');
            
            //don't work on any enumeration fields
            if (!field.isEnum) {
                //all validation functions are in inputs-validation.js
                //check integer
                if (type == "JAVA.LANG.INTEGER") {
                	bReturned = validationIntegerOrSmallint(fieldEl, showValidationMessage, field);
                     
                } else if (type == "JAVA.LANG.DOUBLE" || type == "JAVA.LANG.FLOAT") {
                	var defaultValue = '';
                	if(valueExistsNotEmpty(field.defaultValue) && field.defaultValue != 'null' && field.defaultValue != 'NULL'){
                		defaultValue = field.formatValue(field.defaultValue, true);
                	}
                	 bReturned = validationNumeric(fieldEl, decimal, showValidationMessage, defaultValue, field);   
                }
                
                if(field.isUpperCase()){
                	this.toUpperCase(fieldEl);
                }
              
                if (format === "UPPERALPHANUM") {
                	 bReturned = validationUPPERALPHANUMString(fieldEl.value, showValidationMessage, field);
                } else if (format === "UPPERALPHA") {
                	 bReturned = validationUPPERALPHAString(fieldEl.value, showValidationMessage, field);
                } 
                
                // check required fields
                if (bCheckRequiredFields && (!validationRequiredField(fieldEl, required ? "true" : "false"))) {
                    bReturned = false;
                }
                
            	if(bReturned){
	                // validate user's input aginst field's maxValue and minValue.
	                if(type == "JAVA.LANG.INTEGER" || type == "JAVA.LANG.DOUBLE" || type == "JAVA.LANG.FLOAT"){
	                	bReturned = doMaxAndMinValidation(fieldEl.value, field, showValidationMessage);
	                }
            	}
                
                if(bReturned){
	                // validate user's input aginst field's schema storage limitation (skip date and time fields, skip multiple-value fields)
	                if (type != "JAVA.SQL.DATE" && type != "JAVA.SQL.TIME" && !multiple) {
	                	bReturned = validationDataMaxSize(fieldEl, field, showValidationMessage);
	                }
                }
            }
        }
        return bReturned;
    },
   
    
    enableField: function(fieldName, enabled) {
        var fieldEl = this.getFieldElement(fieldName);
        if (fieldEl != null) {
            var inputs = fieldEl.parentNode.childNodes;
            for (var i = 0; i < inputs.length; i++) {
                var input = inputs[i];

                if (input.type === 'hidden' || !valueExists(input.type)) {
					// ignore non-inputs
				} else {
				    input.readOnly = !enabled;
                }
			}

            this.enableFieldHover(fieldName, enabled);
		}
        this.enableFieldActions(fieldName, enabled);
    },

    
    enableFieldHover: function(fieldName, enabled) {
        var fieldEl = this.getFieldElement(fieldName);
        if (fieldEl != null) {
            if (enabled) {
                Ext.get(fieldEl.parentNode).removeClass('nohover');
            } else {
                Ext.get(fieldEl.parentNode).addClass('nohover');
            }
        }
    },

    
    enableFieldActions: function(fieldName, enabled) {
		var field = this.fields.get(fieldName);
		if (field != null) {
			field.actions.each(function(action) {
				action.enable(enabled);
			});

            this.enableFieldHover(fieldName, enabled);
		}
    },

    
    showField: function(fieldName, show) {
        var fieldEl = this.getFieldElement(fieldName);
        if (fieldEl != null) {
            var parent = fieldEl.parentNode;
 
             if (this.fieldsets.length > 0) {
            	parent = fieldEl;
            	var selectValue = this.getFieldElement(fieldName + '_selectValue');
            	if (selectValue) {
            		this.showElement(selectValue, show);
            	}
            } else if (this.columns < 2) {
            	while (parent.tagName != 'tr' && parent.tagName != 'TR' && parent.parentNode) {
                	parent = parent.parentNode;
            	}
            } else {
            	this.showElement(parent.previousSibling, show);
            }
            
            this.showElement(parent, show);

			// if label is not in same table row show/hide label (previous sibling)
			if (this.labelsPosition == 'top') {
				parent = fieldEl.parentNode.parentNode.previousSibling;
				if (parent)	{
					var labelElem = parent.firstChild;
					if (labelElem && labelElem.className == "labelTop") {
						this.showElement(parent, show);
					}
				}
			}

            // suppress Select Value on hover if the field is hidden
            this.enableFieldHover(fieldName, show);
        }
    },

	
    getFieldElement: function(fieldName, prefix) {
        return $(this.getFieldElementName(fieldName, prefix), false);
    },

    getFieldElementName: function(fieldName, prefix) {
        var name = '';
        if (valueExists(prefix)) {
            name = prefix;
        }
        return name + this.id + '_' + fieldName;
    },

    
    getFieldLabelElement: function(fieldName) {
    	var id = this.getFieldElementName(fieldName, '') + '_labelCell';
        return $(id, false);
    },

    
    updateDocumentButtons: function() {
        var panelId = this.id;
        this.fields.each(function(field) {
            var fieldDef = field.fieldDef;
            if (fieldDef.isDocument) {
                var panel = field.panel;
                var fullName = fieldDef.fullName;
                
                var documentInput = panel.getFieldElement(fullName);
                documentInput.disabled = panel.newRecord;
                
                var documentValue = panel.getFieldValue(fullName);
                
                var documentExists = (documentValue != '');
                var canShow = documentExists;
                var canCheckIn = (!documentExists && !fieldDef.readOnly && !panel.newRecord);
                var canCheckOut = (documentExists && !fieldDef.readOnly && !panel.newRecord);
				// checkin via file browser if showCheckInDialog attribute is false
				var doBrowseForCheckIn = canCheckIn && !fieldDef.showCheckInDialog;
                
                var prefix = panelId + '_' + fullName;
                
                panel.showElement(prefix + '_showDocument', canShow);
                panel.showElement(prefix + '_checkInNewDocument', canCheckIn && fieldDef.showCheckInDialog);
                panel.showElement(prefix + '_checkInNewDocumentVersion', canCheckOut);
                panel.showElement(prefix + '_checkOutDocument', canCheckOut);
                panel.showElement(prefix + '_lockDocument', canCheckOut);
                panel.showElement(prefix + '_deleteDocument', canCheckOut);

				// turn on only one of text input with buttons or file input
                panel.showElement(prefix, !doBrowseForCheckIn);
                panel.showElement(prefix + '_browseDocument_div', doBrowseForCheckIn);				
			}
        });
    },

	
    addFieldEventListener: function(fieldFullName, eventName, listenerFunction, scope) {
        var field = this.fields.get(fieldFullName);
		if (valueExists(field) && field.fieldDef.isDocument) {
            field.addDocumentFieldEventListener(eventName, listenerFunction, scope);
        }
    },

    
    getFieldEventListener: function(fieldFullName, eventName) {
		var listener = null;
        var field = this.fields.get(fieldFullName);
		if (valueExists(field) && field.fieldDef.isDocument) {
			listener = field.getDocumentFieldEventListener(eventName);
        }
        return listener;
    },
    
    
    removeFieldEventListener: function(fieldFullName, eventName) {
        var field = this.fields.get(fieldFullName);
		if (valueExists(field) && field.fieldDef.isDocument) {
	        field.removeDocumentFieldEventListener(eventName);  
		}
    },
    

	
  	getPrimaryKeyFields: function() {
		var pkFields = [];
        this.fields.each(function(field) {
            if (field.fieldDef.primaryKey) {
				pkFields.push(field.fieldDef.fullName);
			}
		});
		return pkFields;
	},

	
    getPrimaryKeyFieldValues: function(ignoreEmptyValues) {
        if (!valueExists(ignoreEmptyValues)) {
            ignoreEmptyValues = false;
        }
        
        var fieldValues = {};
        this.fields.each(function(field) {
            var fieldName = field.fieldDef.fullName;
            var fieldValue = field.panel.getFieldValue(fieldName);

            // add primary key field value UNLESS ignoreEmptyValues is set and the value is empty
            if (!ignoreEmptyValues || fieldValue != '') {
                if (field.fieldDef.primaryKey) {
                  fieldValues[fieldName] = fieldValue;
                }
            }
        });
        return fieldValues;
    },
    
	
    getPrimaryKeyRestriction: function() {
        var pkValues = this.getPrimaryKeyFieldValues(true);
        var restriction = new Ab.view.Restriction(pkValues);
        return restriction;
    },

   // ----------------------- validation methods --------------------------------------------------
    
    
    clearValidationResult: function() {
        this.validationResult = new Ab.form.ValidationResult();
        
        // clear validation message
        var messageCell = this.getMessageCell();
        messageCell.dom.innerHTML = "";
        
        // clear field highlighting for all fields
        this.fields.eachKey(function(fieldName) {
            
            // clear the input element class
            var fieldInput = this.getFieldElement(fieldName);
            if (valueExists(fieldInput)) { 
                var fieldInputTd = fieldInput.parentNode;
                Ext.fly(fieldInputTd).removeClass('formError');

                // remove per-field error messages
                var errorTextElements = Ext.query('.formErrorText', fieldInputTd);
                for (var e = 0; e < errorTextElements.length; e++) {
                    fieldInputTd.removeChild(errorTextElements[e]);
                }
            }

            var fieldLabel = this.getFieldLabelElement(fieldName);
            if (fieldLabel) {
                Ext.fly(fieldLabel).removeClass('formError');
            }
        }, this);
        
        // both Save and Refresh clear the afm_form_values_changed flag
        afm_form_values_changed = false;
    },
    
    
    displayValidationResult: function(result) {
        // if JSON result object is passed in, copy its messages
        if (valueExists(result)) {
            this.validationResult.message = result.message;
            this.validationResult.detailedMessage = result.detailedMessage;
        }
        
        // display error/information message
        var message = this.validationResult.message;
        var detailedMessage = this.validationResult.detailedMessage;
        
        if (valueExists(message) && message != '') {
            // remove technical part of the message if it is provided
            var separatorIndex = message.indexOf('::');
            if (separatorIndex != -1) {
                message = message.substring(0, separatorIndex);
            }

            if (!this.validationResult.valid) {
                this.displayValidationMessage(message, detailedMessage);
            } else {
                this.displayTemporaryMessage(message);
            }
        }
        
        // highlight invalid fields
        for (var fieldName in this.validationResult.invalidFields) {
            var fieldInput = this.getFieldElement(fieldName);
            if (fieldInput) {
                Ext.fly(fieldInput.parentNode).addClass('formError');
            }

            var fieldLabel = this.getFieldLabelElement(fieldName);
            if (fieldLabel) {
                Ext.fly(fieldLabel).addClass('formError');
            }

            // add per-field error messages
            var fieldError = this.validationResult.invalidFields[fieldName];
            if (fieldError != '') {
                var fieldInputTd = fieldInput.parentNode;

                var errorBreakElement = document.createElement('br');
                errorBreakElement.className = 'formErrorText';
                fieldInputTd.appendChild(errorBreakElement);
                
                var errorTextElement = document.createElement('span');
                errorTextElement.className = 'formErrorText';
                errorTextElement.appendChild(document.createTextNode(fieldError));
                fieldInputTd.appendChild(errorTextElement);
            }
        }
    },

    
    displayTemporaryMessage: function(message, duration){
        // show message as inline text, dismiss after 3 seconds
        var messageCell = this.getMessageCell();
        messageCell.dom.innerHTML = "";

        var messageElement = Ext.DomHelper.append(messageCell, '<p>' + message + '</p>', true);
        messageElement.addClass('formMessage');
        messageElement.setVisible(true, {duration: 1});
        messageElement.setHeight(20, {duration: 1});

        // default duration = 3000ms
        this.dismissMessage.defer(valueExistsNotEmpty(duration) ? duration : 3000, this, [messageElement]);

        if (this.isShownInWindow()) {
            this.updateWindowHeight();
        }
    },

    
    displayValidationMessage: function(message, detailedMessage){
        // show message as inline text
        var messageCell = this.getMessageCell();
        messageCell.dom.innerHTML = "";

        // begin paragraph and display message
        var messageAndButton = "<p>" + message;

        // add the Details button
        if (detailedMessage) {
            messageAndButton += " " + "<a>" + Ab.form.Form.z_MESSAGE_LABEL_DETAILS + "</a>";
        }

        // end the paragraph
        messageAndButton += "</p>";

        // put it all into the message cell
        var messageElement = Ext.DomHelper.append(messageCell, messageAndButton, true);
        messageElement.addClass('formError');

        // add event listener to OK button to hide the message
        var form = this;
        messageElement.dom.onclick = function() {
            form.dismissMessage(messageElement);
        };

        // add event listener to Details button to open the popup that shows the detailed message
        if (detailedMessage) {
            messageElement.dom.childNodes[1].onclick = function() {
                View.showMessage('error', message, detailedMessage);
            };
        }

        if (this.isShownInWindow()) {
            this.updateWindowHeight();
        }
    },

    
    dismissMessage: function(messageElement) {
        var form = this;
        messageElement.setVisible(false, {duration: 0.25});
        messageElement.setHeight(0, {
            duration: 1,
            callback: function() {
                messageElement.remove();

                if (form.isShownInWindow()) {
                    form.updateWindowHeight();
                }
            }
        });
    },

    
    getMessageCell: function() {
        return Ext.fly(Ext.query('.formTopSpace', this.parentElement)[0]);
    },

    
    setMaxValue:function(fieldFullName, maxValue){
    	var fieldDef = this.fields.get(fieldFullName).fieldDef;
    	fieldDef.maxValue = maxValue;
    },
   
    
    setMinValue:function(fieldFullName, minValue){
    	var fieldDef = this.fields.get(fieldFullName).fieldDef;
    	fieldDef.minValue = minValue;
    },
    
    // ----------------------- date/time methods ---------------------------------------------------
    
    
    formatDate: function(day, month, year, useIsoFormat) {
	    var d = FormattingDate(day, month, year, strDateShortPattern);
	    if (!valueExists(useIsoFormat) || useIsoFormat) {
	        d = getDateWithISOFormat(d);
	    }
        return d;
    },
	

    // -------------- KB 3024726 browse directly to doc checkin when field attribute directCheckin = 'true' -------------
	
	processingFileInputChange: function(fileNameElement, docFieldName) {
		var fileName = this.validateDocumentFileNameElement(fileNameElement);
		if (fileName == null || fileName == '') { return; }
		
		fileName = this.removeDirectories(fileName);
		if (!this.verifyFileExtension(fileName)) { return; }

		var docFieldPanel = this;
		var tableName = docFieldName.split('.')[0];
		var fieldName = docFieldName.split('.')[1];
		
		// map{[fld,val]} param for svc call. fld is NOT fullName
		var pKeyFieldValues = this.getDocSvcPrimaryKeyFieldValues();
			
		// div wrapping the <input type='file'> element to be reset on success
		var divId = fileNameElement.id + '_div';
		
		DocumentService.checkinNewFile(fileNameElement, pKeyFieldValues, tableName, fieldName, fileName, 'auto', '0', {
			callback: function() {
				// clear value from file input element by resetting the inner html of the div
				// var test = document.getElementById(divId).innerHTML;
				document.getElementById(divId).innerHTML = document.getElementById(divId).innerHTML;
				// refresh with saved record, updates doc field buttons
				docFieldPanel.refresh();
			},
			errorHandler: function(m, e) {
				Ab.view.View.showException(e);
			}
		});
	},
		

	
	validateDocumentFileNameElement: function(fileNameElement) {
		var fileName = fileNameElement.value;
		if (fileNameElement == null || fileNameElement.value == null && fileNameElement.value.trim() == '') {
			var warning_message_empty_filename = Ab.form.Form.z_MESSAGE_EMPTY_FILENAME;
			// TODO transform into validation failure
			View.showMessage('error', warning_message_empty_filename, warning_message_empty_filename);
			return null;
		}
		return fileName
	},

	
	 removeDirectories: function(fileName) {
		var separatorPos = fileName.lastIndexOf('\\');
		if (separatorPos >= 0) {
			fileName = fileName.substring(separatorPos + 1);
		}
		else {
			separatorPos = fileName.lastIndexOf('/');
			if (separatorPos >= 0) {
				fileName = fileName.substring(separatorPos + 1);
			}
		}
		return fileName;
	},

	
	verifyFileExtension: function(fileName) {
		// get filename extension to test
		var docFileExtension  = '';
		if (fileName != '') {
			var pos = fileName.lastIndexOf('.');
			if (pos > 0) {
				docFileExtension = fileName.substring(pos + 1);
			}
		}
		if (docFileExtension.trim().length == 0 || !this.isValidDocumentExtension(docFileExtension) ) {
			// if the doc type is not valid, then prompt a message & return
			var msg = Ab.form.Form.z_MESSAGE_INVALID_FILE_TYPE.replace("{0}", "<b> " + docFileExtension + "</b>")
			var usageMsg = Ab.form.Form.z_MESSAGE_VALID_FILE_TYPES.replace("{1}", Ab.form.Form.DOCMANAGER_ALLOWED_DOCTYPES.toString());
			// TODO transform into validation failure
			View.showMessage('error', msg, msg + ' ' + usageMsg);
			return false;
		}

		return true;	
	},

	
	 isValidDocumentExtension: function(docFileExtension) {
		 // check if the file extension allowed
		 var isValidDoc = false;
		 
		 // loop throught the allowed filetype list
		 for (var i=0, name; name = Ab.form.Form.DOCMANAGER_ALLOWED_DOCTYPES[i]; i++ ) {
			 // !!! file type comparison is case-insensitive
			 var docLower = name.toLowerCase();
			 var docExtLower = docFileExtension.toLowerCase();
			 if (docLower == docExtLower) {
				 isValidDoc = true;
				 break;
			 }
		}
		return isValidDoc;
	},
	
	
	getDocSvcPrimaryKeyFieldValues: function() {
		var pKeyFieldValues = this.getPrimaryKeyFieldValues(true);
		var docSvcKeys = {};
		// remove tableName
		for (fullName in pKeyFieldValues) {
			docSvcKeys[fullName.split('.')[1]] = pKeyFieldValues[fullName];
		}

		return docSvcKeys;
	},
    
    // ----------------------- image support -------------------------------------------------------
    
    
    showImageDoc: function(imageDisplayField, imageDocKeyField, imageDocValueField) {
        var tableName = imageDocKeyField.split('.')[0];
        var keyName = imageDocKeyField.split('.')[1];
        var fieldName = imageDocValueField.split('.')[1];
        
        var keys = {};
        keys[keyName] = this.getFieldValue(imageDocKeyField);
         
        var form = this;
        form.disable();
        
        DocumentService.getImage(keys, tableName, fieldName, '1', true, {
            callback: function(image) {
                dwr.util.setValue(form.getFieldElementName(imageDisplayField), image);
                form.enable();
            },
            errorHandler: function(m, e) {
                Ab.view.View.showException(e);
                form.enable();
            }
        });
    },

    
    showImageFile: function(imageDisplayField, fileName) {
        var field = this.fields.get(imageDisplayField);
        field.dom.src = fileName;
    },
    
    
    clearImage: function(imageDisplayField) {
        this.showImageFile(imageDisplayField, Ab.view.View.contextPath + '/schema/ab-system/graphics/blank.gif');
    }
}, {
    // ----------------------- constants -----------------------------------------------------------

	// @begin_translatable
    z_MESSAGE_INVALID_FIELD: 'Please correct highlighted values and save again.',
	z_MESSAGE_NO_DWG_VIEW: 'no drawing view!!!',
	z_MESSAGE_EMPTY_FILENAME: 'Please choose a file for the document.',
	z_MESSAGE_INVALID_NUMERIC_TOO_LARGE: 'Value entered for [{0}] exceeds the maximum storage limits defined for the field. Please enter a number less than {1}.',
    z_MESSAGE_INVALID_NUMERIC_TOO_SMALL: 'Value entered for [{0}] is smaller than the minimum storage limits defined for the field. Please enter a number greater than -{1}.',
    z_MESSAGE_INVALID_NUMERIC_MAX: 'Value entered for [{0}] exceeds the maximum limits defined for the field. Please enter a number less than or equal to {1}.',
    z_MESSAGE_INVALID_NUMERIC_MIN: 'Value entered for [{0}] is smaller than the minimum limits defined for the field. Please enter a number greater than or equal to {1}.',
    z_MESSAGE_INVALID_UPPERALPHANUM: 'Value entered for [{0}] is invalid. Please enter alpha characters and/or numbers.',
    z_MESSAGE_INVALID_INTEGERORSMALLINT: 'Value entered for [{0}] is not an integer. Please enter an integer.',
    z_MESSAGE_INVALID_NUMERIC: 'Value entered for [{0}] is not a number. Please enter a numeric value.',
    z_MESSAGE_INVALID_NUMERIC_DECIMAL: 'Value entered for [{0}] exceeds the number of decimal places defined for the field. Please enter a number with {1} or fewer numbers after the decimal.',
    z_MESSAGE_INVALID_MEMO_TOO_LARGE: 'Value exceeds the maximum storage limits defined for the field.  Value will be truncated to {0} characters.',
    z_MESSAGE_INVALID_FILE_TYPE: 'Files with extension [{0}] are not allowed for check-in.',
	z_MESSAGE_VALID_FILE_TYPES: 'Use one of [{1}]',
    z_MESSAGE_LABEL_OK: 'OK',
    z_MESSAGE_LABEL_DETAILS: 'Details',
	// @end_translatable
    
    // name of the default WFR used to get the default record
    WORKFLOW_RULE_CLEAR: 'AbCommonResources-getDefaultDataRecord',
    
    // name of the default WFR used to get the record
    WORKFLOW_RULE_REFRESH: 'AbCommonResources-getDataRecord',
    
    // name of the default WFR used to get the record
    WORKFLOW_RULE_SAVE: 'AbCommonResources-saveDataRecord',
    
    // name of the default WFR used to delete the current record
    WORKFLOW_RULE_DELETE: 'AbCommonResources-deleteDataRecords',
    
    // separator character for multiple values in one field, used for Select Multiple console fields
    MULTIPLE_VALUES_SEPARATOR: '^',

	// Collection of file extensions for document types allowed to be associated with a UI document field
	// should get these from the preferences
	DOCMANAGER_ALLOWED_DOCTYPES: new Array('doc','docx','pdf','xls','xlsx','dwg','dwf','txt','jpg','gif','bmp','png','zip','xml','htm','html','log'),

    // Event key for user-defined document field event listener
    DOC_EVENT_CHECKIN: 'onCheckInDocument',
    // Event key for user-defined document field event listener
    DOC_EVENT_CHECKIN_NEW_VERSION: 'onCheckinNewVersion',
    // Event key for user-defined document field event listener
    DOC_EVENT_CHECKOUT: 'onCheckOutDocument',
    // Event key for user-defined document field event listener
    DOC_EVENT_DELETE: 'onDeleteDocument',
    // Event key for user-defined document field event listener
    DOC_EVENT_CHANGE_LOCK_STATUS: 'onChangeLockStatus'

});



function getInputValue(fieldName) {
	var value = '';
	
	var forms = Ab.view.View.getControlsByType('', 'form');
	for (var i = 0; i < forms.length; i++) {
		var form = forms[i];
		if (form.containsField(fieldName)) {
			value = form.getFieldValue(fieldName);
			break;
		}
	}
	
	return value;
}


function setInputValue(fieldName, fieldValue) {
	var forms = Ab.view.View.getControlsByType('', 'form');

	for (var i = 0; i < forms.length; i++) {
		var form = forms[i];
		if (form.containsField(fieldName)) {
			value = form.setFieldValue(fieldName, fieldValue);
			break;
		}
	}
}



Ab.form.AutoComplete = Base.extend({

    
    addAutoCompleteToFormFields: function(panel) {
        var nFields = 0,            // number of form fields
            fieldNames = [],        // names of form fields
            selectFieldNames = [],  // names of select fields in the query
            queryFieldName = '',    // name of the select field for which the user types the value
            showImages = false;     // whether to display images in the drop-down

        // creates restriction: parent form field values + query
        var getAutoCompleteRestriction = function(query) {
            var restriction = new Ab.view.Restriction();

            // add parent field values
            for (var f = 0; f < nFields; f++) {
                if (selectFieldNames[f] !== queryFieldName) {
                    var value = panel.getFieldValue(fieldNames[f]);
                    if (valueExistsNotEmpty(value)) {
                        restriction.addClause(selectFieldNames[f], value);
                    }
                }
            }

            // KB 3038599: Oracle is case-sensitive
            query = query.toUpperCase();

            // add user query string
            if (valueExistsNotEmpty(query)) {
                if (query === '?') {
                    // do not apply the query restriction, show all available values
                } else if (queryFieldName.indexOf('em_id') == -1) {
                    // get values that begin with user query string
                    restriction.addClause(queryFieldName, query, 'LIKE');
                } else {
                    // for employee names, also get values where the first name begins with user query string
                    // e.q. typing 'EL' returns both 'ELLIS, TERRY' and 'PARKER, ELLEN'
                    restriction.addClause(queryFieldName, query + '%', 'LIKE', ')AND(');
                    restriction.addClause(queryFieldName, '%, ' + query + '%', 'LIKE', ')OR(');
                }
            }

            return restriction;
        };

        // called by auto-complete to load values based on user's query
        var autoCompleteSource = function(fieldId, request, response) {
            var query = request.term,
                field = panel.fields.get(fieldId),
                command = field.actions.get(0).config.commands[0];

            fieldNames = _.map(command.fieldNames.split(','), function(name) {
                return name.trim();
            });
            selectFieldNames = _.map(command.selectFieldNames.split(','), function(name) {
                return name.trim();
            });
            _.each(fieldNames, function(fieldName, index) {
                if (fieldName === fieldId) {
                    queryFieldName = selectFieldNames[index];
                }
            });
            nFields = fieldNames.length;
            showImages = false;

            var selectTableName = queryFieldName.split('.')[0],
                entries = [];

            var dataSource = valueExistsNotEmpty(command.dataSource) ?
                View.dataSources.get(command.dataSource) :
                Ab.data.createDataSourceForFields({
                    id: panel.id + '_' + fieldId + '_autoComplete',
                    tableNames: [selectTableName],
                    fieldNames: selectFieldNames
                });
            dataSource.recordLimit = command.recordLimit;
            var restriction = getAutoCompleteRestriction(query);
            var records = dataSource.getRecords(restriction, {
                isDistinct: true
            });

            if (nFields > 0) {
                // for each record in the data set
                for (var r = 0; r < records.length; r++) {
                    // add child entry with parent fields
                    var entry = {};
                    for (var f = 0; f < nFields; f++) {
                        var value = records[r].getValue(selectFieldNames[f]);
                        entry[selectFieldNames[f]] = value;
                    }
                    for (var i = 0; i < selectFieldNames.length; i++) {
                        if (selectFieldNames[i].indexOf('image_file') != -1) {
                            showImages = true;
                            var imageFile = records[r].getValue(selectFieldNames[i]);
                            if (imageFile) {
                                entry.imageFile = imageFile;
                            }
                        }
                    }
                    entries.push(entry);
                }
            } else {
                // assemble flat list of values
                for (var r = 0; r < records.length; r++) {
                    var value = records[r].getValue(selectFieldNames[0]);
                    entries.push(value);
                }
            }

            response(entries);
        };

        // called by auto-complete to format an item
        var autoCompleteFormatter = function(fieldId, ul, item) {
            // the child value to select
            var child = item[queryFieldName];

            var parents = '';
            for (var f = 0; f < nFields; f++) {
                if (selectFieldNames[f] !== queryFieldName) {
                    var value = item[selectFieldNames[f]];
                    if (valueExists(value)) {
                        if (parents !== '') {
                            parents += ':';
                        }
                        parents += value;
                    }
                }
            }

            // add image if the item has the image_file field
            var style = '';
            if (showImages) {
                style = 'height:50px; padding-left: 54px;';
                if (item.imageFile) {
                    style += 'background: url(' + View.getBaseUrl() + '/projects/hq/graphics/' + item.imageFile.toLowerCase() + ') no-repeat;';
                    style += 'background-position: left center;';
                    style += 'background-size: 50px;';
                }
            }

            var html = '<a style = "' + style + '">' + child + '</a><span>' + parents + '</span>';

            return jQuery("<li></li>")
                .data('item.autocomplete', item)
                .append(html)
                .appendTo(ul);
        };

        // called by auto-complete when the user selects a value
        var autoCompleteSelectListener = function(event, ui) {
            var value = ui.item[queryFieldName];
            if (value) {
            	var listener = panel.getEventListener('onAutoCompleteSelect');
                // fill in parent form field values
                for (var f = 0; f < nFields; f++) {
                    panel.setFieldValue(fieldNames[f], ui.item[selectFieldNames[f]]);
                    if (listener) {
                    	listener(panel, fieldNames[f], ui.item[selectFieldNames[f]]);
                    }
                }
            }
            event.preventDefault();
        };

        // called by auto-complete when the user modifies the query
        var autoCompleteSearchListener = function(event, ui) {
            var listener = panel.getEventListener('onAutoCompleteQuery');
            if (listener) {
                listener(panel, event, event.target.value);
                // cancel the event
                return false;
            }
        };

        // called by auto-complete when the user clears the query
        var autoCompleteClearListener = function(event) {
            var listener = panel.getEventListener('onAutoCompleteClear');
            if (listener) {
                listener(panel, event);
            }
        };

        // called by auto-complete when the menu opens; sets the menu z-index to be on top of the parent dialog
        var autoCompleteOpenListener = function(event, ui) {
            var menuWidget = jQuery(event.target).autocomplete('widget');
            menuWidget.context.style.zIndex = 9999;
        };

        // attach auto-complete plug-in to text fields
        panel.fields.each(function(field) {
            var fieldDef = field.fieldDef;
            var fieldElement = panel.getFieldElement(fieldDef.id);
            var fieldInput = jQuery(fieldElement);

            if (fieldElement && !fieldDef.isDate) {

                var action = field.actions.get(0);
                if (action && action.command) {
                    var command = action.command.commands[0];
                    if (command && command.type == 'selectValue' && command.autoComplete) {

                        // attach the plug-in to the input
                        fieldInput.autocomplete({
                            minLength: command.minLength,
                            delay: 250,
                            source: function(request, response) {
                                autoCompleteSource(fieldDef.id, request, response);
                            },
                            select: autoCompleteSelectListener,
                            search: autoCompleteSearchListener,
                            clear: autoCompleteClearListener,
                            open: autoCompleteOpenListener,
                            position: { collision: 'flip' }
                        });

                        var data = fieldInput.data('autocomplete');
                        data._renderItem = function(ul, item) {
                            return autoCompleteFormatter(fieldDef.id, ul, item);
                        };

                        if (command.minLength === '0') {
                            command.handle = function(context) {
                                if (fieldInput.autocomplete('widget').is(':visible') ) {
                                    fieldInput.autocomplete('close');
                                } else {
                                    fieldInput.autocomplete('search', fieldInput.val());
                                    fieldInput.focus();
                                }
                            }
                        }
                    }
                }
            }
        });
    }
});

Ab.namespace('form');



Ab.form.ColumnReport = Ab.view.Component.extend({
    
	// view definition to be displayed
	viewDef: null,
    
	// array of field definitions
	fieldDefs: null,
	
    // name of the default WFR used to get the record
    refreshWorkflowRuleId: '',
    
    // whether the form should display its field values on load
    showOnLoad: false,
    
    // user function to call after refresh()
    afterRefreshListener: null,
    
    //number of table columns
    columns: 1,
    
    // data record retrieved from the server
    record: null,
    
    // ----------------------- initialization ------------------------------------------------------
    
    
	constructor: function(id, configObject) {
        this.inherit(id, 'columnReport', configObject);  

        this.viewDef = new Ab.view.ViewDef(configObject.getConfigParameter('viewDef'), configObject.getConfigParameter('groupIndex'), null, null, configObject.getConfigParameter('dataSourceId'));
                
        this.columns = configObject.getConfigParameter('columns', 1);
        this.showOnLoad = configObject.getConfigParameter('showOnLoad', false);
		this.refreshWorkflowRuleId = configObject.getConfigParameterNotEmpty('refreshWorkflowRuleId', 
            Ab.form.Form.WORKFLOW_RULE_REFRESH);
        this.fieldDefs = configObject.getConfigParameter('fieldDefs', []);

        this.visible = true;
    },
    
    // ------------------------ common control API methods -----------------------------------------
    
    
    createEvaluationContext: function() {
        var ctx = this.inherit();
        if (this.record != null) {
            ctx['record'] = this.record.values;
        }
        return ctx;
    },
    
    
    initialDataFetch: function() {
        if (this.showOnLoad || this.restriction != null) {
            this.getData();
            this.show(true);
        }
        this.show(this.showOnLoad);
    },
    
        
    getData: function() {
        var dataSource = this.getDataSource();
        if (!dataSource) {
			this.setRecord(new Ab.data.Record());
			return;
		}
        try {
            var result = Ab.workflow.Workflow.call(this.refreshWorkflowRuleId, this.getParameters());
            if (valueExists(result.dataSet)) {
                var record = this.getDataSource().processInboundRecord(result.dataSet);
                this.setRecord(record);   
            }
        } catch (e) {
            this.handleError(e);
        }
    },
    
    
    clear: function() {
        var tableId = this.parentElementId + '_table';
        var table = Ext.get(tableId);
        if (table != null) {
            table.remove();
        }
    },
    
    // ----------------------- implementation ------------------------------------------------------
    
    
    getFieldValue: function(fieldName) {
        var value = null;
        if (this.record != null) {
            value = this.record.getValue(fieldName);
        }
        return value;  
    },
    
    
    getRecord: function() {
        return this.record;  
    },
    
    
    getOutboundRecord: function() {
        var record = this.record;
        var dataSource = this.getDataSource();
        if (dataSource) {
        	record = dataSource.processOutboundRecord(record);
        }
        return record;
    },
    
    
    setRecord: function(record) {
        this.record = record;
        this.onModelUpdate();
    },

    
    onModelUpdate: function() {
        // remove existing grid
        this.clear();

        var ctx = this.createEvaluationContext();
        
        // create new table with row for each field
        var tableId = this.parentElementId + '_table';
        var html = '<table id="' + tableId + '" class="columnReport">';

		// map of document field anchor element id - document parameters
		var docFieldLinkMap = {};
      
        var columnCounter = 0;
        for (var i = 0; i < this.fieldDefs.length; i++) {
            var fieldDef = this.fieldDefs[i];
            var hidden = Ab.view.View.evaluateBoolean(fieldDef.hidden, ctx, false);
            if (hidden) {
                continue;
            }
			
            var fieldValue = this.getFieldValue(fieldDef.id);
            
            if (valueExistsNotEmpty(fieldValue)) {
                // format object values into localized strings
                var dataSource = this.getDataSource();
                if (dataSource) {
                    fieldValue = dataSource.formatValue(fieldDef.id, fieldValue, true, true, this.record.values);
                }
            } else {
                fieldValue = '&nbsp;';
            }
            
            var title = '';
            if (valueExistsNotEmpty(fieldDef.title)) {
                title = Ab.view.View.evaluateString(fieldDef.title, ctx, false);
                if (title.charAt(title.length - 1) != ':' && title.charAt(title.length - 1) != '?' && title.indexOf("<div") < 0) {
                    title = title + ':';
                } 
                title = title.replace("&apos;", "'"); 
            } 
            
            if (columnCounter == 0) {
                html = html + '<tr>';
            }
            
            var id = this.id + '_' + fieldDef.id;
			
			var isNumber = (fieldDef.type === 'java.lang.Double' || fieldDef.type === 'java.lang.Integer');
			var style = isNumber ? 'text-align:right;' : '';
            
            var dataCellColSpan = fieldDef.colspan > 1 ? 5 + ((fieldDef.colspan - 2) * 4) : 1;
            
            // replace ASCII line breaks in memo value by HTML line breaks 
            var format = fieldDef.format.toUpperCase();
            if (format=='MEMO' && valueExistsNotEmpty(fieldValue)) {
                // KB 3021342: \n\r does not get replaced, use \n
                fieldValue = fieldValue.replace(/\n/g, "<br/>");
            }
			else if (fieldDef.isDocument) {
				// KB 3025081: doc field in column report as active link to show document

				// anchor element gets its own id
				var linkId = this.id + '_' + fieldDef.id + '_link';
				// parameters to be passed to the function delegate after the HTML document has been written
				var linkParam = {};
				linkParam['key'] = this.getPrimaryKey();
				linkParam['fullName'] = fieldDef.id;
				linkParam['value'] = fieldValue;
				docFieldLinkMap[linkId] = linkParam;
				// field value as an anchor element
				fieldValue = " <a href=\"javascript: //\" id=\"" + linkId + "\">" + fieldValue + "</a>";
			}
            
            html += this.getLabelValueHTML(id, title, style, dataCellColSpan, fieldDef, fieldValue);
            
            columnCounter = columnCounter + fieldDef.colspan;
            if (columnCounter == this.columns) {
                columnCounter = 0;
                html = html + '</tr>';
            }
        }
        html = html + '</table>';
        Ext.DomHelper.insertHtml('afterBegin', this.parentElement, html);

		// if the column report contains document fields, themap is not empty and onClick actions will be attached
		for (linkId in docFieldLinkMap) {
			var params = docFieldLinkMap[linkId];
			var linkElement = Ext.get(linkId);			
			var delegate = this.showDocumentLinkCommand.createDelegate(this, [linkId, params]);
            Ext.get(linkElement).addListener("click", delegate);
		}
    },
    
    
    getFieldElement: function(fieldName) {
        return $(this.id + '_' + fieldName, false);
    },
    
    getFieldEl: function(fieldName) {
        return Ext.get(this.id + '_' + fieldName);
    },
    
	
	getLabelValueHTML: function(id, title, style, dataCellColSpan, fieldDef, fieldValue) {
		var html = '<td class="columnReportSpacer"> </td>'
                 + '<td class="columnReportLabel' + this.getLabelClassIfExists(fieldDef) + '">' + title + '</td>' 
                 + '<td id="' + id + '" class="columnReportValue" style="' + style + '" colspan="' + dataCellColSpan + '">' + fieldValue + '</td>'
                 + '<td class="columnReportSpacer"> </td>';

		return html;
	},

	getLabelClassIfExists: function(fieldDef)  {
		var returnString = '';
		if (fieldDef.labelClass != null) {
			returnString += ' ' + fieldDef.labelClass;
		}
		return returnString;
	},

	
    
    getParameters: function() {
        var parameters = {
            viewName:    this.viewDef.viewName,
			groupIndex:  this.viewDef.tableGroupIndex,
            controlId:   this.id,
            version:     Ab.view.View.version
        };
        if (this.restriction != null) {
            parameters.restriction = toJSON(this.restriction);
        }
        if (this.viewDef.dataSourceId != null) {
			parameters.dataSourceId = this.viewDef.dataSourceId;
		}

        Ext.apply(parameters, this.parameters);

        return parameters;
    },

	
	showDocumentLinkCommand: function(linkId, parameters) {
		var tableAndName = parameters['fullName'].split('.');
		var fileName = parameters['value'];
        var keys = parameters['key'];
		// strip off the table name from each of the primary key field fullName values and add it as a separate attribute
		for (name in keys) {
			var keyName = name.split('.')[1];
			keys[keyName] = keys[name]
		}
		View.showDocument(keys, tableAndName[0], tableAndName[1], fileName, null);
	},
		
	
	getPrimaryKey: function() {
		var primaryKeyValues = {};
		for (var i = 0, fieldDef; fieldDef = this.fieldDefs[i]; i++) {
			if (fieldDef.primaryKey) {
				primaryKeyValues[fieldDef.fullName] = this.getFieldValue(fieldDef.fullName);
			}
		}
		return primaryKeyValues;
	},
	
	// ----------------------- export report selection --------------------------------------------------
	
	callReportJob: function(reportProperties){
		var outputType = reportProperties.outputType, printRestriction = reportProperties.printRestriction, orientation = reportProperties.orientation;
		var jobId = null;
		
		if(outputType === 'docx'){
			var reportTitle = this.title;
			if(reportTitle == ''){
				reportTitle = Ab.view.View.title;
			}
			var parameters = {};
			
			parameters.recordLimit = 1;
			parameters.columns = this.columns;
			
			if(valueExists(printRestriction)){
				parameters.printRestriction = printRestriction;
			}
			if(valueExistsNotEmpty(orientation)){
				parameters.orientation = orientation;
			}
			
			jobId = this.callDOCXReportJob(reportTitle, this.restriction, parameters);
		}else {
			//no translatable since it's only for viwew designers.
    		View.showMessage('error', outputType + ' action is NOT supported for a column report panel.');
		}
		
		return jobId;
	},
	
	callDOCXReportJob: function(title, restriction, parameters){
		var viewName = this.viewDef.viewName + '.axvw'; 
		parameters.formatType = "column";
		return Workflow.startJob(Ab.grid.ReportGrid.WORKFLOW_RULE_DOCX_REPORT, viewName, this.dataSourceId, title, this.getVisibleFieldDefs(), toJSON(restriction), parameters);
	},
	
	
	getVisibleFieldDefs: function(){
		var ctx = this.createEvaluationContext();
    	var fieldDefs = this.fieldDefs;  
    	if(fieldDefs && fieldDefs.length == 0){
    		this.getDataSource().fieldDefs.each(function (fieldDef) {
        		fieldDefs.push(fieldDef);
        	});
    	}
    
    	var visibleFieldDefs = [];
		for (var i = 0, column; column = this.columns[i]; i++) {	
			if(column.hidden){
				continue;
			}
		     var field = this.getFieldDefById(fieldDefs, column.fullName, i);
		     if(valueExists(field)){
		    	 if(field.controlType === '' || field.controlType === 'link'){
		    		 //XXX: evulate field.title and field.hidden proprties
		    		 field.title = Ab.view.View.evaluateString(field.title, ctx, false);
		    		 field.hidden = Ab.view.View.evaluateString(field.hidden, ctx, false);
		    		 visibleFieldDefs.push(field);
		    	 }
		     }
		}	
		var listener = this.getEventListener('beforeExportReport');
        if (listener) {
        	visibleFieldDefs = listener(this, visibleFieldDefs);
        }
		return visibleFieldDefs;
    },
    
    beforeExportReport: function(panel, visibleFieldDefs){
    	return visibleFieldDefs;
    },
   
   
    
    getFieldDefById: function(fieldDefs, fullName, index){
    	if(index < fieldDefs.length){
	    	var field = fieldDefs[index];
	    	if(valueExists(field) && (fullName == field.fullName)){
	    		return field;
	    	}
    	}
    	//use case: manually add columns in js
    	for (var i = 0, field; field = fieldDefs[i]; i++) {
    		if(fullName === field.fullName){
    			return field;
    		}
    	}
    	
    	return null;
    }
    
}, {
    // ----------------------- constants -----------------------------------------------------------
    
    // name of the default WFR used to get the record
    WORKFLOW_RULE_REFRESH: 'AbCommonResources-getDataRecord'
});




Ab.namespace('view');

Ab.view.Scroller = Base.extend({

    // scrollable jQuery element to which the scroller is attached
    el: null,

    // x and y scrollbar objects
    scrollbars: [],

    
    constructor: function(dom, config) {
        this.el = jQuery(dom);
        this.el.addClass('jssb-content');

        // add the scrollbar DOM to the scrollable element's parent
        var prefs = {
            tweenDuration: 500,
            tweenFn: function (pos) {
                return -Math.cos(pos*Math.PI) / 2 + 0.5;
            }
        };
        Ext.apply(prefs, config);
        this.scrollbars = jsScrollbar(this.el.parent(), prefs);

        // check if previous sibling elements exist (headers) within the container and
        // adjust scrolling properties accordingly
        var parentEl = jQuery(this.el.parent());
        if (!parentEl.children().first().hasClass('jssb-content')) {
            var topOffset = parentEl.children().first().innerHeight() + 3;
            parentEl.find('.jssb-content').css({'margin-top' : topOffset + 'px'});
            parentEl.find('.jssb-y').css({'top' : topOffset + 'px'});
        }

        var fadeIn = function(parentEl) {
            var hoverEl = jQuery(parentEl);
            if (hoverEl.hasClass("jssb-scrolly")) {
                hoverEl.find(".jssb-y").fadeIn(500);
            }
            if (hoverEl.hasClass("jssb-scrollx")) {
                hoverEl.find(".jssb-x").fadeIn(500);
            }
        };

        var fadeOut = function(parentEl) {
            var hoverEl = jQuery(parentEl);
            if (hoverEl.hasClass("jssb-scrolly")) {
                hoverEl.find(".jssb-y").fadeOut(500);
            }
            if (hoverEl.hasClass("jssb-scrollx")) {
                hoverEl.find(".jssb-x").fadeOut(500);
            }
        };

        //- Display the associated scrollbar for the hovered panel
        parentEl.hover(
            function() {
                fadeIn(this);
            },
            function() {
                fadeOut(this);
            }
        );

        fadeOut.defer(1000, this, [parentEl]);
    },

    update: function() {
        var scroller = this;
        setTimeout(function () {
            if (scroller.scrollbars) {
                if (valueExists(scroller.scrollbars.length)) {
                    for (var a = 0; a < scroller.scrollbars.length; a++) {
                        scroller.scrollbars[a].recalc();
                    }
                } else {
                    scroller.scrollbars.recalc();
                }
            }
        }, 100);
    },

    detach: function() {
        var parentEl = jQuery(this.el.parent());
        parentEl.off();
    },

    setOnVerticalScroll: function(callback) {
        if (this.scrollbars) {
            this.scrollbars.onVerticalScroll = callback;
        }
    },

    setOnHorizontalScroll: function(callback) {
        if (this.scrollbars) {
            this.scrollbars.onHorizontalScroll = callback;
        }
    }
});



(function () {

this.jsScrollbar = function (el, prefs) {
	var sbs = [], i, ids;
		
	if (typeof prefs === 'undefined')
		prefs = null;
	
	if (typeof el === 'string') {
		ids = el.replace(/\s/g, '').replace(/,$/, '').replace(/#/g, '').split(',');
		
		for (i = 0; i < ids.length; i++) {
			if (verify(find(ids[i])))
				sbs.push(new jsScrollbar.init(find(ids[i]), prefs));
		}
	}
	
	else if (el.nodeType && el.nodeType == 1) {
		if (verify(el))
			sbs.push(new jsScrollbar.init(el, prefs));
	}
	
	else if (el.length && el.length > 0) {
		for (i = 0; i < el.length; i++) {
			if (verify(el[i]))
				sbs.push(new jsScrollbar.init(el[i], prefs));
		}
	}
	
	if (sbs.length == 0)
		return null;
	
	else if (sbs.length == 1)
		return sbs[0];
	
	else
		return sbs;
};

jsScrollbar.scrollbars = [];


jsScrollbar.defaults = {
	scrollSpeed: 30,
	scrollDistance: 10,
	wheelDistance: 40,
	tweenFn: function (pos) { return -Math.cos(pos*Math.PI) / 2 + 0.5; },
	tweenDuration: 500,
	disableTweening: false,
	horizontalScrolling: true,
	verticalScrolling: true,
	fixedThumb: false,
	template:
	'<div class="jssb">'+
		'<div class="jssb-track">'+
			'<div class="jssb-track-mid"></div>'+
			'<div class="jssb-track-end"></div>'+
			'<div class="jssb-thumb">'+
				'<div class="jssb-thumb-mid"></div>'+
				'<div class="jssb-thumb-end"></div>'+
			'</div>'+
		'</div>'+
	'</div>'
};


this.jsScrollbar._closures = {
	objs: [],
	fns: []
};
addEvent(window, 'unload', function () {
	this.jsScrollbar._closures.objs = null;
	this.jsScrollbar._closures.fns = null;
	this.jsScrollbar._closures = null;
	this.jsScrollbar.scrollbars = null;
});


jsScrollbar.init = function () {
	jsScrollbar.scrollbars.push(this);
	this.parent  = arguments[0];
	this._prefs  = extend(jsScrollbar.defaults, arguments[1]);
	this._init();
};

jsScrollbar.init.prototype = {
	_enabled: true,
	_doScrollX: false,
	_doScrollY: false,
	_isAnimating: false,
	_hasFocus: false,
	_temp: null,
	
	_scrollX: null,
	_scrollY: null,
	_prefs: null,
	
	content: null,
	parent: null,

    // vertical scroll callback
    onVerticalScroll: null,

    // horizontal scroll callback
    onHorizontalScroll: null,


	_init: function () {
		//Shorter references
		var pa = this.parent, co = this.content, prefs = this._prefs;
		
		if (!this._temp) this._temp = {};
		
		addClass(pa, 'jssb-applied');
		
		//Add jssb-x elements if required and requested
		if (prefs.horizontalScrolling) {
            var scrollX = find('jssb-x', pa);
            if (!scrollX && (!this._scrollX || !this._scrollX.el)) {
                var html = prefs.template
                                     .replace(/jssb/g, 'jssb-x')
                                     .replace(/-up/g, '-left')
                                     .replace(/-down/g, '-right');
                Ext.DomHelper.append(pa, html);
            } else if (scrollX) {
                scrollX.style.display = 'block';
            }
        }
		
		//Add jssb-y elements if required and requested
        if (prefs.verticalScrolling) {
            var scrollY = find('jssb-y', pa);
            if (!scrollY && (!this._scrollY || !this._scrollY.el)) {
                var html = prefs.template.replace(/jssb/g, 'jssb-y');
                Ext.DomHelper.append(pa, html);
            } else if (scrollY) {
                scrollY.style.display = 'block';
            }
        }
		
		if (!co || (co && !co.parentNode)) {
			co = this.content = find('jssb-content', pa);
		}

		//Is scrolling necessary?
		this._doScrollX = (prefs.horizontalScrolling &&
		                   co.scrollWidth > co.clientWidth) ? true: false;
		this._doScrollY = (prefs.verticalScrolling &&
		                   co.scrollHeight > co.clientHeight) ? true: false;

        if (this._doScrollX) {
			//Add hook for horizontal scrolling
			addClass(pa, 'jssb-scrollx');
	
			//Does a possible shrunk viewport introduce vertical scrolling now?
			if (prefs.verticalScrolling && co.scrollHeight > co.clientHeight)
				this._doScrollY = true;
	
		} else {
			removeClass(pa, 'jssb-scrollx');
		}
	
		if (this._doScrollY) {
			//Add hook for vertical scrolling
			addClass(pa, 'jssb-scrolly');
	
			//Does a possible shrunk viewport introduce horizontal scrolling now?
			if (!this._doScrollX && prefs.horizontalScrolling &&
			    co.scrollWidth > co.clientWidth) {
				this._doScrollX = true;	
				addClass(pa, 'jssb-scrollx');
			}
		} else {
			removeClass(pa, 'jssb-scrolly');
		}
		
		if (prefs.horizontalScrolling) {
			if (this._scrollX === null)
				this._scrollX = new jsScrollbarComponent(find('jssb-x', pa), 'x');
				
			this._prepComponent(this._scrollX, this._doScrollX);

            var el = jQuery(this._scrollX.el);
            if (this._doScrollX) {
                el.fadeIn(500);
            } else {
                el.hide();
            }
		}
		
		if (prefs.verticalScrolling) {
			if (this._scrollY === null)
				this._scrollY = new jsScrollbarComponent(find('jssb-y', pa), 'y');
				
			this._prepComponent(this._scrollY, this._doScrollY);

            var el = jQuery(this._scrollY.el);
            if (this._doScrollY) {
                el.fadeIn(500);
            } else {
                el.hide();
            }
		}
		
		addEvent(pa, 'mousewheel', bind(this._mouseWheel, this));
		addEvent(pa, 'DOMMouseScroll', bind(this._mouseWheel, this));
	
		// Apply events that simulate focus and blur
		// addEvent(pa, 'mousedown', bind(this._focus, this));
		// addEvent(document, 'mousedown', bind(this._blur, this));
		// addEvent(co, 'mousedown', bind(this._selectStart, this));

		addEvent(co, 'scroll', bind(this._keepUp, this));
	},
	

	_prepComponent: function (cmp, doScroll) {
		//Reinitialize component if reference is lost by editing innerHTML
		if (cmp.el && !cmp.el.parentNode) {
			removeEvent(cmp.el, 'mousedown', bind(this._mouseDown, this));
			cmp = new jsScrollbarComponent(find('jssb-'+ cmp.axis, this.parent), cmp.axis, cmp.minThumb);
		}
		
		if (doScroll) {
			var co = this.content,
				trackDim  = cmp.track.relevantDim(),
				thumbDim  = cmp.thumb.relevantDim(),
				clientDim = cmp.axis == 'x' ? co.clientWidth : co.clientHeight,
				scrollDim = cmp.axis == 'x' ? co.scrollWidth : co.scrollHeight;
			
			//Resize the thumb
			if (!this._prefs.fixedThumb) {
				thumbDim = cmp.thumb.relevantDim( Math.round(
				           trackDim * clientDim / scrollDim >= cmp.minThumb?
				           trackDim * clientDim / scrollDim : cmp.minThumb));
			}
			
			//How many content pixels are equal to one scrollbar pixel
			cmp.ratio = (scrollDim - clientDim) / (trackDim - thumbDim);

            if (cmp.ratio <= 0) {
                cmp.ratio = 1;
            }
			
			removeEvent(cmp.el, 'mousedown', bind(this._mouseDown, this));
			addEvent(cmp.el, 'mousedown', bind(this._mouseDown, this));
		}
	},
	

	_mouseDown: function (e) {
		e = fixEvent(e);

		var prefs = this._prefs, co = this.content, temp  = this._temp,
			axis = hasClass(e.target, 'jssb-x', true) ? 'x' : 'y',
			cmp  = axis == 'x' ? this._scrollX : this. _scrollY,
			trackPos, newPos;
	
		//Clicked on the Thumb
		if (hasClass(e.target, 'jssb-'+ axis +'-thumb', true)) {
			addClass(cmp.thumb.el,' jssb-'+ axis +'-thumb-click');
			
			//Add component to temp object for mouseup
			temp.clicked = cmp.thumb.el;
			
			//Track position relative to document, so we don't have to calculate onmousemove
			temp.trackPos = (axis == 'x') ?
			                findOffsetLeft(cmp.track.el):
			                findOffsetTop(cmp.track.el);
				
			//The point on the thumb where it was clicked
			temp.grabPoint = (axis == 'x') ? 
			                 e.pageX - findOffsetLeft(cmp.thumb.el):
			                 e.pageY - findOffsetTop(cmp.thumb.el);
				
			temp.axis = axis;
			
			//Remove scroll listener, we'll do it manually 'cause it's smoother
			removeEvent(this.content, 'scroll', bind(this._keepUp, this));
			
			//Mousemove event for dragging the thumb
			addEvent(document, 'mousemove', bind(this._drag, this));
		}
	
		//Clicked on the Track
		else if (hasClass(e.target, 'jssb-'+ axis +'-track', true)) {
			addClass(cmp.track.el, ' jssb-'+ axis +'-track-click');
			
			//Add component to temp object for mouseup
			temp.clicked = cmp.track.el;
	
			//Get the position of the track
			trackPos = (axis == 'x') ?
					   findOffsetLeft(cmp.track.el):
					   findOffsetTop(cmp.track.el);
			
			//Jump to position
			if (prefs.disableTweening) {
				temp.newPos = (e['page'+ axis.toUpperCase()] - trackPos) * cmp.ratio;
				
				if (axis == 'x')
					this._startScroll(temp.newPos < co.scrollLeft ? -co.clientWidth : co.clientWidth, 0);
				else
					this._startScroll(0, temp.newPos < co.scrollTop ? -co.clientHeight : co.clientHeight);
				
			} else {
				//Position to jump to
				newPos = (e['page'+ axis.toUpperCase()] - trackPos - cmp.thumb.relevantDim() / 2) * cmp.ratio;
				
				if (axis == 'x')
					this.tweenTo(newPos, null);
				else 
					this.tweenTo(null, newPos);
			}
		}
	
		//Directional Buttons
		else if (hasClass(e.target, 'jssb-y-up', true)) {
			addClass(cmp.prev.el, 'jssb-y-up-click');
			temp.clicked = cmp.prev.el;
			this._startScroll(0, -prefs.scrollDistance);
		}
		
		else if (hasClass(e.target, 'jssb-y-down', true)) {
			addClass(cmp.next.el, 'jssb-y-down-click');
			temp.clicked = cmp.next.el;
			this._startScroll(0, prefs.scrollDistance);
		}
		
		else if (hasClass(e.target, 'jssb-x-left', true)) {
			addClass(cmp.prev.el, 'jssb-x-left-click');
			temp.clicked = cmp.prev.el;
			this._startScroll(-prefs.scrollDistance, 0);
		}
		
		else if (hasClass(e.target, 'jssb-x-right', true)) {
			addClass(cmp.next.el, 'jssb-x-right-click');
			temp.clicked = cmp.next.el;
			this._startScroll(prefs.scrollDistance, 0);
		}
		
		addEvent(document, 'mouseup', bind(this._mouseUp, this));
		
		//Prevent text selection
		addEvent(document, 'selectstart', cancelEvent);
		if (e.preventDefault)
			e.preventDefault();
	},
	

	_mouseUp: function (e) {
		var temp = this._temp;
		
		removeClass(temp.clicked, /jssb-[x|y]-[a-z]*-click/g);
		
		if (temp.scrollTimer) {
			window.clearInterval(temp.scrollTimer);
			temp.scrollTimer = null;
		}
		
		if (typeof temp.newPos == 'number')
			temp.newPos = null;
		
		removeEvent(document, 'mousemove', bind(this._drag, this));
		removeEvent(document, 'mouseup', bind(this._mouseUp, this));
		removeEvent(document, 'selectstart', cancelEvent);
				
		addEvent(this.content, 'scroll', bind(this._keepUp, this));
	},
	

	_drag: function (e) {
		e = fixEvent(e); 		
		var temp = this._temp, axis = temp.axis,
		    cmp  = axis == 'x' ? this._scrollX : this._scrollY,
			relToTrack = e['page'+ axis.toUpperCase()] - temp.trackPos,
			newPos = relToTrack - temp.grabPoint;
		
		if (axis == 'x')
			this._scroll(newPos*cmp.ratio, null);
		else
			this._scroll(null, newPos*cmp.ratio);
			
		this._keepUp();
	},
	

	_mouseWheel: function (e) {
		e = e ? e : event;
		var dir = 0, co = this.content;

		if (typeof e.wheelDelta == 'undefined') {
			if (e.detail > 0) dir = 1;
			if (e.detail < 0) dir = -1;
		} else {
			if (e.wheelDelta >= 120) dir = -1;
			if (e.wheelDelta <= -120) dir = 1;
		}

		if (this._prefs.verticalScrolling === false)
			this.scrollBy(dir * this._prefs.wheelDistance, null);
		else
			this.scrollBy(null, dir * this._prefs.wheelDistance);

		//Prevent document from scrolling
		if (co.scrollTop > 0 &&
		    co.scrollTop < co.scrollHeight - co.clientHeight)
			return cancelEvent(e);
	},
	

	_focus: function (e) {
		e = fixEvent(e);
		
		this._focusFlag = true;
		
		if (this._hasFocus)
			return;
		
		this._hasFocus  = true;
		addClass(this.parent, 'jssb-focus');

		//add key events for Keyboard scrolling
		addEvent(document, 'keydown', bind(this._keyDown, this));
	},
	

	_blur: function () {
		if (!this._focusFlag && this._hasFocus) {
			this._hasFocus = false;
			removeClass(this.parent, 'jssb-focus');
			
			//remove key events for Keyboard scrolling
			removeEvent(document, 'keydown', bind(this._keyDown, this));
		}
		this._focusFlag = false;
	},
	

	_keyDown: function (e) {
		e = fixEvent(e);

		var co = this.content, prefs = this._prefs,
		    tag = e.target.tagName.toLowerCase(),
			toFunc = prefs.disableTweening ? this.scrollTo : this.tweenTo,
			byFunc = prefs.disableTweening ? this.scrollBy : this.tweenBy;
		
		//Typing in form elements should not affect scrolling	
		if (tag == 'input' || tag == 'select')
			return;

		switch (e.keyCode) {
			//PageUp, Space/PageDown, End, Home
			case 33: byFunc.call(this, 0, -co.clientHeight); break;
			case 32: case 34: byFunc.call(this, 0, co.clientHeight); break;
			case 35: toFunc.call(this, co.scrollLeft, co.scrollHeight); break;
			case 36: toFunc.call(this, co.scrollLeft, 0); break;
			
			//Left, Up, Right, Down
			case 37: this.scrollBy(-prefs.scrollDistance, 0); break;
			case 38: this.scrollBy(0, -prefs.scrollDistance); break;
			case 39: this.scrollBy(prefs.scrollDistance, 0); break;
			case 40: this.scrollBy(0, prefs.scrollDistance); break;
		}
		
		return (e.keyCode >= 32 && e.keyCode <= 40) ?
			cancelEvent(e):
			true;
	},
	

	_keepUp: function () {
		var sx = this._scrollX,
		    sy = this._scrollY;
			
		if (this._doScrollX)
			sx.thumb.x(Math.round(this.content.scrollLeft/sx.ratio));
			
		if (this._doScrollY)
			sy.thumb.y(Math.round(this.content.scrollTop/sy.ratio));
	},
	

	_scroll: function (x, y) {
		if (x !== null && typeof x !== 'undefined') {
			this.content.scrollLeft = x;

            if (this.onHorizontalScroll) {
                this.onHorizontalScroll(x);
            }
        }
			
		if (y !== null && typeof y !== 'undefined') {
			this.content.scrollTop = y;

            if (this.onVerticalScroll) {
                this.onVerticalScroll(y);
            }
        }
	},
	

	_startScroll: function (x, y) {
		//Initial Scroll
		this.scrollBy(x, y);

		//Delayed continuation
		this._temp.scrollByX = x;
		this._temp.scrollByY = y;
		this._temp.scrollTimer = setTimeout(bind(this._startScrollDelay, this), 300);
	},
	_startScrollDelay: function () {
		this._temp.scrollTimer = setInterval(bind(this._startScrollInterval, this),
		                                     this._prefs.scrollSpeed);
	},
	_startScrollInterval: function () {
		var co = this.content, temp = this._temp,
		    x = temp.scrollByX, y = temp.scrollByY;
		
		if (typeof temp.newPos == 'number') {
			if ((x && temp.newPos >= co.scrollLeft && temp.newPos <= co.scrollLeft + co.clientWidth) ||
			    (y && temp.newPos >= co.scrollTop && temp.newPos <= co.scrollTop + co.clientHeight)) {
				clearTimeout(temp.scrollTimer);
				temp.scrollByX = 0;
				temp.scrollByY = 0;
				return;
			}
		}
		
		this.scrollBy(x, y);
	},
	

	_selectStart: function () {
		this._temp.coTop  = findOffsetTop(this.content);
		this._temp.coLeft = findOffsetLeft(this.content);
		
		addEvent(document, 'mousemove', bind(this._select, this));
		addEvent(document, 'mouseup', bind(this._selectStop, this));
	},
	_select: function (e) {
		e = fixEvent(e);
		
		var co = this.content, temp = this._temp, prefs = this._prefs,
			scrollX = 0, scrollY = 0;
		
		if (prefs.horizontalScrolling) {
			if (e.pageX < temp.coLeft)
				scrollX = -prefs.scrollDistance;
			
			else if (e.pageX > temp.coLeft && e.pageX < temp.coLeft + co.clientWidth)
				scrollX = 0;
				
			else if (e.pageX > temp.coLeft + co.clientWidth)
				scrollX = prefs.scrollDistance;
		}
		
		if (prefs.verticalScrolling) {
			if (e.pageY < temp.coTop)
				scrollY = -prefs.scrollDistance;
			
			else if (e.pageY > temp.coTop && e.pageY < temp.coTop + co.clientHeight)
				scrollY = 0;
				
			else if (e.pageY > temp.coTop + co.clientHeight)
				scrollY = prefs.scrollDistance;
		}
		
		if (!temp.isScrolling && (scrollX !== 0 || scrollY !== 0)) {
			this._startScroll(scrollX, scrollY);
			temp.isScrolling = true;
		}
		
		else if (temp.isScrolling && scrollX === 0 && scrollY === 0) {
			clearInterval(temp.scrollTimer);
			temp.isScrolling = false;
		}
		
		else {
			temp.scrollByX = scrollX;
			temp.scrollByY = scrollY;
		}
	},
	_selectStop: function (e) {
		clearInterval(this._temp.scrollTimer);
		removeEvent(document, 'mousemove', bind(this._select, this));
		removeEvent(document, 'mouseup', bind(this._selectStop, this));
	},
	

	scrollTo: function (a, b) {
		if (typeof b == 'undefined') {
			if (this._prefs.horizontalScrolling === false) {
				this._scroll(null, a);
			} else {
				this._scroll(a, null);
			}
		} else {
			this._scroll(a, b);
		}
	},


	scrollBy: function (a, b) {
		if (typeof b == 'undefined') {
			if (this._prefs.horizontalScrolling === false) {
				this._scroll(null, this.content.scrollTop + a);
			} else {
				this._scroll(this.content.scrollLeft + a, null);
			}
		} else {
			this._scroll(this.content.scrollLeft + a, this.content.scrollTop + b);
		}
	},
	

	tweenTo: function (a, b) {
		if (this._isAnimating)
			return;
			
		var co = this.content, prefs = this._prefs, temp = this._temp,
		    startX = co.scrollLeft, startY = co.scrollTop,
			x, y, distX, distY, start = +new Date;
		
		if (typeof b == 'undefined') {
			if (prefs.horizontalScrolling === false) {
				x = null;
				y = a;
			} else {
				x = a;
				y = null;
			}
		} else {
			x = a;
			y = b;
		}
		
		if (x !== null && x != co.scrollLeft) {
			if (x < 0) x = 0;
			if (x > co.scrollWidth - co.clientWidth)
				x = co.scrollWidth - co.clientWidth;
			distX = x - startX;
		}
		
		if (y !== null && y != co.scrollTop) {
			if (y < 0) y = 0;
			if (y > co.scrollHeight - co.clientHeight)
				y = co.scrollHeight - co.clientHeight;
			distY = y - startY;
		}
		
		this._isAnimating = true;
		
		temp.tweenData = {
			start: start,
			fin: start + prefs.tweenDuration,
			sx: startX, sy: startY,
			dx: distX, dy: distY,
			x: x, y: y
		};
		
		temp.tweenTimer = setInterval(bind(this._tweenToFn, this), 10);
	},
	
	_tweenToFn: function () {
		var tw = this._temp.tweenData, prefs = this._prefs;
		
		var time = +new Date,
		    pos  = time > tw.fin ? 1 : (time - tw.start) / prefs.tweenDuration;
			
		if (prefs.tweenFn)
			pos = prefs.tweenFn(pos);
		
		this.scrollTo(
			tw.x === null ? null : (tw.sx + tw.dx * pos),
			tw.y === null ? null : (tw.sy + tw.dy * pos)
		);
		
		if (time > tw.fin) {
			clearInterval(this._temp.tweenTimer);
			this._isAnimating = false;
		}
	},
	

	tweenBy: function (a, b) {
		if (typeof b == 'undefined') {
			if (this._prefs.horizontalScrolling === false) {
				this.tweenTo(null, this.content.scrollTop + a);
			} else {
				this.tweenTo(this.content.scrollLeft + a, null);
			}
		} else {
			this.tweenTo(this.content.scrollLeft + a, this.content.scrollTop + b);
		}
	},


	recalc: function () {
		if (!this._enabled) return;
	
		var pa = this.parent, co = this.content;
		
		removeEvent(pa, 'mousewheel', bind(this._mouseWheel, this));
		removeEvent(pa, 'DOMMouseScroll', bind(this._mouseWheel, this));
		removeEvent(pa, 'mousedown', bind(this._focus, this));
		removeEvent(document, 'mousedown', bind(this._blur, this));
		removeEvent(co, 'mousedown', bind(this._selectStart, this));
		removeEvent(co, 'scroll', bind(this._keepUp, this));
		
		this._init();
		this._keepUp();
		
		//Sometimes content can get cut off when resizing
		if (co.scrollWidth - co.clientWidth - co.scrollLeft < 0)
			this._scroll(co.scrollWidth - co.clientWidth, null);
		if (co.scrollHeight - co.clientHeight - co.scrollTop < 0)
			this._scroll(null, co.scrollHeight - co.clientHeight);
	},


	disable: function () {
		if (!this._enabled)
			return;
		
		var co = this.content, pa = this.parent;
		
		this._enabled = false;
		this._blur();
		
		removeClass(pa, 'jssb-applied');
		removeClass(pa, 'jssb-scrolly');
		removeClass(pa, 'jssb-scrollx');
		
		removeEvent(co, 'mousedown', bind(this._selectStart, this));
		removeEvent(co, 'scroll', bind(this._keepUp, this));
		removeEvent(pa, 'mousedown', bind(this._focus, this));
		removeEvent(document, 'mousedown', bind(this._blur, this));
	},


	enable: function () {
		if (this._enabled)
			return;
		
		this._enabled = true;
		this.recalc();
	},
	

	prefs: function (pref, value) {
		if (value || typeof pref == 'object') {
			if (typeof pref == 'string')
				this._prefs[pref] = value;
			else if (typeof pref == 'object')
				this._prefs = extend(pref, this._prefs);
			return true;
		}
				
		return this._prefs[pref];
	}
};

function jsScrollbarComponent (el, axis, minThumb) {
	this.el    = el;
	this.axis  = axis;
	this.track = new jsScrollbarComponentItem(find('jssb-'+ axis +'-track', el), axis);
	this.thumb = new jsScrollbarComponentItem(find('jssb-'+ axis +'-thumb', this.track.el), axis);
	this.minThumb = typeof minThumb == 'undefined' ? this.thumb.relevantDim() : minThumb;
}

jsScrollbarComponent.prototype = {
	track: null, thumb: null, prev: null, next: null,
	minThumb: 0,
	ratio: 0
};

function jsScrollbarComponentItem (el, axis) {
	this.el = el;
	this.axis = axis;
}

jsScrollbarComponentItem.prototype = {
	width: function (w) {
		if (typeof w != 'undefined') this.el.style.width = w +'px';
		
		if (!this.el.style.width)
			return this.el.offsetWidth
		
		return parseFloat(this.el.style.width);
	},
	
	height: function (h) {
		if (typeof h != 'undefined') this.el.style.height = h +'px';
		
		if (!this.el.style.height)
			return this.el.offsetHeight
		
		return parseFloat(this.el.style.height);
	},
	
	x: function (x) {
		if (typeof x != 'undefined') this.el.style.left = x +'px';
		return parseFloat(this.el.style.left);
	},
	
	y: function (y) {
		if (typeof y != 'undefined') this.el.style.top = y +'px';
		return parseFloat(this.el.style.top);
	},
	
	relevantDim: function (v) {
		return this.axis == 'x' ? this.width(v) : this.height(v);
	},
	
	relevantPos: function (v) {
		return this.axis == 'x' ? this.x(v) : this.y(v);
	}
};

function extend (a, b) {
	var c = {}, i;
	if (typeof a != undefined && a != null)
		for (i in a)
			c[i] = a[i];
	for (i in b)
		c[i] = b[i];
	return c;
}

function verify (o) {
	if (!o)
		return false;
	
	if (hasClass(o, 'jssb-applied'))
		return false;
	
	var s, p, co = find('jssb-content', o);
	
	if (!co)
		return false;
	
	addClass(o, 'jssb-applied');

    s = jQuery(co).css('overflow');
    p = jQuery(o).css('position');

	removeClass(o, 'jssb-applied');
	
	if (s == 'hidden') {
		if (p == 'static')
			o.style.position = 'relative';
		return true;
	}
	
	return false;
}

function addEvent (obj, type, fn) {
	if (obj.addEventListener)
		obj.addEventListener(type, fn, false);
	else
		obj.attachEvent( 'on'+type, fn );
}
	
function removeEvent (obj, type, fn) {
	if (obj.removeEventListener)
		obj.removeEventListener(type, fn, false);
	else
		obj.detachEvent('on'+type, fn);
}

function cancelEvent (e) {
	if (!e) e = window.event;
	if (e.stopPropagation) e.stopPropagation();
	if (e.preventDefault) e.preventDefault();
	e.cancelBubble = true;
	e.cancel = true;
	e.returnValue = false;
	return false;
}

function fixEvent (e) {
	e = e ? e : window.event;
	if (typeof e.target == 'undefined') e.target = e.srcElement;
	if (typeof e.pageX == 'undefined')  e.pageX  = e.clientX + document.body.scrollLeft;
	if (typeof e.pageY == 'undefined')  e.pageY  = e.clientY + document.body.scrollTop;
	
	return e;
}

function find (c, o) {
	if (typeof o != 'undefined') {
		var kids = o.getElementsByTagName('*', o), i, j;
		for (i = 0, j = kids.length; i < j; i++) {
			if (kids[i].className && hasClass(kids[i], c))
				return kids[i];
		}
		return null;
	} else {
		return document.getElementById(c);
	}
}

function addClass (o, c) {
	if (!hasClass (o, c)) {
		if (o.className.length == 0)
			o.className = c;
		else
			o.className += ' '+ c;
	}
}

function removeClass (o, c) {
	var i, classes = o.className.split(' ');
	for (i = 0; i < classes.length; i++) {
		if (typeof c == 'string') {
			if (classes[i] == c)
				classes[i] = '';
		} else {
			if (classes[i].match(c))
				classes[i] = '';
		}
	}
	
	o.className = classes.join(' ');
}

function hasClass (o, c, p) {
	if (typeof p == 'undefined') {
		var i, classes = o.className.split(' ');
		for (i = 0; i < classes.length; i++) {
			if (classes[i] == c)
				return true;
		}
	}
	
	//Partial className: 'jssb-track' matches jssb-track-mid
	else {
		if (o.className.indexOf(c) > -1)
			return true;
	}
	
	return false;
}

function findOffsetTop (o) {
	var t = 0;
	if (o.offsetParent) {
		while (o.offsetParent) {
			t += o.offsetTop;
			o  = o.offsetParent;
		}
	}
	return t;
}

function findOffsetLeft (o) {
	var t = 0;
	if (o.offsetParent) {
		while (o.offsetParent) {
			t += o.offsetLeft;
			o  = o.offsetParent;
		}
	}
	return t;
}

// Laurens van den Oever's Leak Free Closures
// http://laurens.vd.oever.nl/weblog/items2005/closures/
function bind (fn, obj) {
	var objs  = window.jsScrollbar._closures.objs,
	    fns   = window.jsScrollbar._closures.fns,
		objId = obj.__objId,
		fnId  = fn.__fnId;
	
	if (!objId)
		objs[objId = obj.__objId = objs.length] = obj;
		
	if (!fnId)
		fns[fnId = fn.__fnId = fns.length] = fn;
		
	if (!obj.__closures)
		obj.__closures = [];
		
	if (obj.__closures[fnId])
		return obj.__closures[fnId];	

	obj = fn = objs = fns = null;
	
	return window.jsScrollbar._closures.objs[objId].__closures[fnId] = function () {
		return window.jsScrollbar._closures.fns[fnId].apply(window.jsScrollbar._closures.objs[objId], arguments);
	};
}

})();



Ab.namespace('grid');


Ab.grid.Column = Base.extend({
	
	// column ID, usually a fully-qualified field name e.q. 'rm.rm_id'
	id: '',
	
	// fully-qualified field name
	fullName: '',
	
	// localized column name to be displayed
	name: '',
	
	// column type: 'text'|'number'|'date'|'time'|'button'|'radiobutton'|'checkbox'|'image' | 'link' | 'color'
	type: 'text',
	
	// 'restriction' on column types, for checking validity
	supportedTypes: ['text', 'link', 'number', 'number_link', 'date', 'time', 'button', 'radiobutton', 'checkbox', 'image', 'color'],
	
	// reference to the event handler for the default user action (i.e. onclick)
	defaultActionHandler: null,
	
	// custom handler invoked when each column cell is created
	onCreateCell: null,
	
	// column span
	colSpan: 1,
    
    // column width as a CSS property, i.e. "200px" or "10%", not used if null
    width: null,
		
	// button label text
	text: null,

	// columns that are calculated are virtual
	isVirtual: false,
	
	commands: [],

	imageName: null,

	// column's underlying dataType regardless of presentation (e.g., Double presented as link, Date presented as button)
	javaType: null,

	
	constructor: function(id, name, type, defaultActionHandler, onCreateCell, colSpan, width, text, commands, imageName) {
		this.id = id;
		this.name = name;
		
		// validate given type
		this.type = this.supportedTypes[0];
		for (var i=0; i < this.supportedTypes.length; i++) { 
			if (this.supportedTypes[i] == type) {
				this.type = type;
				break;
			}			
		}
		if (valueExists(defaultActionHandler)) {
			this.defaultActionHandler = defaultActionHandler;
		} 
		if (valueExists(onCreateCell)) {
			this.onCreateCell = onCreateCell;
		} 
		if (valueExists(colSpan)) {
		    this.colSpan = colSpan;
		}
        if (valueExists(width)) {
            this.width = width;
        }
        if (valueExists(text)) {
            this.text = text;
        }
		if (valueExists(commands)) {
			this.commands = commands
		}
		if (valueExists(imageName)) {
			this.imageName = imageName
		}
	},

	addCommand: function(configObject) {
		this.commands.push(configObject);
	}
});



Ab.grid.ColumnCommand = Base.extend({

	columnId: null,

	commandIndex: 0,

	command: '',

	constructor: function( ) {
	}
});



Ab.grid.Grid = Ab.view.Component.extend({
	
	// array of column objects
	columns: null,
	
	// array of 2nd-tier column objects
	columns2: null,
	
	// array of row objects
	rows: null,
	
	// name of the CSS class for the table
	cssClassName: 'panelReport',

	// name of the CSS class for the table header
	cssHeaderClassName: '',

    // 2D array of cell DOM elements, 1st index is row, 2nd index is column
    cells: null,
    
    // array of header cell DOM elements
    headerCells: null,
    
    // array of 2nd-tier header cell DOM elements
    headerCells2: null,
    
    // array of table rows DOM elements
    rowElements: null,
    
 	// The opacity to apply to cell type of 'color'.  Default is null, meaning do not set.
	colorOpacity: null,

	// the maximum width of a grid cell's content, 
	// beyond which content is shortened to ellipses & whole content is shown in tooltip
	maxCellContentWidth: 50,

	
	constructor: function(id, configObject) {
	    this.inherit(id, 'grid', configObject); 
	    
	    this.rows = [];
	    this.columns = [];
	    this.columns2 = [];
        
		var rows = configObject.getConfigParameterIfExists('rows');
		if (valueExists(rows)) {
			this.addRows(rows);
		}
		var columns = configObject.getConfigParameterIfExists('columns');
		if (valueExists(columns)) {
			this.addColumns(columns);
		}
		var maxCellContentWidthConfig = configObject.getConfigParameterIfExists('maxCellContentWidth');
		if (valueExists(maxCellContentWidthConfig)) {
			this.maxCellContentWidth = maxCellContentWidthConfig;
		}
		var cssClassName = configObject.getConfigParameterIfExists('cssClassName');
		if (valueExists(cssClassName)) {
		    this.cssClassName = cssClassName;
		}		
		var cssHeaderClassName = configObject.getConfigParameterIfExists('headerClass');
		if (valueExists(cssHeaderClassName)) {
		    this.cssHeaderClassName = cssHeaderClassName;
		}
	},
	
	// ----------------------- methods to manipulate the grid structure ----------------------------
    
	
	addColumn: function(column, level) {
        this.getColumnsForLevel(level).push(column);
	},
	
	 
	addColumnFirst: function(column) {
		this.columns.unshift(column);
	},
	
	 
	addColumns: function(columns) {
		this.columns = this.columns.concat(columns);
	},
	
	
	removeColumn: function(columnIndex) {
	    this.columns.splice(columnIndex, 1);
	},

    	
	removeColumns: function(columnIndex, level) {
	    var columns = this.getColumnsForLevel(level);
	    columns.splice(columnIndex, columns.length - columnIndex);
	},
	
	
	getColumnsForLevel: function(level) {
	    if (typeof level != 'undefined' && level == 2) {
	        return this.columns2;
	    } else {
		    return this.columns;
	    }
	},
	
	
	addRow: function(row) {
        row.grid = this;
		this.rows.push(row);
	},
	
	 
	addRows: function(rows) {
        for (var r = 0; r < rows.length; r++) {
            rows[r].grid = this;
        }
		this.rows = this.rows.concat(rows);
	},
	
	
	removeRow: function(rowIndex) {
	    this.rows.splice(rowIndex, 1);
	},

    	
	removeRows: function(rowIndex) {
	    this.rows.splice(rowIndex, this.rows.length - rowIndex);
	},

	
	getNumberOfColumns: function() {
		var numberOfColumns = 0;
		for (var c = 0; c < this.columns.length; c++) {
			var column = this.columns[c];
			numberOfColumns += column.colSpan;
		}
		return numberOfColumns;
	},
	
	
	getCell: function(row, column) {
	    return this.cells[row][column];
	},
	
	
	setColorOpacity: function(op) {
	    this.colorOpacity=op;
	},	
	
	// ----------------------- DOM building methods ------------------------------------------------
	
    
    clear: function() {
        this.cells = null;
        
		if (null == this.parentElement) {
			return false;
		}
		
        var tables = this.parentElement.getElementsByTagName('table');
        if (tables != null && tables.length > 0) {
			if (tables[0].id == 'grid_' + this.parentElement.id) {
	            this.parentElement.removeChild(tables[0]);
			}
        }
    },
	
	
	build: function() {
        this.clear();
	    
		var table = document.createElement('table');
		table.id = 'grid_' + this.parentElement.id;
		table.className = this.cssClassName;
				
		var thead = document.createElement('thead');
		var tbody = document.createElement('tbody');
		// not used yet
		// var tfoot = document.createElement('tfoot');
		
		this.rowElements = new Array();
		this.headerCells = new Array();
	    this.headerCells2 = new Array();
		
		// create grid header row
		var columns = this.columns;
		this.createHeaderRow(thead, columns, this.headerCells);

        // create 2nd-tier header row		
		if (this.columns2.length > 0) {
		    columns = this.columns2;
		    this.createHeaderRow(thead, columns, this.headerCells2);
		}
		table.appendChild(thead);
		
		// create grid data rows
		this.createDataRows(tbody, columns);		
		table.appendChild(tbody);

        this.parentElement.appendChild(table);
	},
	
	
	beforeBuild: function() {},
	
	
	afterBuild: function() {},
	
	
	
	createHeaderRow: function(parentElement, columns, headerCells) {
		var headerRow = document.createElement('tr');
		for (var c = 0; c < columns.length; c++) {
			var column = columns[c];
			
			var headerCell = document.createElement('th');
			headerCell.colSpan = column.colSpan;
            if (column.width != null) {
                headerCell.style.width = column.width;
            }
			headerRow.appendChild(headerCell);
			
			headerCell.appendChild(document.createTextNode(column.name));
			
			headerCells.push(headerCell);
		}
	    parentElement.appendChild(headerRow);
	    this.rowElements.push(headerRow);
	},
	
	hasMultiline: function(columns) {
		var multiline = false;
		for (var c = 0, column; column = columns[c]; c++) {
			if(column.width){
				multiline = true;
			}
		}
		return multiline;
	},
		
	
	createDataRows: function(parentElement, columns) {
	    var numRows = this.rows.length;
        this.cells = new Array(numRows);
        var multiline = this.hasMultiline(columns);
	    
		for (var r = 0; r < numRows; r++) {
			var row = this.rows[r];
			row.index = r;
			
			var rowElement = document.createElement('tr');
			rowElement.className = 'dataRow';
			rowElement.className += (multiline) ? ' multiline' : ' singleline'; 
		
		    var numColumns = columns.length;
		    this.cells[r] = new Array(numColumns);	
            
			for (var c = 0; c < numColumns; c++) {
				var column = columns[c];

                var cellElement = document.createElement('td');
                this.cells[r][c] = cellElement;
                
                // if custom create handler is defined for this column
                if (column.onCreateCell != null) {
                    column.onCreateCell(row, column, cellElement);
                    // if custom create handler set the cell colSpan attribute, 
                    // skip as many cells in this row
                    var colSpan = cellElement.colSpan;
                    c = c + colSpan - 1;
                } else {
                    // create default cell content
                    this.createCellContent(row, column, cellElement);
                }                 
			
                if (column.width != null) {
                    cellElement.style.width = column.width;
                }
                
                rowElement.appendChild(cellElement);
			}
            
            parentElement.appendChild(rowElement);
	        this.rowElements.push(rowElement);
		}
	},
	
	
	createCellContent: function(row, column, cellElement, colorVal) {
		var content = "";
		
	    var value = row[column.id];
	    if (typeof value == 'undefined') {
	        value = row[column.fullName];
	    }
	    
		if (column.type == 'text' || column.type == 'number' || column.type == 'date' || column.type == 'time') {
            if (typeof value == 'undefined') {
                value = '';
            }
			
			// handle special characters
			value = this.transformCellValueSpecialChars(value);

            if(valueExistsNotEmpty(column.width)){
            	content = value;
            } else {
            content = Ext.util.Format.ellipsis(value, this.maxCellContentWidth);
          	}

			if (value.length > this.maxCellContentWidth) {
                value = value.replace(/\r\n/g, "<br/>");
                if(!valueExistsNotEmpty(column.width)){
                cellElement.setAttribute('ext:qtip', value);
            }
            }
            
			if (column.type == 'number') {
			    cellElement.style.textAlign = 'right';
			}			
		} else if (column.type == 'link' || column.type == 'number_link') {
            if (typeof value == 'undefined') {
                value = '';
            }

            if (column.type == 'number_link') {
                cellElement.style.textAlign = 'right';
            }
			
            if (column.javaType == 'java.lang.String') {
				value = this.transformCellValueSpecialChars(value);
			}

		    if(valueExistsNotEmpty(column.width)){
		    	if(column.format == 'Memo'){
		    		content = "<p class='memo' ext:qtip='" + value.replace(/\r\n/g, "<br/>") + "'><a href='javascript: //'>" + value + "</a></p>";
		    	} else {
		    		content = "<a href='javascript: //'>" + value + "</a>";
		    	}
		    } else {
		    content = "<a href='javascript: //'>" + Ext.util.Format.ellipsis(value, this.maxCellContentWidth) + "</a>";
		    }
			
			if (value.length > this.maxCellContentWidth && !valueExistsNotEmpty(column.width)) {
                cellElement.setAttribute('ext:qtip', value.replace(/\r\n/g, "<br/>"));
            }
		} else if (column.type == 'button') {
		    if (typeof value == 'undefined' || value == true) {
			    content = "<input type='button' value='" + column.text + "'/>";
		    }
        } else if (column.type == 'image') {
            if (typeof value == 'undefined' || value == true) {
                content = "<img alt='" + column.text + "' title='" + column.text + "' src='" + column.imageName + "' hspace='1' border='0'/>";
                if (this.isActiveColumn(column)) {
                    content = "<a href='javascript: //'>" + content + "</a>";
                }
            }
		} else if (column.type == 'checkbox') {
            content = "<input type='checkbox'";
            if (value == 'true') {
                content = content + " checked='true' ";
            }
            content = content + "/>";
		} else if (column.type == 'radiobutton') {
            content = "<input type='radio' name='" + column.id + "'";
            if (value == 'true') {
                content = content + " checked='true' ";
            }
            content = content + "/>";
		} else if (column.type == 'color') {
			if (value == undefined)
				value = '';
			  content = (valueExistsNotEmpty(column.width)) ? '' : Ext.util.Format.ellipsis('', 50);

			var hpattern = new Ab.data.HighlightPattern(value);
			if (hpattern.isHatched()) {
		    	// HATCHED pattern
				var bitmapName = this.getLegendBitmapName(column.id, row, hpattern);
				if (bitmapName) {
					//KB# 3036630 - fill the cell with hatch pattern.
					//kb# 3036164 - fix "unusual row height when bitmap images are not yet generated."
	                content = "<img src='" + View.project.projectGraphicsFolder + '/' + bitmapName + ".png' hspace='0' border='0' style='width:100%;height:16px;'/>";
				}
		    	
			} else {
				// handle possibility that the raw value passed in is a hex value already
				var color = '';
				if (value.substr(0,2) == '0x') {
					color = value.substr(2);
			    } else {
					color = gAcadColorMgr.getRGBFromPatternForGrid(value, true);
					if (color == "-1") {
						if (colorVal == undefined || !colorVal.length)
							color = gAcadColorMgr.getUnassignedColor(true);
						else
							color = gAcadColorMgr.getColorFromValue(colorVal, true);
					}
				}

				var legendKeyColumn = this.getLegendKeyColumn();
				if(valueExists(legendKeyColumn)){
					gAcadColorMgr.setColor(legendKeyColumn.id, row[legendKeyColumn.id], color);
				}
				
				
				var style = (valueExistsNotEmpty(this.colorOpacity)) ? 'opacity: ' + this.colorOpacity + '; filter: alpha(opacity=\'' + (this.colorOpacity * 100).toFixed() + '\')' : '';
				content = '<div class="colorSwatch" style="background-color:#' + color + ';' + style + '"></div>';
				

				// KB 3027141 content width should not be set or the color block does NOT fill the cell
				// var width = '200px';
				// if (column.width != null) { width = column.width; }
				//content = '<div style="width:' + width + ';height:16px;background-color:#' + color + ';"></div>';
				//content = '<div style="width:100%;height:16px;background-color:#' + color + ';"></div>';
		    }
			cellElement.style.padding = "0";
			}
        
        cellElement.innerHTML = content;
        if(column.type.match(/button|link|checkbox|radiobutton/i)){
        	Ext.get(cellElement).addListener('keypress', function(e, cellElement) {
        		if(e.keyCode == 13){
        			cellElement.click();
        		}
        	});
        }
				
        var contentElement = cellElement.childNodes[0];
        // IE6 cannot add an ID to a text node
        if (valueExists(contentElement) && contentElement.nodeType != 3) {
            contentElement.id = this.generateId(row, column);
        }
        
        // register default column event handler
        if (column.defaultActionHandler != null) {
            var fn = column.defaultActionHandler;
            if (!fn.call) {
                fn = window[fn];
            }
            var delegate = fn.createDelegate(row, [row, column]);
            Ext.get(contentElement).addListener("click", delegate);
        }
		this.afterCreateCellContent(row, column, cellElement);
	},


	
	getLegendKeyColumn: function(){
		for(var i=0; i < this.columns.length; i++){
			var column = this.columns[i];
			if(valueExistsNotEmpty(column.legendKey) && column.legendKey === "true"){
				return column;
			}
		}
		return null;
	},


	transformCellValueSpecialChars: function(value) {
            // handle special characters to make them shown up in both IE and FireFox
            value = value.replace(/\&/g, "&amp;");
            value = value.replace(/>/g, "&gt;");
            value = value.replace(/</g, "&lt;");
			// extended ASCII characters (e.g., &#225; &aacute) must preserver the &, translate only isolated ampersands
            //value = value.replace(/ & /g, " &amp; ");

			return value;
	},

	
	
	getLegendBitmapName: function(id, row, hpattern) {
		return null;
	},
	
	
	afterCreateCellContent: function(row, column, cellElement) {
	},
	
	
	isActiveColumn: function(column) {
	    return (column.defaultActionHandler != null || 
	            (column.commands != null && column.commands.length > 0));
	},
	
	
	generateId: function(row, column) {
	    return (this.id + '_row' + row.index + '_' + column.id);
	},

	
	createImage: function(src, alt, hspace, width, height) {
        var image = document.createElement('img');
        image.src = src;
        image.alt = alt;
        image.title = alt;
        image.border = 0;
        image.hspace = hspace;
        if (valueExists(width)) {
            image.width = width;
        }
        if (valueExists(height)) {
            image.height = height;
        }
        return image;    
	},
	
	
	createLink: function() {
		var link = document.createElement('a');
		link.href = 'javascript: //';
        return link;	    
	}
});








Ab.grid.ReportGrid = Ab.grid.Grid.extend({
    
    // ----------------------- configuration parameters --------------------------------------------

    // name of the default WFR used to render the data
    refreshWorkflowRuleId: '',
    
	// view definition to be displayed
	viewDef: null,
	
	// if this flag set to true, the WFR returns records with distinct PK values
	isDistinct: false,

	// array of primary key ID attributes, i.e. ['rm.bl_id', 'rm.fl_id', 'rm.rm_id']
    primaryKeyIds: [],
    
    // array of field definitions for grid columns
    fieldDefs: [],
    
    // whether to display the total count of records
    showCounts: false,
    
    // whether to override the data source's "apply VPA restriction" property - used for Select Value
    applyVpaRestrictions: true,
    
    // ----------------------- control state that can be saved/restored ----------------------------
    
    // ----------------------- control state that is retained for lifetime of the control instance -

	// header row is member variable for restore of HTML on rebuild
	headerRows: [],

	// <table> element that is the parent of <thead><tbody><tfoot>, retained for lifetime of grid
	tableElement: null,
	// <thead> element that is the parent of all header rows, retained for lifetime of grid
	tableHeadElement: null,
	// <tbody> element that is the parent of all data rows, retained for lifetime of grid
	tableBodyElement: null,
	// <tfoot> element that is the parent of all footer rows, retained for lifetime of grid
	tableFootElement: null,

    
    // whether the selection indicator is enabled
    selectionEnabled: true,
    
    // 0-based index of the selected row (-1 = no row selected)
    selectedRowIndex: -1,
    
    // whether the multiple selection checkboxes should be enabled
    multipleSelectionEnabled: false,
    
	// whether to display sort indicators in columns
	sortEnabled: true,
	
	// column on which table is sorted only after user clicks header cell
	sortColumnID: '',

	// sort order for column on which table is sorted, exists before columns (& thus sortDirections array) exist
	sortColumnOrder: 1,

	// array of {sort column ID - sort order pairs} from panel configuration for initial data fetch sorting, 
	// exists before columns (& sortDirections) exist, constant over grid lifetime, sortColumnID takes precedence if it exists
	sortColumns: [],

	// collection of sortDirections ; sortColumnDirection.length == columns.length ; 0 'natural', 1 ascending, -1 descending, or '' non-sortable (e.g., button column)
	sortDirections: [],

	// action listener on sortable column header
	sortListener: null,
	// flag to workaround removeSortListener bug
	sortListening: true,

	// type of report export output ['' i.e., standard; 'PDF'; 'EXCEL' ]
	exportType: '',
	
	// optional name of the XSL-FO file
	exportFile: '',
	
	 //export reporting case with tab & its useFrame=false
    exportReportViewName: null,


	// URL of export to be fetched from server
	exportURL: '',

	// data source holds more records than are shown in table ( > RecordLimit)
	hasMoreRecords: false,
	
	hasNoRecords: false,

	recordLimit: -1,
	
	recordSet: null,
	
	// Ext.util.MixedCollection of Ab.grid.Row objects
	gridRows: null,

	// icon for sortable columns, ascending, location of graphics files completed in constructor	
	imageSortAscending: 'ab-sort-asc.png',

	// icon for sortable columns, descending, location of graphics files completed in constructor	
	imageSortDescending: 'ab-sort-desc.png',

	// icon for sortable columns, natural, location of graphics files completed in constructor	
	imageSortNatural: 'ab-sort-natl.png',

	// iinitial sort direction
	initialSortDirection: 0, // 'natural'

	userDefinedFooterHtml: null,
	
	//select value case: default sort orders like [{'fieldName':'dp.dp_id','sortOrder':1}] 
	sortValues: null,
	
	// Ab.data.Record containing total count of records and totals for numeric fields
	totals: null,
	
	// Ab.data.Record containing total count of records and average values for numeric fields
	average: null,
	
	// Ab.data.Record containing total count of records and minimum values for numeric fields
	minimum: null,
	
	// Ab.data.Record containing total count of records and maximum values for numeric fields
	maximum: null,
	
	
	statisticAttributes: null,
	
	// name of the default WFR used to get the statistic data
	statisticWorkflowRuleId: '',
	
	scrollbarFactor: 20,
	
	
	constructor: function(id, configObject) {
        // call Ab.grid.Grid constructor
        this.inherit(id, configObject); 

        this.showCounts = configObject.getConfigParameter('showCounts', false);
        
        this.fieldDefs = configObject.getConfigParameter('fieldDefs', []);
        
        // set up the primary key array based on field definitions
        this.primaryKeyIds = [];
        for (var i = 0; i < this.fieldDefs.length; i++) {
            var fieldDef = this.fieldDefs[i];
            if (fieldDef.primaryKey) {
                this.primaryKeyIds.push(fieldDef.fullName);
            }
        }        
        
        var ctx = this.createEvaluationContext();
               
        var sidecarColumns = this.getSidecar().get('columns');       	        
        if(sidecarColumns && sidecarColumns.length > 0){
        	// restore selected fields from sidecar when the view loads
        	if(sidecarColumns[0].id == 'multipleSelectionColumn'){
        		sidecarColumns.shift();
        	}
        	this.columns = sidecarColumns;
        }else{
        	
        	// if there is only one clickable column, make all columns clickable as well
        	this.defaultCommands = this.getDefaultCommands(this.fieldDefs);
        	
        	// create grid columns based on field definitions
        	for (var i = 0; i < this.fieldDefs.length; i++) {
        		var fieldDef = this.fieldDefs[i];
        		
        		var column;
        		var defaultActionHandler = null;
        		// view's onclick attribute
        		if (fieldDef.defaultActionHandler) {
        			defaultActionHandler = fieldDef.defaultActionHandler;
        		}else if (fieldDef.isDocument){
        			defaultActionHandler = this.showDocumentLinkCommand.createDelegate(this);
        		}
        		
        		if (valueExistsNotEmpty(fieldDef.controlType) || this.defaultCommands) {
        			if (fieldDef.controlType == 'button') {
        				column = new Ab.grid.Column(fieldDef.id, '', 'button', defaultActionHandler, null, null, null, fieldDef.title, fieldDef.commands);
        			} 
        			else if (fieldDef.controlType == 'image') {
        				column = new Ab.grid.Column(fieldDef.id, fieldDef.title, 'image', defaultActionHandler, null, null, null, fieldDef.title, fieldDef.commands, fieldDef.imageName);
        			} 
        			else if ((fieldDef.controlType == 'link') || (this.getEventListener('onClickItem')) || this.defaultCommands) {
        				var columnType = 'link';
        				if (fieldDef.type === 'java.lang.Double' || fieldDef.type === 'java.lang.Integer') {
        					columnType = 'number_link';
        				}
        				var fieldDefCommands = (this.defaultCommands) ? this.defaultCommands : fieldDef.commands;
        				column = new Ab.grid.Column(fieldDef.id, fieldDef.title, columnType, defaultActionHandler, null, null, null, fieldDef.title, fieldDefCommands);
        			} 
        			else {
        				column = new Ab.grid.Column(fieldDef.id, fieldDef.title, fieldDef.controlType);
        			}
        		} else if (fieldDef.isDate) {
        			column = new Ab.grid.Column(fieldDef.id, fieldDef.title, 'date');
        		} else if (fieldDef.isTime) {
        			column = new Ab.grid.Column(fieldDef.id, fieldDef.title, 'time');
        		} else {
        			var columnType = 'text';
        			if (fieldDef.type === 'java.lang.Double' || fieldDef.type === 'java.lang.Integer') {
        				columnType = 'number';
        			}
        			column = new Ab.grid.Column(fieldDef.id, fieldDef.title, columnType);
        		}
        		column.fullName = fieldDef.fullName;
        		column.tooltip = fieldDef.tooltip;
        		column.enabled = fieldDef.enabled;
        		column.width = fieldDef.width;
        		column.hidden = Ab.view.View.evaluateBoolean(fieldDef.hidden, ctx, false);
        		column.javaType = fieldDef.type;
        		column.legendKey = fieldDef.legendKey;
        		column.format = fieldDef.format;
        		this.addColumn(column);
        	}
    	}  
              
        this.sortValues = configObject.getConfigParameterIfExists('sortValues');
        
        // ReportGrid always uses the ViewDef
		var viewDef = configObject.getConfigParameterIfExists('viewDef');
        if (typeof viewDef == 'string') {
			var groupIndex = configObject.getConfigParameter('groupIndex');
			var dataSourceId = configObject.getConfigParameter('dataSourceId');
            this.viewDef = new Ab.view.ViewDef(viewDef, groupIndex, null, null, dataSourceId);
        } else {
		    this.viewDef = viewDef;
        } 

		// get webApp context path from view and initialize value for sort graphics
		this.imageSortAscending = Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-sort-asc.png';
		this.imageSortDescending = Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-sort-desc.png';
		this.imageSortNatural = Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-sort-natl.png';

		// set up column sorting
		var sortCols = configObject.getConfigParameterIfExists('sortColumns');
		if (valueExists(sortCols) && sortCols.length > 0) {
			this.sortColumns = sortCols;
			this.sortColumnOrder = sortCols[0].ascending == true ? 1 : -1;
		}
		this.sortListener = this.onClickSort;
    	//this.initializeSortDirections();

		this.applyVpaRestrictions = configObject.getConfigParameter('applyVpaRestrictions', true);
		this.sortEnabled = configObject.getConfigParameter('sortEnabled', true);
		this.selectionEnabled = configObject.getConfigParameter('selectionEnabled', true);
		this.multipleSelectionEnabled = configObject.getConfigParameterIfExists('multipleSelectionEnabled', false);
		this.refreshWorkflowRuleId = configObject.getConfigParameterNotEmpty('refreshWorkflowRuleId', Ab.grid.ReportGrid.WORKFLOW_RULE_REFRESH);
		this.recordLimit = configObject.getConfigParameter('recordLimit', -1);
		this.gridRows = new Ext.util.MixedCollection();

        this.addEventListenerFromConfig('onMultipleSelectionChange', configObject);

        this.addEventListenerFromConfig('afterGetData', configObject);
		if (!this.getEventListener('afterGetData')) {
			this.addEventListener('afterGetData', this.afterGetData);
		}
		
		if (!this.getEventListener('beforeExportReport')) {
			this.addEventListener('beforeExportReport', this.beforeExportReport);
		}

		// initialize statistic attributes
		this.statisticAttributes = {
				formulas: [],
				fields: []
		};
		
        // initialize grid columns        
        if (this.multipleSelectionEnabled && this.columns.length > 0) {
            this.addColumnFirst(new Ab.grid.Column(Ab.grid.ReportGrid.COLUMN_NAME_MULTIPLE_SELECTION, '', 'checkbox', 
                this.onChangeMultipleSelection.createDelegate(this)));
        }
        this.initializeColumns();
	},

	
	getDefaultCommands: function(fieldDefs) {
		var defaultCommands = null;

		var found = false;
		for (var i = 0; i < fieldDefs.length; i++) {
			var fieldDef = fieldDefs[i];
			if (valueExistsNotEmpty(fieldDef.controlType) && found) {
				return null;
			}
			if (valueExistsNotEmpty(fieldDef.controlType)){
				found = true;
				if(fieldDef.controlType == 'link'){
					defaultCommands = fieldDef.commands;
				}
			}
		}

		return defaultCommands; 
    },
    	
	
	getData: function(parameters) {
		var result = null;

		// if the WFR ID is in the activity-rule-method format, use method call
		var useMethodCall = this.refreshWorkflowRuleId.split('-').length == 3;
		if (useMethodCall) {
			result = Workflow.callMethod(this.refreshWorkflowRuleId, parameters);
		} else {
			result = Workflow.call(this.refreshWorkflowRuleId, parameters);
		}
		
		//get statistic data using custom wfr
		var statisticResult = this.getStatisticData(parameters);
		if (valueExists(statisticResult)) {
			// put statistic results to main result object
			if (valueExists(statisticResult.data.totals)) {
				result.data["totals"] = statisticResult.data.totals;
			}
			if (valueExists(statisticResult.data.maximum)) {
				result.data["maximum"] = statisticResult.data.maximum;
			}
			if (valueExists(statisticResult.data.minimum)) {
				result.data["minimum"] = statisticResult.data.minimum;
			}
			if (valueExists(statisticResult.data.average)) {
				result.data["average"] = statisticResult.data.average;
			}
		}
		
		if (useMethodCall) {
			this.handleDataSet(result);
		} else {
			this.formatDataRecords(result);
		}
		
		return result;
	},
		
	
	getStatisticData: function(parameters) {
		var result = null;
		// set some parameters for WFR 
		var ds =  this.getDataSource();
		
		if (this.isShowMax() || this.isShowMin() || this.isShowAverage() || (this.isShowSum() && ds && ds.type == 'grouping')) {

			if (ds && ds.type != 'grouping') {
				// totals are calculated with refresh WFR
				parameters.showTotals = false;
			} else if (ds && ds.type == 'grouping') {
				parameters.showTotals = this.isShowSum();
			}
			
			parameters.statisticFields = toJSON(this.statisticAttributes.fields);
			parameters.showMax = this.isShowMax();
			parameters.showMin = this.isShowMin();
			parameters.showAvg = this.isShowAverage();
			
			result = Workflow.call(this.statisticWorkflowRuleId, parameters);
		}

		return result;
	},
	
	
	handleDataSet: function(result) {
		if (valueExists(result.dataSet)) {
	        var records = [];
	        for (var i = 0; i < result.dataSet.records.length; i++) {
	            var record = this.recordToRow(result.dataSet.records[i]);
	            records.push(record);
	        }
			result.data.records = records;
			result.data.hasMoreRecords = result.dataSet.hasMoreRecords;
		}
	},
	
	
	formatDataRecords: function(result) {
		var ds = this.getDataSource();
		if (valueExists(ds) && valueExists(result.data.records)) {
	        for (var i = 0; i < result.data.records.length; i++) {
	            var formattedValues = ds.formatCurrencyValues(result.data.records[i]);
	            Ext.apply(result.data.records[i], formattedValues);
	        }
	        
	        if (valueExists(result.data.totals)) {
	            var formattedValues = ds.formatCurrencyValues(result.data.totals);
	            Ext.apply(result.data.totals, formattedValues);
	        }

	        if (valueExists(result.data.maximum)) {
	            var formattedValues = ds.formatCurrencyValues(result.data.maximum);
	            Ext.apply(result.data.maximum, formattedValues);
	        }

	        if (valueExists(result.data.minimum)) {
	            var formattedValues = ds.formatCurrencyValues(result.data.minimum);
	            Ext.apply(result.data.minimum, formattedValues);
	        }

	        if (valueExists(result.data.average)) {
	            var formattedValues = ds.formatCurrencyValues(result.data.average);
	            Ext.apply(result.data.average, formattedValues);
	        }
		}
	},
	
	
	initialDataFetch: function() {
        if (this.showOnLoad) {
			try {
				View.log('Before initial data fetch: grid = [' + this.id + ']');

				var result = this.getData(this.getParametersForRefresh());
				
				// handle totals record
				if (valueExists(result.data.totals)) {
					this.totals = new Ab.data.Record();
					this.totals.fromJSON(result.data.totals);
				}

				// handle maximum record
				if (valueExists(result.data.maximum)) {
					this.maximum = new Ab.data.Record();
					this.maximum.fromJSON(result.data.maximum);
				}

				// handle minimum record
				if (valueExists(result.data.minimum)) {
					this.minimum = new Ab.data.Record();
					this.minimum.fromJSON(result.data.minimum);
				}

				// handle average record
				if (valueExists(result.data.average)) {
					this.average = new Ab.data.Record();
					this.average.fromJSON(result.data.average);
				}
				
				// call afterGetData for post-processing (e.g., localization of data from messages)
                var listener = this.getEventListener('afterGetData');
                if (listener) {
                    listener(this, result.data);
                }
                             
				this.onInitialDataFetch(result);			
				var data = result.data;
				   
				if (this.columns.length == 0 && valueExists(data.columns)) {
					if (this.multipleSelectionEnabled) {
						this.addColumn(new Ab.grid.Column(Ab.grid.ReportGrid.COLUMN_NAME_MULTIPLE_SELECTION, '', 'checkbox', 
							this.onChangeMultipleSelection.createDelegate(this)));
					}
					this.addColumns(data.columns);
					this.initializeColumns();
				}

				if (data.records) {
					this.addRows(data.records);
					this.hasMoreRecords = data.hasMoreRecords;
					this.hasNoRecords = (data.records.length < 1);
				} else {
					this.hasNoRecords = true;
				}
				
				this.beforeBuild();
				this.build();
				this.afterBuild();

                this.visible = true;
                // show|hide the panel instructions
                if (this.getInstructionsEl()) {
                    this.showElement(this.getInstructionsEl(), true);
                }

				this.afterRefresh();

				View.log('After initial data fetch: grid = [' + this.id + ']');
				
			} catch (e) {
				this.handleError(e);
			}
		}
		else { // even if the panel is not shown, enable | disable titlebar actions
			var grid = this;

		    // KB 3024172 make grid consistent with form, when showOnLoad=false don't show titlebar

		    this.show(this.showOnLoad);

		}
	},
    
    
    onInitialDataFetch: function(result) {},
    
    // ---------------------- grid modification API -----------------------------------------------

    
    addGridRow: function(record, index) {
        if (record.constructor === Ab.data.Record) {
            record = this.recordToRow(record);
        }
        
        if (valueExists(index)) {
            this.rows.splice(index, 0, record);
            for (var i = index + 1; i < this.rows.length; i++) {
                this.rows[i].index = this.rows[i].index + 1;
            }
        } else {
            this.rows.push(record);
        }
    },
    
    
    removeGridRow: function(index) {
        var removed = this.rows.splice(index, 1);
        for (var i = index + 1; i < this.rows.length; i++) {
            this.rows[i].index = this.rows[i].index + 1;
        }
        return removed[0];        
    },
    
    
    moveGridRow: function(currentIndex, newIndex) {
        var record = this.removeGridRow(currentIndex);
        this.addGridRow(record, newIndex);
    },
    
    
    clearGridRows: function() {
        this.rows = [];  
    },
    
    
    getColumns: function() {
    	return this.columns;
    },
                
    
    findColumnIndex: function(columnId) {
    	var index = -1;
    	for (var i = 0; i < this.columns.length; i++) {
    		if (this.columns[i].id === columnId) {
    			index = i;
    			break;
    		}
    	}
    	
    	return index;
    },
    
    
    showColumn: function(columnId, show) {
    	if (!valueExists(show)) {
    		show = true;
    	}
    	
    	for (var i = 0; i < this.columns.length; i++) {
    		if (this.columns[i].id === columnId) {
    			this.columns[i].hidden = !show;
    			break;
    		}
    	}
    },
    
    
    hideColumn: function(columnId) {
    	this.showColumn(columnId, false);
    },
    
    
    setColumnDisplayOrder: function(columnId, newIndex) {
    	var currentIndex = this.findColumnIndex(columnId);
    	if (currentIndex >= 0) {
    		var thisColumn = this.columns[currentIndex];
    		
    		// remove the column from its position
    		this.columns.splice(currentIndex, 1);
    		
    		// insert it into the new position
    		this.columns.splice(newIndex, 0, thisColumn);
    	}
    },
    
    
    sortColumns: function(beginIndex, endIndex) {
    	var sortArray = this.columns.slice(beginIndex, endIndex);
    	
    	sortArray.sort(function (columnA, columnB) {
    		return columnA.name.localeCompare(columnB.name);
    	});

    	for (var i = beginIndex; i < endIndex; i++) {
    	    this.columns[i] = sortArray[i - beginIndex];
        }
    },
    
    
    update: function() {
        this.updateHeader();
        this.reloadGrid();
        this.afterRefresh();
    },
    
    
    updateHeader: function() {
		if (this.tableHeadElement) {
			rows = this.tableHeadElement.getElementsByTagName('tr');
		    for (var i=0, row; row = rows[0]; ) {
		        this.tableHeadElement.removeChild(row);
			}
	    	this.buildHeader(this.tableHeadElement);
        }
    },

	// ----------------------- common control API methods ------------------------------------------

    
    refresh: function(restriction, newRecord, clearRestriction) {
        this.beforeRefresh(restriction, newRecord);

        this.firstRecords = [];
        if (valueExists(clearRestriction) && clearRestriction == true) {
            this.restriction = null;
        }
        this.doRefresh();

        this.afterRefresh();
    },	
	
    
    doRefresh: function() {
        // clear the selection
        this.selectedRowIndex = -1;
        
        // get and display data rows
        try {
    		var result = this.getData(this.getParametersForRefresh());

			// call afterGetData for post-processing (e.g., localization of data from messages)
            var listener = this.getEventListener('afterGetData');
            if (listener) {
                listener(this, result.data);
            }

			this.reloadGrid(result.data);
			this.exportURL = result.data.exportURL;
		} catch (e) {
		    this.handleError(e);
		}
	},
    


	
    afterGetData: function(reportGrid, data) {
		// message key is tbl_col_val, save tbl_col_ prefix before testing messages or iteraing over records
		var messageKeyPrefixes = reportGrid.getMsgKeyPrefixesFromColumns();

		// test messages
		if (!reportGrid.hasMessagesForColumns(messageKeyPrefixes)) {
			return;
		}

		// iterate over records and replace value where needed
		for (var r = 0, record; record = data.records[r]; r++) {
            for (var c = 0, column; column = reportGrid.columns[c]; c++) {
			    var value = record[column.id];
				if (column.hidden || !value || (typeof value != 'string') || value.length == 0) {
					continue;
				}

				// value may be multiple words and/or upCased -> camelCase the value
				var valParts = value.split(' ');
				var messageKey = valParts[0].toLowerCase();
				for (var ii = 1, part; part = valParts[ii]; ii++) {
					part = part.toUpperCase().substr(0,1) + part.toLowerCase().substr(1);
					messageKey += part;
				}
				messageKey = messageKeyPrefixes[c] + messageKey;

				// efficiency advantage over getMessage & test
				if (valueExists(View.messages[messageKey])) {
					record[column.id] = View.messages[messageKey];
				}
			}
		}
	},

	
	getMsgKeyPrefixesFromColumns: function() {
		var messageKeyPrefixes = new Array(this.columns.length);
        for (var i = 0, column; column = this.columns[i]; i++) {
			if (column.hidden) {
				continue;
			}
			// get column name (separated by '_' rather than '.') & save as prefix for camelCased value as key to getMessage()
			var columnId = valueExists(column.fullName) ? column.fullName : column.id;
			var columnNames = columnId.split('.');
			messageKeyPrefixes[i] = columnNames[0] + '_' + columnNames[1] + '_';
		}
		return messageKeyPrefixes;
	},


	
	hasMessagesForColumns: function(messageKeyPrefixes) {
		// test whether any view message starts with a column name 
		var hasMsgForColumn = false;
		for (msg in View.messages) {
			if (hasMsgForColumn) {
				break;
			}
			for (var m=0,colName; colName = messageKeyPrefixes[m]; m++) {
				if (msg.indexOf(colName) == 0) {
					hasMsgForColumn = true;
					break;
				}
			}
		}
		return hasMsgForColumn;
	},

    afterRefresh: function() {
        // after rebuilding the rows, auto-wire row-level event handlers to view controllers
        var panel = this;
        View.controllers.each(function (controller) {
            controller.autoWireGridRows(panel);
        });
        
        // clear the Check All checkbox
        var checkAllEl = Ext.get(this.id + '_checkAll');
        if (valueExists(checkAllEl)) {
            checkAllEl.dom.checked = false;
        }
        
        this.inherit();
            this.updateHeight();
    },
    
    
    clear: function() {       
		if (null == this.parentElement) {
			return false;
		}
		this.removeRowsFromTable();
    },
	
	
	reloadGrid: function(resultData) {
		if (this.actionbar) {
				this.actionbar.updateSelected(0);
		}
        // data object containing essential members returned by WFR as stored in the grid
        var data = this.getReloadDataFromGrid(resultData);

		if (this.tableHeadElement == null) {
            this.beforeBuild();
            this.build();
            this.afterBuild();
		}

		this.rows = new Array();
		// assign new records to rows data member
		this.addRows(data.records);
		// clear children of <thead>, <tbody> & <tfoot>
		this.removeRowsFromTable();
		// recreate/reattach grid header rows
		this.rebuildHeader(this.tableHeadElement, data);
		// create grid data rows
		this.createDataRows(this.tableBodyElement, this.columns);
		// create grid footer rows
		this.buildFooterRows(this.tableFootElement, data);
		
		this.displayHeaderRows();
					
		// hide the panel if there are no records
        if (!this.showIfNoData && data.records.length == 0) {
            this.show(false, true);
        }
		else {
			this.show(true);
		}
		this.updateHeight();
    },
    
	
	rebuildHeader: function(parentElement, data) {
		// add pre-header rows, any custom rows
		this.buildPreHeaderRows(parentElement);
		// reload old header row(s) if no mods were added. HOW TO DETECT USER MOD ?? in miniConsole compare grid.indexEntries w/ data.index
		for (var i=0; i < this.headerRows.length; i++) {
			parentElement.appendChild(this.headerRows[i]);
		}
	},

	
	getReloadDataFromGrid: function(resultData) {
        // create data object using info saved from last WFR run
        var data = {};        
        if (valueExists(resultData) && valueExists(resultData.records)) {
            data.records = resultData.records;
            data.hasMoreRecords = resultData.hasMoreRecords;
            data.pagingAllSortFields = resultData.pagingAllSortFields;
        } 
		else {
            data.records = this.rows;
			data.hasMoreRecords = this.hasMoreRecords;
			data.pagingAllSortFields = this.pagingAllSortFields;
        }
        
        data.hasNoRecords = (data.records.length < 1);

		// handle totals record
		if (valueExists(resultData) && valueExists(resultData.totals)) {
			this.totals = new Ab.data.Record();
			this.totals.fromJSON(resultData.totals);
		}

		// handle maximum record
		if (valueExists(resultData) && valueExists(resultData.maximum)) {
			this.maximum = new Ab.data.Record();
			this.maximum.fromJSON(resultData.maximum);
		}
		
		// handle minimum record
		if (valueExists(resultData) && valueExists(resultData.minimum)) {
			this.minimum = new Ab.data.Record();
			this.minimum.fromJSON(resultData.minimum);
		}
		
		// handle average record
		if (valueExists(resultData) && valueExists(resultData.average)) {
			this.average = new Ab.data.Record();
			this.average.fromJSON(resultData.average);
		}
        
        return data;
	},

    // ----------------------- implementation methods ----------------------------------------------

	
	initializeColumns: function() {
		this.initializeSortDirections();
	},

	
	getParameters: function(sortValue) {
		var parameters = {
			controlId:  this.id,
			viewName:   this.viewDef.viewName,
			groupIndex: this.viewDef.tableGroupIndex,
			tableName:  this.viewDef.tableName,
			fieldNames: this.viewDef.getFields(),
			isDistinct: this.isDistinct,
			sortValues: sortValue,
			showData:   true, 
			exportType: this.exportType,
			exportFile: this.exportFile,
			exportReportViewName: valueExists(this.exportReportViewName)? this.exportReportViewName : this.viewDef.viewName,
			exportTitle: this.title,
            version:     Ab.view.View.version
		};
		if (this.applyVpaRestrictions === false) {
			parameters.applyVpaRestrictions = this.applyVpaRestrictions;
		}
        if (this.restriction != null) {
            parameters.restriction = toJSON(this.restriction);
        }
		if (this.viewDef.dataSourceId != null) {
			parameters.dataSourceId = this.viewDef.dataSourceId;
		}
		if ((parameters.viewName == '' && parameters.tableName == '' && parameters.fieldNames == '' ) && 
			 this.columns.length > 0) {
			parameters.tableName = this.columns[0].id.split('.', 1)[0];
			parameters.fieldNames = this.getFieldNamesParameterFromColumns();
		}
		if (this.recordLimit >= 0) {
			parameters.recordLimit = this.recordLimit;
		}
		if (!parameters.groupIndex) {
			parameters.groupIndex = '0';
		}

		parameters.showTotals = (this.isShowTotals() || this.isShowCounts());
		parameters.showCounts = this.isShowCounts();

        Ext.apply(parameters, this.parameters);

        return parameters;
	},


	
	getParametersForRefresh: function() {
		return this.getParameters( this.getCurrentSortValues() );
	},

	
	isShowTotals: function() {
		result = false;
		
		// totals are not supported for grouping data sources
		var ds = this.getDataSource();
		if (ds && ds.type != 'grouping') {
		    for (var i = 0; i < this.fieldDefs.length; i++) {
		        var fieldDef = this.fieldDefs[i];
		        if (fieldDef.showTotals) {
		        	result = true;
		        	break;
		        }
		    }
		}
		
		return result;
	},
		
	
	isShowCounts: function() {
		return this.showCounts;
	},
		
	
	getCurrentSortValues: function() {
		var sortElems = [];
		if (this.sortEnabled) {
			if (valueExistsNotEmpty(this.sortColumnID)) {
				if (this.hasFilterConfiguration(this.sortColumnID)) {
					var customFields = this.getFilterConfigurationFields(this.sortColumnID);
					for (var i=0; i<customFields.length; i++) {
						sortElems.push({'fieldName': customFields[i], 'sortOrder': this.sortColumnOrder});				
					}
				} else {
					sortElems.push({'fieldName': this.sortColumnID, 'sortOrder': this.sortColumnOrder});					
				}
			} else if (this.sortColumns && this.sortColumns.length > 0 && typeof this.sortColumns[0] != 'function') {
				for (var i=0, sc; sc = this.sortColumns[i]; i++) {
					sortElems.push({'fieldName': sc.fieldName, 'sortOrder': (sc.ascending == true) ? 1 : -1});
				}
			} else if(valueExistsNotEmpty(this.sortValues)) {
				//XXX: select value case
				return this.sortValues;
			}
		}
		return toJSON(sortElems);
	},

	
	getFieldNamesParameterFromColumns: function() {
		var fieldNameArray = new Array();
		for (var i=0, col; col = this.columns[i]; i++) {
			fieldNameArray.push(col.id);
		}
		return toJSON(fieldNameArray);
	},

    
	updateHeight: function() {
		this.inherit();

		var headerTable = Ext.get(this.headerTableElement);
		if (headerTable) {
			headerTable.addClass(this.cssClassName);
			if (this.format === 'table') {
			    headerTable.addClass('panelReportAutoWidth');
			}
		}
		
		// body
		var table = Ext.get(this.tableElement);
		if (table) {
			table.addClass(this.cssClassName);
			//table.addClass('panelReport100Width');
			if (this.format === 'table') {
			    table.addClass('panelReportAutoWidth');			    
			}		
		}	

		// footer
		var footerTable = Ext.get(this.footerTableElement);
		if (footerTable) {
			footerTable.addClass(this.cssClassName);	
			if (this.format === 'table') {
			    footerTable.addClass('panelReportAutoWidth');
			}
		}

        // KB 3039173: height can be NaN in IE8
        var height = this.determineDivBodyHeight();
        if (height === 'auto' || !isNaN(height)) {
            this.setDivBodyHeight(height);
        }

		this.resizeColumnWidths();

        // if the panel is not displayed in a dialog (dialogs have their own scrollers)
        if (this.useScroller() && (height === 'auto' || height > Ab.grid.ReportGrid.MIN_SCROLLING_HEIGHT)) {
            this.updateScroller();
        } else {
            // even if the grid should not have full scroller, do display the horizontal scroller
            this.updateScroller({
                verticalScrolling: false
            });
        }

        // KB 3041475: supress duplicate scroll bars
        if (this.divHeadElement) {
            this.divHeadElement.scrollLeft = 1;
            this.divHeadElement.scrollLeft = 0;
        }
        if (this.divFootElement) {
            this.divFootElement.scrollLeft = 1;
            this.divFootElement.scrollLeft = 0;
        }
	},

    
    useScroller: function() {
        return valueExists(this.window) ||
            (this.ownsLayoutRegion() && this.hasScrollingHeight()) ||
            (this.lastInLayoutRegion() && this.hasScrollingHeight()) ||
            this.lastInTab() ||
            this.singleVisiblePanel() ||
            this.hidden;
    },

    
    createScroller: function(scrollableEl, scrollerOptions) {
        this.inherit(scrollableEl, scrollerOptions);

        var grid = this;
        this.scroller.setOnHorizontalScroll(function(x) {
            grid.divHeadElement.scrollLeft = x;
            grid.divFootElement.scrollLeft = x;
        });
    },

    
    hasScrollingHeight: function() {
        var hasScrollingHeight = false;

        if (this.divBodyElement) {
            var bodyHeight = Ext.get(this.divBodyElement).getHeight();
            hasScrollingHeight = (bodyHeight > Ab.grid.ReportGrid.MIN_SCROLLING_HEIGHT);
        }

        return hasScrollingHeight;
    },

    
	setDivBodyHeight: function(height) {
		if (this.divBodyElement) {
            if (height != 'auto' && height < this.scrollbarFactor) {
                height = 'auto';
            }
			this.divBodyElement.style.height =  (height == 'auto') ? height : height + 'px';

            // The jssb-content DIV nested inside the body DIV is absolutely positioned.
            // This means it does not inherit the child table content height.
            // Set the height explicitly to make sure the table is visible in views
            // where multiple grids are stacked inside the same layout region.
            if (height === 'auto') {
                var tableHeight = Ext.get(this.tableElement).getHeight();
                this.divBodyElement.style.height = (tableHeight + 16) + 'px';
            }
		}
	},
		
	
	determineDivBodyHeight: function(){
		var divBodyHeight = 0;		
		var headerTable = Ext.get(this.headerTableElement);													
		if(headerTable){

			// reset
			this.divHeadElement.style.width =  'auto';
			this.headerTableElement.style.width =  'auto';
			this.divHeadElement.style.overflow =  'hidden';						
			this.divFootElement.style.width =  'auto';
			this.footerTableElement.style.width =  'auto';
			this.divFootElement.style.overflow =  'hidden';		
											
			// get div body WIDTH to match scrollable el's width
			var initialScrollableElWidth = this.getScrollableEl().dom.scrollWidth;
			var newDivHeadWidth = initialScrollableElWidth;
			var newHeaderTableWidth = initialScrollableElWidth;
			var newFooterTableWidth = initialScrollableElWidth;
			var newDivBodyWidth = initialScrollableElWidth;
			var newTableWidth = initialScrollableElWidth;		

			// get initial shrunken widths
			var initialShrunkTableHeadElementWidth = this.headerTableElement.scrollWidth;
			var initialShrunkTableElementWidth = this.tableElement.scrollWidth;	
			var initialShrunkTableFootElementWidth = this.footerTableElement.scrollWidth;
			var stretchedWidth = initialScrollableElWidth;
			var newScrollableElWidth = stretchedWidth;

			// determine if there is enough room to add a vertical scrollbar in the data--and have contents fit without a horizontal scrollbar?
			var potentialDataVertScrollableFactor = 0;
			if((Math.max(initialShrunkTableElementWidth, initialShrunkTableHeadElementWidth, initialShrunkTableFootElementWidth)  + this.scrollbarFactor) < initialScrollableElWidth){

				// if so, just factor in this potential scrollbar width;  
				// doesn't really matter at this point if width is not exact, but need for calculating height
				potentialDataVertScrollableFactor = this.scrollbarFactor;
				newDivHeadWidth = initialScrollableElWidth;
				newHeaderTableWidth = initialScrollableElWidth;
				newDivBodyWidth = initialScrollableElWidth ;
				newTableWidth = initialScrollableElWidth - potentialDataVertScrollableFactor;					
			}

			// set the rough row widths
			this.divHeadElement.style.width = newDivHeadWidth + 'px';
			this.headerTableElement.style.width = (newHeaderTableWidth)+ 'px';
			if(!this.hasNoRecords  && (navigator.appVersion.toLowerCase().indexOf("MSIE 8") == -1)){				
				this.divBodyElement.style.width = (newDivBodyWidth > 0) ? (newDivBodyWidth ) + 'px' : 'auto';
				this.tableElement.style.width = (newTableWidth > 0) ? (newTableWidth) + 'px' : 'auto';	
			}
			this.footerTableElement.style.width = (newFooterTableWidth) + 'px';
						
			// now calculate the height		
			divBodyHeight = this.calculateDivBodyHeight();					
		}
							
		return divBodyHeight;	
	},

	
	calculateDivBodyHeight: function(){
		var divBodyHeight = 'auto';
		var availableHeight = this.determineAvailableHeight();
		
		if(!this.hasNoRecords && availableHeight > 0){
			// now calculate height								
			divBodyHeight = availableHeight;
			divBodyHeight -= this.divHeadElement.scrollHeight;				//divHeadHeight
			divBodyHeight -= this.divFootElement.scrollHeight;				//divFootHeight
			divBodyHeight -= this.getScrollableEl().getPadding('tb');	//scrollElPaddingTop and bottom			
			divBodyHeight -= 2;
			if(this.actionbar){    // action bar height
				divBodyHeight -= (Ext.get(this.id + '_actionbar').getHeight() + Ext.get(this.id + '_actionbar').getPadding('tb'));   // actionbar
			}		
			var instructions = Ext.get(this.id + '_instructions'); 		// instructions
			if(instructions){
				divBodyHeight -= instructions.getHeight();  
			}
			
			if(divBodyHeight < 0){
				divBodyHeight = 'auto';
			}

            
		}

		return divBodyHeight;
	},

		
	getFirstRowIndex: function(){
		var rows = this.getDataRows();
		this.columnWidthRowIndex = (rows.length > 0) ? rows[0].rowIndex: -1	
		return this.columnWidthRowIndex;
	},

		
	getCustomWidths: function(dataColumns, headerColumns){
		var customWidths = new Array();
		var scrollableElWidth = this.getScrollableEl().getWidth();
		for(var i=0; i<dataColumns.length; i++){
			var dataColumn = dataColumns[i];
			var width = dataColumn.width;
			
			// Handling percentages
			if(width.match(/%/)){
				width = Number(width.replace('%', ''));
				width = Math.round((this.tableElement.scrollWidth) * .01 * width);
			} 	
			customWidths.push(Number(width));
		}
		return customWidths;
	},

			
	clearGridWidths: function(headerColumns, dataColumns, footerColumns){
		// reset
		this.divHeadElement.style.width = 'auto';
		this.headerTableElement.style.width = 'auto';
		this.divBodyElement.style.width = 'auto';
		this.tableElement.style.width = 'auto';	
		this.divFootElement.style.width = 'auto';
		this.footerTableElement.style.width = 'auto';	
		this.nestedBodyDiv.style.width = 'auto';
						
		for(var i=0; i<headerColumns.length; i++){
			if(i==0 && this.multipleSelectionEnabled){
				dataColumns[i].style.width = '22px';
				headerColumns[i].style.width = '22px';
			}else{
				dataColumns[i].style.width = 'auto';
				headerColumns[i].style.width = 'auto';
			}
			
		}
		for(var j=0; j<footerColumns.length; j++){
			if(footerColumns[j]){
				if(j==0 && this.multipleSelectionEnabled){
					footerColumns[j].style.width = '22px';
				}else{
					footerColumns[j].style.width = 'auto';
				}
				if(footerColumns[j].id && Ext.get(footerColumns[j].id)){
					Ext.get(footerColumns[j].id).removeClass('lastFooterCell');		
				}
			}	
		}	
	},

		
	resizeColumnWidths: function() {
		if(this.tableBodyElement && this.tableHeadElement){

			var firstRowIndex = this.getFirstRowIndex();
			if(firstRowIndex >= 0 && this.tableBodyElement.rows[firstRowIndex]){
					var headerColumns = this.getHeaderColumns();
					var headerTable = Ext.get(this.headerTableElement);			
					var table = Ext.get(this.tableElement);	
					var dataColumns = this.tableBodyElement.rows[firstRowIndex].cells;
					
					if(headerColumns.length != dataColumns.length){
						return;
					}
					
					// the totals row isn't necessarily on the first row
					var footerRow = this.getFooterRowWithMostColumns();
					var footerColumns = (footerRow) ? footerRow.cells : [];
		
					// get custom widths
					var customColumnWidths = this.getCustomWidths(dataColumns, headerColumns);
								
					// clear
					this.clearGridWidths(headerColumns, dataColumns, footerColumns);
																		
					// get starting widths, paddings, and margins
					var headerColumnOffsets = new Array();
					var dataColumnOffsets = new Array();
					var footerColumnOffsets = new Array();
					var headerOriColumnWidths = new Array();
					var dataOriColumnWidths = new Array();																				
					var footerOriColumnWidths = new Array();
					var lastFooterOriRightOffset = 0;
					for(var i=0; i<headerColumns.length; i++){

						var headerColumn= Ext.get(headerColumns[i]);						
						if(Ext.isIE && headerColumn && headerColumn.dom.style.display == 'none'){
							headerOriColumnWidths.push(0);
							headerColumnOffsets.push(0);
							dataOriColumnWidths.push(0);
							dataColumnOffsets.push(0);
							footerColumnOffsets.push(0);
							footerOriColumnWidths.push(0);
							
						}else{
							headerOriColumnWidths.push(headerColumn.getWidth());
							var headerOffset = headerColumn.getPadding('lr') + headerColumn.getBorderWidth('lr');
							headerColumnOffsets.push(headerOffset);
							
							var dataColumn= Ext.get(this.tableElement.rows[firstRowIndex].cells[i]);
							dataOriColumnWidths.push(dataColumn.getWidth());
							var dataOffset = dataColumn.getPadding('lr') + dataColumn.getBorderWidth('lr');
							dataColumnOffsets.push(dataOffset);
							
							var footerColumn= Ext.get(footerColumns[i]);
							if(footerColumn){
								var footerOffset = footerColumn.getPadding('lr') + footerColumn.getBorderWidth('lr');
								footerColumnOffsets.push(footerOffset);
								footerOriColumnWidths.push(footerColumn.getWidth());
								if(i == footerColumns.length-1){
									lastFooterOriRightOffset = footerColumn.getPadding('r');
								}
							}
						}						
					}

					// get max column width between header table and body table, whether calculated or custom widths	
					var cellWidths = new Array();
					var rowWidth = 0;
					for(var i=0; i<dataColumns.length; i++){
						var customWidth = customColumnWidths[i];
						var footerWidth = (footerColumns.length == dataColumns.length) ? footerOriColumnWidths[i] : 0;
	
						var max = Math.max(headerOriColumnWidths[i], dataOriColumnWidths[i], headerColumns[i].width, footerWidth);
						if((customWidth > 0) && customWidth > max){
							cellWidths[i] = customWidth;
						}else{
							cellWidths[i] = max;
						}
						rowWidth += cellWidths[i];						
					}

                // assign column widths to standard position(scenario0)
					for(var k=(this.multipleSelectionEnabled)? 1:0; k<headerColumns.length; k++){
						
											
						// minimum cell width is 0
						var newHeaderColumnWidth = (cellWidths[k] == 0) ? 0 : (cellWidths[k] - headerColumnOffsets[k] );
						var newDataColumnWidth =  (cellWidths[k] == 0) ? 0 : (cellWidths[k] - dataColumnOffsets[k] ) ;
						var newFooterColumnWidth =  (cellWidths[k] == 0) ? 0 : (cellWidths[k] - footerColumnOffsets[k] ) ;	
					
						headerColumns[k].style.width =  (newHeaderColumnWidth) + 'px';
						dataColumns[k].style.width = (newDataColumnWidth) + 'px';
						if(footerColumns.length == headerColumns.length){						
							footerColumns[k].style.width = (newFooterColumnWidth) + 'px';	
						} 
					}		
					
					// assign row widths to the header and body, just assume there is a vertical scrollbar for body
					//this.headerTableElement.style.width = Number(rowWidth ) + 'px';

					this.tableElement.style.width = Number(rowWidth) + 'px';
					var lastColumnIndex = headerColumns.length -1;
					var lastHeaderColumn = headerColumns[lastColumnIndex];
					this.headerTableElement.style.width = Number(rowWidth+this.scrollbarFactor ) + 'px';
					this.footerTableElement.style.width = Number(rowWidth+this.scrollbarFactor ) + 'px';
					if(typeof lastHeaderColumn!="undefined")
					lastHeaderColumn.style.width = (newHeaderColumnWidth+this.scrollbarFactor) + 'px';
					if(footerColumns.length > 0){
						var lastFooterColumn = footerColumns[footerColumns.length-1];
						lastFooterColumn.style.width = (footerColumns.length == 1) ? Number(rowWidth+this.scrollbarFactor):(newFooterColumnWidth+this.scrollbarFactor) + 'px';
						if(this.divBodyElement.scrollHeight > this.divBodyElement.clientHeight){							
							lastFooterColumn.style.width = (footerColumns.length == 1) ? Number(rowWidth + lastFooterOriRightOffset):(newFooterColumnWidth + lastFooterOriRightOffset) + 'px';	
							Ext.get(lastFooterColumn.id).addClass('lastFooterCell');
						}	
					}
															
					// determine if there is a difference from standard position					
					var scrollableEl = this.getScrollableEl();
					var headerTableElement = this.headerTableElement;
					var tableElement = this.tableElement;
					var max = Math.max(headerTableElement.scrollWidth, tableElement.scrollWidth);
					var lastDataColumn = dataColumns[lastColumnIndex];
					var scrollableVsMaxDifference = scrollableEl.dom.scrollWidth - max;

					// scenario1: when the grid is stretched from standard position
					if(scrollableVsMaxDifference > 0){
						// for <table> elements, can just add the scrollable difference
						this.headerTableElement.style.width = Number(rowWidth + this.scrollbarFactor + scrollableVsMaxDifference ) + 'px';
						this.tableElement.style.width = Number(rowWidth + scrollableVsMaxDifference) + 'px';
						this.footerTableElement.style.width = Number(rowWidth + this.scrollbarFactor + scrollableVsMaxDifference) + 'px';	
						
						// for <th> and <td> elements, evenly spread this difference through columns
						var columnOffset = scrollableVsMaxDifference / headerColumns.length;													
						for(var k=(this.multipleSelectionEnabled)? 1 : 0; k<headerColumns.length; k++){
							var newHeaderColumnWidth = (cellWidths[k] - headerColumnOffsets[k] );
							var newDataColumnWidth =  (cellWidths[k] - dataColumnOffsets[k] ) ;
							var newFooterColumnWidth =  (cellWidths[k] - footerColumnOffsets[k] ) ;
							headerColumns[k].style.width =  (newHeaderColumnWidth+columnOffset) + 'px';
							dataColumns[k].style.width = (newDataColumnWidth+columnOffset) + 'px';
							if(footerColumns.length == headerColumns.length){						
								footerColumns[k].style.width = (newFooterColumnWidth+columnOffset) + 'px';
							}	
						}
						
						// account for scrollbars, but add only to last column
						lastHeaderColumn.style.width = (newHeaderColumnWidth+this.scrollbarFactor + columnOffset) + 'px';
						
						if(footerColumns.length == headerColumns.length){
							if(this.divBodyElement.scrollHeight > this.divBodyElement.clientHeight){
								lastFooterColumn.style.width = (newFooterColumnWidth + lastFooterOriRightOffset + columnOffset) + 'px';
							}else{
								lastFooterColumn.style.width = (newFooterColumnWidth + this.scrollbarFactor + columnOffset) + 'px';
							}
						}
												
						if(this.divBodyElement.scrollHeight > this.divBodyElement.clientHeight){
							lastDataColumn.style.width = (newDataColumnWidth + columnOffset) + 'px';
												
							// selectV issue
							var headerDifference = this.divHeadElement.scrollWidth - this.headerTableElement.scrollWidth;
							if(headerDifference > 0){
								this.headerTableElement.style.width = Number(rowWidth + this.scrollbarFactor + scrollableVsMaxDifference + headerDifference) + 'px';
								this.tableElement.style.width = Number(rowWidth + scrollableVsMaxDifference + headerDifference) + 'px';
							}														
							var footerDifference = this.divFootElement.scrollWidth - this.footerTableElement.scrollWidth;
							if(footerDifference > 0){
								this.footerTableElement.style.width = Number(rowWidth + this.scrollbarFactor + scrollableVsMaxDifference + footerDifference) + 'px';
							}		
						}else{
                            if (this.scroller) {
                                this.tableElement.style.width = Number(rowWidth + scrollableVsMaxDifference) + 'px';
                                lastDataColumn.style.width = (newDataColumnWidth + columnOffset) + 'px';
                            } else {
                                this.tableElement.style.width = Number(rowWidth + scrollableVsMaxDifference + this.scrollbarFactor - 1) + 'px';
                                lastDataColumn.style.width = (newDataColumnWidth + columnOffset + this.scrollbarFactor) + 'px';
                            }
						}							
															
					// scenario2: when the grid is shrunk from standard position and there are scrollbars												
					} else if(scrollableVsMaxDifference < 0){

						// synchronize scroll position
						this.scrollHeaderAndFooter();
						var divBodyHeight = this.calculateDivBodyHeight();
						//this.setDivBodyHeight(this.calculateDivBodyHeight());

						// re-adjust height									
						this.setDivBodyHeight(divBodyHeight);
						if(this.ownsLayoutRegion() && Ext.get(this.id + '_layoutWrapper')){
							var containerEl = Ext.get(this.id + '_layoutWrapper').dom.parentElement;
							if(containerEl.parentElement.scrollWidth > containerEl.parentElement.clientWidth){				
								//this.setDivBodyHeight(divBodyHeight-this.scrollbarFactor);
								this.headerTableElement.style.width = Number(rowWidth+this.scrollbarFactor) + 'px';
								if(containerEl.parentElement){
									if((containerEl.parentElement.scrollHeight > containerEl.parentElement.clientHeight)){
										containerEl.style.height = containerEl.parentElement.clientHeight + 'px';
									}
								}
							}
						} else {
							this.setDivBodyHeight(divBodyHeight);
						}
						
						// for grids where there's no vertical scrollbar and the header is too wide
						//if((this.divBodyElement.scrollHeight - this.divBodyElement.clientHeight <= 0)){
						if((this.divBodyElement.scrollHeight - this.divBodyElement.clientHeight < 0)){
							lastHeaderColumn.style.width = (newHeaderColumnWidth) + 'px';
							this.headerTableElement.style.width = Number(rowWidth) + 'px';
						}else if(this.divBodyElement.scrollHeight - this.divBodyElement.clientHeight == 0){
							if(this.divBodyElement.scrollWidth - this.divBodyElement.clientWidth > 0){
								//lastHeaderColumn.style.width = (newHeaderColumnWidth + this.scrollbarFactor) + 'px';
								this.headerTableElement.style.width = Number(rowWidth + this.scrollbarFactor) + 'px';
								this.tableElement.style.width = Number(rowWidth + this.scrollbarFactor) + 'px';
								lastDataColumn.style.width = (newDataColumnWidth + this.scrollbarFactor) + 'px';
							} else {
								lastHeaderColumn.style.width = (newHeaderColumnWidth + this.scrollbarFactor) + 'px';
								this.headerTableElement.style.width = Number(rowWidth + this.scrollbarFactor) + 'px';
							}
						}																			
					}					
				}	else if(this.tableFootElement && this.tableHeadElement && this.hasNoRecords){
				
					// match footer if no body rows				
					this.headerTableElement.style.width = (Ext.get(this.divFootElement).getWidth()) + 'px';
					this.divHeadElement.style.width = (Ext.get(this.divFootElement).getWidth()) + 'px';
					this.footerTableElement.style.width = (Ext.get(this.divFootElement).getWidth()) + 'px';
				}					
				
				// if panel title bar is can be scrolled further than div body, set nested div width larger				
                // GM: KB 3038497 - by changing this.nestedBodyDiv.style.width property, horizontal scrollbar become disabled.
                // KB 3041475
				if(this.divBodyElement && this.nestedBodyDiv.style.width != ''){
                    var panelTitleEl = Ext.get(this.parentElement.id + '_head');
                    if (panelTitleEl) {
                        var panelTitle = panelTitleEl.dom;
                        if(panelTitle.scrollWidth > this.nestedBodyDiv.scrollWidth && this.nestedBodyDiv.offsetWidth != panelTitle.scrollWidth){
                            this.nestedHeaderDiv.style.width = panelTitle.scrollWidth + 'px';
                            this.nestedBodyDiv.style.width = (this.divBodyElement.scrollHeight - this.divBodyElement.clientHeight > 0) ? (panelTitle.scrollWidth - this.scrollbarFactor) + 'px' :  +  (panelTitle.scrollWidth) + 'px';
                            this.nestedFooterDiv.style.width = panelTitle.scrollWidth + 'px';
                        }
                    }
				}
			}
	},	

	getHeaderColumns: function(){
		var tableHeadElements = this.tableHeadElement.getElementsByTagName('th');
		var headerColumns = [];
		for(var i=0; i<this.columns.length; i++){
			for (var j=0, headElem; headElem = tableHeadElements[j]; j++) {
				if (headElem.id == 'sortHeader_' + i) {
					headerColumns.push(headElem);
				}
			}
		}
		return headerColumns;
	},
	
	getFooterRowWithMostColumns: function(){
		var footerRowWithMostColumns = null;
		var footerRows = this.footerTableElement.rows;
		var columns = [];
		for (var rowIndex =0; rowIndex < footerRows.length; rowIndex++){
			var cells = footerRows[rowIndex].cells;
			if(cells.length > columns.length){
				columns = cells;
				footerRowWithMostColumns = footerRows[rowIndex];
			}
		}
		return footerRowWithMostColumns;
	},

    
    isScrollInLayout: function() {
        return !this.useScroller();
    },

	
    isAutoScroll: function() {
        // disable default component scrolling - the grid scrolls its body only
        return false;
    },

    
    getScrollableEl: function() {
        return Ext.get(this.divBodyElement);
    },

	// ----------------------- export report selection --------------------------------------------------
    
    
	callReportJob: function(reportProperties){
		var outputType = reportProperties.outputType, printRestriction = reportProperties.printRestriction, 
			orientation = reportProperties.orientation, handler = reportProperties.handler, recordLimit = reportProperties.recordLimit,
			pageSize = reportProperties.pageSize;
		
		var jobId = null;
		
		var reportTitle = this.title;
		if(reportTitle == ''){
			reportTitle = Ab.view.View.title;
		}
		var parameters = this.getParametersForRefresh();
		
		if(valueExists(handler)){
			parameters.handler = handler;
		}
		
		if(valueExists(recordLimit)){
			parameters.recordLimit = recordLimit;
		}else{
			if(valueExists(parameters.recordLimit)){
				//don't pass panel's recordLimit
				delete parameters.recordLimit;
			}
		}
		
		if(valueExists(printRestriction)){
			parameters.printRestriction = printRestriction;
		}
		
		if(outputType === 'docx' || outputType === 'pdf'){
			if(valueExistsNotEmpty(orientation)){
				parameters.orientation = orientation;
			}
			
			if(valueExistsNotEmpty(pageSize)){
				parameters.pageSize = pageSize;
			}
			
			parameters.outputType = outputType;
			
			jobId = this.callDOCXReportJob(reportTitle, this.restriction, parameters);
		}else if(outputType === 'xls'){
			jobId = this.callXLSReportJob(reportTitle, this.restriction, parameters);
		}
		
		return jobId;
	},
	
	callDOCXReportJob: function(title, restriction, parameters){
		var viewName = this.viewDef.viewName + '.axvw'; 
		return Workflow.startJob(Ab.grid.ReportGrid.WORKFLOW_RULE_DOCX_REPORT, viewName, this.dataSourceId, title, this.getVisibleFieldDefs(), toJSON(restriction), parameters);
	},
	
	callXLSReportJob: function(title, restriction, parameters){
		var viewName = this.viewDef.viewName + '.axvw'; 
		return Workflow.startJob(Ab.grid.ReportGrid.WORKFLOW_RULE_XLS_REPORT, viewName, this.dataSourceId, title, this.getVisibleFieldDefs(), toJSON(restriction), parameters);
	},
	
	
	getVisibleFieldDefs: function(){
		var ctx = this.createEvaluationContext();
    	var fieldDefs = this.fieldDefs;  
    	if(fieldDefs && fieldDefs.length == 0){
    		this.getDataSource().fieldDefs.each(function (fieldDef) {
        		fieldDefs.push(fieldDef);
        	});
    	}
    
    	var visibleFieldDefs = [];
		for (var i = 0, column; column = this.columns[i]; i++) {
		     if(column.hidden){
			continue;
		     }	 
		     var field = this.getFieldDefById(fieldDefs, column.fullName, i);
		     if(valueExists(field)){
		    	 if(field.controlType === '' || field.controlType === 'color' || field.controlType === 'link'){
		    		//XXX: evaluate field.title
			    	field.title = Ab.view.View.evaluateString(field.title, ctx, false);
			    	//XXX: column.hidden has already been evaluated and the column is shown
			    	field.hidden = "false";
			    	visibleFieldDefs.push(field);
		    	 }
		     }
		}	
		var listener = this.getEventListener('beforeExportReport');
        if (listener) {
        	visibleFieldDefs = listener(this, visibleFieldDefs);
        }
        
		return visibleFieldDefs;
    },
    
    
    beforeExportReport: function(panel, visibleFieldDefs){
    	return visibleFieldDefs;
    },
   
   
    
    getFieldDefById: function(fieldDefs, fullName, index){
    	if(index < fieldDefs.length){
	    	var field = fieldDefs[index];
	    	if(valueExists(field) && (fullName == field.fullName)){
	    		return field;
	    	}
    	}
    	//use case: manually add columns in js
    	for (var i = 0, field; field = fieldDefs[i]; i++) {
    		if(fullName === field.fullName){
    			return field;
    		}
    	}
    	
    	return null;
    },

	
	getDataSourceFieldDefById: function(id) {
		var ds = this.getDataSource();
		return (ds && ds.hasOwnProperty('fieldDefs')) ? ds.fieldDefs.get(id) : null;		
	},
	
	// ----------------------- multiple selection --------------------------------------------------

    
    onChangeMultipleSelection: function(row) {
    	// if single checked box is unchecked, uncheck the select all checkbox
    	if (row.row.isSelected() == false){
    		var checkAllEl = Ext.get(this.id + '_checkAll');
    		if (valueExists(checkAllEl)) {
    			checkAllEl.dom.checked = false;
    		}
    	}

    	if (this.actionbar) {
            this.actionbar.updateSelected(this.getSelectedRows().length);
    	}
    	
    	var listener = this.getEventListener('onMultipleSelectionChange');
    	if (listener) {
    		listener(row);
    	}
    },

    
    enableSelectAll: function(enabled) {
        if (this.multipleSelectionEnabled) {
            var checkAllEl = Ext.get(this.id + '_checkAll');
            if (checkAllEl) {
                checkAllEl.setDisplayed(enabled);
            }
        }
    },

	//----------------------------------------sort---

	
	
	columnTypeIsSortable: function(columnType) {
		var ret = false;
 		if (columnType == 'text' || columnType == 'number' || columnType == 'date' || columnType == 'time' || columnType == 'link' || columnType == 'number_link') {
			ret = true;
		}
		return ret;
	},

	
	initializeSortDirections: function() {
		this.sortDirections = [];
		for (var i=0, col; col = this.columns[i]; i++) {
			this.sortDirections[i] = '';
			for (var j=0, sortCol; sortCol = this.sortColumns[j]; j++) {
				if (col.id == sortCol.fieldName) {
					this.sortDirections[i] = sortCol.ascending ? 1 : -1; 
					continue;
				}
			}
			if (this.columnTypeIsSortable(col.type) && this.sortDirections[i] == '') {
				this.sortDirections[i] = this.initialSortDirection;
			}
		}
	},

	
	incrementSortDirection: function(input) {
		return (input == 1) ? -1 : input + 1;
	},
	
	
	incrementHdrSortDirections: function(sortColIndex) {		
		var oldSortLink;
		var headerCells = this.headerRows[0].getElementsByTagName("th");
		// iterate over header cells. test, set sortDirections[], set image
		for (var i=0, headerCell; headerCell = headerCells[i]; i++) {
			//var headerCell = headerCells[i];
			// get column number from header cell id
			var colNumber = headerCell.id.substring(11);
			var imgLinks = headerCell.getElementsByTagName('img');
			var oldSortLink;
			if (imgLinks != null && imgLinks.length > 0) {
				oldSortLink = imgLinks[0];
			}				
			
			// if col not sortable || dir == 0 && index != sortColumnIndex -> null op
			if (colNumber == '' || (colNumber != sortColIndex && this.sortDirections[colNumber] == this.initialSortDirection)) {
				continue;
			}
			// else if index == sortColumnIndex -> increment val in sortDirections[], reset image 
			else if (colNumber == sortColIndex && oldSortLink != null) {
				var nextSortDir = this.incrementSortDirection(this.sortDirections[colNumber]);
				this.sortDirections[colNumber] = nextSortDir;
				var sortLink = this.getSortImage(nextSortDir);
				sortLink.id = 'sortLink_' + colNumber;
				headerCell.replaceChild(sortLink, oldSortLink);
 			}
			// else if col's dir != 0 && index != sortColumnIndex, reset to 0 in sortDirections[], reset image
			else if (oldSortLink != null) {
				this.sortDirections[colNumber] = this.initialSortDirection;
				var sortLink = this.getSortImage(this.initialSortDirection);
				sortLink.id = 'sortLink_' + colNumber;
				headerCell.replaceChild(sortLink, oldSortLink);
			}
		}
	},


	
	getSortImage: function(dir) {
		var sortImage;
		switch (dir) {
			case 1:		// ascending
		    	sortImage = this.createImage(this.imageSortAscending, '', 4)
				break
			case -1:	// descending
   				sortImage = this.createImage(this.imageSortDescending, '', 4)
				break
			default:// 'natural'
				sortImage = this.createImage(this.imageSortNatural, '', 4)
		}
		return sortImage;
	},




	
	activateSortListener: function(sortHeaderCell, columnIndex) {
		if (this.sortListener != null && typeof this.sortListener == "function") {
		    var delegate = this.sortListener.createDelegate(this, [columnIndex]);
			Ext.fly(sortHeaderCell).addListener("click", delegate);
		}
	},

	
	removeSortListener: function(sortHeaderCell) {
		if (this.sortListener != null && typeof this.sortListener == "function") {
		    Ext.fly(sortHeaderCell).removeListener("click", this.sortListener);
		}
	},

	
	onClickSort: function(columnIndex) {
		if (!this.sortListening) {
			return;
		}

		// integer index into columns[] specifying which column to sort on
        var c = this.columns[columnIndex];
		this.sortColumnID = valueExists(c.fullName) ? c.fullName : c.id;
        
		var parameters = this.getParameters(this.getNextSortValues(columnIndex));
		try {
		    var result = this.getData(parameters);

			// call afterGetData for post-processing (e.g., localization of data from messages)
            var listener = this.getEventListener('afterGetData');
            if (listener) {
                listener(this, result.data);
            }
			this.reloadOnSort(result.data);
		} catch (e) {
			this.handleError(e);
		}
		this.incrementHdrSortDirections(columnIndex);
		this.updateHeight();
		
		// anchor to sorted column's header
		window.location.hash = '#sortHeader_' + columnIndex;
	},

	
	getNextSortValues: function(sortColIndex) {
		var sortElems = new Array();
		this.sortColumnOrder = this.incrementSortDirection(this.sortDirections[sortColIndex]); 
		if (this.sortEnabled) {
			if (this.hasFilterConfiguration(this.sortColumnID)) {
				var customFields = this.getFilterConfigurationFields(this.sortColumnID);
				for (var i=0; i<customFields.length; i++) {
					sortElems.push({'fieldName': customFields[i], 'sortOrder': this.sortColumnOrder});				
				}
			} else {
				sortElems.push({'fieldName': this.sortColumnID, 'sortOrder': this.sortColumnOrder});
			}
		}
		return toJSON(sortElems);
	},

	// private
	getFilterConfigurationFields: function(columnId) {
		return this.filterConfiguration.columns[columnId].fields;
	},
	
	// ----------------------- HTML DOM building ---------------------------------------------------
	
	beforeBuild: function() {
		this.inherit();
	},


	
	build: function() {
        this.clear();
        
        // KB 3023647: if the previous TABLE element exists, remove it, otherwise we will get 
        // multiple TABLE elements with the same ID
        var tableElementId = 'grid_' + this.parentElement.id;
        this.removeHtmlTable(tableElementId);
        this.removeHtmlTable(tableElementId + '_divHead');
        this.removeHtmlTable(tableElementId + '_divBody');
        this.removeHtmlTable(tableElementId + '_divFooter');
                        
		// header table
		var headerTable = document.createElement('table');
		headerTable.id = tableElementId + '_header';

		// create grid header rows, add all header rows to a THEAD element in the table
		var tHead = document.createElement('thead');
		this.tableHeadElement = tHead;
		this.headerTableElement = headerTable;
		headerTable.appendChild(tHead);
		var div = document.createElement('div');
		div.id = tableElementId + '_divHead';
		div.appendChild(headerTable);
		this.divHeadElement = div;
		
		// nested DIV required for scrolling
        this.nestedHeaderDiv = document.createElement('div');
        this.nestedHeaderDiv.appendChild(headerTable);
        div.appendChild(this.nestedHeaderDiv);
		this.parentElement.appendChild(div);

		// body table
		var table = document.createElement('table');
		table.id = tableElementId + '_body';
		this.tableElement = table;
		var div = document.createElement('div');
		div.id = tableElementId + '_divBody';

        // nested DIV required for scroller
        this.nestedBodyDiv = document.createElement('div');
        this.nestedBodyDiv.appendChild(table);
        div.appendChild(this.nestedBodyDiv);

        div.className = 'panelReport';
		div.style.overflow = 'auto';
		this.divBodyElement = div;
		this.parentElement.appendChild(div);
		//this.parentElement.appendChild(table);
		var tBody = document.createElement('tbody');
		this.tableBodyElement = tBody;
		table.appendChild(tBody);

		// footer table
		var footerTable = document.createElement('table');
		footerTable.id = tableElementId + '_footer';
		this.footerTableElement = footerTable;
		var div = document.createElement('div');
		div.id = tableElementId + '_divFooter';
		div.appendChild(footerTable);
		div.style.overflow = 'hidden';
		div.className = 'footerDiv'
		this.divFootElement = div;
		
		// nested DIV required for scrolling
        this.nestedFooterDiv = document.createElement('div');
        this.nestedFooterDiv.appendChild(footerTable);
        div.appendChild(this.nestedFooterDiv);
		this.parentElement.appendChild(div);
		var tFoot = document.createElement('tfoot');
		this.tableFootElement = tFoot;
		footerTable.appendChild(tFoot);
	
		this.headerRows = new Array();
		this.buildHeader(tHead);

		var columns = this.columns2.length > 0 ? this.columns2 : this.columns;
	
		// create grid data rows
		this.createDataRows(this.tableBodyElement, columns);
				
		// create grid footer rows, add all footer rows to a TFOOT element in the table
		this.buildFooterRows(tFoot);

		var scrollableEl = this.getScrollableEl();
		Ext.get(this.divHeadElement).on('scroll',this.scrollBodyAndFooter, this);	
		Ext.get(this.divBodyElement).on('scroll',this.scrollHeaderAndFooter, this);
		
		this.displayHeaderRows();
			
		this.updateHeight();
	},

		
	removeHtmlTable: function(tableElementId){
		var tableEl = Ext.get(tableElementId);
        if (tableEl) {
        	tableEl.remove();
        }
	},

		
	scrollHeaderAndFooter: function(){
		var src = this.divBodyElement;						
		this.divHeadElement.scrollLeft = src.scrollLeft;
		this.divFootElement.scrollLeft = src.scrollLeft;		
		this.scrollPanelTitle(src);
	},	

		
	scrollBodyAndFooter: function(){				
		var src = this.divHeadElement;
		this.divBodyElement.scrollLeft = src.scrollLeft;
		this.divFootElement.scrollLeft = src.scrollLeft;		
		this.scrollPanelTitle(src);
	},	

		
	scrollPanelTitle: function(source){
        var panelTitleEl = Ext.get(this.parentElement.id + '_head');
        if (panelTitleEl) {
            var panelTitle = panelTitleEl.dom;
            panelTitle.style.overflow = 'hidden';
            panelTitle.scrollLeft = source.scrollLeft;
        }
	},	

	
	displayHeaderRows: function() {
		for(var i=0; i<this.headerRows.length; i++){
			this.headerRows[i].style.display = (this.rows.length == 0) ? 'none' : '';
		}
	},
		
	
	buildHeader: function(parentElement) {
		this.buildPreHeaderRows(parentElement);

		// create grid header row
		var columns = this.columns;
		this.createHeaderRow(parentElement, columns, 0);
		// create subsequent grid header rows
		if (this.columns2.length > 0) {
		    columns = this.columns2;
		    this.createHeaderRow(parentElement, columns, 1);
		}
	},


	
	buildPreHeaderRows: function(parentElement) {
	},


	
	getTableBodyElement: function() {
		return this.tableBodyElement;
	},
	
	getTableHeadElement: function() {
		return this.tableHeadElement;
	},
	
	getTableFootElement: function() {
		return this.tableFootElement;
	},

	

	
	removeRowsFromTBody: function() {
		this.removeRowsFromTable();
	},
	
	removeRowsFromTable: function() {
		this.removeActionListeners();
		
		if (this.tableBodyElement) {
			var rows = this.tableBodyElement.getElementsByTagName('tr');
		    for (var i=0, row; row = rows[0]; ) {
			    this.tableBodyElement.removeChild(row);
	        }
		}		

		if (this.tableHeadElement) {
			rows = this.tableHeadElement.getElementsByTagName('tr');
		    for (var i=0, row; row = rows[0]; ) {
			    this.tableHeadElement.removeChild(row);
			}
        }

		if (this.tableFootElement) {
			rows = this.tableFootElement.getElementsByTagName('tr');
		    for (var i=0, row; row = rows[0]; ) {
			    this.tableFootElement.removeChild(row);
			}
        }

        // GM: KB 3039081 - destroy scroller object and recreate them, when grid.clear() is called.
        this.clearScroller();
	},

	
	getDisplayableTitle: function(title) {
		if (valueExistsNotEmpty(title)){
			title = title.replace(/&amp;/g, '&');
			title = title.replace(/&gt;/g, '>');
			title = title.replace(/&lt;/g, '<');
			title = title.replace(/&apos;/g, '\'');
			title = title.replace(/&quot;/g, '\"');
		}
		return title;
	},		

	
	createHeaderRow: function(parentElement, columns, level) {
		//var tHead = this.tableHeadElement;
		var headerRow = document.createElement('tr');
		headerRow.id = 'headerRow_' + level;
		if (this.cssHeaderClassName != '') {
			headerRow.className = this.cssHeaderClassName;
		}

		for (var c = 0, column; column = columns[c]; c++) {
		    if (column.hidden === true) continue;
		    
			var headerCell = document.createElement('th');
			headerCell.colSpan = column.colSpan;
			headerCell.id = 'sortHeader_' + c;
            if (column.width != null) {
                headerCell.style.width = column.width;
            }
			var title = this.getDisplayableTitle(column.name);
			headerCell.innerHTML = '<div>' + Ext.util.Format.ellipsis(title, 80) + '</div>';
			
            if (c == 0 && this.multipleSelectionEnabled) {
                var handler = this.onChangeMultipleSelection.createDelegate(this);
                headerCell.innerHTML = '<input id="' + this.id + '_checkAll" type="checkbox"/>';
            }
			
			this.decorateHeaderCell(level, c, column, headerCell);
			
            if (c > 0 || !this.multipleSelectionEnabled) {
			    // justify titles to match content (numbers are right justified if no sort and it's the last column or there's no filter, text left justified)
            	headerCell.className = ((column.type == 'number' || column.type == 'number_link') && !this.sortEnabled && (c < this.columns.length -1 || !this.filterEnabled)) ? 'headerTitleNumberNoSort' : 'headerTitleText';
            }
			
			headerRow.appendChild(headerCell);

		}

		// somehow parentElement gets lost in IE, reset
		if (parentElement == null) {
			parentElement = this.tableHeadElement;
		}

		parentElement.appendChild(headerRow);
		this.headerRows[level] = headerRow;
        
		// add select all/unselect all event handler
        var checkAllEl = Ext.get(this.id + '_checkAll');
        if (valueExists(checkAllEl)) {
            var panel = this;
            checkAllEl.on('click', function(event, el) {
                panel.selectAll(el.checked);
            });
        }
	},



	
	decorateHeaderCell: function(level, c, column, headerCell) {
		if (this.sortEnabled && level == 0 && this.columnIsSortable(column)) {
			var sortLink = this.getSortImage(this.sortDirections[c]);
			sortLink.id = 'sortLink_' + c;
			// onClick function
			this.activateSortListener(headerCell, c);
    		headerCell.appendChild(sortLink);
		}
	},
	
	// private
	columnIsSortable: function(column) {
		return (this.columnTypeIsSortable(column.type) && this.getDataSourceFieldDefById(column.id)) || this.hasFilterConfiguration(column.id);
	},

	// private
	hasFilterConfiguration: function(columnId) {
		return !this.getDataSourceFieldDefById(columnId) && this.filterConfiguration && this.filterConfiguration['columns'] && this.filterConfiguration.columns[columnId];
	},
	
	
	removeSorting: function() {
		var headerCells = this.headerRows[0].getElementsByTagName("th");
		this.sortListening = false;

		// iterate over header cells. test, set sortDirections[], set image
		for (var i=0, headerCell; headerCell = headerCells[i]; i++) {
			var imgLinks = headerCell.getElementsByTagName('img');
			if (imgLinks.length > 0 && imgLinks[0].id.substr(0,8) == 'sortLink') {
					headerCell.removeChild(imgLinks[0]);
			}
		}
	},


	
	restoreSorting: function() {
		var headerCells = this.headerRows[0].getElementsByTagName("th");
		this.sortListening = true;

		// iterate over header cells. test, set sortDirections[], set image
		for (var i=0, headerCell; headerCell = headerCells[i]; i++) {
			// if img link exists no-op
			var imgLinks = headerCell.getElementsByTagName('img');
			if (imgLinks.length > 0 && imgLinks[0].id.substr(0,8) == 'sortLink') {
				continue;
			}
			// use old sort directions, create link add to DOM
			if (typeof this.sortDirections[i] == 'number') {
				var sortLink = this.getSortImage(this.sortDirections[i]);
				sortLink.id = 'sortLink_' + i;
				headerCell.appendChild(sortLink);
			}
		}
	},

	
	createDataRows: function(parentElement, columns) {
	    this.gridRows = new Ext.util.MixedCollection();
	    var multiline = this.hasMultiline(columns);
        
		var rows = this.rows;
		var listener = this.getEventListener('onClickItem');
		
		// create row & cell elements
		for (var r = 0, record; record = rows[r]; r++) {

            var rowElement = document.createElement('tr');  
            rowElement.className = (r % 2 == 0) ? 'dataRow' : 'dataRow odd' ;
            rowElement.onmouseover = function(){
            	this.className = this.className + ' hovered';
          	}
            rowElement.onmouseout = function(){
            	this.className = this.className.replace(' hovered', '');
          	}
          	rowElement.className += (multiline) ? ' multiline' : ' singleline';   
		    var row = new Ab.grid.Row(this, record, rowElement);
		    this.gridRows.add(row);
		    
		    record.index = r;	
		    record.row = row;
		        						
            for (var c = 0, column; column = columns[c]; c++) {
                if (column.hidden === true) continue;
            
                var cellElement = document.createElement('td');
                if(listener && this.columnTypeIsSortable(column.type) && column.type != 'image' && column.enabled == "true"){
                	column.type = 'link';
                	if (column.javaType === 'java.lang.Double' || column.javaType === 'java.lang.Integer') {
	                    column.type = 'number_link';
	                }
                }
				cellElement.className = column.type;
				if (column.width != null) {
					if(!column.width.match(/%/) || (column.width.match(/%/) && r == 0)){
						cellElement.width = column.width;
					}
                }

                if (column.onCreateCell != null) {
                    column.onCreateCell(record, column, cellElement);
                } 
				else {
                    this.createCellContent(record, column, cellElement);
                }
                                  
                rowElement.appendChild(cellElement); 
                
                var cell = new Ab.grid.Cell(row, column, cellElement);
                row.cells.add(column.id, cell);               			
			}
			parentElement.appendChild(rowElement);
		}
		
		this.addRowLevelActions(listener, columns);		
        
		this.afterCreateDataRows(parentElement, columns);
	},

	
	addRowLevelActions: function(listener, columns){
		// add row-level actions
        var panel = this;
        var multipleSelectListener = this.getEventListener('onMultipleSelectionChange');
		this.gridRows.each(function(row) {
            for (var c = 0, column; column = columns[c]; c++) {
                if (column.hidden === true) continue;
                
                var record = row.record;
                var id = panel.generateId(record, column);
                var contentElement = Ext.get(id);
       
                if (contentElement || listener) {
                	if( !(listener && multipleSelectListener && c == 0) ) {
                		panel.createCellActions(record, column, id); 	
                	}               	              		
                }
            }
		});
	},
		  
	
	removeActionListeners: function() {
		this.gridRows.each(function(row) {
			row.removeActionListeners();
		});
	},
	
	
	afterCreateDataRows: function(parentElement, columns) {
	},


	
	addExtraRowCells: function(rowElement) {
	},


	
	createCellActions: function(row, column, id) {
        // create command chain to execute            
        var command = new Ab.command.commandChain(this.id, this.getPrimaryKeysForRow(row));
        var listener = this.getEventListener('onClickItem');
        
        if (this.selectionEnabled) {
            // add selection command first
            var selectionCommand = new Ab.grid.SelectionCommand(this, row);
            command.addCommand(selectionCommand);
        }

        if (typeof(column.commands) != 'undefined' && column.commands.length > 0) {
            // add other commands specified in the column
            command.addCommands(column.commands);
        }       
        
        if (listener && column.type != 'image') {
        	if (typeof(listener.commands) != 'undefined' && listener.commands.length > 0) {
                // add other commands specified in the column
                var listenerCommands = listener.commands;
                for (var i = 0; i < listener.commands.length; i++) {
            	    var listenerCommand = listener.commands[i];
            	    delete listenerCommand['applySelectionRestriction'];
            	    var temp = {};
            	    for (var property in listenerCommand) {
            		    if (property != "applySelectionRestriction") {
            			    temp[property] = listenerCommand[property];
                        }
            	    }
            	    listener.commands[i] = temp;
                }
                command.addCommands(listener.commands);
        	} else {
                command.addCommand(new Ab.grid.OnClickCommand(row, listener));
            }
      	} 
      	
        var actionConfig = {
            useExtButton: false, // use link|button DOM element generated by the grid already
            id: id, // the id of the generated DOM element
            originalId: column.id,
            text: (column.type == 'button') ? column.text: null,
            tooltip: column.tooltip,
            enabled: (listener) ? "true": column.enabled,
            hidden: column.hidden,
            command: command
        };
            
        row.row.addAction(actionConfig);
	},


	
	buildFooterRows: function(parentElement, data) {
		this.buildPreFooterRows(parentElement);

		if (data) { // rebuild
			this.hasMoreRecords = data.hasMoreRecords;
			this.hasNoRecords = (!valueExists(data.hasNoRecords)) ? (data.records.length<1) : data.hasNoRecords;

			if (valueExists(data.totals)) {
				this.totals = new Ab.data.Record();
				this.totals.fromJSON(data.totals);
			}
			
			if (valueExists(data.maximum)) {
				this.maximum = new Ab.data.Record();
				this.maximum.fromJSON(data.maximum);
			}

			if (valueExists(data.minimum)) {
				this.minimum = new Ab.data.Record();
				this.minimum.fromJSON(data.minimum);
			}
			
			if (valueExists(data.average)) {
				this.average = new Ab.data.Record();
				this.average.fromJSON(data.average);
			}
		}

		if (this.hasMoreRecords && !(this.hasPaging)) {
			this.buildMoreRecordsFooterRow(parentElement, this.getLocalizedString(Ab.grid.ReportGrid.z_NOT_ALL_RECORDS_CAN_BE_SHOWN))
		}

		if (this.hasNoRecords) {
			this.buildMoreRecordsFooterRow(parentElement, this.getLocalizedString(Ab.grid.ReportGrid.z_NO_RECORDS_TO_DISPLAY))
		}

		if (this.hasPaging && (this.rows.length > 0) && (this.rows.length < this.allCount)) {
			this.buildMoreRecordsFooterRow(parentElement, '')
		}
		
		// display statistic rows here
		for (var i = 0; i < this.statisticAttributes.formulas.length ; i++ ) {
			var formula = this.statisticAttributes.formulas[i];
			this.buildStatisticFooterRow(parentElement, formula);
		}
		
		if (this.isShowTotals() && !this.isShowSum() && this.statisticAttributes.formulas.length == 0) {
			// use old function - this will not display totals row title
			this.buildTotalsFooterRow(parentElement);
		}else if (this.isShowTotals() && !this.isShowSum() && this.statisticAttributes.formulas.length > 0) {
			// use new function that will add totals row title
			this.buildStatisticFooterRow(parentElement, 'sum');
		}
		
		if (this.isShowCounts()) {
			this.buildCountsFooterRow(parentElement);
		}
				
		this.buildPostFooterRows(parentElement);
	},
			
	
	buildPreFooterRows: function(parentElement) {
	},
	
	
	buildPostFooterRows: function(parentElement) {
	},
	

	
	buildMoreRecordsFooterRow: function(parentElement, message) {
		//create footer row
		var rowElement = document.createElement('tr');
			
		//create message cell in footer row
		var cellElement = document.createElement('td');
		var msg = this.userDefinedFooterHtml != null ? this.userDefinedFooterHtml : message;
		cellElement.className = 'message';
		cellElement.colSpan = this.getNumberOfColumns();
		cellElement.innerHTML = msg;
		if (this.hasPaging){
			this.createPagingLinks(cellElement);
		}
		if(message == this.getLocalizedString(Ab.grid.ReportGrid.z_NOT_ALL_RECORDS_CAN_BE_SHOWN)){
			var detailsMsg = this.getLocalizedString(Ab.grid.ReportGrid.z_NOT_ALL_RECORDS_CAN_BE_SHOWN2);
			detailsMsg = detailsMsg.replace('{0}', this.rows.length);
			cellElement.setAttribute('ext:qtip', detailsMsg);
		}
	
        rowElement.appendChild(cellElement);
		parentElement.appendChild(rowElement);
	},
	//zhaoyongli grid汇总格式 
	buildCountsFooterRow: function(parentElement) {
		var mainTableName = this.getDataSource().mainTableName;
		var countValue = this.getRecordCountValue();
		if(parentElement.childNodes.length==0){
			var rowElement = document.createElement('tr');
			rowElement.id = this.id + '_count';
			var cellElement = document.createElement('td');
			cellElement.className = 'count';
			cellElement.colSpan = this.getNumberOfColumns();
			cellElement.innerHTML = View.getLocalizedString(Ab.grid.ReportGrid.z_COUNT_OF_RECORDS) + ' ' + countValue;
	        rowElement.appendChild(cellElement);
			parentElement.appendChild(rowElement);
		}else{
			var trElement=parentElement.childNodes[0];
			var firstTdElement=trElement.childNodes[0];
			if (this.multipleSelectionEnabled) {
				if(countValue!=0){
				trElement.deleteCell(1);
				firstTdElement.setAttribute("colspan", 2);
				firstTdElement.style['textAlign'] = 'left';
				}
			}
			else {
				firstTdElement.className = 'count';
			}
			firstTdElement.innerHTML = View.getLocalizedString(Ab.grid.ReportGrid.z_COUNT_OF_RECORDS) + ' ' + countValue;
		}
	},

	
	getRecordCountValue: function(){
		var countValue = null;
		var mainTableName = this.getDataSource().mainTableName;
		if (valueExists(this.totals)) {
			countValue = this.totals.getLocalizedValue(mainTableName + '.count_of_records');
		} else if (valueExists(this.maximum)) {
			countValue = this.maximum.getLocalizedValue(mainTableName + '.count_of_records');
		} else if (valueExists(this.minimum)) {
			countValue = this.minimum.getLocalizedValue(mainTableName + '.count_of_records');
		} else if (valueExists(this.average)) {
			countValue = this.average.getLocalizedValue(mainTableName + '.count_of_records');
		}
		return countValue;
	},
	
	buildTotalsFooterRow: function(parentElement) {
		var rowElement = document.createElement('tr');
		rowElement.id = this.id + '_totals';
		
		var mainTableName = this.getDataSource().mainTableName;
		
		for (var c = 0; c < this.columns.length; c++) {
			var column = this.columns[c];
			if (column.hidden) {
				continue;
			}

			var cellElement = document.createElement('td');
			cellElement.className = 'totals';

			var id = valueExists(column.fullName) ? column.fullName : column.id;
			var name = id;
			if (name.indexOf('.') != -1) {
				name = name.substring(name.indexOf('.') + 1);
			}
			var totalValue = this.totals.getLocalizedValue(mainTableName + '.sum_' + name);
			if (valueExists(totalValue)) {
				cellElement.innerHTML = totalValue;
			}

			rowElement.appendChild(cellElement);		
		}
		parentElement.appendChild(rowElement);
	},
	
	
	buildStatisticFooterRow: function(parentElement, formula) {
		var title  = this.getStatisticTitleByType(formula);
		var fieldSufix = this.getFieldSufix(formula);
		var fieldPrefix = '.' + formula + '_';
		var dataRecord = this.getStatisticRecord(formula);
		
		var rowElement = document.createElement('tr');
		rowElement.id = this.id + fieldSufix;
		
		var mainTableName = this.getDataSource().mainTableName;
		var skipColumn =  false;
		for (var c = 0; c < this.columns.length; c++) {
			var column = this.columns[c];
			if (column.hidden || skipColumn) {
				// we must reset skipColumn if is true
				if (skipColumn){ 
					skipColumn =  false;
				}
				continue;
			}
			
			var cellElement = document.createElement('td');
			cellElement.className = 'totals';

			var id = valueExists(column.fullName) ? column.fullName : column.id;
			var name = id;

			if (name.indexOf('.') != -1) {
				name = name.substring(name.indexOf('.') + 1);
			}
			
			var statisticValue = dataRecord.getLocalizedValue(mainTableName + fieldPrefix + name);
			if (valueExists(statisticValue)) {
				cellElement.innerHTML = statisticValue;
				// don't add title after value
				title = null;
			}
			
			if (valueExists(title)) {
				// add row title
				cellElement.className = 'count';
				cellElement.innerHTML = View.getLocalizedString(title);
				// set colspan
				var colspan = this.getColspanForStatisticTitle(c, column.id);
				cellElement.colSpan = colspan;
				skipColumn = (colspan == 2);
				// set title null - was added
				title =  null;
			}
			rowElement.appendChild(cellElement);
		}
		parentElement.appendChild(rowElement);
	},
	
	
	getColspanForStatisticTitle: function(index, currentId) {
		var result = 1;
		if (currentId == 'multipleSelectionColumn') {
			// check if we can set colspan 2
			// get next visible column
			var nextColumnId =  null;
			for (var i = index+1; i < this.columns.length; i++) {
				var nextColumn = this.columns[i];
				if (nextColumn.hidden) {
					continue;
				}else{
					nextColumnId = nextColumn.id;
					break;
				}
			} 
			if (valueExists(nextColumnId)) {
				// get fieldDefs for next column to check if showTotals = false
				var fieldDef = null;
				for (var i = 0; i < this.fieldDefs.length ; i++) {
					fieldDef = this.fieldDefs[i];
					if (fieldDef.id ==  nextColumnId) {
						break;
					}
				}
				if (this.statisticAttributes.fields.indexOf(nextColumnId) == -1 && !fieldDef.showTotals) {
					result = 2;
				}
			}
		}
		return result;
	},
	
	getStatisticTitleByType: function(type) {
		var result = null;
		if (type == 'avg') {
			result = Ab.grid.ReportGrid.z_TITLE_AVERAGE;
		} else if (type == 'min') {
			result = Ab.grid.ReportGrid.z_TITLE_MINIMUM;
		} else if (type == 'max') {
			result = Ab.grid.ReportGrid.z_TITLE_MAXIMUM;
		} else if (type == 'sum') {
			result = Ab.grid.ReportGrid.z_TITLE_TOTALS;
		}
		return result;
	},
	
	getStatisticRecord: function(type) {
		var result = null;
		if (type == 'avg') {
			result = this.average;
		} else if (type == 'min') {
			result = this.minimum;
		} else if (type == 'max') {
			result = this.maximum;
		} else if (type == 'sum') {
			result = this.totals;
		}
		return result;
	},
	
	getFieldSufix: function (type) {
		var result = null;
		if (type == 'avg') {
			result = '_average';
		} else if (type == 'min') {
			result = '_minimum';
		} else if (type == 'max') {
			result = '_maximum';
		} else if (type == 'sum') {
			result = '_totals';
		}
		return result;
	},

	
    setFooter: function(htmlText) {
		this.userDefinedFooterHtml = htmlText;
	},

    // ----------------------- client API ----------------------------------------------------------
	
	
	getCellElement: function(rowIndex, columnIndex) {
	    var rowElement = this.getDataRows()[rowIndex];
	    var cellElement = rowElement.childNodes[columnIndex];
	    return cellElement;
	},
    
    
    getPrimaryKeysForRow: function(row) {
        var keys = new Object();
        for (var i = 0; i < this.primaryKeyIds.length; i++) {
            var id = this.primaryKeyIds[i];
            keys[id] = row[id + ".key"];
        }
        return keys;
    },
    
    
    getPrimaryKeyRecordForRow: function(row) {
        var keys = '';
        for (var i = 0; i < this.primaryKeyIds.length; i++) {
            var id = this.primaryKeyIds[i];
            keys = keys + id  + '=\'' + row[id + ".key"] + '\' ';
        }
        return '<record ' + keys + '><keys ' + keys + '/></record>';
    },
    
    
    getPrimaryKeysForSelectedRows: function() {
        var selectedRows = new Array();
        
        var dataRows = this.getDataRows();
        for (var r = 0; r < dataRows.length; r++) {
            var dataRow = dataRows[r];
            
            var selectionCheckbox = dataRow.firstChild.firstChild;
            if (selectionCheckbox.checked) {
                
                var rowKeys = this.getPrimaryKeysForRow(this.rows[r]);
                selectedRows.push(rowKeys);
            }
        }
        
        return selectedRows;
    },
    
    
   	
	reloadOnSort: function(data) {
        this.beforeRefresh();

		this.rows = [];
		this.addRows(data.records);
		this.removeRowsFromTBody();

		this.rebuildHeader(this.tableHeadElement, data);

		// create grid data rows
		this.createDataRows(this.tableBodyElement, this.columns);

		this.buildFooterRows(this.tableFootElement, data);
		
        this.afterRefresh();
	},


	
    getSelectedRows: function() {
        var selectedRows = new Array();
        
        var dataRows = this.getDataRows();
        for (var r = 0; r < dataRows.length; r++) {
            var dataRow = dataRows[r];
            
            var selectionCheckbox = dataRow.firstChild.firstChild;
            if (selectionCheckbox.checked) {
                selectedRows.push(this.rows[r]);
            }
        }
        
        return selectedRows;
    },
    
    
    getSelectedGridRows: function() {
        var rows = [];
        this.gridRows.each(function (row) {
            if (row.isSelected()) {
                rows.push(row);
            }
        });
        return rows;
    },
    
    
    getSelectedRecords: function() {
        var records = [];
        this.gridRows.each(function (row) {
            if (row.isSelected()) {
                records.push(row.getRecord());
            }
        });
        return records;
    },
    
    
    getFieldValuesForSelectedRows: function(fieldName) {
    	var values = [];
    	this.gridRows.each(function (row) {
    		if (row.isSelected()) {
    			values.push(row.getRecord().getValue(fieldName));
    		}
    	});
    	return values;    
    },
        
	
    setAllRowsSelected: function(selected) {
		// get switch value, default == true
		var setSelectedTrue = ((typeof selected == 'undefined') || selected == true) ? true : false;
        var selectedRows = new Array();
        
        var dataRows = this.getDataRows();
        for (var r = 0; r < dataRows.length; r++) {
            var dataRow = dataRows[r];
            
            var selectionCheckbox = dataRow.firstChild.firstChild;
            if (typeof selectionCheckbox.checked != 'undefined') 
			{
				if (selectionCheckbox.checked != setSelectedTrue) {
					selectionCheckbox.checked = setSelectedTrue;
					this.onChangeMultipleSelection(this.rows[r]);
				}
                selectedRows.push(this.rows[r]);			
            }
        }
        
        return selectedRows;
    },
    
    
    selectAll: function(selected) {
        this.setAllRowsSelected(selected);  
    },
    
	
    setAllRowsUnselected: function() {
		return this.setAllRowsSelected(false);        
    },
    
    
    unselectAll: function() {
        this.setAllRowsUnselected();  
    },
    
    
    selectRow: function(index) {
        var dataRows = this.getDataRows();
        
        if (this.selectedRowIndex >= 0 && dataRows.length > this.selectedRowIndex) {
            Ext.get(dataRows[this.selectedRowIndex]).removeClass('selected');
        }
        
        this.selectedRowIndex = index;
        if (dataRows.length > this.selectedRowIndex) {
           Ext.get(dataRows[this.selectedRowIndex]).addClass('selected');
        }
    },

	
	selectRowChecked: function(index, selected) {
		// get switch value, default == true
		var setSelectedTrue = ((typeof selected == 'undefined') || selected == true) ? true : false;

        var dataRow = this.getDataRows()[index];
		var selectionCheckbox = dataRow.firstChild.firstChild;

		if (typeof selectionCheckbox.checked != 'undefined' && selectionCheckbox.checked != setSelectedTrue) {
			selectionCheckbox.checked = setSelectedTrue;
			this.onChangeMultipleSelection(this.rows[index]);			
		}
	},
    
    
    getDataRows: function() {
        return Ext.query('.dataRow', this.parentElement);
    },

    
    evaluateExpressions: function(ctx) {
        if (!valueExists(ctx)) {
            ctx = this.createEvaluationContext();
        }
        
        this.inherit(ctx);
        
		// evaluate column titles
		for (var i=0, fld; fld = this.fieldDefs[i]; i++) {
			if (fld.controlType == 'button') {
				continue;
			}
	        var evaluatedTitle = Ab.view.View.evaluateString(fld.title, ctx, false);
			if (evaluatedTitle != fld.title) {
				this.setFieldLabel(fld.id, evaluatedTitle);
			}
		}

        // delegate to all constituent rows
        this.gridRows.each(function(row) {
	        ctx.record = row.record;
            row.evaluateExpressions(ctx);
            ctx.record = null;
        });

    },

	// find & set the column title 
	setFieldLabel: function(fieldName, fieldLabel) {
		if (!this.tableHeadElement) {
			return;
		}
		
		var columnIndex = -1;
		for (var c=0, col; col = this.columns[c]; c++) {
			if (col.id == fieldName) {
				columnIndex = c;
				break;
			}
		}
		if (columnIndex < 0) {
			return;
		}
		var targetId = 'sortHeader_' + columnIndex;

		var tableHeadElements = this.tableHeadElement.getElementsByTagName('th');
		for (var i=0, headElem; headElem = tableHeadElements[i]; i++) {
			if (headElem.id == targetId) {
				if (headElem.firstChild.textContent) { // KB 3030672, 3038065
                    headElem.firstChild.textContent = fieldLabel;
				} else {
                    headElem.firstChild.innerHTML = fieldLabel;
				}
				return;
			}
		}
	},

    
    addColumnActionListener: function(actionId, callback, scope) {
        // if the caller did not specify the scope, use this panel
        if (!valueExists(scope)) {
            scope = this;
        }
        
        this.gridRows.each(function (row) {
            var action = row.actions.get(actionId);
            if (action) {
                action.addListener(callback.createDelegate(scope, [row, action]));
            }
        });
    },

    
    rowToRecord: function(row, fieldNames) {
        var rawValues = {};        
        
        if (valueExists(fieldNames)) {
            for (var i = 0; i < fieldNames.length; i++) {
                var name = fieldNames[i];

                var rawValue = row[name + '.raw'];
                if (!valueExists(rawValue)) {
                    rawValue = row[name];
                }
                rawValues[name] = rawValue;
            }
        } else {
            for (var name in row) {
                // add only raw values
                if (!endsWith(name, '.key') && !endsWith(name, '.raw') &&
                    name != 'grid' && name != 'index' && name != 'row') {
                    
                    var rawValue = row[name + '.raw'];
                    if (!valueExists(rawValue)) {
                        rawValue = row[name];
                    }
                    rawValues[name] = rawValue;
                }
            }
        }
        
        // parse raw values into objects
        var values = this.getDataSource().parseValues(rawValues, false);
        var oldValues = this.getDataSource().parseValues(rawValues, false);
        
        // create and return record
        var record = new Ab.data.Record(values, false);
        record.oldValues = oldValues;
        return record;
    },

    
    recordToRow: function(record) {
        var rawValues = this.getDataSource().formatValues(record.values, false);
        var formattedValues = this.getDataSource().formatValues(record.values, true);

        var row = {};
        for (var name in rawValues) {
            row[name + '.raw'] = rawValues[name];
        }
        for (var name in formattedValues) {
            row[name] = formattedValues[name];
        }
        
        for (var i = 0; i < this.primaryKeyIds.length; i++) {
            var name = this.primaryKeyIds[i];
            row[name + ".key"] = rawValues[name];
        }
        
        return row;
    },
    
    
    setRecords: function(records, hasMoreRecords) {
        this.beforeRefresh();

        if (!valueExists(hasMoreRecords)) {
            hasMoreRecords = false;
        }
        this.hasMoreRecords = hasMoreRecords;

        var rows = [];
        for (var i = 0; i < records.length; i++) {
            var row = this.recordToRow(records[i]);
            rows.push(row);
        }
        this.rows = [];
        this.addRows(rows);

        this.beforeBuild();
        this.build();
        this.afterBuild();

        this.afterRefresh();
    },
    
	
	showDocumentLinkCommand: function(row, column) {
		var tableAndName = column.fullName.split('.');
        var fileName = row[column.fullName];
        var keys = row.grid.getPrimaryKeysForRow(row);
		for (name in keys) {
			var keyName = name.split('.')[1];
			keys[keyName] = keys[name]
		}

		View.showDocument(keys, tableAndName[0], tableAndName[1], fileName, null);
	},

	
	getLegendBitmapName: function(id, row, hpattern) {
    	// find the field definition for specified column ID
    	var tableName = '';
    	for (var i = 0; i < this.fieldDefs.length; i++) {
    		var fieldDef = this.fieldDefs[i];
    		if (fieldDef.id === id) {
    			tableName = fieldDef.fullName.substring(0, fieldDef.fullName.indexOf('.'));
    			break;
    		}
    	}
    	
    	// prepare primary key values from specified table
    	var primaryKeyValues = [];
        for (var i = 0; i < this.primaryKeyIds.length; i++) {
            var id = this.primaryKeyIds[i];
            
            if (id.indexOf(tableName + '.') != 0) {
            	continue;
            }
            
            var pkey = row[id + ".key"];
            
            if (!valueExists(pkey)) {
	            pkey = row[id];
	        } 
	       
	        primaryKeyValues.push(pkey); 
        }
    	
		return hpattern.getLegendBitmapName(tableName, primaryKeyValues);
	},
	
	//--------------- Statistic data -----------------------------
	
	setStatisticAttributes: function(configObject){
		// statistic formula
		if (valueExists(configObject.formulas)) {
			this.statisticAttributes.formulas = configObject.formulas; 
		}
		// statistic fields
		if (valueExists(configObject.fields)) {
			this.statisticAttributes.fields = configObject.fields;
		}
		
		if (this.statisticAttributes.fields.length == 0 || this.statisticAttributes.formulas.length == 0) {
			this.statisticAttributes.formulas = [];
			this.statisticAttributes.fields = [];
			return;
		}
		// make statistic data array lower case
		var tmpValues = this.statisticAttributes.formulas.join(',').toLowerCase();
		this.statisticAttributes.formulas = tmpValues.split(',');		
		
		// WFR id
		this.statisticWorkflowRuleId = Ab.grid.ReportGrid.WORKFLOW_RULE_STATISTIC_DATA;
		
	},
	
	// Show average values ?
	isShowAverage: function(){
		return (this.statisticAttributes.formulas.indexOf('avg') != -1);
	},
	
	// Show maximum values ?
	isShowMax: function() {
		return (this.statisticAttributes.formulas.indexOf('max') != -1);
	},
	
	//Show minimum values ?
	isShowMin: function() {
		return (this.statisticAttributes.formulas.indexOf('min') != -1);
	},
	
	// Show totals for grouping data source?
	isShowSum: function() {
		return (this.statisticAttributes.formulas.indexOf('sum') != -1);
	},

	//--------------- API -----------------------------	
	
	showNoRecordsMessage: function(){
		this.hasNoRecords = true;
		this.buildMoreRecordsFooterRow(this.tableFootElement, this.getLocalizedString(Ab.grid.ReportGrid.z_NO_RECORDS_TO_DISPLAY));
	},

		
	showMoreRecordsMessage: function(){
		this.hasMoreRecords = true;
		this.buildMoreRecordsFooterRow(this.tableFootElement, this.getLocalizedString(Ab.grid.ReportGrid.z_NOT_ALL_RECORDS_CAN_BE_SHOWN));
	}	
	
}, 
{
    // ----------------------- constants -----------------------------------------------------------

	// @begin_translatable
	z_NOT_ALL_RECORDS_CAN_BE_SHOWN: 'Not all records are shown.',
	z_NOT_ALL_RECORDS_CAN_BE_SHOWN2: 'This view displays the first {0} records.',
	z_NO_RECORDS_TO_DISPLAY: 'No records to display.',
	z_PAGING_NOT_ALL_RECORDS_CAN_BE_SHOWN: 'Not all records can be shown.',
	z_COUNT_OF_RECORDS: 'Total records:',
	z_TITLE_TOTALS: 'Totals:',
	z_TITLE_MAXIMUM: 'Maximum:',
	z_TITLE_MINIMUM: 'Minimum:',
	z_TITLE_AVERAGE: 'Average:',
	// @end_translatable

	// predefined name for the column that contains multiple selection checkboxes
    COLUMN_NAME_MULTIPLE_SELECTION: 'multipleSelectionColumn',

    // name of the default WFR used to render the data
    WORKFLOW_RULE_REFRESH: 'AbCommonResources-getDataRecords',
    // name of the default WFR used to get the statistic data
    WORKFLOW_RULE_STATISTIC_DATA: 'AbCommonResources-StatisticDataService-getStatisticDataRecords',

    //WFR to generate a DOCX report
    WORKFLOW_RULE_DOCX_REPORT: 'AbSystemAdministration-generatePaginatedReport-buildDocxFromDataSource',
    //WFR to generate a XLS report
    WORKFLOW_RULE_XLS_REPORT: 'AbSystemAdministration-generatePaginatedReport-generateGridXLSReport',

    // minimum height of the grid body in pixels required for the scroller to be displayed
    MIN_SCROLLING_HEIGHT: 30
});



Ab.grid.Cell = Base.extend({
    // parent Ab.grid.Row object
    row: null,
    
    // matching Ab.grid.Column object
    column: null,
    
    // <td> DOM element reference
    dom: null,
    
    
    constructor: function(row, column, cellElement) {
        this.row = row;
        this.column = column;
        this.dom = cellElement;
    },
    
    getEl: function() {
        return Ext.get(this.dom);
    }
});



Ab.grid.Row = Base.extend({
    // parent grid panel reference
    panel: null,
    
    // row data record
    record: null,
    
    // Ext.util.MixedCollection of actions, keyed by the field name
    actions: null,
    
    // Ext.util.MixedCollection of cells, keyed by the field name
    cells: null,
    
    // <tr> DOM element reference
    dom: null,
    
    
    constructor: function(panel, record, rowElement) {
        this.panel = panel;
        this.record = record;
        this.dom = rowElement;
        this.actions = new Ext.util.MixedCollection();
        this.cells = new Ext.util.MixedCollection();
    },
    
    
    addAction: function(config) {
        var action = new Ab.view.Action(this.panel, config);
        action.row = this;
        this.actions.add(action.originalId, action);
    },
    
    
    removeActionListeners: function() {
        this.actions.each(function(action) {
            action.removeListeners();
        });
    },
    
    
    getRecord: function(fieldNames) {
        return this.panel.rowToRecord(this.record, fieldNames);
    },
    
    
    getFieldValue: function(fieldName) {
        var rawValue = this.record[fieldName + '.raw'];
        if (!valueExists(rawValue)) {
            rawValue = this.record[fieldName];
        }
        
        var value = rawValue;
        var dataSource = this.panel.getDataSource();
        if (dataSource) {
            value = dataSource.parseValue(fieldName, rawValue, false);
        }
        
        return value;
    },
    
    
    setFieldValue: function(fieldName, fieldValue) {
        var rawValue = this.panel.getDataSource().formatValue(fieldName, fieldValue, false);
        this.record[fieldName + '.raw'] = rawValue;
        
        var formattedValue = this.panel.getDataSource().formatValue(fieldName, fieldValue, true);

        var cellEl = Ext.get(this.cells.get(fieldName).dom);
        var linkEl = cellEl.child('a');
        if (linkEl) {
            linkEl.dom.innerHTML = formattedValue;
        } else {
            cellEl.dom.innerHTML = formattedValue;
        }
    },
    
    
    isSelected: function() {
        var selectionCheckbox = this.dom.firstChild.firstChild;
        return (selectionCheckbox.checked);
    },
    
    
    select: function(selected) {
        if (!valueExists(selected)) {
            selected = true;
        }
        var selectionCheckbox = this.dom.firstChild.firstChild;
        if (valueExists(selectionCheckbox.checked)) {
            selectionCheckbox.checked = selected;
        }
    },
    
    
    unselect: function() {
        this.select(false);
    },

        
    getIndex: function() {
        return this.record.index;  
    },
    
    
    evaluateExpressions: function(ctx) {
        // TODO: evaluate expressions in text values, i.e. 
        // value="${record['mo.from_bl_id'] + '|' + record['mo.from_fl_id']}"
        
        this.actions.each(function(action) {
            action.evaluateExpressions(ctx);
        });
    }
});



Ab.grid.SelectionCommand = Ab.command.Command.extend({
    
    // mini-console instance
    grid: null,
    
    // row to select
    row: null,
    
    
    constructor: function(grid, row) {
        this.grid = grid;
        this.row = row;
    },
    
    
    handle: function() {
	    if (this.grid.selectionEnabled) {
	        this.grid.selectRow(this.row.index);
	    }
    }
});


Ab.grid.OnClickCommand = Ab.command.Command.extend({

    // row to select
    row: null,

    // listener function to call
    listener: null,

    
    constructor: function(row, listener) {
        this.row = row;
        this.listener = listener;
    },

    
    handle: function() {
        this.listener(this.row.row);
    }
});





var INDEX_DISPLAY_THRESHOLD = 50;



Ab.grid.MiniConsole = Ab.grid.ReportGrid.extend({

	// filter row is member variable for possible restore of HTML on rebuild
	filterRow: null,
	
	// index row is member variable for possible restore of HTML on rebuild
	indexRow: null,

	// whether to display the index bar
    indexEnabled: false,

	// column on which console is indexed
	indexColumnIndex: -1,

	indexColumnID: null,

	// index entry in the {text, url} format	???
	indexValue: '',
	
	// index level or length of character string shown in index link
	indexLevel: 0,
	
	// holder for actual index entries returned from WFR
	indexEntries: null,

	// whether to display the filter bar
	filterEnabled: false,
	
	// hold FilterValues object between contructor & build calls, after that DOM elements are model + view
	filterValues: [],

	// action listener on column index links
	indexListener: null,

	// action listener on column filter controls
	filterListener: null,
	clearFilterListener: null,

	// search palette DOM element
	filterPaletteElement: null,

	// count of entries & exits to test for hide
	filterPaletteEntryCount: 0,

	// shorthand boolean to guide listeners & workaround FF 2 bug
	filterPaletteIsActive: false,

    // whether the filter and index bar's collapse or expanded
    isCollapsed: false,
	
	// image file constants
	imageFilterClear: '',
	imageExpand: '',
	imageCollapse: '',

	// record limit defined in afm-cofig.xml
	configurationRecordLimit: -1,
	
	// boolean for whether paging exists	
	hasPaging: false, 

	firstListener: null,
	
	// action listener for Prev link
	prevListener: null,
	
	// action listener for Next link
	nextListener: null,
	
	// holder for first row of current page
	currentPageFirstRecord: {},
	
	// holder for last row of current page
	currentPageLastRecord: {},
	
	// array of first rows
	firstRecords: null,	
	
	pagingAllSortFields: [],
	
	// count of all records found in the index
	allCount: 0,
	
	// whether prev or next
	pagingAction: null,
	
	// current page number
	currentPage: -1,
	
	// total number of pages
	totalPages: -1,
	

	
	constructor: function(id, configObject) {
		this.inherit(id, configObject);

		// if index column is not specified, do not show index row
		var indexColumnID = configObject.getConfigParameterIfExists('indexColumnID');
		if (valueExistsNotEmpty(indexColumnID)) {
		    this.indexEnabled = true;
			this.indexColumnID = indexColumnID;
			this.indexListener = this.onClickIndex;
			this.prevListener = this.onClickPrev;
			this.nextListener = this.onClickNext;	
			this.firstListener = this.onClickFirst;	
			this.isCollapsed = false;
		}       
		else {
		    this.indexEnabled = false;
			this.indexColumnID = '';
		}
		this.filterListener = this.onClickFilter;
		this.clearFilterListener = this.clearAllFilters;

		var restriction = configObject.getConfigParameterIfExists('restriction');
		if (valueExists(restriction) && restriction != '') {
		    this.restriction = restriction;
		}

		var filterValues = configObject.getConfigParameterIfExists('filterValues');
        if (valueExists(filterValues)) {
            this.filterValues = new Array();
			for (var colName in filterValues) {		
				var value = filterValues[colName];
				if (value != null && trim(value) != '')	{
					this.filterValues.push({"fieldName":  colName, "filterValue": value});
				}
			}
			this.filterEnabled = true;
			this.isCollapsed = false;
		}
        
        var showIndexAndFilterOnLoad = configObject.getConfigParameterIfExists('showIndexAndFilterOnLoad');
        this.isCollapsed = !showIndexAndFilterOnLoad;
        		
		// initialize image file 'constants'
		this.imageFilterClear = Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/view/ab-filter-clear.png';
		this.imageExpand = Ab.view.View.contextPath + '/schema/ab-system/graphics/ab-miniconsole-expand.gif';
		this.imageCollapse = Ab.view.View.contextPath + '/schema/ab-system/graphics/ab-miniconsole-collapse.gif';

		// initialize paging vfariables
		this.firstRecords = [];
		this.pagingAction = null;
		this.currentPageFirstRecord = null;
		this.currentPageLastRecord = null;
		this.configurationRecordLimit = configObject.getConfigParameterIfExists('configurationRecordLimit');
		this.pagingAllSortFields = [];

	},

	
	// ----------------------- common control API methods ------------------------------------------

        
	// ----------------------- implementation methods ----------------------------------------------

	
	initializeColumns: function() {
		this.inherit();
		this.setFilterEnabled();
	},

	
	setFilterEnabled: function() {
		for (var i=0, col; col = this.columns[i]; i++) {
			var fieldDef = this.getFieldDef(col.id);
			var isDateField = (fieldDef && fieldDef.hasOwnProperty('type'))? (fieldDef.type.toUpperCase() == 'JAVA.SQL.DATE') : false;


			if (!col.isVirtual  && 
					(col.type == 'text' ||col.type == 'date'|| col.type == 'number' || col.type == 'link' || col.type == 'number_link')) {
				col.filterEnabled = true;
			}
			else {
				col.filterEnabled = false;
			}
		}
	},


	
	beforeBuild: function() {
		this.inherit();
		this.enableIndex(this.indexEnabled, this.indexColumnID, this.indexEntries);
		this.filterEnabled = true;
	},

	
	afterBuild: function() {
		this.inherit();
		this.showIndexAndFilter();
		this.addFilterPaletteAndListeners();
	},

    
	updateHeader: function() {
		this.inherit();
		this.showIndexAndFilter();
		this.addFilterPaletteAndListeners();
	},

	
	addFilterPaletteAndListeners: function() {
		var smartSearchDivId = 'searchDiv_' + this.parentElement.id;
		var smartSearchDiv = document.getElementById(smartSearchDivId);
		if (smartSearchDiv == null) {
			this.filterPaletteElement = document.createElement('div');
			this.filterPaletteElement.id = smartSearchDivId;
			this.filterPaletteElement.style.zIndex = -2;
			this.filterPaletteElement.style.display = 'none';
			this.filterPaletteElement.className = 'smartFilterPalette';
			this.parentElement.appendChild(this.filterPaletteElement);

			//this.createHeaderButtons( this.filterPaletteElement );
			//this.createFilterButtons( this.filterPaletteElement );
		}
		
		// place mouse listeners on all column headers
		if (this.headerRows.length > 0) {
			var headerRow = this.headerRows[0];
			var grid = this;
			for (var i=0, headerCell; headerCell = this.headerRows[0].childNodes[i]; i++) {
				this.activateFilterPaletteListener(headerCell, false);
			}
		}
		if (this.filterRow != null) {
			for (var j=0, filterCell; filterCell = this.filterRow.childNodes[j]; j++) {
				this.activateFilterPaletteListener(filterCell, false);
			}
		}
		this.activateFilterPaletteListener(this.filterPaletteElement, true);
	},

	expandIndexAndFilter: function(){
		if(this.filterEnabled){
			this.isCollapsed = false;
			this.showIndexAndFilter();
		}
	},
	
	
	activateFilterPaletteListener: function(element, self) {
		var delegateOver = !self ? this.filterPaletteExposeListener.createDelegate(this) : this.filterPaletteExposeSelfListener.createDelegate(this);
		var delegateOut = this.filterPaletteHideListener.createDelegate(this);
	    Ext.fly(element).on({
			'mouseover' : {fn: delegateOver, scope: element},
			'mouseout' : {fn: delegateOut, scope: element}
		});
	},
	
	
	filterPaletteExposeListener: function() {
		// if palette buttons haven't been created yet, create and reposition
		//if (this.filterPaletteElement.firstChild == null) {
			var extTop = Ext.fly(this.tableBodyElement).getTop(false);
			var extLeft = Ext.fly(this.tableBodyElement).getLeft(false);
			Ext.fly(this.filterPaletteElement).setY(extTop);
			Ext.fly(this.filterPaletteElement).setX(extLeft);
		//}

		// expose
		this.filterPaletteElement.style.zIndex = 200;
		this.filterPaletteElement.style.visibility = 'visible';
		this.filterPaletteIsActive = true;		
		if (this.filterPaletteEntryCount == 0) {
			this.filterPaletteEntryCount++;
		}
	},

	
	filterPaletteExposeSelfListener: function() {
		if (this.filterPaletteElement.style.zIndex >= 0) {
			this.filterPaletteElement.style.zIndex = 200;
			this.filterPaletteElement.style.visibility = 'visible';
			this.filterPaletteIsActive = true;
			if (this.filterPaletteEntryCount == 0) {
				this.filterPaletteEntryCount++;
			}
		}
	},

	
	filterPaletteHideListener: function() {
		if (this.filterPaletteEntryCount > 0) {
			this.filterPaletteEntryCount--;
		}
		// defer hide for 1/2 sec
		this.hideFilterPalette.defer(500, this);
	},

	
	hideFilterPalette: function() {
		if (this.filterPaletteEntryCount <= 0 ) {
			this.filterPaletteElement.style.zIndex = -2;
			this.filterPaletteElement.style.visibility = 'hidden';
			this.filterPaletteIsActive = false;
		}
	},
	
	
	onClickSort: function(columnIndex) {
		this.firstRecords = [];
		this.inherit(columnIndex);
	},



	
	getParameters: function(sortValues, index) {
		var parameters = this.inherit(sortValues);
		if (typeof(index) != 'undefined' && index != null) {
			this.indexColumnID = index.columnName;
			this.indexLevel = index.index_level;
			this.indexValue = index.value + '%';
		}
		// sort from reportGrid has no idex arg, use this' index properties
		if (typeof(this.indexColumnID) != 'undefined' && this.indexColumnID != null) {
		    parameters.indexField = this.indexColumnID;
			parameters.indexLevel = this.indexLevel;
			parameters.indexValue = this.indexValue + '%';
		}
		parameters.filterValues = this.getFilterValues();
		parameters.pagingAction = this.pagingAction;
		parameters.currentPageFirstRecord = this.currentPageFirstRecord;
		parameters.currentPageLastRecord = this.currentPageLastRecord;
		if (this.firstRecords.length > 0){
			parameters.firstRecords = this.firstRecords[this.firstRecords.length-1];
		} else {
			parameters.pagingAction = null;
			parameters.currentPageFirstRecord = {};
			parameters.currentPageLastRecord = {};
			parameters.firstRecords = {};		
		}
		
		parameters.pagingAllSortFields = toJSON(this.pagingAllSortFields);
		
        return parameters;
	},

	
	getInitialParameters: function() {
		var parameters = this.inherit();
	    parameters.indexField = this.indexColumnID;
		parameters.indexLevel = '0';
		parameters.indexValue = '';
		parameters.filterValues = this.getFilterValues();
		parameters.pagingAction = this.pagingAction;
		return parameters;
	},

	
	getParametersForRefresh: function() {
		return this.getParameters(this.getCurrentSortValues(), new Ab.grid.IndexValue(this.indexColumnID, this.indexValue, this.indexLevel));
	},


	//-----------------------------------------index--

	
	setIndexColumnByID: function(indexColumnID) {
		//var test = indexColumnID.replace(/^\s+/, '');
		if (this.columns == null && indexColumnID.length == 0 )	{
			return;
		}
		for (var i=0; i < this.columns.length; i++) {
			if (this.columns[i].id == indexColumnID) {
				this.indexColumnIndex = i;
				return true;
			}
		}
		// use sort column if not defined
		if (this.sortColumnID != '') {
			for (var i=0; i < this.columns.length; i++) {
				if (this.columns[i].id == this.sortColumnID) {
					this.indexColumnIndex = i;
					return true;
				}
			}
		}

		// use 1st column if sort not defined
		for (var i=0; i < this.columns.length; i++) {
			var type = this.columns[i].type;
			if (this.columnTypeIsSortable(type)) {
				this.indexColumnIndex = i;
			}
		}	
	},


	
	getIndexColumn: function() {
        var indexColumn = null;
        if (this.indexColumnIndex >= 0) {
            indexColumn = this.columns[this.indexColumnIndex];
        }
        return indexColumn;
	},

	
	getIndexColumnName: function() {
        var indexColumnName = '';
        var indexColumn = this.getIndexColumn();
        if (null != indexColumn) {
            indexColumnName = indexColumn.name;
        }
        return indexColumnName;
	},

	
	setIndexEntries: function(indexEntries) {
		if (typeof indexEntries != 'undefined') {
			this.indexEntries = indexEntries;		
		}
	},

	
	enableIndex: function(enabled, newIndexColumnID, indexEntries, level) {
		this.indexEnabled = enabled;
		if (!enabled || this.columns == null || this.columns.length <= this.indexColumnIndex) {
			return;
		}
		// changing index columns reset level to zero unless explicitly given
		if (this.indexColumnID != newIndexColumnID) {
			if (level)	{
				this.indexLevel = level;
			}
			else {
				this.indexLevel = 0;
			}			
		}
		this.setIndexColumnByID(newIndexColumnID);
		this.setIndexEntries(indexEntries);
	},

	
	setIndexLevel: function(level) {
		this.indexLevel = level;
	},

	getIndexLevel: function() {
		return this.indexLevel;
	},

	
	setIndexValue: function(value) {
		indexValue = value;
	},

	getIndexValue: function() {
		return (null != this.indexValue) ? this.indexValue : '';
	},



	
	setCurrentIndex: function(index) {
		for (var i=0; i < this.columns.length; i++) {
			if (this.columns[i].id == index.columnName) {
				this.indexColumnIndex = i;
				break;
			}
		}
		this.indexValue = index.value;
		//View.log('Index = ' + index.value);
		this.indexLevel = index.index_level;
	},


	
	getCurrentIndex: function() {
		return new Ab.grid.IndexValue(this.indexColumnID, this.getIndexValue(), this.indexLevel);
	},

	
	activateIndexListener: function(indexLink, index) {
		if (this.indexListener != null && typeof this.indexListener == "function") {
		    var delegate = this.indexListener.createDelegate(this, [index]);
		    Ext.fly(indexLink).addListener("click", delegate);
		}
	},

	
	onClickIndex: function(index) {
		// clear previous and next restriction if navigate back to top level or if switching between indexes
		if((index.index_level == 0) || (this.indexValue.charAt(0) != index.value.charAt(0)) || (this.indexLevel > index.index_level) ){
			this.firstRecords = [];						
		}
		
		// nothing within the grid tells us which index was clicked, so set from out here.
		this.setCurrentIndex(index);
		var parameters = this.getParameters(this.getCurrentSortValues(), index);
		try {
		    var result = this.getData(parameters);
			this.pagingAllSortFields = result.data['pagingAllSortFields'];
			this.reloadOnIndex(result.data);
		} catch (e) { 
			this.handleError(e);
		}
	},

	
	activatePrevListener: function(prevLink, index) {
		if (this.prevListener != null && typeof this.prevListener == "function") {
		    var delegate = this.prevListener.createDelegate(this, [index]);
		    Ext.fly(prevLink).addListener("click", delegate);
		}
	},

	
	onClickPrev: function() {
		this.pagingAction = "prev";
		if(this.getDataSource(this.dataSourceId)){
			var ds = this.getDataSource(this.dataSourceId);
			this.currentPageFirstRecord = toJSON(ds.processOutboundRecord(this.rows[0].row.getRecord()).values);
			this.currentPageLastRecord = toJSON(ds.processOutboundRecord(this.rows[this.rows.length-1].row.getRecord()).values);
		} else {
			this.currentPageFirstRecord = toJSON(this.getPagingValuesFromRecord(this.rows[0].row.record));
			this.currentPageLastRecord = toJSON(this.getPagingValuesFromRecord(this.rows[this.rows.length-1].row.record));			
		}
		if (this.firstRecords.length > 0){
			this.doRefresh();		
			this.firstRecords.pop();				
	 	}				 	
        this.afterRefresh();
	},

		
	getPagingRecordLimit: function(){
		if (this.recordLimit == -1){
			if (this.configurationRecordLimit){
				return this.configurationRecordLimit;
			} else {
				return this.rows.length;
			}
		} else {
			return this.recordLimit;
		}		
	},
			
	activatePageFirstListener: function(nextLink, index) {
		if (this.firstListener != null && typeof this.firstListener == "function") {
			var delegate = this.firstListener.createDelegate(this, [index]);
			Ext.fly(nextLink).addListener("click", delegate);
		}
	},
	onClickFirst: function() {
		this.pagingAction = "first";
		this.firstRecords=[];
		this.doRefresh();
		this.afterRefresh();
	},
	
	
	activateNextListener: function(nextLink, index) {
		if (this.nextListener != null && typeof this.nextListener == "function") {
		    var delegate = this.nextListener.createDelegate(this, [index]);
		    Ext.fly(nextLink).addListener("click", delegate);
		}
	},
	
		
	onClickNext: function() {
		this.pagingAction = "next";
		if(this.getDataSource(this.dataSourceId)){
			var ds = this.getDataSource(this.dataSourceId);
			this.currentPageFirstRecord = toJSON(ds.processOutboundRecord(this.rows[0].row.getRecord()).values);
			this.currentPageLastRecord = toJSON(ds.processOutboundRecord(this.rows[this.rows.length-1].row.getRecord()).values);
		} else {
			this.currentPageFirstRecord = toJSON(this.getPagingValuesFromRecord(this.rows[0].row.record));
			this.currentPageLastRecord = toJSON(this.getPagingValuesFromRecord(this.rows[this.rows.length-1].row.record));						
		}

		this.firstRecords.push(this.currentPageFirstRecord);
		this.doRefresh();		     
        this.afterRefresh();
	},
	
		
	getPagingValuesFromRecord: function(record){
		var values = {};		
		for (var name in record) {
			if (name.indexOf('.key') == -1 && name.indexOf('.raw') == -1 &&
				name != 'grid' && name != 'index' && name != 'row') {
					var value = new Object();
					values[name] = record[name];     
			}
		}
		return values;
	},

	//---------------------------------------filter----

	
	setFilterValue: function(columnName, val) {
		var elem = $(this.getFilterInputId(columnName));
		if (null != elem) {
			elem.value = val;
		}
	},
    
    
    clearAllFilterValues: function() {
        var filterElements = this.getAllFilterElements();
        for (var i=0, elem; elem = filterElements[i]; i++) {
            if (elem.id.indexOf('_filterColumn_') != -1) {
                elem.value = '';
            }
        }
    },

	
	clearAllNonQuotedFilterValues: function() {
        var filterElements = this.getAllFilterElements();
        for (var i=0, elem; elem = filterElements[i]; i++) {
            if (elem.id.indexOf('_filterColumn_') != -1) {
				if (elem.value != '' && elem.value.charAt(0) != '"')
				{
					elem.value = '';
				}
            }
        }
    },

	
	clearAllFilters: function() {
		if (this.filterPaletteIsActive) {
			this.clearAllFilterValues(); 
			
			// reset paging parameters
			this.pagingAction = null;  
			this.firstRecords = []; 
			this.currentPageFirstRecord = {};
			this.currentPageLastRecord = {};
			       
			var parameters = this.getParameters(
				this.getCurrentSortValues(),
				new Ab.grid.IndexValue(this.indexColumnID, this.indexValue, this.indexLevel));
			try {
			    var result = this.getData(parameters);
				this.reloadOnFilter(result.data);
			} catch (e) {
				this.handleError(e);
			}
		}
	},

	
	getAllFilterElements: function(){
		var filterInputs = [];
		if (this.filterRow != null && typeof(this.filterRow) != 'undefined') {
			// regular field filters
			var inputs = this.filterRow.getElementsByTagName('input');
			if(inputs != null){
				for(var i = 0;i < inputs.length; i++){
					filterInputs.push(inputs[i]);
				}
			}
			// Enum field filters
			var selects = this.filterRow.getElementsByTagName('select');
			if(selects != null){
				for(var i = 0;i < selects.length; i++){
					filterInputs.push(selects[i]);
				}
			}
		}
		
		return filterInputs;
	},
	
	getFilterValues: function() {
		var filterFieldValues = new Array();
		if (this.filterEnabled) {
			// get filter values from DOM elements
			if (this.filterRow != null && typeof(this.filterRow) != 'undefined') { 
				var filterInputs = this.getAllFilterElements();
				
				for (var i=0, filterInput; filterInput = filterInputs[i]; i++) {
				    var index = filterInput.id.indexOf('_filterColumn_');
					if (index != -1 && 
					     null != filterInput.id && 
					     null != filterInput.value &&  
					      '"' != filterInput.value &&  
					        0  < filterInput.value.length ) {
					    var fieldName = filterInput.id.substring(index + 14);
					
					    // allow filter to accept comma decimal separator
					    var filterInputValue = filterInput.value;				    
					    for (var j = 0; j < this.columns.length; j++) {
					    	if (this.columns[j].id == fieldName) {				    	
					    		if(this.columns[j].type == 'number'){
					    			filterInputValue = filterInputValue.replace(strGroupingSeparator, '');
					    			filterInputValue = filterInputValue.replace(strDecimalSeparator, sNeutralDecimalSeparator);
					    		}
					    	}
					    }
					    filterFieldValues.push({"fieldName": fieldName, "filterValue": filterInputValue});
					}
				}
			}
			// get filter values from member variable because DOM elements don't exist yet
			else if ((this.filterRow == null || typeof(this.filterRow) == 'undefined') && 
				(this.filterValues != null && this.filterValues.length > 0)) {
				filterFieldValues = this.filterValues;
			}
		}
		return toJSON(filterFieldValues);
	},

	activateClearFilterListener: function(clearLink, miniConsole) {
		if (this.clearFilterListener != null && typeof this.clearFilterListener == "function") {
		    Ext.fly(clearLink).addListener("click", this.clearFilterListener, this);
		}
	},

	
	onClickFilter: function(e) {
		if (this.filterPaletteIsActive) {
			this.onFilter();
		}
	},
	 
	onFilter: function(e, el) {
		if (e && e.target){
			e.target.blur(); //otherwise click two times to fire the event???
		}
		
		if (this.filterPaletteIsActive) {
			this.firstRecords = [];
		}

		var parameters = this.getParameters(
				this.getCurrentSortValues(), 
				new Ab.grid.IndexValue(this.indexColumnID, this.indexValue, this.indexLevel));
		try {
		    var result = this.getData(parameters);
			this.reloadOnFilter(result.data);

			if(el && el.target){
				el.target.focus();
				//el.target.select();
			}
		} catch (e) {
			this.handleError(e);
		}
	},

	// ----------------------- HTML DOM building ---------------------------------------------------

	
	onInitialDataFetch: function(result) {
		if ((this.columns.length != 0 || result.data.columns.length != 0) && null != result.data.index) {
			this.indexEntries = result.data.index;
		}
		this.inherit(result);
		this.pagingAllSortFields = result.data['pagingAllSortFields'];
	},

	
	buildHeader: function(parentElement) {
		// create grid index row
		if (this.indexEnabled && this.indexEntries != null) {
			this.createIndexRow(parentElement);
		}

		// super.buildHeader() 
		this.inherit(parentElement);

		// create grid filter row
		if (this.filterEnabled) {
		    this.createFilterRow(parentElement);
		    Ext.get(this.filterRow).setDisplayed((this.rows.length == 0  && (this.getFilterValues().length == 2)) ? false : true);
		}		
	},
	

	
	rebuildHeader: function(parentElement, data) {
		 if(data['pagingAllSortFields']){
			 this.pagingAllSortFields = data['pagingAllSortFields'];
		 }
		 
		// add pre-header rows, any custom rows
		this.buildPreHeaderRows(parentElement);

		// var rebuildNeeded = !this.indicesEqual(this.indexEntries, data.index);
		
		if (this.indexEnabled) {
			this.indexEntries = data.index;
			if (this.indexEntries != null && this.indexEntries.length > 0) {
				// create index row
				this.createIndexRow(parentElement);
				
		    } else if (this.indexRow) {
				// use existing index row
				parentElement.appendChild(this.indexRow);
			}
		}

		// reload old column title header row(s)
		for (var i=0; i < this.headerRows.length; i++) {
			parentElement.appendChild(this.headerRows[i]);
		}

		// reload old filter header row(s)
		if (this.filterRow != null) {
			parentElement.appendChild(this.filterRow);

			Ext.get(this.filterRow).setDisplayed((this.rows.length == 0  && (this.getFilterValues().length == 2)) ? false : true);
		}

	},

	
	displayHeaderRows: function() {
		for(var i=0; i<this.headerRows.length; i++){
			this.headerRows[i].style.display = (this.rows.length == 0 && (this.getFilterValues().length == 2)) ? 'none' : '';
		}
	},

	
	getReloadDataFromGrid: function(resultData) {
		// create data object using info saved from last WFR run
		var data = this.inherit(resultData);
		if (valueExists(resultData) && valueExists(resultData.index)) {
		    data.index = resultData.index;
		}
		return data;
	},


	
	indicesEqual: function(currentIndexEntries, newIndexEntries) {
		var result = false;
		// first test whether two arrays are structurally equal
		if ((currentIndexEntries && newIndexEntries) &&
			(currentIndexEntries != null && newIndexEntries != null) &&
			(currentIndexEntries.length == newIndexEntries.length)) {
			// second test whether each entry is equal
			for (var i=0, curEntry, newEntry; curEntry = currentIndexEntries[i], newEntry = newIndexEntries[i]; i++) {
				if (curEntry.value != newEntry.value ||
					curEntry.count != newEntry.count ||
					curEntry.index_level != newEntry.index_level) {
					// two entries are not equal
					result = false;
					return result;
				}
			}
			result = true;
		}
		return result;
	},

	
	
	createIndexRow: function(parentElement) {
        if (this.indexColumnIndex < 0) {
            // index is disabled
            return;
        }        
        
		var indexRow = document.createElement('tr');
		indexRow.id = this.id + '_indexRow';
		parentElement.appendChild(indexRow);
		
		// index cell occupies the complete width of the grid
		var indexCell = document.createElement('th');
		indexCell.colSpan = this.getNumberOfColumns();
		indexCell.className = 'index';
		indexRow.appendChild(indexCell);
		
		// create leftmost cell (indexColumn title or blank) of each row
		var indexTitle = document.createElement('div');
	    indexTitle.className = 'indexTitle';
		indexTitle.appendChild(document.createTextNode('' + this.getDisplayableTitle(this.columns[this.indexColumnIndex].name) + ':'));
		indexCell.appendChild(indexTitle);
		
		var indexBody = document.createElement('div');
		indexBody.className = 'indexBody';
		indexCell.appendChild(indexBody);

		// first run through entries to see if only one entry has entry.count >= 1. if so NO bDrilldownExists
		var bDrilldownExists = this.testForDrillDown();
		// counter for tally displayed by 'All link'
		var allCnt = 0;

		// form single table row of index links within header
		for (var i = 0, indexEntry; indexEntry = this.indexEntries[i]; i++) {
			allCnt = this.createSingleIndexLink(i, indexBody, bDrilldownExists, allCnt, indexEntry);
		}	
		
		this.createPagingLinks(indexBody);			    		
		this.indexRow = indexRow;

        var idxRow = Ext.get(this.id + "_indexRow", parentElement);
        if (idxRow) {
            idxRow.setDisplayed(!this.isCollapsed);
        }
	},

	
	checkPagingPrerequisites: function(){				
		// check that there are sort fields
		if ((this.pagingAllSortFields.length == 0) || (this.primaryKeyIds.length == 0)){
			this.hasPaging = false;
		}
		
		// if there are sorts, check that primary keys are in the sort
		for(var x=0; x<this.primaryKeyIds.length; x++){
			var bFound = false;
			for(var y=0; y<this.pagingAllSortFields.length; y++){
				if (this.pagingAllSortFields[y].fieldName == this.primaryKeyIds[x]){
					bFound = true;
				}				
			}	
			if(bFound == false){
				this.hasPaging = false;
			}			
		}	
	},
	
	
	createPagingLinks: function(parentElement){

		// 'Next' and 'Prev' buttons are never shown in aggregating views
		if (!this.hasGrouping() && (this.rows.length > 0)){
			
			// find current page
			this.currentPage = this.firstRecords.length + 1;
				
			// indicate current and total pages
			this.totalPages = (this.getPagingRecordLimit() == 0) ? 0 : Math.ceil((this.allCount / this.getPagingRecordLimit()));

			// decrement page number if prev button is clicked
			if((this.pagingAction == 'prev') && (this.currentPage > 1)){
				this.currentPage += -1;
			}	
			
			if (this.currentPage < this.totalPages){
				this.hasPaging = true;
			}
			
			this.checkPagingPrerequisites();
			
			// only show paging links if there is paging
			if(this.hasPaging){
				
				// create element to hold prev, page of, and next text
				var pagingElement = parentElement.appendChild(document.createElement('span'));
				
				// keep paging elements together
				pagingElement.style.whiteSpace = 'nowrap';
				
				
				// only show prev button if after page1
				if (this.currentPage > 1){
					var prev = document.createElement('a');
					prev.appendChild(document.createTextNode(this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_PREVIOUS) + '    '));
					prev.style.whiteSpace = 'pre';	
					pagingElement.appendChild(prev);	
					prev.href = 'javascript: //' ;
					this.activatePrevListener(prev, '');
				}
				
				var pageFirst= document.createElement('a');
				pageFirst.appendChild(document.createTextNode(this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_FIRST)+'    '));
				pagingElement.appendChild(pageFirst);
				pageFirst.href = 'javascript: //' ;
				this.activatePageFirstListener(pageFirst, '');
				
				// Page X of Y
				var page = document.createElement('span');
				page.appendChild(document.createTextNode(this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_DI) + ' ' + this.currentPage + ' '+ this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_PAGE) + ' ' + this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_TOTAL) +' ' + this.totalPages + ' '+this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_PAGE)));
				page.style.whiteSpace = 'pre';
				pagingElement.appendChild(page);	    	
				
				// only show next button if current page is less than total pages
				if (this.currentPage < this.totalPages){
					var next = document.createElement('a');
					next.appendChild(document.createTextNode('		'+ this.getLocalizedString(Ab.grid.MiniConsole.z_MESSAGE_NEXT)));
					pagingElement.appendChild(next);	
					next.href = 'javascript: //' ;
					this.activateNextListener(next, '');
				}
			}
		}	
	},

	
	 hasGrouping: function(){
	 	var ds = this.getDataSource();		  
	 	if((ds) && (ds.hasOwnProperty("type"))){
	 		if (ds.type){
  			return true;
  	  }
  	}
		return false;
	},

	
	createSingleIndexLink: function(i, indexCell, bDrilldownExists, allCnt, indexEntry)	{
		var bIndexEntryNonLink = false;
		var indexLink = document.createElement('a');
		indexLink.href = 'javascript: //' ;
		var indexLinkVal;
		var indexLinkLevel;
		//var iCount = indexEntry.count;
		// 'UP' or 'TOP' link (indexEntry.count for UP: -1, for TOP: -9)
		if (indexEntry.count < 0 && i > 0)	{
			indexLink.appendChild(document.createTextNode(indexEntry.value));
			// set vals for listener arg for UP
			indexLinkVal = this.indexEntries[i - 1].value.substring(0, Math.max(this.indexEntries[i - 1].value.length - 2, 1));
			indexLinkLevel = Math.max(0, this.indexLevel + parseInt(indexEntry.count));
		}
		// 'down' links
		else if (indexEntry.count > 0) {
			if (!bDrilldownExists) {
				indexLink = document.createElement('span');
				bIndexEntryNonLink = true;
			}
			indexLink.appendChild(document.createTextNode(indexEntry.value));
			var indexCount = document.createElement('span');
			indexCount.appendChild(document.createTextNode('[' + indexEntry.count + '] '));
			indexCount.className = 'count';
			indexLink.appendChild(indexCount);
			// set vals for listener arg
			indexLinkVal = indexEntry.value;
			indexLinkLevel = this.indexLevel + 1;
			allCnt += parseInt(indexEntry.count);
		}
		// 'ALL' non-link
		else if (indexEntry.count == 0)	{
			indexLink = document.createElement('span');
			var indexText = document.createTextNode(indexEntry.value);
			indexLink.className = 'all';
			var indexCount = document.createElement('span');
			indexCount.appendChild(document.createTextNode('[' + allCnt + ']       '));
			indexCount.style.whiteSpace = 'pre';
			if (this.firstRecords.length == 0){
				this.allCount = allCnt;
			}
			indexCount.className = 'count';
			indexLink.appendChild(indexText);
			indexLink.appendChild(indexCount);					
			// set flag for non-link
			bIndexEntryNonLink = true;
		}
		indexCell.appendChild(indexLink);
		// 'ALL' is not a link, just text
		if (!bIndexEntryNonLink) {
			var indexVal = new Ab.grid.IndexValue(this.columns[this.indexColumnIndex].id, indexLinkVal, indexLinkLevel);
			this.activateIndexListener(indexLink, indexVal);
		}
		return allCnt;
	},


	
	testForDrillDown: function() {
		var ret =  false;
		var max = 0;
		for (var i=0, indx; indx = this.indexEntries[i]; i++) {
			if (indx.count > max) {
				max = indx.count;
			}
		}


		if (max > 1) {
			ret = true;
		}
		return ret;
	},


	
	createFilterRow: function(parentElement) {
		var row = document.createElement('tr');
		row.id = this.id + '_filterRow';
		this.filterRow = row;

		for (var c = 0; c < this.columns.length; c++) {
			if (this.columns[c].hidden) {
				continue;
			}
			var filterCell = document.createElement('th');
			row.appendChild(filterCell);		
			this.createFilterCellContent(c, filterCell);
		}
		parentElement.appendChild(row);
	},

	
	getFieldDef:function(name){
		for (var i = 0, fieldDef; fieldDef = this.fieldDefs[i]; i++) {
			if(fieldDef.id == name) return fieldDef;  
		}
		return null;
	},
	
	
	 createFilterCellContent: function(columnIndex, cell) {
		var column = this.columns[columnIndex];
		 
		if (column.filterEnabled) {	
			var id = valueExists(column.fullName) ? column.fullName : column.id;	
			var fieldDef = this.getFieldDef(id);
			var isEnumField = fieldDef != null && fieldDef.isEnum;
			var input = null;
			if(isEnumField){
				var i = 0;
				input = document.createElement("select");
				input.options[i++] = new Option("","", true);
				for(var storedValue in fieldDef.enumValues){
					input.options[i++] = new Option(fieldDef.enumValues[storedValue], storedValue);
				}	
				input.className="inputField_box";				
				input.className += ((column.type == 'number' || column.type == 'number_link') && !this.sortEnabled) ? ' floatRight': '';	

				// run filter when user click on one enum value
				Ext.EventManager.addListener(input, "change", this.onFilter.createDelegate(this));
			}else{
				input = document.createElement('input')		
				// run filter when user presses enter key
				var control = this;
                Ext.get(input).on('keydown', function (e) {
					if(e.keyCode == 13){
						this.blur();
						control.onFilter();
						this.focus();					
					}
				}, false);

				input.size = 12;
				if(column.type=="date"){
					input.disabled="disabled";
					input.size = 9;
				}
				
				if(typeof(column.fullName)=='undefined'){
					column.fullName=column.name;
				}
				if(column.fullName.indexOf('_id')!=-1 || column.fullName.indexOf('_code')!=-1 || column.fullName.indexOf('_name')!=-1){
					input.size=column.name.length*2;
				}
				if(column.fullName.indexOf('count')!=-1 || column.fullName.indexOf('price')!=-1 || column.fullName.indexOf('cost_')!=-1){
					input.size=column.name.length>=5?column.name.length+3:column.name.length+4;
				}
				if(column.type=="number"){
					input.size = 8;
					if(column.fullName.indexOf('count_')!=-1){
						input.size=column.name.length+2;
					}
					
					if(column.fullName.indexOf('area')!=-1){
						input.size=(column.name.length-1)*2;
					}
				}
				input.style.marginRight = '4';
			}
			input.id = this.getFilterInputId(id);
			cell.appendChild(input);
			for (var i=0, filterVal; filterVal = this.filterValues[i]; i++) {
				if (filterVal.fieldName == column.id) {
					input.value = filterVal.filterValue;
					break;
				}
			}
		} else {
			cell.appendChild(document.createTextNode(''));
		}
		if(columnIndex == this.columns.length-1){
			//this.createHeaderButtons( cell );
			this.createFilterButtons( cell );
		}
	 },


    
    createHeaderButtons: function(cell) {
		var collapseExpandLink = this.createLink();
		var collapseExpandImage = this.createImage(this.imageExpand, this.getLocalizedString(Ab.grid.MiniConsole.z_TOOLTIP_EXPAND), 0);
		collapseExpandImage.id = 'collapseExpand_' + this.id;
		collapseExpandLink.appendChild(collapseExpandImage);
		cell.appendChild(collapseExpandLink);
        Ext.fly(collapseExpandLink).addListener("click", this.toggleSmartSearch, this);
	},

	
    
    createFilterButtons: function(cell) {
        var clearLink = document.createElement('a');
        this.activateClearFilterListener(clearLink, this);
        clearLink.href = 'javascript: //';
		msg = this.getLocalizedString(Ab.grid.MiniConsole.z_TITLE_CLEAR);
		var clearImage = this.createImage(this.imageFilterClear, msg, 2, 16, 16);
		clearImage.className = 'clearFilterBtn';
        clearLink.appendChild(clearImage);       
        cell.appendChild(clearLink);      
	},
	
	
	toggleSmartSearch: function() {
		if (!this.filterPaletteIsActive) {
			return;
		}
	    if (this.isCollapsed == true) {
	        this.isCollapsed = false;
	    } 
		else {
	        this.isCollapsed = true;
	    }
	    this.showIndexAndFilter();
	},
	
	
	showIndexAndFilter: function() {
	    var image = $('collapseExpand_' + this.id);
        if (valueExists(image)) {
    	    if (this.isCollapsed == false) {
    	        image.src = this.imageCollapse;
    	        image.alt = this.getLocalizedString(Ab.grid.MiniConsole.z_TOOLTIP_COLLAPSE);
    	        image.title = this.getLocalizedString(Ab.grid.MiniConsole.z_TOOLTIP_COLLAPSE);
    	    } 
			else {
    	        image.src = this.imageExpand;
    	        image.alt = this.getLocalizedString(Ab.grid.MiniConsole.z_TOOLTIP_EXPAND);
    	        image.title = this.getLocalizedString(Ab.grid.MiniConsole.z_TOOLTIP_EXPAND);
    	    }
        }
        
        var isCollapsed = this.isCollapsed;
       	if(this.rows.length == 0 && (this.getFilterValues().length == 2) && this.visible){
            isCollapsed = true;
       	}

        var indexRow = Ext.get(this.id + "_indexRow", this.parentElement);
        if (indexRow) {
            indexRow.setDisplayed(!isCollapsed);
        }
        
        var filterRow = Ext.get(this.id + "_filterRow", this.parentElement);
        if (filterRow) {
            filterRow.setDisplayed(!isCollapsed);
        }
        this.updateHeight();
	},
	
	


	
	reloadOnFilter: function(data) {
        this.beforeRefresh();

        this.rows = [];

		// call afterGetData for post-processing (e.g., localization of data from messages)
        var listener = this.getEventListener('afterGetData');
        if (listener) {
            listener(this, data);
        }

		this.addRows(data.records);
		this.removeRowsFromTBody();

		this.rebuildHeader(this.tableHeadElement, data);

		// create grid data rows
		this.createDataRows(this.tableBodyElement, this.columns);

		this.buildFooterRows(this.tableFootElement, data);
        
        this.afterRefresh();
        this.updateHeight();
	},

	// KB 3022769: with multiple miniConsoles loaded into multiple tabs refresh on select tabs to reposition searchPalette.
	// KB 3024774: do not call afterRefresh() - it will register duplicate per-row button event listeners.
	showActions: function(visible) {
        this.inherit();
	},

	
	afterRefresh: function() {
		this.inherit();
		this.showIndexAndFilter();
	},
	
	
	// @deprecated
	repositionSearchPalette: function() {
	},

	
	reloadOnIndex: function(data) {
        this.beforeRefresh();

   		this.indexEntries = data.index;
		this.rows = [];
		this.addRows(data.records);

		this.removeRowsFromTBody();
		
		this.buildPreHeaderRows(this.tableHeadElement);
		// create grid index row(s)
		if (this.indexEnabled) {
			this.createIndexRow(this.tableHeadElement);
		}
		// append old header row(s)
		for (var i=0; i < this.headerRows.length; i++) {
			this.tableHeadElement.appendChild(this.headerRows[i]);
		}
		// restore grid filter row
		if (this.filterEnabled) {
			this.tableHeadElement.appendChild(this.filterRow);
		}		
		// create grid data rows
		this.createDataRows(this.tableBodyElement, this.columns);

		this.buildFooterRows(this.tableFootElement, data);
        
        this.afterRefresh();
	},
	
	
	getFilterInputId: function(columnId) {
	    return this.id + '_filterColumn_' + columnId;
	}
},
{
	// @begin_translatable
	z_TITLE_CLEAR: 'Clear',
	z_TOOLTIP_COLLAPSE: 'Collapse',
	z_TOOLTIP_EXPAND: 'Expand',
	z_MESSAGE_NEXT: 'Next >>',
	z_MESSAGE_PREVIOUS: '<< Prev',
	z_MESSAGE_DI: 'di',
    z_MESSAGE_TOTAL: 'total',
	z_MESSAGE_PAGE: 'Page',
	z_MESSAGE_OF: 'of',
	z_MESSAGE_FIRST: '首页',
	z_MESSAGE_END: 'end'
	// @end_translatable
});




Ab.grid.IndexValue = Base.extend({
	// full table.column of index column
	columnName: '',
	
	// value for the SQL WHERE columnName LIKE 'val%' clause
	value: '',

	// level (renamed because 'level' is a keyword in Oracle)
	index_level: 0,

	
	constructor: function(column, val, lvl) {
		this.columnName = column;
		this.value = val;
		this.index_level = lvl;
	}
});


Ab.grid.Category = Ab.grid.MiniConsole.extend({

	// datasource for grouping categories
	categoryDataSource: null,

	// datasource id for grouping categories
	categoryDataSourceId: '',
	
	categoryField: '',
	
	categoryOrder: [],
	
	categoryRecords: [],
	
	categoryColors: {},
			
	// @begin_translatable
	z_NO_FIELD_ERROR_MESSAGE: 'No field specified.  Please specify a field name.',
	z_CATEGORY_FIELD_NOT_FOUND_ERROR_MESSAGE: 'Category field could not be matched to field list in details.  Please ensure that a category field has been specified and that a similar field exists in the details datasource and panel.',
	z_NONE: '<none>',
	// @end_translatable
				
	
	constructor: function(id, configObject) {
		// call Ab.grid.MiniConsole constructor
		configObject.recordLimit = 0;
		this.inherit(id, configObject); 
		this.imageCategoryCollapse = Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/tri-opened.png';
		this. imageCategoryExpand = Ab.view.View.contextPath + '/schema/ab-core/graphics/icons/tri-closed.png';
		this.categoryDataSourceId = configObject.getConfigParameterIfExists('categoryDataSource');
	},

	getCategoryDataSourceId: function() {
		return this.categoryDataSourceId;
	},
	
	setCategoryDataSourceId: function(categoryDataSourceId) {
		this.categoryDataSourceId = categoryDataSourceId;	
	},

	getCategoryField: function() {
		return this.categoryField;
	},
	
	setCategoryField: function(categoryField) {
		this.categoryField = categoryField;	
	},
	
	getCategoryOrder: function() {
		return this.categoryOrder;
	},
	
	setCategoryOrder: function(categoryOrder) {
		this.categoryOrder = categoryOrder;	
	},	
	
	getCategoryColors: function(){
		return this.categoryColors;
	},
	
	setCategoryColors: function(categoryColors){
		this.categoryColors = categoryColors;
	},

	getCategoryRecords: function() {
		return this.categoryRecords;
	},

	setCategoryRecords: function(categoryRecords) {
		return this.categoryRecords;
	},
	
	getCategoryField: function() {
		return this.categoryField;	
	},
			
	setCategoryField: function(categoryField) {
		this.categoryField = categoryField;	
	},
			
	getCategoryDataSource: function() {
		return this.categoryDataSource;
	},
	
	setCategoryDataSource: function(categoryDataSource) {
		this.categoryDataSource = categoryDataSource;	
	},

	setCategoryDataSourceById: function(categoryDataSourceId) {
		this.categoryDataSource = View.dataSources.get(categoryDataSourceId)
	},

	setshowWithoutGroupings: function(showWithoutGroupings) {
		this.showWithoutGroupings = showWithoutGroupings;	
	},
			
	getshowWithoutGroupings: function() {
		return this.showWithoutGroupings;
	},
			
	setCategoryConfiguration: function(configObj){
		// showWithoutGroupings
		if(valueExists(configObj['showWithoutGroupings'])){  
			this.setshowWithoutGroupings(configObj['showWithoutGroupings']);
		}
				
		if(this.showWithoutGroupings){
			return;
		}

		// specify the category field
		if(valueExists(configObj['fieldName'])){		
			this.setCategoryField(configObj['fieldName']);
		} else {
			var message = View.getLocalizedString(this.z_NO_FIELD_ERROR_MESSAGE);
			View.showMessage('error', message);
			return;
		}
		
		// specify the order in which the categories should appear.
		if(valueExists(configObj['order'])){  
			this.setCategoryOrder(configObj['order']);
		}
		
		if(valueExists(configObj['categoryDataSourceId'])){
			this.setCategoryDataSourceId(configObj['categoryDataSourceId']);
		}

		if(valueExists(configObj['setCategoryDataSouceById']) && (configObj['setCategoryDataSouceById'] == true)){
			this.setCategoryDataSourceById(configObj['categoryDataSourceId']);
		}
		
		if(valueExists(configObj['categoryDataSource'])){
			this.setCategoryDataSource(configObj['categoryDataSource']);
		}
				
		// apply custom style for category
		if(valueExists(configObj['getStyleForCategory'])){
			this.getStyleForCategory = configObj['getStyleForCategory'];
		}
							
		// apply order and style
		this.setOrderAndStyle(); 		
	},
	
		
	setOrderAndStyle: function() {
		var categoryDS = View.dataSources.get(this.getCategoryDataSourceId());
		var reorderedRecords = [];
		var records = categoryDS.getRecords();
		
		// if no order is specified, use default
		if(this.categoryOrder.length == 0 ){
			for(var h=0; h<records.length; h++){
				this.categoryOrder.push(records[h].getValue(this.categoryField));
			}
		}
		
		var fieldDef = this.getFieldDef(this.categoryField);
		if(fieldDef){
			// get the display value for enums, if such exists
			var isEnum = fieldDef.isEnum;
			var enumValues = (isEnum) ? fieldDef.enumValues : {};
			
			for(i=0; i<this.categoryOrder.length; i++){
				for(var j=0; j<records.length; j++){
					var record = records[j];
					var category = record.getValue(this.categoryField);
					if(category == this.categoryOrder[i]){
						record.style = this.getStyleForCategory(record);
						record.categoryTitle = (isEnum)? enumValues[category]: category;
						reorderedRecords.push(record);
					}  
				}  		    		
			}
		} else {
			var message = View.getLocalizedString(this.z_CATEGORY_FIELD_NOT_FOUND_ERROR_MESSAGE);
			View.showMessage('error', message);
			return;
		}
		this.categoryRecords = reorderedRecords;
		
		return this.categoryRecords;
	},
	
	// can be used to specify custom style for categories
	getStyleForCategory: function(record){
		record.style = {};
		return record;
	},    				
  
  	
	findStopIndex: function(currentIndex){
		var categoryDetailEls = this.tableBodyElement.getElementsByTagName('th');
		var stopIndex = 0;

		// find the index of the next category
		for(var k=0; k<categoryDetailEls.length; k++){
			if(categoryDetailEls[k].parentElement.rowIndex ==  currentIndex){
				stopIndex = (k==categoryDetailEls.length-1) ?  this.tableBodyElement.rows.length+ categoryDetailEls[0].parentElement.rowIndex: categoryDetailEls[k+1].parentElement.rowIndex;
			}
		}
		return stopIndex;
	},


	
	beforeBuild: function() {
		this.inherit();
		this.enableIndex(this.indexEnabled, this.indexColumnID, this.indexEntries);
		this.filterEnabled = this.config.getConfigParameterIfExists('showIndexAndFilterOnLoad');;
	},

			
	createDataRows: function(parentElement, columns) {
		if(this.showWithoutGroupings){
			this.inherit(parentElement, columns);
		}else{
			var tableEl = Ext.get(this.parentElement.id);
			tableEl.addClass('categoryGrid');
			this.createCategoryAndDetailRows(parentElement, columns);
		}
	},

	createCategoryAndDetailRows: function(parentElement, columns) {
		this.gridRows = new Ext.util.MixedCollection();
		var noneMsg = View.getLocalizedString(this.z_NONE);
		
		for (var x = 0; x < this.categoryRecords.length; x++) {

            // create category row
 			var category = document.createElement('th');
			category.colSpan = this.columns.length;

            // create category title element
            var categoryTitleElement = document.createElement('a');
            var categoryTitle = this.categoryRecords[x].categoryTitle;
            if(!valueExistsNotEmpty(categoryTitle)){
            	categoryTitle = noneMsg;
            }
            categoryTitleElement.appendChild(document.createTextNode(categoryTitle));
            categoryTitleElement.style.background = 'url(' + this.imageCategoryCollapse + ') no-repeat 0 50%';
			category.appendChild(categoryTitleElement);
			            
            // add custom style properties to the category title element
            var style = this.categoryRecords[x].style;
            for (var s in style) {
                categoryTitleElement.style[s] = style[s];
            }

            var tr = document.createElement('tr');
            tr.className = 'categoryRow';
            tr.appendChild(category);           
            this.tableBodyElement.appendChild(tr);

            var grid = this;
            Ext.get(category).addListener('click', function() {
                var categoryTitleElement = this.first().dom;

                var stopIndex = grid.findStopIndex(categoryTitleElement.parentElement.parentElement.rowIndex);
                var categoryDetailEls = grid.tableBodyElement.getElementsByTagName('th');
                
                // account for header rows, showIndexAndFilterOnLoad
                var offset = categoryDetailEls[0].parentElement.rowIndex;

                // toggleExpand
                var backgroundImage = '';
                var display = '';
                if (categoryTitleElement.style.background.match(/closed/gi)) {
                    backgroundImage = grid.imageCategoryCollapse;
                } else {
                    backgroundImage = grid.imageCategoryExpand;
                    display = 'none';
                }

                categoryTitleElement.style.background = 'url(' + backgroundImage + ') no-repeat 0 50%';;
                for (var m = categoryTitleElement.parentElement.parentElement.rowIndex - offset +1; m < stopIndex - offset; m++) {
                    grid.tableBodyElement.rows[m].style.display = display;
                }
                
                grid.clearPreviousColumnRowWidths();            
                grid.updateHeight();
            });

            // create data rows
            this.createDetailRows(this.tableBodyElement, columns, this.categoryRecords[x].categoryTitle, category);
        }
	},
			
	createDetailRows: function(parentElement, columns, category, categoryElement) {
        
		var rows = this.rows;
		var listener = this.getEventListener('onClickItem');
		var multiline = this.hasMultiline(columns);
		var count = 0;

		// create row & cell elements
		for (var r = 0, record; record = rows[r]; r++) {
			var recordCategory = record[this.categoryField];
			if(recordCategory == category){
				var rowElement = document.createElement('tr'); 
				rowElement.name = category + '_details'; 
				
				rowElement.className = (this.tableBodyElement.rows.length % 2 == 0) ? 'dataRow' : 'dataRow odd' ;
				rowElement.onmouseover = function(){
					this.className = this.className + ' selected';
				}
				rowElement.onmouseout = function(){
					this.className = this.className.replace(' selected', '');
				}
				rowElement.className += (multiline) ? ' multiline' : ' singleline';
				
				var row = new Ab.grid.Row(this, record, rowElement);
				this.gridRows.add(row);
				
				record.index = r;	
				record.row = row;
				
				for (var c = 0, column; column = columns[c]; c++) {
					if (column.hidden === true) continue;
					var cellElement = document.createElement('td');
					
					// TODO: ab-sp-hl-su-by-ls.axvw
					if(listener && this.columnTypeIsSortable(column.type) && column.type != 'image' && column.enabled == "true"){
						column.type = 'link';
						if (column.javaType === 'java.lang.Double' || column.javaType === 'java.lang.Integer') {
							column.type = 'number_link';
						}
					}
					
					cellElement.className = column.type;
					
					if (column.width != null) {
						cellElement.width = column.width;
					}
					
					if (column.onCreateCell != null) {
						column.onCreateCell(record, column, cellElement);
					} else {
						this.createCellContent(record, column, cellElement);
					}                                 
					
					rowElement.appendChild(cellElement); 
					
					var cell = new Ab.grid.Cell(row, column, cellElement);
					row.cells.add(column.id, cell);               			
				}
				parentElement.appendChild(rowElement);
				count += 1;
			}
		}
		
		if(count == 0){
			parentElement.deleteRow(parentElement.rows.length-1);
		} else {
			var countElement = document.createElement('a');
			countElement.innerHTML = "(" + count + ")";
			countElement.className = 'count';
			categoryElement.appendChild(countElement);
		}	
		
		// add row level actions
		this.addRowLevelActions(listener, columns);
		        
		this.afterCreateDataRows(parentElement, columns);
	},

	
	getFirstRowIndex: function(){
		this.columnWidthRowIndex = this.getFirstUncollapsedRowIndex();
		return this.columnWidthRowIndex;
	},

					
	getFirstUncollapsedRowIndex: function(){
		// TODO: optimize
		var dataRows = Ext.query('.dataRow', this.parentElement);
		for(var i=0; i<dataRows.length; i++){
			var dataRowIndex = dataRows[i].rowIndex;
			if(dataRowIndex < this.tableBodyElement.rows.length){
				if(this.tableBodyElement.rows[dataRowIndex].style.display == ''){
					return dataRowIndex
				}
			}
		}
		return -1;
	},

	
	clearPreviousColumnRowWidths: function(){
		if(this.columnWidthRowIndex != -1){
			var columns = this.tableBodyElement.rows[this.columnWidthRowIndex].cells;
			for(var i=0; i<columns.length; i++){
				columns[i].style.width = 'auto';
			}	
		}	
	},
			
	
	setAllRowsSelected: function(selected) {
		// get switch value, default == true
		var setSelectedTrue = ((typeof selected == 'undefined') || selected == true) ? true : false;
		var selectedRows = new Array();
		
		var dataRows = this.getDataRows();
		for (var r = 0; r < dataRows.length; r++) {
			var dataRow = dataRows[r];
			var selectionCheckbox = dataRow.firstChild.firstChild;
			if (typeof selectionCheckbox.checked != 'undefined') {
				if (selectionCheckbox.checked != setSelectedTrue) {
					selectionCheckbox.checked = setSelectedTrue;
					this.onChangeMultipleSelection(this.gridRows.get(r).record);
				}
				selectedRows.push(this.gridRows.get(r).record);			
			}
		}
		return selectedRows;
	},
	
	/////////////////////panel reports///////////////////
	callDOCXReportJob: function(title, restriction, parameters){
		this.setCategoryProperties(parameters);
		if(!valueExistsNotEmpty(title)){
			title = "";
		}
		var viewName = this.viewDef.viewName + '.axvw'; 
		return Workflow.startJob(Ab.grid.ReportGrid.WORKFLOW_RULE_DOCX_REPORT, viewName, this.dataSourceId, title, this.getVisibleFieldDefs(), toJSON(restriction), parameters);
	},
	callXLSReportJob: function(title, restriction, parameters){
		this.setCategoryProperties(parameters);
		if(!valueExistsNotEmpty(title)){
			title = "";
		}
		var viewName = this.viewDef.viewName + '.axvw'; 
		return Workflow.startJob(Ab.grid.ReportGrid.WORKFLOW_RULE_XLS_REPORT, viewName, this.dataSourceId, title, this.getVisibleFieldDefs(), toJSON(restriction), parameters);
	},
	
	setCategoryProperties: function(parameters){
		parameters.categoryDataSourceId = this.getCategoryDataSourceId();
		parameters.categoryFields = [this.getCategoryFieldDef(this.categoryField)];
		//XXX: 
		for(var i=0;i<this.getVisibleFieldDefs().length; i++){
			parameters.categoryFields.push({});
		}
		parameters.categoryOrder = this.categoryOrder;
		parameters.categoryColors = this.categoryColors;
	},
	getCategoryFieldDefs: function(){
		var ctx = this.createEvaluationContext();
		
		var categoryFields = [];
		var categoryDS = View.dataSources.get(this.getCategoryDataSourceId());
		categoryDS.fieldDefs.each(function (fieldDef) {
			fieldDef.title = Ab.view.View.evaluateString(fieldDef.title, ctx, false);
			fieldDef.hidden = Ab.view.View.evaluateString(fieldDef.hidden, ctx, false);
			categoryFields.push(fieldDef);
    	});
		return categoryFields;
	},
	getCategoryFieldDef: function(fieldId){
		var categoryFields = this.getCategoryFieldDefs();
		for (var i = 0, field; field = categoryFields[i]; i++) {
			if(field.id === fieldId){
				return field;
			}	
		}
		return {};
	}
});






Ab.namespace('tree');


Ab.tree.TreeControl = Ab.view.Component.extend({


    
    _nodes: null,

    
    _levels: null,

    
    _dragEnabled: null,

    
    _viewFile: null,

    
    _panelsData: null,


    
    _groupIndex: 0,

    
    treeView: null,

    
    maxLevel: 0,


    
    type: 'tree',

    lastNodeClicked: null,

    
    recordLimit: -1,
    
    
  
    restriction: null,

 	
	colorOpacity: null,
	 

	// @begin_translatable
	z_EMPTY_TREE_MESSAGE: 'No records available.',
	// @end_translatable
	
	
	
    // --------------------- private methods -----------------------------------

    
    _addTreeLevel: function(level) {
      this._levels.push(level);
    },


    
    _addTreeNode: function(node) {
      this._nodes.push(node);
    },

    _getParameters: function(panelData, parent, level) {

        // compose the parameter list to pass to WFR
        var  parameters = {
                          version: '2',
                          viewName: this._viewFile,
                          dataSourceId: panelData.dataSourceId,
                          controlId: panelData.panelId,
                          groupIndex: this._groupIndex,
                          treeType:  this.type,
                          treeLevel: level
                          };

        if (this.recordLimit != undefined && this.recordLimit != -1){
            parameters.recordLimit = this.recordLimit;
        }

        var restriction = this._createRestrictionForLevel(parent, level);

        if (restriction && restriction.clauses != undefined && restriction.clauses.length > 0){
            parameters.restriction = toJSON(restriction);
        }

        Ext.apply(parameters, this.parameters);

        return parameters;
    },

     
    _createRestrictionForLevel: function(parentNode, level) {
        var restriction = this.createRestrictionForLevel(parentNode, level);
		
		if (!restriction) {
			restriction = new Ab.view.Restriction();
			
			// add the tree restriction to parameter list if not null.
			if (this.restriction && this.restriction.clauses != undefined && this.restriction.clauses.length > 0) {
				restriction.addClauses(this.restriction, true);
			}
			
			// add the tree level's restriction to parameter list if not null.
			var levelRest = this.getRestrictionForLevel(level);
			if (levelRest && levelRest.clauses != undefined && levelRest.clauses.length > 0) {
				restriction.addClauses(levelRest, true);
			}
			
			// add the parent node's restriction to parameter list. it should always contain something
			if (!parentNode.isRoot()){
				if(this.type=='hierTree' || this.type=='selectValueHierTree'){
					restriction.addClauses(parentNode.restriction, true);
			    } else {
			    	if (this._panelsData[level].useParentRestriction==true) {
						restriction.addClauses(parentNode.restriction, true);
					}
				}
			}
		}
		
		return restriction;
	}, 

     
    createRestrictionForLevel: function(parentNode, level) {
		return null;
	},

    
     _initTree: function(panelData, parent, level, panelDataNextLevel) {

		// if panelData not define, return
		if(typeof(panelData) == 'undefined'){
			return;
		}

        // call WFR to get the data
        try{
        	var result = Workflow.call('AbCommonResources-getDataRecords', this._getParameters(panelData, parent, level), 120);
        	
        	if (result.code == 'executed') {
    			// call afterGetData for post-processing (e.g., localization of data from messages)
    			var listener = this.getEventListener('afterGetData');
    			if (listener) {
    				listener(this, result.data, level);
    			}
    			
    			var elem = document.getElementById(panelData.panelId + "_msg_no_record");
    			if(elem != null){
    				elem.parentNode.removeChild(elem); 
    			}
    			
    			if( result.data.records.length > 0 ) {
    				// if the WFR succeeded, create a treeLevel object
    				var treeLevel = new Ab.tree.TreeLevel(level, result.data, panelData);
    				this.applySidecarToLevel(treeLevel);
    				this._addTreeLevel(treeLevel);
    				
    				// create a TreeNode for each record returned from server
    				this._addTreeNodes(result, parent, treeLevel, panelDataNextLevel);
    				
    				// if the child nodes are added fine, then for hierarchy tree, set the maxLevel to the current deepest level.
    				if (this.type=='hierTree' && this.maxLevel < level) {
    					this.maxLevel = level;
    				}
    			} 
    			else {
    				if(level > 0){
    					//kb# 3022422 
    					parent.isLeafNode = true;
    				} else {
    		        	var elem = document.getElementById(panelData.panelId);
    					if(elem != null){
    						var divNode = document.createElement("div");
    						divNode.id = panelData.panelId + "_msg_no_record";
    						divNode.className = "instruction";
    						divNode.innerHTML = "<br>" + this.getLocalizedString(this.z_EMPTY_TREE_MESSAGE);
    						elem.parentNode.appendChild(divNode)
    					}
    				}
    			}
            } else {
                // handle the exceptions
                this.handleError(result);
            }
        } catch (e){
			this.handleError(e);
		}

        
    },

    applySidecarToLevel: function(treeLevel){
    	var sidecar = this.getSidecar();
    	var sidecarLevels = sidecar.get('levels');
    	if(sidecarLevels && sidecarLevels[treeLevel.levelIndex]){
    		treeLevel.visibleFields = sidecarLevels[treeLevel.levelIndex].visibleFields;
    	}
    	return treeLevel;
    },
        
    _addTreeNodes: function(result, parent, treeLevel, panelDataNextLevel){

        // create a TreeNode for each record returned from server
        for (var i = 0; i < result.data.records.length; i++) {
            //get the record data in JSON format from server
            var record = result.data.records[i];

            //create a new TreeNode -  a YUI text node with AFM-specific info
            var treeNode = new Ab.tree.TreeNode(this, treeLevel, record, parent, false);

            if(!treeNode.isLeafNode && typeof(panelDataNextLevel) != 'undefined'){
				var resultNextLevel = Ab.workflow.Workflow.runRuleAndReturnResult('AbCommonResources-getDataRecords', this._getParameters(panelDataNextLevel, treeNode, treeLevel.levelIndex+1));
				if (resultNextLevel.code == 'executed') {
					if(typeof resultNextLevel.data == "undefined" || typeof resultNextLevel.data.records == "undefined" || resultNextLevel.data.records.length <= 0){
						treeNode.isLeafNode = true;
						
						//kb# 3022422 
						parent.isLeafNode = false;
					}
				} else {
					alert(resultNextLevel.code + " :: " + resultNextLevel.message);
				}
			}
			else if (treeNode.isLeafNode){
				//kb# 3022422 
				parent.isLeafNode = false;
			}
			
            // add the tree node to the tree control's top node collection
            if(parent.isRoot()) {
              this._addTreeNode(treeNode);
            }
        }

    },

    
    _registerEvents: function(node) {

        // index to the events array
        var eventIndex = 0;

        if (node.level.events.length == 0) {
        	// register the default click listener
        	this.addLink(node);
        }
        
        // does the level contains any events?
        while (node.level.events[eventIndex]) {
              // based on the event type, we call different component functions
              // currently we only support 'onClickNode' event
              switch (node.level.events[eventIndex]["type"]){
                 case 'onClickNode':
                      this.addLink(node, eventIndex);
                      break;
                 case 'onContextMenu':
                      break;
				 case 'onChangeMultipleSelection':
				 	  var delegate = this.onChangeMultipleSelection.createDelegate(node, [node]);
				 	  YAHOO.util.Event.addListener(YAHOO.util.Dom.get(node.checkElId), "click", delegate);
				 	  break;
                 default:
                      break;
              }
                              
              eventIndex++;
        }

        // create drag source object carrying node PK values
        if (this.isDragEnabledForLevel(node.level.levelIndex)) {
            new Ext.dd.DragSource(node.labelElId, {
                dragData: node
            });
        }
    },


    
    _loadNodeData: function(node, onCompleteCallback) {

      // set the children's level index number
      var nextLevel = node.level.levelIndex + 1;
	  
      // the level of tree nodes to be added can not exceed the maximum tree level number
      // otherwise, it is a leaf node.
      if(node.treeControl.type=='tree' && nextLevel > node.treeControl.maxLevel) {
        node.isLeafNode = true;
      } 

      // for non-leaf nodes, call WFR to populate the data
      if(!node.isLeafNode) {
          // get the next level tree node's panel data
          // initialize the node's children
          if(node.treeControl.type=='hierTree'){
            node.treeControl._initTree(node.treeControl._panelsData[0], node, nextLevel, node.treeControl._panelsData[0] );
          } else {
          	if(node.isLeafNode){
	            node.treeControl._initTree(node.treeControl._panelsData[nextLevel], node, nextLevel, null);
    		} else {
	            node.treeControl._initTree(node.treeControl._panelsData[nextLevel], node, nextLevel, node.treeControl._panelsData[nextLevel+1] );
    		}
          }
      }

      // Be sure to notify the TreeView component when the data load is complete
      onCompleteCallback();

      // after all children are generated, register the events for each child node
      node.treeControl._registerNodesEvents(node.children);
    },

    
    addLink: function(node, eventIndex) {
        // !!!YUI bug - do not use TextNode's getLabelEl() or Node's getEl() which will return NULL.
        // get the Node's label id through the property directly -->
    	var linkId = node.labelElId;
        var link = $(linkId);
    	
    	var command = null;
    	if (valueExists(eventIndex)) {
	    	var commandsData = node.level.events[eventIndex]["commands"];
	    	var restriction = node.restriction;
	
	        // create command chain
	        command = new Ab.command.commandChain(this.id, restriction);
	        command.addCommands(commandsData);

	        // add command as a link property
	        link.command = command;
    	}

        // register the command as an event listener
        
        // KB 3028554: call the event handlers in the right order
        var listener = function() {
        	// call the default tree node event handler that sets the lastNodeClicked property
        	node.onLabelClick(node);
        	// call the view command
        	if (command) {
        	    command.handle();
        	}
        }

        YAHOO.util.Event.addListener(link, "click", listener);
    },

    // get the restriction for level.
    // @param level could be either Integer or String
    //        if user passed in an Integer value, it indicates the tree level's index
    //        if user passed in a String value, it indicates the tree level's panelId
    getRestrictionForLevel: function(level) {

         if(typeof size == 'number'){
            // the level index is passsed in
            var iLevel = parseInt(level);
            for(var treeLevel in this._levels){
              if(treeLevel.levelIndex == iLevel){
                return treeLevel.restriction;
              }
            }
         } else if (typeof size == 'string') {
            // the panel id is passed in
            for(var treeLevel in this._levels){
              if(treeLevel.panelId == level){
                return treeLevel.restriction;
              }
            }
         }

         return null;
    },


    
    addRestriction: function(restriction){
      if(this.restriction==null){
        this.restriction = new Ab.view.Restriction();
      }

      this.restriction.addClauses(restriction, true);
    },
    
    
    getLevel: function(index) {
      return this._levels[index];  
    },
    
    
    
    enableDragForLevel: function(index, enabled) {
      if (!valueExists(enabled)) {
          enabled = true;
      }
      this._dragEnabled[index] = enabled;  
    },
    
    
    isDragEnabledForLevel: function(index) {
      return this._dragEnabled[index];  
    },

    // ----------------------- public methods ----------------------------------

    
    constructor: function(id, configObject) {

        // set the view name that the tree is loaded.
        var viewFile = configObject.getConfigParameterIfExists('viewDef');
        if (valueExists(viewFile) && viewFile != '') {
            this._viewFile = viewFile;
        }

        // set the panel's data for all tree levels
        var panelsData = configObject.getConfigParameterIfExists('panelsData');
        if (valueExists(panelsData) && panelsData != '') {
          this._panelsData = panelsData;
        }

        // add the groupIndex for multiple table groups view
        var groupIndex = configObject.getConfigParameter('groupIndex');
        if (valueExists(groupIndex) && groupIndex != '') {
            this._groupIndex = groupIndex;
        }

        // set the view's restriction
        var restriction = configObject.getConfigParameterIfExists('restriction');
        if (valueExists(restriction) && restriction != '') {
            this.restriction = restriction;
        }

        // set the tree max level
        var maxLevel = configObject.getConfigParameterIfExists('maxLevel');
        if (valueExists(maxLevel) && maxLevel != '') {
            this.maxLevel = maxLevel;
        }

        // set the tree type - 'tree' or 'hierTree'
        var type = configObject.getConfigParameterIfExists('type');
        if (valueExists(type) && type != '') {
            this.type = type;
        }

		var showOnLoad = configObject.getConfigParameterIfExists('showOnLoad');
		if (valueExists(showOnLoad)) {
		    this.showOnLoad = showOnLoad;
		}
		
	    configObject.addParameterIfNotExists('useParentRestriction', false);

	    var recordLimit = configObject.getConfigParameterIfExists('recordLimit');
        if (valueExists(recordLimit) && recordLimit != '') {
            this.recordLimit = recordLimit;
        }

        // call the base Component constructor to set the base properties
        // and register the control in the view, so that other view parts can find it
        this.inherit(id, this.type, configObject);

        // create the tree
        this.treeView = new YAHOO.widget.TreeView(this.id);

        //turn dynamic loading on for entire tree:
        this.treeView.setDynamicLoad(this._loadNodeData, 1);

        // initialize the top nodes array
        this._nodes = [];

        // initialize the levels array
        this._levels = [];
        this._dragEnabled = [];

        this.addEventListenerFromConfig('afterGetData', configObject);
		if (!this.getEventListener('afterGetData')) {
			this.addEventListener('afterGetData', this.afterGetData);
		}

        if (View.preferences.useScroller) {
            var updateScroller = this.updateScroller.createDelegate(this);
            this.treeView.subscribe("expand",  updateScroller);
            this.treeView.subscribe("collapse", updateScroller);
        }
    },

    
    isAutoScroll: function() {
        // KB 3038581: if the tree auto-scrolls, the panel title and actions can be cut off
        return false;
    },

    
    getScrollableEl: function() {
        // KB 3038581: if the tree auto-scrolls, the panel title and actions can be cut off
        return null;
    },

    
    updateHeight: function() {
        // determine the height available to show the scrollable element
        var availableHeight = this.determineAvailableHeight();

        // if the available height can be determined, set the element height and enable scrolling
        var scrollableEl = this.getScrollableEl();
        if (availableHeight > 0 && scrollableEl != null) {
            scrollableEl.setHeight(availableHeight);
        }

        // update component's scroller
        if (this.isAutoScroll() && !this.isScrollInLayout()) {
            this.updateScroller();
        } else {
            this.updateLayoutScroller();
        }

        // update the collapsed/expanded state of the panel
        this.updateCollapsed();
    },


    initialDataFetch: function() {
        // create the Tree Level and Tree Nodes for the top level
        var rootNode = this.treeView.getRoot();

		// display the first level node only if showOnLoad is set to true
		if(this.showOnLoad)
		{
			if(this.type=='selectValueTree' || this.type=='selectValueHierTree') {
	          this._initTree(null, rootNode, 0, null);
	        } else {
	          if(this.type=='tree'){
		          this._initTree(this._panelsData[0], rootNode, 0, this._panelsData[1]);
			  } else {
			      this._initTree(this._panelsData[0], rootNode, 0, this._panelsData[0]);
			  }
	        }
		}
			
        // display the tree
        this.treeView.draw();

        this._registerNodesEvents(this._nodes);
    },
    
    _registerNodesEvents: function(nodes){

      // register all top level nodes events
      for(var nodeCounter = 0; nodeCounter < nodes.length; nodeCounter++) {
        this._registerEvents(nodes[nodeCounter]);
      }
    },

    
    doRefresh: function() {
        this.clear();

        var rootNode = this.treeView.getRoot();

		if (this.type=='selectValueTree' || this.type=='selectValueHierTree') {
	          this._initTree(null, rootNode, 0, null);
	    } else {
	          if (this.type=='tree') {
		          this._initTree(this._panelsData[0], rootNode, 0, this._panelsData[1]);
			  } else {
			      this._initTree(this._panelsData[0], rootNode, 0, this._panelsData[0]);
			  }
	    }
        
        rootNode.refresh();

        // display the tree
        this.treeView.draw();

        this._registerNodesEvents(this._nodes);
	},

    
	refreshNode: function(parentNode){
	
		// remove all the parent node's children
		this.treeView.removeChildren(parentNode);

		// get the current node's level
		var levelIndex = parentNode.level.levelIndex;
		
		// propagate the parent node with its children from db
		this._initTree(this._panelsData[levelIndex+1], parentNode, levelIndex+1, this._panelsData[levelIndex+2]);
		
		// refresh the parent node
		parentNode.refresh();

		this._registerNodesEvents(parentNode.children);
	},

	// This function will expand the current node with all its ancestors
	// it will also refresh the current node with new data
	expandNode: function(parentNode){

		if(!parentNode.isRoot()){
			var tmpNodes = new Array();
			var tmpParent = parentNode;
			tmpNodes[0] = tmpParent;
			var index = 1;
			//looping through curretn node to compose all its ancestors Nodes into an array
			while(tmpParent.parent){
				tmpParent = tmpParent.parent;
				tmpNodes[index] = tmpParent;
				index++;
			}
			
			// from the oldest ancestor, expand the nodes
			for (index=tmpNodes.length-1;index>=0;index--)
			{
				if(tmpNodes[index].parent!=null){
					// for the current node, remoce all the children so we can refresh the data when calling expand()
					// we only refresh the current node instead of all its ancestors for performance reasons
					if(index==0){
						this.treeView.removeChildren(tmpNodes[index]);
						tmpNodes[index].collapse();
					} 
					tmpNodes[index].isLeafNode = false;
					tmpNodes[index].expand();
				} 
			}
		}
	},
	
	
	
    afterGetData: function(tree, data, level) {
		// for each record
		//	for each field 
		//		if field is not raw or key && typeof string && value != ''
		//		1) camelCase the value
		//		2) prepend val with column + '_'
		//		3) call getMessage() with column_value key
		//		4) if getMessage returns different value, replace

		for (var r = 0, record; record = data.records[r]; r++) {
			for (fieldName in record) {
				var fieldNameParts = fieldName.split('.');
				if (fieldNameParts.length == 2) {
					var value = record[fieldName];
					if (!value || typeof value != 'string' || value.length == 0) {
						continue;
					}
					var valParts = value.split(' ');
					var targetVal = valParts[0].toLowerCase();
					for (var ii = 1, part; part = valParts[ii]; ii++) {
						part = part.toUpperCase().substr(0,1) + part.toLowerCase().substr(1);
						targetVal += part;
					}
					targetVal = fieldNameParts[0] + '_' + fieldNameParts[1] + '_' + targetVal;
					var messageVal = getMessage(targetVal);
					
					//3031177 - compare with the parsed special characters [] as <>.
					if (messageVal != replaceHTMLPlaceholders(targetVal)) {
						record[fieldName] = messageVal;
					}
				}
			}
		}
	},

    
    clear: function() {

        // remove all children from the tree control's rootNode
        var rootNode = this.treeView.getRoot();
        this.treeView.removeChildren(rootNode);
        
        // clear last node click
        this.lastNodeClicked = null;

        // clear restriction and refersh the tree control
        rootNode.refresh() ;

        // remove top nodes
        this._nodes = [];

        // remove all the levels
        this._levels = [];
    },

    
    collapse: function(){
        for(var nodeCounter = 0; nodeCounter < this._nodes.length; nodeCounter++) {
            this._nodes[nodeCounter].collapse();
        }
    },

    
    expand: function(){
        for(var nodeCounter = 0; nodeCounter < this._nodes.length; nodeCounter++) {
            this._nodes[nodeCounter].expand();
        }
    },
	
	
	setMultipleSelectionEnabled: function(levelIndex, enabled) {
    	if (!valueExists(enabled)) {
    		enabled = true;
    	}
		this._panelsData[levelIndex].multipleSelectionEnabled = true;
		var event = {
			type: 'onChangeMultipleSelection'
		};
		this._panelsData[levelIndex].events.push(event);
	},
	
	
	getSelectedNodes: function(levelIndex){
		var nodes = [];
		for(var i=0; i< this.treeView._nodes.length; i++){
			var node = this.treeView._nodes[i];
			if(node && node.level.levelIndex == levelIndex && node.isSelected()){
				nodes.push(node);
			}
		}
		return nodes;
	},
	
	
	getSelectedRecords: function(levelIndex){
		var records = [];
		for(var i=0; i< this.treeView._nodes.length; i++){
			var node = this.treeView._nodes[i];
			if(node && node.level.levelIndex == levelIndex && node.isSelected()){
				var pkValues = node.getPrimaryKeyValues();
				var record = new Ab.data.Record(pkValues, false);
				records.push(record);
			}
		}
		return records;
	},
	
    
	onChangeMultipleSelection: function(node){
		var obkChk = YAHOO.util.Dom.get(node.checkElId);
		node.setSelected(obkChk.checked);
		
        var listener = node.treeControl.getEventListener('onChangeMultipleSelection');
        if (listener) {
            listener(node);
        }
	},
	
	
	selectAll: function(selected) {
		if (!valueExists(selected)) {
			selected = true;
		}
		for(var i=0; i< this.treeView._nodes.length; i++){
			var node = this.treeView._nodes[i];
			if (node) {
			    node.setSelected(selected);
			}
		}		
	},
	
	
	unselectAll: function() {
		this.selectAll(false);
	},

	
	setTreeNodeConfigForLevel: function(levelIndex, treeNodeConfig){
		this._panelsData[levelIndex].treeNodeConfig = treeNodeConfig;
	},
	
	
	setColorOpacity: function(op) {
	    this.colorOpacity=op;
	}
});



 
Ab.tree.TreeNode = function(treeControl, treeLevel, data, parent, expanded) {

        // set the node's attribute
        this.treeControl = treeControl;
        this.level = treeLevel;
        this.tree = treeControl.treeView;

        // default to no children
        this.children = [];

        this.parent = parent;

        this.restriction = new Ab.view.Restriction();

        // call YAHOO.widget.TextNode init() function
        this.init(data, parent, expanded);

        // decide if the node is a leaf node?
        if((this.treeControl.type=='tree' || this.treeControl.type=='selectValueTree' )
                && this.level.levelIndex == this.treeControl.maxLevel){
          this.isLeafNode = true;
        }
		
		// generate an id for select element
		this.checkElId = "ygtvcheck"+this.index;
		
        // does the level contains any events?
        if(this.treeControl.type=='tree' || this.treeControl.type=='hierTree') {
          var eventIndex = 0;
          while(treeLevel.events[eventIndex] && !this.hasLabelClickEvent) {
                //does the events contain a "onLabelClick" event?
                 if(treeLevel.events[eventIndex]["type"]=='onClickNode'){
                   this.hasLabelClickEvent = true;
                 }

                eventIndex++;
          }
        }

        // make sure this function stays in the last line within the function
        // create the label
        this._createLabel();
};


YAHOO.extend(Ab.tree.TreeNode, YAHOO.widget.TextNode, {

    // reference to the Ab.tree.TreeLevel instance
    level: null,

    // reference to the Ab.tree.TreeControl instance
    treeControl: null,

    // is the node a leaf node?
    isLeafNode: false,

    // does user defined the custom label click event?
    hasLabelClickEvent: false,

    // restriction for the current node, this restriction is composed of primary key/value and
    // used to restrict the children nodes
    // @type Ab.view.Restriction
    restriction: null,
	
	//if node is selected or node
	selected: false,
	
	checkElId: null,
	
    
    _createLabel: function(){

        // compose the label text field using the primary keys
        var labelText = "";
        
        if(this.level.treeNodeConfig){
        	labelText = this.getLabelForNodeConfig(this.level);
        }else{
        	// loop thought the visible fields and compose the label's text
            for (var j = 0; j < this.level.visibleFields.length; j++) {
            	var value = this.data[this.level.visibleFields[j].name];
            	if(value!=undefined){
            		if(j>0){
            			labelText = labelText + " ";
            		}
            		
            		// user can use custom style class for primary key and non-primary key part of labels
            		var isColorField = (this.level.visibleFields[j].controlType == 'color');
            		if(isColorField){
            			labelText = labelText + "<span class='" + this.level.cssClassName + " colorSpan' " + ">" + this.getColorContentHtml(value, this.level.visibleFields[j], this.data) + "</span>";
            		}else if(this.level.visibleFields[j].isPk){
            			labelText = labelText + "<span class='" + this.level.cssPkClassName + "'>" + value + "</span>";
            		} else {
            			labelText = labelText + "<span class='" + this.level.cssClassName + "'>" + value + "</span>";
            		} 
            	}
            }
       	}
        
        // set the label
        this.setUpLabel(labelText);
        
		//call custom handler
        if(typeof afterGeneratingTreeNode == "function"){
        	afterGeneratingTreeNode(this);
        }
        		
        // turn off the toggle if the label has custom defined event
        // use: this.href="javascript:void(0);" instead of "#" to avoid jumping to the top of the page
        if(this.hasLabelClickEvent) {
          this.href = "javascript:void(0);";
          // KB 3028554: the textNodeParentChange property is not supported in YUI 2.8
          // instead, the onLabelClick is called from the event listener defined in the addLink() method
          //this.textNodeParentChange = "onLabelClick";
        }
		
		
		
        // loop through the primary keys and compose the pkData list
        var pkFieldName = "";
        var parentPkFieldValue = "";
        for (var j = 0; j < this.level.pkFields.length; j++) {
            pkFieldName = this.level.pkFields[j] + ".key";
            
            if(this.parent != null && !this.parent.isRoot()){
				parentPkFieldValue = this.parent.getPrimaryKeyValue(this.level.pkFields[j]);
				if( parentPkFieldValue!= null && parentPkFieldValue!= '' &&  this.treeControl.type!='hierTree' &&  this.treeControl.type!='selectValueHierTree'){
					// add the parent restriction if exists
					this.restriction.addClause(this.level.pkFields[j], parentPkFieldValue, "=");
				} else {
					// add the primary keys data to restriction object
    	        	this.restriction.addClause(this.level.pkFields[j], this.data[pkFieldName], "=");
				}
			} else {
				// add the primary keys data to restriction object
    	       	this.restriction.addClause(this.level.pkFields[j], this.data[pkFieldName], "=");
			}
        }
    },

    
    getLabelForNodeConfig: function(){
    	var labelText = "";
    	for(var i = 0; i < this.level.treeNodeConfig.length; i++){
    		var element = this.level.treeNodeConfig[i];
    		var value = element.text;
    		var cssClass = this.level.cssPkClassName;
    		
    		if(!valueExistsNotEmpty(value) && valueExistsNotEmpty(element.fieldName)){
    			value = this.data[element.fieldName];
    			
    			if(valueExistsNotEmpty(element.length)){
    				if (value.length > element.length) {
    		        	value = value.substr(0, element.length) + " ...";
    				}
    			}
    			
    			if(valueExistsNotEmpty(element.pkCssClass)){
    				cssClass = (element.pkCssClass == 'true') ? this.level.cssPkClassName : level.cssClassName;
    			}else if(this.level.pkFields.indexOf(element.fieldName)<0){
    				cssClass = this.level.cssClassName;
    			}
    		}
    		
    		if(value!=undefined){
                if(i>0){
                  labelText = labelText + " ";
                }
                var isColorField = (this.level.treeNodeConfig[i].controlType == 'color');
            	if(isColorField){
            		labelText = labelText + "<span class='" + this.level.cssClassName + " colorSpan' " + ">" + this.getColorContentHtml(value, this.level.treeNodeConfig[i], this.data) + "</span>";
            	}else {
            		labelText = labelText + "<span class='" + cssClass + "'>" + value + "</span>";
            	}
            }
    	}
    	return labelText;
    },

    
    getColorContentHtml: function(value, fieldDef, row, colorVal) {     
			if (value == undefined)
				value = '';
			  //content = (valueExistsNotEmpty(column.width)) ? '' : Ext.util.Format.ellipsis('', 50);

			var hpattern = new Ab.data.HighlightPattern(value);
			if (hpattern.isHatched()) {
		    	// HATCHED pattern
				var bitmapName = hpattern.getLegendBitmapName(fieldDef.name, row, hpattern);
				if (bitmapName) {
	                content = "<img src='" + View.project.projectGraphicsFolder + '/' + bitmapName + ".png' hspace='0' border='0'/>";
				}
		    	
			} else {
				// handle possibility that the raw value passed in is a hex value already
				var color = '';
				if (value.substr(0,2) == '0x') {
					color = value.substr(2);
			    } else {
					color = gAcadColorMgr.getRGBFromPatternForGrid(value, true);
					if (color == "-1") {
						if (colorVal == undefined || !colorVal.length)
							color = gAcadColorMgr.getUnassignedColor(true);
						else
							color = gAcadColorMgr.getColorFromValue(colorVal, true);
					}
				}
				
				var legendKeyFieldDef = this.getLegendKeyFieldDef();
				
				if(valueExists(legendKeyFieldDef)){
					gAcadColorMgr.setColor(legendKeyFieldDef.name, this.data[legendKeyFieldDef.name], color);
				}

				// KB 3027141 content width should not be set or the color block does NOT fill the cell
				// var width = '200px';
				// if (column.width != null) { width = column.width; }
				//content = '<div style="width:' + width + ';height:16px;background-color:#' + color + ';"></div>';
				// border:1px solid #000000
				var opacity = this.treeControl.colorOpacity;
				var filter = "alpha(opacity='" + (opacity * 100).toFixed() + "')";	// IE
				var style = (opacity != null) ? 'opacity: ' + opacity + '; filter: ' + filter : '';
				content = '<div class="colorSwatch" style="background-color:#' + color + ';' + style + '"></div>';
		  }
			
			return content;
		},
	
		
		getLegendKeyFieldDef: function(){
			for(var i=0; i < this.level.visibleFields.length; i++){
				var fieldDef = this.level.visibleFields[i];
				if(valueExistsNotEmpty(fieldDef.legendKey) && fieldDef.legendKey === "true"){
					return fieldDef;
				}
			}
			return null;
		},

     
    getStyle: function() {

        if (this.isLoading) {
            return "ygtvloading";
        } else {
            // location top or bottom, middle nodes also get the top style
            var loc = (this.nextSibling) ? "t" : "l";

            // type p=plus(expand), m=minus(collapase), n=none(no children)
            var type = "n";

            // only non-leaf node sets the expand/collapse style
            if (!this.isLeafNode && (this.hasChildren(true) || (this.isDynamic() && !this.getIconMode()))) {
                type = (this.expanded) ? "m" : "p";
            }

            return "ygtv" + loc + type;
        }
    },

   
    getHoverStyle: function() {
        var s = this.getStyle();

        // only non-leaf node sets the expand/collapse hover style
        if (!this.isLeafNode && (this.hasChildren(true) && !this.isLoading)) {
            s += "h";
        }
        return s;
    },

    
    onLabelClick: function(me) {
    
      // make the current selected node stand out a bit
      Ext.get(me.labelElId).parent().addClass('selectedTreeNode');
	  // YAHOO.util.Dom.setStyle(me.labelElId, 'opacity', 0.5);

	  if (this.treeControl.lastNodeClicked != null) {
          //set the last node clicked to its normal style
          var textNode = Ext.get(this.treeControl.lastNodeClicked.labelElId);
          if (textNode) {
              textNode.parent().removeClass('selectedTreeNode');
          }
	  	  // YAHOO.util.Dom.setStyle(this.treeControl.lastNodeClicked.labelElId, 'opacity', 1);
	  }
	  
      this.treeControl.lastNodeClicked = me;
    },


    getPrimaryKeyValues: function() {
      var pkArray = {};
      if(this.restriction.clauses) {
        for(var index = 0; index < this.restriction.clauses.length; index++) {
          pkArray[ this.restriction.clauses[index].name] = this.restriction.clauses[index].value;
        }
      }
      return pkArray;
    },

    getPrimaryKeyValue: function(name) {
      if(this.restriction.clauses) {
        for(var index = 0; index < this.restriction.clauses.length; index++) {
          if(this.restriction.clauses[index].name == name){
            return this.restriction.clauses[index].value;
          }
        }
      }
      return "";
    },
	
	
	getText: function() {
		var result = '';
		for (var i = 0; i < this.level.pkFields.length; i++) {
			if (i > 0) {
				result += '|';
			}
			result += this.data[this.level.pkFields[i] + '.key'];
		}
		return result;	
	},
    
	isSelected: function(){
		return this.selected;
	},
	
	setCheckState: function(selected){
		this.selected = selected;
		if (YAHOO.util.Dom.get(this.checkElId)) {
			YAHOO.util.Dom.get(this.checkElId).checked = selected;
		}
	},
	
	setSelected: function(selected){
		if(this.level.multipleSelectionEnabled){
			this.setCheckState(selected);
			for( var i=0; i < this.children.length; i++){
				var child = this.children[i];
				if(child.setSelected){
					child.setSelected(selected);
				}
			}
			this.updateParent();
		}
	},
	
    
    updateParent: function() { 
        var parent = this.parent;
		
		if(!parent || !parent.updateParent || !parent.level.multipleSelectionEnabled){
			return;
		}
		
        var somethingChecked = false;
        var somethingNotChecked = false;

        for (var i=0; i < parent.children.length; i++) {
            var n = parent.children[i];
            if ("selected" in n) {
                if (n.selected) {
                    somethingChecked = true;
                } else {
                    somethingNotChecked = true;
                }
            }
        }

        if (somethingChecked && !somethingNotChecked) {
            parent.setCheckState(true);
        } else if(somethingNotChecked) {
            parent.setCheckState(false);
        }
        parent.updateParent();
    },
		
	// overrides YAHOO.widget.Node
    getNodeHtml: function() { 
        var sb = [];

        sb[sb.length] = '<table id="ygtvtableel' + this.index + '" border="0" cellpadding="0" cellspacing="0" class="ygtvtable ygtvdepth' + this.depth;
        if (this.enableHighlight) {
            sb[sb.length] = ' ygtv-highlight' + this.highlightState;
        }
        if (this.className) {
            sb[sb.length] = ' ' + this.className;
        }           
        sb[sb.length] = '"><tr class="ygtvrow">';
        
        for (var i=0;i<this.depth;++i) {
            sb[sb.length] = '<td class="ygtvcell ' + this.getDepthStyle(i) + '"><div class="ygtvspacer"></div></td>';
        }

        if (this.hasIcon) {
            sb[sb.length] = '<td id="' + this.getToggleElId();
            sb[sb.length] = '" class="ygtvcell ';
            sb[sb.length] = this.getStyle() ;
            sb[sb.length] = '"><a href="#" class="ygtvspacer">&#160;</a></td>';
        }
		
		if(this.level.multipleSelectionEnabled){
			sb[sb.length] = '<td class="ygtvcell ';
			sb[sb.length] = this.contentStyle  + ' ygtvcontent" ';
			sb[sb.length] = '>';
			sb[sb.length] = '<input type="checkbox"';
			sb[sb.length] = ' id="'+ this.checkElId +'"';
			if(!this.parent.isRoot() && this.parent.isSelected()){
				this.setCheckState(this.parent.isSelected());
				sb[sb.length] = ' CHECKED ';
			}	
			sb[sb.length] = '/> ';
			sb[sb.length] = '</td>';
		}
		
        sb[sb.length] = '<td id="' + this.contentElId; 
        sb[sb.length] = '" class="ygtvcell ';
        sb[sb.length] = this.contentStyle  + ' ygtvcontent" ';
        sb[sb.length] = (this.nowrap) ? ' nowrap="nowrap" ' : '';
        sb[sb.length] = ' >';
        sb[sb.length] = this.getContentHtml();
        sb[sb.length] = '</td></tr></table>';

        return sb.join("");

    },
	
    // overrides YAHOO.widget.Node
    getContentHtml: function() { 
        var sb = [];
        //sb[sb.length] = this.href?'<a':'<span';
		sb[sb.length] = '<a';
        sb[sb.length] = ' id="' + this.labelElId + '"';
        sb[sb.length] = ' class="' + this.labelStyle  + '"';
        if (this.href) {
            sb[sb.length] = ' href="' + this.href + '"';
            sb[sb.length] = ' target="' + this.target + '"';
        } 
        if (this.title) {
            sb[sb.length] = ' title="' + this.title + '"';
        }
        sb[sb.length] = ' >';
        sb[sb.length] = this.label;
		sb[sb.length] = '</a>';
        //sb[sb.length] = this.href?'</a>':'</span>';
        return sb.join("");
    }
	
  });


 Ab.tree.TreeLevel = Base.extend({

    // tree level, 0 for top-level, 1, 2, etc.
    levelIndex: 0,

    // array of visible field names and isPk (if it is primary key field?)
    visibleFields: null,

    // array of primary key field names
    pkFields: null,

    // data source id
    dataSourceId: null,

    // panel id - used to set the restriction for the level
    panelId: null,

    // non-primary key visible field label format
    cssClassName: 'ygtvlabel',      // default to YUI label

    // primary key visible field label format
    cssPkClassName: 'ygtvlabel_pk',    // default to YUI label

    // panel events defined in the view, such as onClickNode, onContextMenu
    events: null,

    // restriction for the tree level. this attribute usually set from the application JS code
    restriction: null,
	
	// multiple selection enabled for level, default is false
	multipleSelectionEnabled: false,
	
	//object tree node configuration for level 
	//object format: [{text: 'customMessage'}, 
	//				 {fieldName: 'fieldId', length: numericValue, pkCssClass: 'true'|'false'}]
	//where length (optional) is set for fields to be trimmed, 
	//pkCssClass (optional) is true for custom display similar to primary key fields
	treeNodeConfig: null,
	
    
    constructor: function(levelIndex, data, panelData) {

        // set the tree level index
        this.levelIndex = levelIndex;

        // add all the visible field names to create node label
        this.visibleFields = [];

        // field definitions can be specified in the panel (only for the top-level tree panel) 
        // or in the data source (for any tree level)
        var panel = null;
		var ds = null;
        if (valueExists(panelData)) {
       		var found = false;
       		//3032594 - loop through the panel's items instead of panels array. For tree control, only the first panel is stored in View.panels object 
       		//			while View.panels.items[rootTreePanel]._panelsData store all the tree panels information
       		for(var index=0; (index < View.panels.length && !found); index++){
       			var panelItem = View.panels.items[index];
       			if(panelItem.type == 'tree' && panelItem._panelsData!= null && panelItem._panelsData.length > 0){
               		for(var innerIndex=0; innerIndex < panelItem._panelsData.length; innerIndex++){
               			if(panelItem._panelsData[innerIndex].panelId == panelData.panelId){
               				found = true;
               				panel = panelItem._panelsData[innerIndex];
               				break;
               			}
               		}
               	}
        	}
			ds = View.dataSources.get(panelData.dataSourceId);
		}
	
        // determine visible fields for this level
        for (var i = 0; i < data.columns.length; i++) {
        	var fieldName = data.columns[i].id;

            var isVisibleField = true;
            var controlType = '';
            var legendKey = '';
            //3032594 - try to find the field in the panel's fieldDef object
            if (isVisibleField && valueExists(panel) && valueExists(panel.fieldDefs)) {
		        for (var j = 0; j < panel.fieldDefs.length; j++) {
		        	if (fieldName == panel.fieldDefs[j].id && panel.fieldDefs[j].hidden == "true") {
		        		// the field is found, and is hidden
		                isVisibleField = false;
		                break;
		            }
		        	if ((fieldName == panel.fieldDefs[j].id) && (panel.fieldDefs[j].controlType == "color")) {
		        		// the field is found, and is hidden
		        		controlType = 'color';
		        		break;
		        	}	
		        	
		        	if (fieldName == panel.fieldDefs[j].id){
		        		legendKey = panel.fieldDefs[j].legendKey; break;
		        	}
		        }
		    }

            // try to find the field in the data source
		    if (isVisibleField && valueExists(ds) && valueExists(ds.fieldDefs)) {
				if (ds.fieldDefs.get(fieldName) && ds.fieldDefs.get(fieldName).hidden == "true") {
					isVisibleField = false;
				}
		    }
		    
		    // not a visible field
	        if (!isVisibleField) {
	        	continue;
	        }
		  
            // check if the field is a primary key field
	    
            var isPk = false;
            for (var j = 0; j < data.primaryKeyIds.length; j++) {
                if (fieldName === data.primaryKeyIds[j]){
                    isPk = true;
                    break;
                }
            }

            // add visible fields with field name and isPk value.
            this.visibleFields.push({name: fieldName, isPk: isPk, controlType: controlType, legendKey: legendKey});
        }

        // add all primary key fields used to generate drill-down restrictions
        this.pkFields = [];
        for (var i = 0; i < data.primaryKeyIds.length; i++) {
            this.pkFields.push(data.primaryKeyIds[i]);
        }

        // set other properties
        if (valueExists(panelData)) {
            this.dataSourceId = panelData.dataSourceId;
            this.panelId = panelData.panelId;

            // set the non-primary key style - cssClassName
            if (valueExistsNotEmpty(panelData.cssClassName)) {
                this.cssClassName = panelData.cssClassName;
            }

            // set the primary key style - cssPkClassName
            if (valueExistsNotEmpty(panelData.cssPkClassName)) {
                this.cssPkClassName = panelData.cssPkClassName;
            }
		  
		    // set multipleSelectionEnabled
		    if (valueExists(panelData.multipleSelectionEnabled)) {
		  	    this.multipleSelectionEnabled = panelData.multipleSelectionEnabled;
		    }
		    		    
		    // set treeNodeConfig
		    if (valueExists(panelData.treeNodeConfig)) {
		  	    this.treeNodeConfig = panelData.treeNodeConfig;
		    }

            // add panel events to the tree level
            this.events = panelData.events;
        }
    },

    
    addRestriction: function(restriction) {
        if (this.restriction == null){
            this.restriction = new Ab.view.Restriction();
        }

        this.restriction.addClauses(restriction, true);
    }
});

Ab.namespace('tree');


Ab.tree.TreeTable = Ab.tree.TreeControl.extend({
	
	maxVisibleFields: -1,
	
    
	constructor: function(id, configObject) {
		this.inherit(id, configObject);
		this.maxVisibleFields = this._findMaxVisibleFields();
	},

    
	_findMaxVisibleFields: function(i) {
		var maxVisibleFields = -1;
		for(var i=0; i<this._panelsData.length; i++){
			var fieldDefs = this._panelsData[i].fieldDefs;
			var numberOfVisibleFields = 0;
			for(var j=0; j<fieldDefs.length; j++){
				if(fieldDefs[j].hidden != 'true'){
					numberOfVisibleFields += 1;
				}
			}
			
			if(numberOfVisibleFields > maxVisibleFields){
				maxVisibleFields = numberOfVisibleFields;
			}
		}
		return maxVisibleFields;
	},	

	
    
	_addTreeNodes: function(result, parent, treeLevel, panelDataNextLevel){
		// create a TreeNode for each record returned from server
		for (var i = 0; i < result.data.records.length; i++) {
			//get the record data in JSON format from server
			var record = result.data.records[i];

			//create a new TreeNode -  a YUI text node with AFM-specific info
			// expand node
			//var treeNode = new Ab.tree.TreeTableNode(this, treeLevel, record, parent, true);
			var treeNode = new Ab.tree.TreeTableNode(this, treeLevel, record, parent, false);
			if (treeNode.isLeafNode){
				parent.isLeafNode = false;		
			}
			
			// add the tree node to the tree control's top node collection
			if(parent.isRoot()) {
				this._addTreeNode(treeNode);
			}	
		}	
	},

    
    _initTree: function(panelData, parent, level, panelDataNextLevel) {

		// if panelData not define, return
		if(typeof(panelData) == 'undefined'){
			return;
		}

        // call WFR to get the data
        try{
        	var result = Workflow.call('AbCommonResources-getDataRecords', this._getParameters(panelData, parent, level), 120);
        	
        	if (result.code == 'executed') {
    			// call afterGetData for post-processing (e.g., localization of data from messages)
    			var listener = this.getEventListener('afterGetData');
    			if (listener) {
    				listener(this, result.data, level);
    			}
    			
    			var elem = document.getElementById(panelData.panelId + "_msg_no_record");
    			if(elem != null){
    				elem.parentNode.removeChild(elem); 
    			}

    			if( result.data.records.length > 0 ) {
    				// if the WFR succeeded, create a treeLevel object
    				var treeLevel = new Ab.tree.TreeTableLevel(level, result.data, panelData);
    				treeLevel = this.applySidecarToLevel(treeLevel);

    				this._addTreeLevel(treeLevel);
    				
    				// create a TreeNode for each record returned from server
    				this._addTreeNodes(result, parent, treeLevel, panelDataNextLevel);
    				
    				// if the child nodes are added fine, then for hierarchy tree, set the maxLevel to the current deepest level.
    				if (this.type=='hierTree' && this.maxLevel < level) {
    					this.maxLevel = level;
    				}
    			} 
    			else {
    				if(level > 0){
    					//kb# 3022422 
    					parent.isLeafNode = true;
    				} else {
    		        	var elem = document.getElementById(panelData.panelId);
    					if(elem != null){
    						var divNode = document.createElement("div");
    						divNode.id = panelData.panelId + "_msg_no_record";
    						divNode.className = "instruction";
    						divNode.innerHTML = "<br>" + this.getLocalizedString(this.z_EMPTY_TREE_MESSAGE);
    						elem.parentNode.appendChild(divNode)
    					}
    				}
    			}
            } else {
                // handle the exceptions
                this.handleError(result);
            }
        } catch (e){
			this.handleError(e);
		}      
    },
    
    
    addLink: function(node, eventIndex) {
        // !!!YUI bug - do not use TextNode's getLabelEl() or Node's getEl() which will return NULL.
        // get the Node's label id through the property directly -->
        
        for(var i=0; i<=node.position; i++){
        	var linkId = node.labelElId + '_' + i;
        	var link = $(linkId);      	
        	
        	// skip cell if contains button
        	if(link.className.match(/buttonContainer/)){
        		continue;		
        	}
    	       	       	
        	var command = null;
        	if (valueExists(eventIndex)) {
        		var commandsData = node.level.events[eventIndex]["commands"];
        		var restriction = node.restriction;
        		
        		// create command chain
        		command = new Ab.command.commandChain(this.id, restriction);        		
        		if(commandsData[0].type == 'onClickNode'){
        			command.handle= commandsData[0].handle;
        		}        
        		command.addCommands(commandsData);
        		
        		// add command as a link property
        		link.command = command;
        	}
        	
        	// register the command as an event listener
        	
        	// KB 3028554: call the event handlers in the right order
        	var listener = function() {
        		
        		// call the default tree node event handler that sets the lastNodeClicked property
        		node.onLabelClick(node);
        		
        		// call the view command
        		if (command) {
        			if(valueExists(commandsData) && commandsData[0].type == 'onClickNode'){
        				command.handle(commandsData[0].panel, node);
        			}else{
        				command.handle();
        			}
        		}
        	}
        	
        	YAHOO.util.Event.addListener(link, "click", listener);
    	}
    }    		
});

 
Ab.tree.TreeTableNode = function(treeControl, treeLevel, data, parent, expanded) {
	// set the node's attribute
	this.treeControl = treeControl;
	this.level = treeLevel;
	this.tree = treeControl.treeView;
	
	// default to no children
	this.children = [];
	
	this.parent = parent;
	
	this.restriction = new Ab.view.Restriction();
	
	// call YAHOO.widget.TextNode init() function
	this.init(data, parent, expanded);
	
	// decide if the node is a leaf node?
	if((this.treeControl.type=='tree' || this.treeControl.type=='selectValueTree' )
			&& this.level.levelIndex == this.treeControl.maxLevel){
		this.isLeafNode = true;
	}
	
	// generate an id for select element
	this.checkElId = "ygtvcheck"+this.index;
	
	// does the level contains any events?
	if(this.treeControl.type=='tree' || this.treeControl.type=='hierTree') {
		var eventIndex = 0;
		while(treeLevel.events[eventIndex] && !this.hasLabelClickEvent) {
			//does the events contain a "onLabelClick" event?
			if(treeLevel.events[eventIndex]["type"]=='onClickNode'){
				this.hasLabelClickEvent = true;
			}
			eventIndex++;
		}
	}
	
	// make sure this function stays in the last line within the function
	// create the label
	//this._createLabel();
};	



YAHOO.extend(Ab.tree.TreeTableNode, Ab.tree.TreeNode, {

    
    getElId: function() {
        return this.id;
    },

    
    getEl: function() {
        return document.getElementById(this.getElId());
    },

        
    getTableElId: function() {
    	return  this.treeControl.id + '_' + 'ygtvtableel' + '0';
    }, 

          
    getTableEl: function(){
    	return document.getElementById(this.getTableElId()).tBodies[0];
    },   

        
    getDivElId: function() {
    	return  this.treeControl.id;
    },

          
    getDivEl: function(){
    	return document.getElementById(this.getDivElId());
    },  
        
    
    getToggleElId: function() {
        return "ygtvt" + this.index;
        //return "ygtvt" + (this.id + 1);
    },

    
    getToggleEl: function() {
        return document.getElementById(this.getToggleElId());
        //return "ygtvt" + (this.id + 1);
    },
                    
    
    getHtml: function() {
        this.childrenRendered = false;

        var sb = [];

        if(this.parent.isRoot() && !this.previousSibling){

        	if(!this.isLeafNode || (this.isLeafNode && !this.previousSibling)){
        		sb[sb.length] = '<table id="' + this.getTableElId() + '" border="0" cellpadding="0" cellspacing="0" class="ygtvtable ygtvdepth' + this.depth;
        		if (this.enableHighlight) {
        			sb[sb.length] = ' ygtv-highlight' + this.highlightState;
        		}
        		if (this.className) {
        			sb[sb.length] = ' ' + this.className;
        		}           
        		
        		sb[sb.length] = ' treeTable';
        		sb[sb.length] = '">';
        	}
        	
        	sb[sb.length] = this.generateFieldTitles(this.parent);
    	}
  	
        if(this.isLeafNode){
        	sb[sb.length] = this.getNodeHtml();
        }else{
        	sb[sb.length] = this.getNodeHtml();        	
        	sb[sb.length] = this.getChildrenHtml();
        }
     
        if(!this.nextSibling && !this.isLeafNode){
        	sb[sb.length] = '</table>';
        }

        return sb.join("");
    },
    
    
    getChildrenHtml: function() {
        var sb = [];        	
        // Don't render the actual child node HTML unless this node is expanded.
        if ( (this.hasChildren(true) && this.expanded) ||
                (this.renderHidden && !this.isDynamic()) ) {               
            sb[sb.length] = this.renderChildren();
        }
        return sb.join("");
    },
        
     
    completeRender: function() {
        var sb = [];        
        sb[sb.length] = this.generateFieldTitles(this);       
        for (var i=0; i < this.children.length; ++i) {
            // this.children[i].childrenRendered = false;
            this.children[i].id = (this.id != undefined) ? this.id + '_' + i : '_' + i;
            sb[sb.length] = this.children[i].getHtml();
        }
                
        this.childrenRendered = true;

        return sb.join("");
    },
    
   	generateFieldTitles: function(node) {
   		var str = '';
   		if(node.children.length > 0){        
        	var childrenLevel = node.children[0].level;
        	if(childrenLevel.showLabels){
        		str += '<tr class="headerRow">';
        		
        		if(childrenLevel){
        			for (var x=0; x < childrenLevel.visibleFields.length; x++) {
        				str += '<td class="headerCell"';       			
        				str += (x== childrenLevel.visibleFields.length-1) ? ' colspan="' + (this.treeControl.maxVisibleFields-childrenLevel.visibleFields.length+1) : '';
        				str +=  '" >';
        				if(x == 0 ){
        					str += this.createDepthIconsForTitle(node, node.depth+1);        			
        				}
        				if( childrenLevel.visibleFields[x].controlType != 'button'){
        					//str += '<div class="headerTitleText">' + childrenLevel.visibleFields[x].title + '</div>' + '</td>';         				   				
        					str += '<div class="headerTitleText';
        					str += (x==0) ? ' firstTitle' : '';
        					str += '">' + childrenLevel.visibleFields[x].title + '</div>';
        				}
        				str += '</td>';
        			}
        			str += '</tr>';
        		}
        	}
        }
        return str;       
   	},
   	
   	getHeightClass: function(){
   		return (mozillaFireFoxBrowser) ? 'heightDynamic' : '';
   	},
  
    createDepthIconsForTitle: function(node, depth, space){
    	var str = '';
    	var depthDiv = '<div class="ygtvdepthcell ' + this.getHeightClass() + ' headerDepth floatLeft"></div>';
    	var blankDiv = '<div class="ygtvblankdepthcell ' + this.getHeightClass() + ' headerBlank floatLeft"></div>';


        for (var i=0;i<depth-1;i++) {
        	if(node.children.length > 1 || i<this.depth){       		
        		if(node.parent.nextSibling || (i==0 )){
        			str += depthDiv;
        		}else{
        			str += blankDiv;
        		}
        	}
        } 
        
        if(!node.isRoot()){
        	if((this.nextSibling)){
        		str += depthDiv;
        	}else{
        		str += blankDiv;
        	} 
        }
        str +=  '<div class="ygtvblankdepthcell ' + this.getHeightClass() + ' headerLastBlank floatLeft"></div>';     
        return str;
    },
       	
    
    loadComplete: function() {
		var table = YAHOO.util.Dom.get(this.getTableElId());
		var rowsHTML = this.completeRender();
		rowsHTML = rowsHTML.replace('<\table>', '');
		rowsHTML = rowsHTML.split('</tr>');

		for(var i=rowsHTML.length-2; i>=0; i--){
			var rowIndex = table.rows.namedItem(this.id).rowIndex+1;
			var newRow = table.insertRow(rowIndex);	
			this.setPropertiesForTag(newRow, rowsHTML[i], 'tr');

			var tdRegExp = new RegExp('<td.*?>(.*?[\\S\\s]*?)<\/td>', 'gi');
			var cellsHTML = rowsHTML[i].match(tdRegExp);
			if(cellsHTML){

				for(var k=0; k<cellsHTML.length; k++){
					var newCell = newRow.insertCell(k);
					newCell.innerHTML = cellsHTML[k].replace(tdRegExp, "$1");
					this.setPropertiesForTag(newCell, cellsHTML[k], 'td');	
			
					var buttons = Ext.query('.button', newCell);
					for(var m=0; m<buttons.length; m++){
						var button = buttons[m];
						if (valueExists(button) && button.nodeType != 3 && button.type == 'button' && this.children) {
							var levelIndex = this.level.levelIndex + 1;
							var panel = this.treeControl._panelsData[levelIndex];						
							var fieldIndex =  button.id.replace('button', '');
							var levels = newRow.id.split('_');
							var index = levels[levels.length-1];							
							var node = this.tree._nodes[index];	
							var listenerName = panel.panelId + '_on' + capitalizeFirst(this.children[0].level.visibleFields[fieldIndex].name);					
							this.tree.attachListenerToElement(listenerName, button, newRow, panel, node);				
						}
					}				        	
				}
			}
		}	
				
		if (this.propagateHighlightDown) {
			if (this.highlightState === 1 && !this.tree.singleNodeHighlight) {
				for (var i = 0; i < this.children.length; i++) {
				this.children[i].highlight(true);
			}
			} else if (this.highlightState === 0 || this.tree.singleNodeHighlight) {
				for (i = 0; i < this.children.length; i++) {
					this.children[i].unhighlight(true);
				}
			} // if (highlighState == 2) leave child nodes with whichever highlight state they are set
		}
				
        this.dynamicLoadComplete = true;
        this.isLoading = false;
        this.expand(true);
        this.tree.locked = false;
    },   

    
    setPropertiesForTag: function(el, html, tagName) { 
    	//var tagRegExp = (tagName == 'tr') ? new RegExp('(<tr id=["]?' + this.id + '["]?.*?[^>]*>)', 'gmi') :
    	var tagRegExp = (tagName == 'tr') ? new RegExp('(<tr id=["]?' + '.*?' + '["]?.*?[^>]*>)', 'gmi') :
    		new RegExp('(<td.*?>)', 'gmi');
    	var tag = html.match(tagRegExp);
    	var propertyRegExp = / (.*?)\=\"(.*?)\"/gi;	
    	var properties = (tag) ? tag[0].match(propertyRegExp): [];
    	for(var j=0; j<properties.length; j++){
    		var pair = properties[j].split("=");
    		el.setAttribute(trim(pair[0].replace(/"/g, "")), pair[1].replace(/"/g, ""));
    	}
    },
       			           
    
    getNodeHtml: function() { 
        var sb = [];
        //if(this.id == undefined){
        	this.id = this.index;
        //}
                        
        sb[sb.length] = '<tr id="' + this.id + '" ' + 'class="ygtvrow">';              
        this._createLabel();
        sb[sb.length] = this.getContentHtml();
        sb[sb.length] = '</tr>';                
        var str = sb.join("");

        return str;
    },   
        
    
    getContentHtml: function() { 
        var sb = [];
        sb[sb.length] = this.label;
        return sb.join("");
    },  
    
         
    wrapWithAnchorTag: function(value){
		var str = '<a';
		this.labelElId = "ygtvlabelel" + this.index + '_' + this.position ;
        str += ' id="' + this.labelElId + '"';
        str += ' class="' + this.labelStyle  + ' ' + '"';
        if (this.href) {
            str += ' href="' + this.href + '"';
            str += ' target="' + this.target + '"';
        } 
        if (this.title) {
            str += ' title="' + this.title + '"';
        }
        str += ' >';
        str += value;
		str += '</a>';
		return str;
    },

         
    wrapWithAnchorTagForButton: function(value){
		var str = '<div';
		this.labelElId = "ygtvlabelel" + this.index + '_' + this.position ;
        str += ' id="' + this.labelElId + '"';
        str += ' class="' + this.labelStyle  + ' buttonContainer"';
        if (this.href) {
            str += ' href="' + this.href + '"';
            str += ' target="' + this.target + '"';
        } 
        if (this.title) {
            str += ' title="' + this.title + '"';
        }
        str += ' >';
        str += value;
		str += '</div>';
		return str;
    },
           
    
    _createLabel: function(){

        // turn off the toggle if the label has custom defined event
        // use: this.href="javascript:void(0);" instead of "#" to avoid jumping to the top of the page
        if(this.hasLabelClickEvent) {
          this.href = "javascript:void(0);";
          // KB 3028554: the textNodeParentChange property is not supported in YUI 2.8
          // instead, the onLabelClick is called from the event listener defined in the addLink() method
          //this.textNodeParentChange = "onLabelClick";
        }
        
        // compose the label text field using the primary keys
        var labelText = "";

        if(this.level.treeNodeConfig){
        	labelText = this.getLabelForNodeConfig(this.level);
        }else{
        	// loop thought the visible fields and compose the label's text
        	for (var j = 0; j < this.level.visibleFields.length; j++) {
        		var value = (this.level.visibleFields[j].value) ? this.level.visibleFields[j].value : this.data[this.level.visibleFields[j].name];
        		labelText = this.buildLabelText(labelText, this.level.visibleFields, j, value);        
        	}
    	}
	        
        // set the label
        this.setUpLabel(labelText);
        
		//call custom handler
		var afterGeneratingTreeNode = this.level.afterGeneratingTreeNode;
		var node = this;
        if(typeof afterGeneratingTreeNode == "function"){
        	afterGeneratingTreeNode(this);
        }        		
				
        // loop through the primary keys and compose the pkData list
        var pkFieldName = "";
        var parentPkFieldValue = "";
        for (var j = 0; j < this.level.pkFields.length; j++) {
            pkFieldName = this.level.pkFields[j] + ".key";
            
            if(this.parent != null && !this.parent.isRoot()){
				parentPkFieldValue = this.parent.getPrimaryKeyValue(this.level.pkFields[j]);
				if( parentPkFieldValue!= null && parentPkFieldValue!= '' &&  this.treeControl.type!='hierTree' &&  this.treeControl.type!='selectValueHierTree'){
					// add the parent restriction if exists
					this.restriction.addClause(this.level.pkFields[j], parentPkFieldValue, "=");
				} else {
					// add the primary keys data to restriction object
    	        	this.restriction.addClause(this.level.pkFields[j], this.data[pkFieldName], "=");
				}
			} else {
				// add the primary keys data to restriction object
    	       	this.restriction.addClause(this.level.pkFields[j], this.data[pkFieldName], "=");
			}
        }
    },

    
    getLabelForNodeConfig: function(){
    	var labelText = "";
    	for(var j = 0; j < this.level.treeNodeConfig.length; j++){
    		var element = this.level.treeNodeConfig[j];
    		var value = element.text;
    		var cssClass = this.level.cssPkClassName;

    		
    		if(!valueExistsNotEmpty(value) && valueExistsNotEmpty(element.fieldName)){
    			value = this.data[element.fieldName];

    			if(valueExistsNotEmpty(element.length)){
    				if (value.length > element.length) {
    		        	value = value.substr(0, element.length) + " ...";
    				}
    			}
    			
    			if(valueExistsNotEmpty(element.pkCssClass)){
    				cssClass = (element.pkCssClass == 'true') ? this.level.cssPkClassName : level.cssClassName;
    			}else if(this.level.pkFields.indexOf(element.fieldName)<0){
    				cssClass = this.level.cssClassName;
    			}
    		}
    		
    		labelText = this.buildLabelText(labelText, this.level.treeNodeConfig, j, value);       		
    	}
    	return labelText;
    },

        
    buildLabelText: function(labelTxt, fields, index, value){
    	var idText = ' id="' + this.contentElId + '_' + index + '" ';        		
    	this.position = index;
    	//var tagName = (index == 0) ? '<td style="white-space:nowrap" ' : '<td';
    	var tagName = '<td';
    	var tagEnd = (index == 0) ? '</td>' : '</td>';
    	var depthIcons = (index==0) ? this.createDepthIcons('', this.depth) : '';
    	var toggleIcon = (index==0 && this.hasIcon) ? this.createToggleIcon('') : '';
    	var multiSelectIcon = (index==0 && this.level.multipleSelectionEnabled) ? this.createMultipleSelectionEnabled('') : '';
    	var firstCell = (index==0) ? ' firstContent' : '';
    	var firstCellMargin = (index==0) ? ' style="padding-right: ' + 16*(this.treeControl.maxLevel+1) + 'px"' : '';
    	
    	if(value!=undefined){
    		if(index>0){
    			labelTxt = labelTxt + " ";
    		}
    		
    		// user can use custom style class for primary key and non-primary key part of labels
    		var isColorField = (fields[index].controlType == 'color');
    		var colSpan = (!this.nextSibling  && index== fields.length-1)? this._calculateColSpan() : 0; 
    		var colSpanText = (colSpan == 0 || colSpan == 1) ? '' :  ' colSpan="' + colSpan + '"';            	
    		
    		if(isColorField){
    			labelTxt = labelTxt + tagName + idText + 'class="' + this.level.cssClassName + ' contentCell colorContent"' + colSpanText + '>' + depthIcons + toggleIcon + multiSelectIcon + this.wrapWithAnchorTag(this.getColorContentHtml(value, fields[index], this.data)) + tagEnd;
    		}else if(fields[index].isPk){
    			labelTxt = labelTxt + tagName + idText + 'class="' + this.level.cssPkClassName + firstCell +' contentCell"' + colSpanText + firstCellMargin + '>' + depthIcons + toggleIcon + multiSelectIcon +  this.wrapWithAnchorTag(value) + tagEnd;
    		} else {
    			labelTxt = labelTxt + tagName + idText + 'class="' + this.level.cssClassName + firstCell + ' contentCell"' + colSpanText + firstCellMargin +'>' + depthIcons + toggleIcon + multiSelectIcon + this.wrapWithAnchorTag(value) + tagEnd;
    		} 
    	}else if(fields[index].controlType == 'button'){
    		labelTxt += tagName + idText + 'class="' + this.level.cssClassName + ' contentCell "' + colSpanText + '>';
    		labelTxt += depthIcons + toggleIcon + multiSelectIcon;
    		labelTxt += this.wrapWithAnchorTagForButton('<input id="button' + index + '" type="button" class="button mediumAction" value="' + fields[index].title + '" name="' + this.level.panelId + '_' + fields[index].name + '"/>');
    		labelTxt += tagEnd;
    	} 
    	return labelTxt;
    },
    
    
    createToggleIcon: function(innerHTML){
    	var str = '';
    	str += '<div id="' + this.getToggleElId();
    	str += '" class="';
    	str += this.getStyle() ;
    	str += ' toggleIcon ';
    	str += ' floatLeft">';
    	str += innerHTML;
    	str += '</div>';
    	return str;
    },

    
    createDepthIcons: function(innerHTML, depth){
    	var str = '';
        for (var i=0;i<depth;i++) {
        	str += '<div class="' + this.getDepthStyle(i) + ' ' + ' floatLeft">';
            str += innerHTML;
            str += '</div>';
        }
        return str;
    },

                
    createMultipleSelectionEnabled: function(innerHTML){
    	var str = '';
    	str += '<div class="';
    	str += this.contentStyle  + ' ygtvcontent floatLeft" ';
    	str += '>';
    	str += '<input type="checkbox"';
    	str += ' id="'+ this.checkElId +'"';
    	if(!this.parent.isRoot() && this.parent.isSelected()){
    		this.setCheckState(this.parent.isSelected());
    		str += ' CHECKED ';
    	}	
    	str += '/>';
    	str += innerHTML;			
    	str += '</div>';
    	return str;
    },
    
     
    _calculateColSpan: function(){
    	var maxNumberOfColumns = this.treeControl.maxVisibleFields;
    	var numberOfColumnsOnThisLevel = this.level.visibleFields.length - 1;			
        var colSpan = 0;
        if(maxNumberOfColumns  > numberOfColumnsOnThisLevel){
        	 colSpan = maxNumberOfColumns - numberOfColumnsOnThisLevel;
        }
        
        return colSpan;
    }, 
    
    
    expand: function(lazySource) {
        // Only expand if currently collapsed.
        if (this.isLoading || (this.expanded && !lazySource)) { 
            return; 
        }

        var ret = true;

        // When returning from the lazy load handler, expand is called again
        // in order to render the new children.  The "expand" event already
        // fired before fething the new data, so we need to skip it now.
        if (!lazySource) {
            // fire the expand event handler
            ret = this.tree.onExpand(this);

            if (false === ret) {
                return;
            }
            
            ret = this.tree.fireEvent("expand", this);
        }

        if (false === ret) {
            return;
        }

        if (!this.getEl()) {
            this.expanded = true;
            return;
        }

        if (!this.childrenRendered) {
            this.renderChildren();
        } else {
        }

        this.expanded = true;

        this.updateIcon();

        // this.getSpacer().title = this.getStateText();

        // We do an extra check for children here because the lazy
        // load feature can expose nodes that have no children.

        // if (!this.hasChildren()) {
        if (this.isLoading) {
            this.expanded = false;
            return;
        }

        if (! this.multiExpand) {
            var sibs = this.getSiblings();
            for (var i=0; sibs && i<sibs.length; ++i) {
                if (sibs[i] != this && sibs[i].expanded) { 
                    sibs[i].collapse(); 
                }
            }
        }

        this.showChildren();

        ret = this.tree.fireEvent("expandComplete", this);
    },
            
     
    showChildren: function() {  	
        if (!this.tree.animateExpand(this.getChildrenEl(), this)) {
            if (this.hasChildren()) {
            	var startIndex = this.getEl().rowIndex+1;
            	var stopIndex = this._findStopIndex();
            	var hideIndex = stopIndex;
            	
            	var footprint = new Array(this.treeControl.maxLevel+1);
            	var curDepth = this.depth;
            	var prevDepth = curDepth;
            	var parentExpanded = new RegExp(/ygtvtm|ygtvlm/).test(this.getEl().innerHTML);
            	footprint[curDepth] = parentExpanded;

            	for(var i=startIndex; i< stopIndex; i++){

            		var curHTML = this.getTableEl().rows[i].innerHTML;
            		if(curHTML.match(/ygtvdepthcell/g)){
            			curDepth = curHTML.match(/ygtvdepthcell/g).length;
            		}
        		
            		if(curHTML.match(/ygtvblankdepthcell/g)){
            			curDepth += curHTML.match(/ygtvblankdepthcell/g).length;
            		}
            		if(curHTML.match(/headerCell/g)){
            			curDepth -= 1;
            		}

            		if(curDepth == prevDepth){
            			
            			// is sibling, show if parentExpanded == true           			          			
            			parentExpanded = footprint[curDepth-1]; 
            			this.getTableEl().rows[i].style.display = (parentExpanded == true) ? "" : "none";
           		         			
            		}else if(curDepth > prevDepth){          		
            			
            			// is child, show if parentExpanded == true 
            			var html = this.getTableEl().rows[i].innerHTML;
            			
            			// add to footprint
            			if(footprint[curDepth-1] == false){
            				footprint[curDepth]= false;
            			}else{
            				footprint[curDepth] = new RegExp(/ygtvtm|ygtvlm|headerCell/).test(html); 
            			}           			 
            			parentExpanded = footprint[curDepth-1];             			         			
            			this.getTableEl().rows[i].style.display = (parentExpanded == true) ? "" : "none";
            			//prevDepth = curDepth;
            			           		   			          		          			
            		}else if(curDepth < prevDepth){
            			
            			// is on a different branch, use footprint[curDepth - 1]
            			prevDepth = curDepth;            			
            			parentExpanded = footprint[curDepth - 1];
            			this.getTableEl().rows[i].style.display = (parentExpanded == true) ? "" : "none";
            			
            			// clear footprint
            			
            			
            		}
               	}
               	
            }
        }
    },
    
    
    
    hideChildren: function() {
        if (!this.tree.animateCollapse(this.getChildrenEl(), this)) {    	
            var startIndex = this.getEl().rowIndex+1;
            var stopIndex = this._findStopIndex();
            for(var i=startIndex; i< stopIndex; i++){
            	 this.getTableEl().rows[i].style.display = "none";
            }
        }
    },
    
    
    _findStopIndex: function() {
    	var stopIndex = this.getTableEl().rows.length;
   	
    	if(this.nextSibling){
    		stopIndex = this.getTableEl().rows.namedItem(this.nextSibling.id).rowIndex;
    	} else if(this.parent && this.parent.nextSibling){
    		stopIndex = this.getTableEl().rows.namedItem(this.parent.nextSibling.id).rowIndex;
    	} else if(this.parent && this.parent.parent && this.parent.parent.nextSibling){
    		stopIndex = this._findParentSibling(this.parent);
    	}
    	
    	return stopIndex;
    },             

    
    _findParentSibling: function(parent) {
    	if(parent.parent && parent.parent.nextSibling){ 
    		return this.getTableEl().rows.namedItem(parent.parent.nextSibling.id).rowIndex;
    	} else {
    		this._findParentSibling(parent.parent);
    	}  	
    },
 
    
    onLabelClick: function(me) {

      // make the current selected node stand out a bit
      Ext.get(me.labelElId + '_' + me.position).parent().parent().addClass('selectedTreeNode');
	  // YAHOO.util.Dom.setStyle(me.labelElId, 'opacity', 0.5);

	  if(this.treeControl.lastNodeClicked != null){
	      //set the last node clicked to its normal style
          Ext.get(this.treeControl.lastNodeClicked.labelElId + '_' + this.treeControl.lastNodeClicked.position).parent().parent().removeClass('selectedTreeNode');
	  	  // YAHOO.util.Dom.setStyle(this.treeControl.lastNodeClicked.labelElId, 'opacity', 1);
	  }
	  
      this.treeControl.lastNodeClicked = me;  
    }         
});


    
Ab.tree.TreeTableLevel = Ab.tree.TreeLevel.extend({
	
	showLabels: true,
		
    
    constructor: function(levelIndex, data, panelData) {
    	
    	// set the tree level index
        this.levelIndex = levelIndex;
        
        // add all the visible field names to create node label
        this.visibleFields = [];
        
        // field definitions can be specified in the panel (only for the top-level tree panel) 
        // or in the data source (for any tree level)
        var panel = null;
        var ds = null;
        if (valueExists(panelData)) {
        	var found = false;
        	//3032594 - loop through the panel's items instead of panels array. For tree control, only the first panel is stored in View.panels object 
        	//			while View.panels.items[rootTreePanel]._panelsData store all the tree panels information
        	for(var index=0; (index < View.panels.length && !found); index++){
        		var panelItem = View.panels.items[index];
        		if(panelItem.type == 'tree' && panelItem._panelsData!= null && panelItem._panelsData.length > 0){
        			for(var innerIndex=0; innerIndex < panelItem._panelsData.length; innerIndex++){
        				if(panelItem._panelsData[innerIndex].panelId == panelData.panelId){
        					found = true;
        					panel = panelItem._panelsData[innerIndex];
        					this.showLabels = panel.showLabels;
        					break;
        				}
        			}
        		}
        	}
        	ds = View.dataSources.get(panelData.dataSourceId);
        }
        
        // determine visible fields for this level
        if(panelData.fieldDefs.length > 0){	
        	this._findVisibleFieldsFromPanel(panel, ds, data);
        }else{
        	this._findVisibleFieldsFromDs(ds, panel, data);
        }
        
        // add all primary key fields used to generate drill-down restrictions
        this.pkFields = [];
        for (var m = 0; m < data.primaryKeyIds.length; m++) {
        	this.pkFields.push(data.primaryKeyIds[m]);
        }
        // set other properties
        if (valueExists(panelData)) {
        	this.dataSourceId = panelData.dataSourceId;
        	this.panelId = panelData.panelId;
        	
        	// set the non-primary key style - cssClassName
        	if (valueExistsNotEmpty(panelData.cssClassName)) {
        		this.cssClassName = panelData.cssClassName;
        	}
        	
        	// set the primary key style - cssPkClassName
        	if (valueExistsNotEmpty(panelData.cssPkClassName)) {
        		this.cssPkClassName = panelData.cssPkClassName;
        	}
        	
        	// set multipleSelectionEnabled
        	if (valueExists(panelData.multipleSelectionEnabled)) {
        		this.multipleSelectionEnabled = panelData.multipleSelectionEnabled;
        	}

		    // set treeNodeConfig
		    if (valueExists(panelData.treeNodeConfig)) {
		  	    this.treeNodeConfig = panelData.treeNodeConfig;
		    }
		            	
        	// add panel events to the tree level
        	this.events = panelData.events;
        	
        	// add onClickNode listener
        	var onClickNodeFunction = this._getControllerFunction(panel.panelId + '_onClickNode');
        	if(onClickNodeFunction){
        		this.events.push({type: 'onClickNode', commands: [{type: 'onClickNode', handle: onClickNodeFunction, panel: panelData}]});
        	}
        	
        	this.afterGeneratingTreeNode = this._getControllerFunction(panel.panelId + '_afterGeneratingTreeNode');       		      		
        }
    },
    
    
    _getControllerFunction: function(listenerName){
    	var fn = null
    	View.controllers.each(function (controller) {
    		fn = controller[listenerName];
    		if(fn){
    			if (!fn.call) {
    				fn = window[fn];
    			}						
    		}							
    	});
    	return fn;
    },    

    // custom handler
    afterGeneratingTreeNode: function(node){
    },
        
        
    _findVisibleFieldsFromPanel: function(panel, ds, data) {
    	for (var j = 0; j < panel.fieldDefs.length; j++) {
    		var isVisibleField = true;
    		var controlType = '';
    		var fieldName = panel.fieldDefs[j].id;
    		 var legendKey = panel.fieldDefs[j].legendKey; 
    		
    		//3032594 - try to find the field in the panel's fieldDef object
    		if (isVisibleField) {		            
    			if (panel.fieldDefs[j].controlType == "button") {
    				// buttons fields won't have ds definition
    				controlType = 'button';
    				//fieldName = panel.fieldDefs[j].id;
    			} else {       				
    				for (var i = 0; i < data.columns.length; i++) {    					
    					if (fieldName == data.columns[i].id && panel.fieldDefs[j].hidden == "true") {
    						// the field is found, and is hidden
    						isVisibleField = false;
    						break;
    					}
    				} 
    				
    				if (panel.fieldDefs[j].controlType == "color") {
    					// color fields may or may not have a ds a definition
    					controlType = panel.fieldDefs[j].controlType;
    				}    
    				
    				
    			}        			
    		}
    		
    		// try to find the field in the data source
    		if (isVisibleField && valueExists(ds) && valueExists(ds.fieldDefs)) {
    			if (ds.fieldDefs.get(fieldName) && ds.fieldDefs.get(fieldName).hidden == "true") {
    				isVisibleField = false;
    			}
    		}
    		
    		// not a visible field
    		if (!isVisibleField) {
    			continue;
    		}

    		// check if the field is a primary key field
    		var isPk = false;
    		for (var k = 0; k < data.primaryKeyIds.length; k++) {
    			if (fieldName === data.primaryKeyIds[k]){
    				isPk = true;
    				break;
    			}
    		}
    		
    		// add visible fields with field name and isPk value.
    		var visibleField = {name: fieldName, isPk: isPk, controlType: controlType, legendKey:legendKey};
    		visibleField.title =  (panel.fieldDefs[j].title) ? panel.fieldDefs[j].title : ds.fieldDefs.get(fieldName).title;

    		if(panel.fieldDefs[j].type != ''){
    			visibleField.type =  panel.fieldDefs[j].type;
    		}

    		if(panel.fieldDefs[j].value != ''){
    			visibleField.value =  panel.fieldDefs[j].value;
    		}
    		this.visibleFields.push(visibleField);
    	}
    },

        
    _findVisibleFieldsFromDs: function(ds, panel, data) {
    	for (var i = 0; i < data.columns.length; i++) {
    		var fieldName = data.columns[i].id;
    		
    		var isVisibleField = true;
    		var controlType = '';
    		
    		//3032594 - try to find the field in the panel's fieldDef object
    		if (isVisibleField && valueExists(panel) && valueExists(panel.fieldDefs)) {
    			for (var j = 0; j < panel.fieldDefs.length; j++) {
    				if (fieldName == panel.fieldDefs[j].id && panel.fieldDefs[j].hidden == "true") {
    					// the field is found, and is hidden
    					isVisibleField = false;
    					break;
    				}
    				if ((fieldName == panel.fieldDefs[j].id) && (panel.fieldDefs[j].controlType == "color")) {
    					// the field is found, and is hidden
    					controlType = panel.fieldDefs[j].controlType;
    					break;
    				}		            
    			}
    		}
    		
    		// try to find the field in the data source
    		if (isVisibleField && valueExists(ds) && valueExists(ds.fieldDefs)) {
    			if (ds.fieldDefs.get(fieldName) && ds.fieldDefs.get(fieldName).hidden == "true") {
    				isVisibleField = false;
    			}
    		}
    		
    		// not a visible field
    		if (!isVisibleField) {
    			continue;
    		}
    		
    		// check if the field is a primary key field
    		var isPk = false;
    		for (var j = 0; j < data.primaryKeyIds.length; j++) {
    			if (fieldName === data.primaryKeyIds[j]){
    				isPk = true;
    				break;
    			}
    		}

    		title = ds.fieldDefs.get(fieldName).title;

    		// add visible fields with field name and isPk value.
    		this.visibleFields.push({name: fieldName, isPk: isPk, controlType: controlType, title: title});
        }
    }
});  



YAHOO.widget.TreeView.prototype._getEventTargetTdEl = function (ev) {
	
	var target = YAHOO.util.Event.getTarget(ev); 
	if (target && (target.tagName.toUpperCase() == 'DIV' && YAHOO.util.Dom.hasClass(target,'floatLeft'))) { 
	} else {
		// go up looking for a TD with a className with a ygtv prefix
		while (target && !(target.tagName.toUpperCase() == 'TD' && YAHOO.util.Dom.hasClass(target.parentNode,'ygtvrow'))) { 
			target = YAHOO.util.Dom.getAncestorByTagName(target,'td'); 
		}
	}
	
	if (YAHOO.lang.isNull(target)) { return null; }
	// If it is a spacer cell, do nothing
	if (/\bygtv(blank)?depthcell/.test(target.className)) { return null;}
	// If it has an id, search for the node number and see if it belongs to a node in this tree.
	if (target.id) {
		var m = target.id.match(/\bygtv([^\d]*)(.*)/);
		if (m && m[2] && this._nodes[m[2]]) {
			return target;
		}
	}
	return null;
};

  
YAHOO.widget.TreeView.prototype.attachListenerToElement = function(listenerName, contentElement, row, panel, node){
	View.controllers.each(function (controller) {
        var scope = controller;
		var fn = controller[listenerName];
		if (fn) {
			if (!fn.call) {
				fn = window[fn];
                scope = window;
			}
			
			var listener = function() {
				// call the default tree node event handler that sets the lastNodeClicked property
				node.onLabelClick(node);
				fn.call(scope, contentElement, panel, node);
			}
			
			Ext.get(contentElement).addListener("click", listener);	
		}							
	});
};


  
YAHOO.widget.TreeView.prototype.focus = function () {
	var focused = false, self = this;
	
	if (this.tree.currentFocus) {
		this.tree.currentFocus._removeFocus();
	}
	
	var  expandParent = function (node) {
		if (node.parent) {
			expandParent(node.parent);
			node.parent.expand();
		} 
	};
	
	expandParent(this);
	
	//YS: check if self.getEl() is null to avoid JS error
	var firstChild = null;
	if(self.getEl()!=null){
		firstChild = self.getEl().firstChild;
	}
	YAHOO.util.Dom.getElementsBy  ( 
		function (el) {
			return (/ygtv(([tl][pmn]h?)|(content))/).test(el.className);
		} ,
		'td' , 
		firstChild, 
		function (el) {
			YAHOO.util.Dom.addClass(el, YAHOO.widget.TreeView.FOCUS_CLASS_NAME );
			if (!focused) { 
				var aEl = el.getElementsByTagName('a');
				if (aEl.length) {
					aEl = aEl[0];
					aEl.focus();
					self._focusedItem = aEl;
					Event.on(aEl,'blur',function () {
						//console.log('f1');
						self.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
						self.tree.currentFocus = null;
						self._removeFocus();
					});
					focused = true;
				}
			}
			self._focusHighlightedItems.push(el);
		}
	);
	if (focused) { 
		//console.log('f2');
		this.tree.fireEvent('focusChanged',{oldNode:this.tree.currentFocus,newNode:this});
		this.tree.currentFocus = this;
	} else {
		//console.log('f3');
		this.tree.fireEvent('focusChanged',{oldNode:self.tree.currentFocus,newNode:null});
		this.tree.currentFocus = null;
		this._removeFocus(); 
	}
	return focused;
};   


 
YAHOO.widget.RootNode.prototype.refresh = function(){
	//this.loadComplete();
	if (this.hasIcon) {
		var el = this.getToggleEl();
		if (el) {
			el.className = el.className.replace(/\bygtv[lt][nmp]h*\b/gi,this.getStyle());
		}
	}
};






Ab.grid.SelectValue = Ab.grid.MiniConsole.extend({
    
    // custom event handler called when the user selects the row
    selectValueListener: null,

    // configuration parameters
    fieldNames: null,
    selectFieldNames: null,
    visibleFieldNames: null,

	// KB 3031386 Allow configuration of visible field titles. Configuration may affectively contain ONE of either visibleFieldNames OR visibleFields
	visibleFields: null,

    actionListener: null,
    
    // 'grid' or 'multiple'
    selectValueType: null,
    
    // the parent form panel
    form: null,
    
    // allows app developers to reference custom Add New dialogs from the Select Vaue command.  Specified as a filename (ie. ab-sp-common-add-building.axvw)
    addNewDialog: null,
   
	// add NULL & NOT NULL values at the begining of the grid rows
	showNullFilters: false,
   
    
	constructor: function(dialog) {
        this.window = dialog;

        var parameters = Ab.view.View.selectValueParameters;
	    this.form = View.getControl('', parameters.formId); 
        this.fieldNames = parameters.fieldNames;

		// Configuration may affectively contain ONE of either visibleFieldNames OR visibleFields. visibleFields has priority
		if (valueExists(parameters.visibleFields)) {
			this.visibleFields = parameters.visibleFields;

			// copy fieldNames over to legacy collection
			this.visibleFieldNames = new Array();
			for (var i = 0, visibleField; visibleField = parameters.visibleFields[i]; i++) {
				this.visibleFieldNames.push(visibleField.fieldName);
			}
			parameters.visibleFieldNames = this.visibleFieldNames;
		}
		else {
	        this.visibleFieldNames = parameters.visibleFieldNames;
		}

		this.selectFieldNames = parameters.selectFieldNames;
        this.selectValueType = parameters.selectValueType;
        this.actionListener = parameters.actionListener;
		this.showNullFilters = parameters.showNullFilters;

        if (valueExists(parameters.addNewDialog)) {
        	this.addNewDialog = parameters.addNewDialog;
        }

        // set Select Value view title
        var defaultTitle = this.getLocalizedString(Ab.grid.SelectValue.z_TITLE_DEFAULT_TITLE);//'Select Value';
        var title = defaultTitle + ' - ' + parameters.title;
        dialog.setTitle(title);

        // convert filter values from target form field names to visible field names
        var convertedFilterValues = {};
        if (parameters.applyFilter && valueExists(parameters.filterValues)) {
            for (var i = 0; i < parameters.selectFieldNames.length && i < parameters.fieldNames.length; i++) {
                var fieldName = parameters.fieldNames[i];
                var selectedFieldName = parameters.selectFieldNames[i];
    
                var filterValue = parameters.filterValues[fieldName];
                // KB 3027339: use the exact value (not a LIKE clause) for parent fields
				// KB 3031943 check all fieldNames 'cause they aren't necesarily in order
                if (i <= parameters.fieldNames.length - 1 && valueExistsNotEmpty(filterValue)) {
                	filterValue = '\"' + filterValue + '\"';
                }
				// KB 3031797 multi-value parent field must become OR-ed multi-value WHERE clause on server ('"A#B"' -> '{"A","B"}')
				if (valueExistsNotEmpty(filterValue) && filterValue.indexOf(Ab.form.Form.MULTIPLE_VALUES_SEPARATOR) > 0)
				{
					// NB:  if Ab.form.Form.MULTIPLE_VALUES_SEPARATOR changes, must change the following regex-es
					if (filterValue.indexOf('\"') >= 0) {
						filterValue = filterValue.replace(/\^/gi, '\",\"');
						filterValue = '{' + filterValue + '}';
					}
					else {
						filterValue = filterValue.replace(/\^/gi, ',');
						filterValue = '{' + filterValue + '}';
					}
				}

                convertedFilterValues[selectedFieldName] = filterValue;
            }
        }
        
        // merge visible fields and select fields - get all fields from the server
        var allFieldNames = parameters.visibleFieldNames.concat(parameters.selectFieldNames);
        parameters.restriction = this.evaluateRestrictionBindings(parameters.restriction); 
           
        var configObject = new Ab.view.ConfigObject();
        configObject.setConfigParameter('buttonsPosition', 'footer');
        configObject.setConfigParameter('viewDef', new Ab.view.ViewDef(null, 0, parameters.selectTableName, toJSON(allFieldNames)));
        configObject.setConfigParameter('sortColumnID', parameters.visibleFieldNames[0]);
        configObject.setConfigParameter('indexColumnID', parameters.showIndex ? parameters.visibleFieldNames[0] : '');
        configObject.setConfigParameter('restriction', parameters.restriction);
        configObject.setConfigParameter('refreshWorkflowRuleId', parameters.workflowRuleId);
        configObject.setConfigParameter('groupIndex', 0);
        configObject.setConfigParameter('cssClassName', null);
        configObject.setConfigParameter('showOnLoad', true);
        configObject.setConfigParameter('selectionEnabled', true);
        configObject.setConfigParameter('useParentRestriction', false);
        configObject.setConfigParameter('recordLimit', parameters.recordLimit);
        configObject.setConfigParameter('applyVpaRestrictions', parameters.applyVpaRestrictions);
			
        if (valueExists(parameters.sortValues)){
       	 	configObject.setConfigParameter('sortValues', parameters.sortValues);
        }
		// KB 3029973
        else if (valueExists(parameters.sortFields)){
       	 	configObject.setConfigParameter('sortFields', parameters.sortFields);
        }
        
        if (this.selectValueType === 'multiple') {
            configObject.setConfigParameter('multipleSelectionEnabled', true);
            configObject.setConfigParameter('filterValues', convertedFilterValues);
        } else {
            configObject.setConfigParameter('multipleSelectionEnabled', false);
            configObject.setConfigParameter('filterValues', convertedFilterValues);
        }
        
        // construct the grid
        this.selectValueListener = this.afterSelectValue.createDelegate(this);
        this.isDistinct = true;

        this.inherit(dialog.body.id, configObject);
        this.isCollapsed = false;

        //XXX: 3025656
        if (valueExists(parameters.sortValues)) {
        	var sortColumns = [];
        	var tempSortValues = Ext.util.JSON.decode(parameters.sortValues);
        	//XXX: there is no way to set up ascending in select value command
        	for (var i=0; i<tempSortValues.length; i++) {
        		sortColumns.push({'fieldName':tempSortValues[i].fieldName,'ascending':true});
        	}
        	//XXX: defined in ab-reportgrid.js
        	this.sortColumns = sortColumns;
        	this.sortColumnOrder = true;        	
        }
		// KB 3029973
		else if (valueExists(parameters.sortFields)) {
			var sortColumns = [];
        	for (var i=0; i < parameters.sortFields.length; i++) {
        		sortColumns.push({'fieldName':parameters.sortFields[i].fieldName, 'ascending':parameters.sortFields[i].sortAscending});
        	}
        	this.sortColumns = sortColumns;
        	this.sortColumnOrder = true;        	
		}

        if (this.addNewDialog != null) {
            this.addAction({
            	id:'addNew', 
            	text:this.getLocalizedString(Ab.grid.SelectValue.z_TITLE_ADD_NEW),
            	tooltip: this.getLocalizedString(Ab.grid.SelectValue.z_TOOLTIP_ADD_NEW),
				enabled: 'true',
            	listener: this.onAddNew.createDelegate(this)});          	
    	}
       
        if ((this.selectValueType === 'multiple')) {
            this.addAction({
            	id:'saveSelected', 
            	text:this.getLocalizedString(Ab.grid.SelectValue.z_TITLE_SAVE_SELECTED),
            	tooltip: this.getLocalizedString(Ab.grid.SelectValue.z_TOOLTIP_SAVE_SELECTED),
				enabled: '${this.getSelectedGridRows().length > 0}',
            	listener: this.onSaveSelected.createDelegate(this)});
            this.addAction({
            	id:'clear', 
            	text:this.getLocalizedString(Ab.grid.SelectValue.z_TITLE_CLEAR), 
            	tooltip: this.getLocalizedString(Ab.grid.SelectValue.z_TOOLTIP_CLEAR),
				enabled: '${this.getSelectedGridRows().length > 0}',
            	listener: this.onClear.createDelegate(this)});
            this.addEventListener('onMultipleSelectionChange', 
            		this.onMultipleSelectionChange.createDelegate(this));
        }

        this.displaySelectValueRecords(convertedFilterValues);
        
		// allow saveSelected and clear actions to be enabled & disabled by OnSelectionChanged
		this.actions.each(function(action) {
            action.forceDisable(false);
        });

		this.displayInitialSelection();		
		// initial opening of selectValue should not show filter and index is showIndex == false (the default)
		this.showIndexAndFilter();
		
        this.setDivBodyHeight( this.determineDivBodyHeight());
        this.resizeColumnWidths();

        if (this.useScroller()) {
            this.updateScroller();
        }

        var grid = this;
        this.window.on('resize', function(window, width, height) {
            grid.updateHeight();
        });
    },

    
    useScroller: function() {
        return true;
    },

    
    calculateDivBodyHeight: function() {
        var divBodyHeight = this.inherit();

        if (!this.hasNoRecords && !View.preferences.useScroller) {
            divBodyHeight -= this.scrollbarFactor;
        }

        return divBodyHeight;
    },

    
    evaluateRestrictionBindings:function (strRestriction) {
        if (valueExistsNotEmpty(strRestriction) && typeof(strRestriction) == 'string' && strRestriction.indexOf('{') != -1) {
            var ctx = this.createEvaluationContext();
            if (!valueExistsNotEmpty(ctx['record']) && this.form) {
                ctx['record'] = this.form.getRecord().values;
            }
            // escape sql expressions, they will be parsed on server side.
            var _bindReplacement = "~1R~";
            var bindingCursor = '';
            var _sqlSubstr = '{sql';
            if (strRestriction.indexOf(_sqlSubstr) != -1) {
                bindingCursor = strRestriction.substring(strRestriction.indexOf(_sqlSubstr) - 1, strRestriction.indexOf(_sqlSubstr));
                strRestriction = strRestriction.split(bindingCursor + _sqlSubstr).join(_bindReplacement);
            }

            strRestriction = Ab.view.View.evaluateString(strRestriction, ctx);

            if (strRestriction.indexOf(_bindReplacement) != -1) {
                strRestriction = strRestriction.split(_bindReplacement).join(bindingCursor + _sqlSubstr);
            }
        }
        return strRestriction;
    },
    
    
    displaySelectValueRecords: function(convertedFilterValues) {
        // get data records
        this.initialDataFetch();
        
		// we need to requery only if there is a single result row AND
		// all filter values exactly match the row values
		// i.e. the filter values specify one and only one existing record
        var requery = false;
        if (this.rows.length == 1 || 
			(this.showNullFilters == true && this.rows.length <= 3)) {
			requery = true;
			if (this.selectValueType != 'multiple') {
				for (var name in convertedFilterValues) {
					var filterValue = convertedFilterValues[name];
					var recordValue = this.rows[0][name];
					if (filterValue !== recordValue &&
						(this.showNullFilters == false || (filterValue !== 'NULL' && filterValue !== 'NOT NULL'))) {
						requery = false;
						break;
					}
				}
			}
			// KB 3032410 if (this.selectValueType == 'multiple') 
			// requery only if there is a single result row AND all of the selectField values are selected
			else {
				for (var i=0, selectFieldName; selectFieldName = this.selectFieldNames[i]; i++) {
					var filterValue = convertedFilterValues[selectFieldName];
					if (filterValue == null) {
						requery = false;
						break;
					}
				}
			}
		}
			
        // filter values specify one and only one existing record - remove the filter and re-query
		if (requery) {
			if (this.primaryKeyIds.length > 0) {
				// we are selecting a PK value - remove the last PK field from the filter
				var lastPrimaryKeyId = this.primaryKeyIds[this.primaryKeyIds.length - 1];
				this.setFilterValue(lastPrimaryKeyId, '');
			} else {
				// we are selecting a non-PK value - remove all filter values
				this.clearAllFilterValues();
			}
			this.refresh();
		}
        
        // collapse the mini-console if there are less than 30 records
        this.showIndexAndFilter();

        this.updateHeight();
    },
    
    
    onInitialDataFetch: function(result) {
    	var columns = result.data.columns;
    	var visibleColumns = [];
    	for (var c = 0; c < columns.length; c++) {
    		var column = columns[c];
    		var isVisible = false;
    		
    		for (var f = 0; f < this.visibleFieldNames.length; f++) {
    			if (column.id == trim(this.visibleFieldNames[f])) {
    				isVisible = true;
    				break;
    			}
    		}
    		
    		if (isVisible) {
    			visibleColumns.push(column);

				// KB 3031386 Allow configuration of visible field titles. 
				for (var v = 0, visFld; valueExists(this.visibleFields) && (visFld = this.visibleFields[v]); v++) {				
					if (column.id == trim(visFld.fieldName) && valueExists(visFld.title)) {
						column.name = visFld.title;
						break;
					}
				}
    		}
    	}
    	result.data.columns = visibleColumns;

    	this.inherit(result);
    },

	
	addNullFilterRows: function() {
		var nullFilterRow = {};
		nullFilterRow[this.visibleFieldNames[0]] ='NULL';
		nullFilterRow[this.visibleFieldNames[0].key] ='NULL';

		var notNullFilterRow = {};
		notNullFilterRow[this.visibleFieldNames[0]] ='NOT NULL';
		notNullFilterRow[this.visibleFieldNames[0].key] ='NOT NULL';
			
		var rowIndex = 0;
		this.rows.splice(rowIndex++, 0, nullFilterRow);
		this.rows.splice(rowIndex++, 0, notNullFilterRow);
		for (var i = rowIndex; i < this.rows.length; i++) {
			this.rows[i].index = this.rows[i].index + 1;
		}
		
		this.updateHeader();
		this.reloadGrid();
	},
	
	
	beforeBuild: function() {
	    this.inherit();

		if (this.selectValueListener != null) {
    		for (var c = 0; c < this.columns.length; c++) {
    			var column = this.columns[c];
    			if (column.type == 'text' || column.type == 'number') {
        			column.type = 'link';
        			column.defaultActionHandler = this.selectValueListener;
    			}
    		}	    
		}				
	},
	
	
	displayInitialSelection: function() {
        if (this.form) {
        	// use the last field in the fieldNames list to set the initial selection
        	var fieldName = trim(this.fieldNames[this.fieldNames.length - 1]);
        	var selectFieldName = trim(this.selectFieldNames[this.fieldNames.length - 1]);
        	
        	var parentFieldValues = [];
        	for (var i = 0; i < this.fieldNames.length - 1; i++) {
        		parentFieldValues.push(this.form.getFieldValue(this.fieldNames[i]));
        	}
        	
        	if (this.form.hasFieldMultipleValues(fieldName)) {
        		var childFieldValues = this.form.getFieldMultipleValues(fieldName);
        		this.selectMatchingRows(parentFieldValues, childFieldValues);
        	}
			else if (this.selectValueType === 'multiple' && this.form.getFieldValue(fieldName)) {
				var childFieldValues = [];
				childFieldValues.push(this.form.getFieldValue(fieldName));
        		this.selectMatchingRows(parentFieldValues, childFieldValues);
			}
		}
		
        // enable/disable the action buttons
		this.onMultipleSelectionChange();
	},
	
	
	selectMatchingRows: function(parentFieldValues, childFieldValues) {
		var parentFieldNames = this.fieldNames.slice(0, -1);
		var childFieldName = this.fieldNames[this.fieldNames.length - 1];

		var selectParentFieldNames = this.selectFieldNames.slice(0, -1);
		var selectChildFieldName = this.selectFieldNames[this.fieldNames.length - 1];
		
		this.gridRows.each(function (row) {
			// check if the row matches all parent field values
			var parentValuesMatch = true;
			for (var i = 0; i < parentFieldNames.length; i++) {
				if (parentFieldValues[i] !== row.getFieldValue(selectParentFieldNames[i])) {
					parentValuesMatch = false;
				}
			}

			// check if the row matches any of the child field values
			var childValueMatches = false;
			for (var i = 0; i < childFieldValues.length; i++) {
				if (childFieldValues[i] === row.getFieldValue(selectChildFieldName)) {
					childValueMatches = true;
					break;
				}
			}
			
			if (parentValuesMatch && childValueMatches) {
				row.select();
			}
		});
	},
		
	
	onMultipleSelectionChange: function() {
		var selectedRows = this.getSelectedGridRows();
		this.enableAction('saveSelected', selectedRows.length > 0);
		this.enableAction('clear', selectedRows.length > 0);
	},
	
	
	onAddNew: function() {
		var parameters = Ab.view.View.selectValueParameters;
		var title = parameters.title;					
       	View.openDialog(this.addNewDialog, null, false, {
            x: 100,
            y: 100,
            width: 550,
            height: 400,
            title: this.getLocalizedString(Ab.grid.SelectValue.z_TITLE_ADD_NEW) + ' ' + title,
            useAddNewSelectVDialog: true,
            closeButton: false
        });
	},
			
	
	onSaveSelected: function() {
		var rows = this.getSelectedRows();
		this.saveSelected(rows);
	},
	
	
	onClear: function() {
		var rows = [];
		this.saveSelected(rows);
	},
	
	
	afterSelectValue: function(row) {
		var rows = [];
		rows.push(row);
		this.saveSelected(rows);
	},
		
	
	afterRefresh: function() {
        this.inherit();

		if (this.selectValueType === 'multiple') {
			this.displayInitialSelection();
		}
		if (this.showNullFilters) {
			this.addNullFilterRows();
		}
	},


	
	onClickIndex: function(index) {
		// save collection of currently checked rows
		var selectedRows = this.getSelectedRows();		
		this.inherit(index);

		this.restorePreviousSelections(selectedRows);
	},

	
	onFilter: function(e) {
		// save collection of currently checked rows
		var selectedRows = this.getSelectedRows();		
		this.inherit(e);

		this.restorePreviousSelections(selectedRows);
	},

			
	restorePreviousSelections: function(selectedRows) {
		if (this.selectValueType != 'multiple' || selectedRows.length == 0) {
			return;
		}

		// restore any existing selected 
		for (var r = 0, row; row = this.rows[r]; r++) {
        	for (var rr = 0, selectedRow; selectedRow = selectedRows[rr]; rr++) {
				// Need good test for equivalency here. 
				var rowsAreEquivalent = true;
				for (var v = 0, visField; visField = this.visibleFieldNames[v]; v++) {
					if (!valueExists(row[visField]) || !valueExists(selectedRow[visField]) || row[visField] != selectedRow[visField]) {
						rowsAreEquivalent = false;
						break;
					}
				}
				if (rowsAreEquivalent) {
					this.selectRowChecked(r)
					break;
				}
			}
		}
	},


	
	saveSelected: function(rows) {
	    // for all selected values
	    for (var i = 0; i < this.selectFieldNames.length && i < this.fieldNames.length; i++) {
	    	
	        var fieldName = trim(this.fieldNames[i]);
	        var selectFieldName = trim(this.selectFieldNames[i]);
	        
	        // guard for duplicate values
	        var setOfSelectedValues = {};
	        
	        // get selected value for this field
	        var selectedValue = '';
	        var selectedValueRaw = '';
	        var selectedValueRows = new Array();
	        var maxValueLengthReached = false;

	        // there may be multiple selected values in the grid
        	for (var r = 0; r < rows.length; r++) {
        		var value = (valueExists(rows[r][selectFieldName + ".key"])) ? rows[r][selectFieldName + ".key"] : rows[r][selectFieldName];
        		var rawValue = (valueExists(rows[r][selectFieldName + ".raw"])) ? rows[r][selectFieldName + ".raw"] : '';        		
        		var row = rows[r];

    	    	// if multiple values are selected, save all selected values for the last field,
        		// but only the first selected value for parent fields
        		// save the parent field value only if it is the same across all selected rows
    	    	if (this.selectValueType == 'multiple' && i != this.selectFieldNames.length - 1 && r > 0) {
    	    		if(row[selectFieldName] != rows[r-1][selectFieldName]){
    	    			View.alert(this.getLocalizedString(Ab.grid.SelectValue.z_MESSAGE_DIFFERENT_PARENT_VALUES));
    	    			//alert(row[selectFieldName] + ' ' +  rows[r-1][selectFieldName]);
    	    			return;
    	    		} else {
    	    			continue;
    	    		}
    	    	}
    	    	
    	    	
        		// make sure the final value is not too long for Sybase SQl Anywhere
        		if (selectedValueRaw.length + value.length > Ab.grid.SelectValue.MAX_VALUE_LENGTH) {
        			maxValueLengthReached = true;
        			break;
        		}
        		
        		// prevent saving duplicate values
        		if (!valueExists(setOfSelectedValues[value])) {
        			setOfSelectedValues[value] = value;
        			
	        		// add values to the list
	        		selectedValue += value;
	    	        selectedValueRaw += rawValue;
	
	    	        // add multiple value separator
	    	        selectedValue += Ab.form.Form.MULTIPLE_VALUES_SEPARATOR;
	    			selectedValueRaw += Ab.form.Form.MULTIPLE_VALUES_SEPARATOR;
	    			selectedValueRows.push(row);
        		}
        	}

        	// discard the trailing multiple value separator
        	if (selectedValue.lastIndexOf(Ab.form.Form.MULTIPLE_VALUES_SEPARATOR) == selectedValue.length - 1) {
        		selectedValue = selectedValue.slice(0, selectedValue.length - 1);
        	}

        	if (selectedValueRaw.lastIndexOf(Ab.form.Form.MULTIPLE_VALUES_SEPARATOR) == selectedValueRaw.length - 1) {
        		selectedValueRaw = selectedValueRaw.slice(0, selectedValueRaw.length - 1);
        	}
        	        	
        	// save the selected value to the form field
        	var saveSelectedValue = this.saveSelectedValue.createDelegate(this, [fieldName, selectedValue, selectedValueRaw, selectedValueRows]);
        	if (maxValueLengthReached) {
    			var message = 
    				this.getLocalizedString(Ab.grid.SelectValue.z_MESSAGE_MAX_VALUE_LENGTH_1) 
    				+ ' ' 
    				+ r 
    				+ ' ' 
    				+ this.getLocalizedString(Ab.grid.SelectValue.z_MESSAGE_MAX_VALUE_LENGTH_2); 
    			View.alert(message, function() {
    				saveSelectedValue();
    			});
        	} else {
        		saveSelectedValue();
        	}
	    }

	    View.closeDialog();
	},
	
	
	determineHeight: function(el) {
		var height = 0;
		var id = this.getParentElementId();
		
		if (!valueExists(el)) {
			el = this.parentEl;
		}
		
		// get parent region panel height
		var parentRegionHeight = Ext.get(el).parent().getHeight();
		
		// adjust for title bar height
		var titleBarHeight = this.getTitlebarHeight();
		height = parentRegionHeight - titleBarHeight - 2;
		
		return height;
	},
	
	
	saveSelectedValue: function(fieldName, selectedValue, selectedValueRaw, selectedValueRows) {
        // save selected value into opener form field (if it exists)
    	var input = null;
    	var previousValue = null;
        if (this.form) {
	        input = this.form.getFieldElement(fieldName);
	        if (input) {
	            previousValue = input.value;
	        }
        }
		
        var canSave = true;
        // optionally call custom action listener
        var fn = this.actionListener;
        if (fn != null && fn != '' && typeof(fn) != 'undefined') {
            if (!fn.call) {
                fn = window[fn];
            }
            if (fn.call) {
                var result = fn.call(window, fieldName, selectedValue, previousValue, selectedValueRaw, selectedValueRows);
                if (typeof(result) == 'boolean') {
                    canSave = result;
                }
            }
        }

        // save selected value into opener form field (if the custom action listener does not prevent it)
        if (canSave && input && valueExists(selectedValue)) {
        	this.form.setFieldValue(fieldName, selectedValue, null, false)
         
            // set the value tooltip
            this.form.setFieldTooltip(fieldName, selectedValue);

            afm_form_values_changed = true;
        }
	}
},
{
	// Sybase SQL Anywhere does not support more than 126 characters in the LIKE pattern.
	// Reserve 2 characters for leading and trailing %.
	MAX_VALUE_LENGTH: 124,
	
	// @begin_translatable
	z_TITLE_DEFAULT_TITLE: 'Select Value',
	z_TITLE_SAVE_SELECTED: 'Save Selected',
	z_TITLE_CLEAR: 'Clear',
    z_TOOLTIP_SAVE_SELECTED: 'Save selected values into the field',
    z_TOOLTIP_CLEAR: 'Clear all values from the field',
    z_MESSAGE_MAX_VALUE_LENGTH_1: 'You have selected too many values. Only the first',
    z_MESSAGE_MAX_VALUE_LENGTH_2: 'values will be used. <br/>To include all records in the search do not select any values for this field.',
	z_MESSAGE_DATE_FORMAT_ERROR: 'Date format error',
	z_MESSAGE_DATE_FORMAT_ERROR_DETAILS: 'Selected date is not in expected format:',
	z_MESSAGE_DIFFERENT_PARENT_VALUES: 'Can not save.  Parent values must be the same for all selected records.',
	z_TITLE_ADD_NEW: 'Add New',
    z_TOOLTIP_ADD_NEW: 'Add new select values'	
	// @end_translatable

});






Ab.tree.SelectValueTree = Ab.tree.TreeControl.extend({

    // custom event handler called when the user selects the row
    selectValueListener: null,

    // the main table name of the tree control
    selectTableName: null,

    // the visible fields of the tree control
    visibleFieldNames: null,

    filterValues: null,

	_getParameters: function(panelData, parent, level) {
		
        var  parameters = {
                          tableName:  this.selectTableName,
                          fieldNames: toJSON(this.visibleFieldNames),
                          treeType:  this.type,
                          treeLevel: level
                          };
    
        if(this.filterValues != null) {
          var filterFieldValues = new Array();
          for(var fieldName in this.filterValues){
        	var filterValue = this.filterValues[fieldName];
        	if(valueExists(filterValue)){
        		//XXX:get the first value from hierarchical value.
        		var hierarchy_delim = Ab.view.View.preferences.hierarchy_delim;
        		if(!valueExistsNotEmpty(hierarchy_delim)){
        			//default
        			hierarchy_delim = "|";
        		}
        		filterValue = filterValue.split(hierarchy_delim)[0];
        	}
        	
            filterFieldValues.push({"fieldName": fieldName, "filterValue": filterValue})
          }
          parameters.filterValues = toJSON(filterFieldValues);
        }

        var restriction = new Ab.view.Restriction();

        // add the tree restriction to parameter list if not null.
        if(this.restriction && this.restriction.clauses != undefined && this.restriction.clauses.length > 0) {
         if(this.type=='selectValueTree'){
            for(var index=0; index < this.visibleFieldNames.length; index++){
                var clause = this.restriction.findClause(this.visibleFieldNames[index]);
                if(clause){
                  restriction.clauses.push(clause);
                }
            }
         } else {
          restriction.addClauses(this.restriction, true);
         }
        }

        // add the tree level's restriction to parameter list if not null.
        if(this.type!='selectValueTree') {
          var levelRest = this.getRestrictionForLevel(level);
          if(levelRest && levelRest.clauses != undefined && levelRest.clauses.length>0){
            restriction.addClauses(levelRest, true);
          }
        }

        // add the parent node's restriction to parameter list. it should always contain something
        if(!parent.isRoot()) {
          restriction.addClauses(parent.restriction, true);
		}

        if(restriction.clauses != undefined && restriction.clauses.length > 0){
          parameters.restriction = toJSON(restriction);
        } else if(this.restriction && (this.restriction.clauses == undefined || this.restriction.clauses.length <= 0)) {
        	//could be SQL statement
        	// test if the restriction is an empty {}.
        	if(toJSON(this.restriction)!="{}"){
        		parameters.restriction = this.restriction;
        	}
        }
        
        //KB# 3035596 - Select Value dialogs of type=tree and type=hierTree ignore recordLimit attribute and ignore recordLimit option in View.selectValue. 
        if (this.recordLimit != -1){
        	parameters.recordLimit = this.recordLimit;
        }

        return parameters;
    },

    
     _initTree: function(panelData, parent, level, panelDataNextLevel) {

		// if panelData not define, return
		if(typeof(panelData) == 'undefined'){
			return;
		}

        // call WFR to get the data
        var result = null;

        try{
        	result = Workflow.call('AbCommonResources-getDataRecords', this._getParameters(panelData, parent, level), 120);
        } catch (e){
			this.handleError(e);
		}

        if (result.code == 'executed') {
			// call afterGetData for post-processing (e.g., localization of data from messages)
			var listener = this.getEventListener('afterGetData');
			if (listener) {
				listener(this, result.data, level);
			}

		    // set the max level only once for selectValueTree
            if(level == 0 && this.type=='selectValueTree'){
                this.maxLevel =   result.data.primaryKeyIds.length-1;
            }

			if(panelData!=null && panelData.panelId != null){
	        	var elem = document.getElementById(panelData.panelId + "_msg_no_record");
				if(elem != null){
					elem.parentNode.removeChild(elem); 
				}
			}

            if( result.data.records.length > 0 ) {
				// if the WFR succeeded, create a treeLevel object
	            var treeLevel = new Ab.tree.TreeLevel(level, result.data, panelData);
	            this._addTreeLevel(treeLevel);
	
	            // create a TreeNode for each record returned from server
	            this._addTreeNodes(result, parent, treeLevel, panelDataNextLevel);
	
	            // if the child nodes are added fine, then for hierarchy tree, set the maxLevel to the current deepest level.
	            if(this.type=='selectValueHierTree' && this.maxLevel < level){
	                this.maxLevel = level;
	            }
			} else {
				if(level == 0 && panelData!=null && panelData.panelId != null){
		        	var elem = document.getElementById(panelData.panelId);
					if(elem != null){
					 	divNode = document.createElement("div");
						divNode.id = panelData.panelId + "_msg_no_record";
						divNode.className = "instruction";
						divNode.innerHTML = "<br>" + this.getLocalizedString(this.z_EMPTY_TREE_MESSAGE);
						elem.parentNode.appendChild(divNode);
					}
				}
			}
        } else {
          // handle the exceptions
          this.handleError(result);
      }
    },

    
    _registerEvents: function(node) {
        if(this.selectValueListener!=''
          && ((this.type=='selectValueTree' && node.isLeafNode) || this.type=='selectValueHierTree')) {
             YAHOO.util.Event.addListener(node.getLabelEl(), "click", this.selectValueListener, node);
        }
    },

    
    _loadNodeData: function(node, onCompleteCallback) {

      // set the children's level index number
      var nextLevel = node.level.levelIndex + 1;

      // the level of tree nodes to be added can not exceed the maximum tree level number
      // otherwise, it is a leaf node.
      if(node.treeControl.type=='selectValueTree' && nextLevel > node.treeControl.maxLevel) {
        node.isLeafNode = true;
      }

      // for non-leaf nodes, call WFR to populate the data
      if(!node.isLeafNode) {
        // initialize the node's children
        node.treeControl._initTree(null, node, nextLevel );
      }

      // Be sure to notify the TreeView component when the data load is complete
      onCompleteCallback();

      // after all children are generated, register the events for each child node
      for(var nodeCounter = 0; nodeCounter < node.children.length; nodeCounter++) {
          node.treeControl._registerEvents(node.children[nodeCounter]);
      }
    },


    // ----------------------- public methods ----------------------------------

    
    constructor: function(dialog) {
        var parameters = Ab.view.View.selectValueParameters;
    
        // set dialog title
        // TODO: localize
        var defaultTitle = this.getLocalizedString(Ab.tree.SelectValueTree.z_TITLE_SELECT_VALUE);
        dialog.setTitle(defaultTitle + ' - ' + parameters.title);

        var configObject = new Ab.view.ConfigObject();
    
        //set default paramters
        this.inherit(dialog.body.id, configObject);
    
        // overwrite default parameters with tree specific values.
        this.type = (parameters.selectValueType === 'tree') ? 'selectValueTree' : 'selectValueHierTree';
        this.visibleFieldNames = parameters.visibleFieldNames;
        this.selectTableName = parameters.selectTableName;
        this.selectValueListener = afterSelectValueTree;
        this.isDistinct = true;
        this.isCollapsed = false;

        if(parameters.restriction){
        	this.restriction = new Ab.view.Restriction();
        	try{
        		this.restriction.addClauses( eval('(' + parameters.restriction + ')'), true);
        	} catch (e){
        		this.restriction = parameters.restriction;
        	}
        }
        
        // convert filter values from target form field names to visible field names
        if (valueExists(parameters.applyFilter) && parameters.applyFilter==='true') {
        	var convertedFilterValues = {};
        	 
            for (var i = 0; i < parameters.selectFieldNames.length && i < parameters.fieldNames.length; i++) {
                var fieldName = parameters.fieldNames[i];
                var selectedFieldName = parameters.selectFieldNames[i];
    
                var filterValue = parameters.filterValues[fieldName];
				if (valueExists(filterValue)) {
					convertedFilterValues[selectedFieldName] = filterValue;
				}
            }
            this.filterValues = convertedFilterValues;
        }
      
        // KB# 3035596 - Select Value dialogs of type=tree and type=hierTree ignore recordLimit attribute and ignore recordLimit option in View.selectValue. 
        if (valueExists(parameters.recordLimit) ) {
        	this.recordLimit = parameters.recordLimit;
        } 

		this.addEventListenerFromConfig('afterGetData', configObject);
		if (!this.getEventListener('afterGetData')) {
			this.addEventListener('afterGetData', this.afterGetData);
		}
        
		this.initialDataFetch();
    }
},
{
	// @begin_translatable
	z_TITLE_SELECT_VALUE: 'Select Value'
	// @end_translatable

});



function afterSelectValueTree(e, node) {
    var parameters = Ab.view.View.selectValueParameters;

    var form = Ab.view.View.getControl('', parameters.formId); 
    var openerWindow = Ab.view.View.getOpenerWindow();
    
    // for all selected values
    for (var i = 0; i < parameters.selectFieldNames.length && i < parameters.fieldNames.length; i++) {
        var fieldName = parameters.fieldNames[i];
        var selectedFieldName = parameters.selectFieldNames[i];

        // get selected value
        var selectedValue = node.getPrimaryKeyValue(selectedFieldName);

        // look back the current node's parent to find the pk values
        var thisNode = node;
        while (selectedValue == undefined && thisNode.parent != null) {
            thisNode = thisNode.parent;
            if (!thisNode.isRoot()) {
                selectedValue = thisNode.getPrimaryKeyValue(selectedFieldName);
            }
        }

        // save selected value into opener form field (if it exists)
        var previousValue = null;
        if (form != null) {
            var input = form.getFieldElement(fieldName);
            if (input != null) {
            	previousValue = input.value;
            }
        }

        var canSave = true;
        // optionally call custom action listener
        var fn = parameters.actionListener;
        var win = window;
        if (fn != null && fn != '' && typeof(fn) != 'undefined') {  
            if (!fn.call) {
                fn = win[fn];
            }
            if (!valueExists(fn) || !fn.call) {
            	win = openerWindow;
                fn = win[fn];
            }
            if (fn.call) {   
                var result = fn.call(win, fieldName, selectedValue, previousValue);
                if (typeof(result) == 'boolean') {
                    canSave = result;
                }
            }
        }

        // save selected value into opener form field (if the custom action listener does not prevent it)
        if (canSave && input != null && valueExists(selectedValue)) {
            input.value = selectedValue;
            openerWindow.afm_form_values_changed = true;
        }
    }

    Ab.view.View.closeDialog();
}



Ab.view.DataViewLevel = Base.extend({

    // id of the DataSource
    dataSourceId: '',
    
    // HTML template DOM element ids
    bodyTemplate: 'bodyTemplate',
    
    // Ext.XTemplate objects that generates the content
    bodyXTemplate: null,
    
    // optional callbacks that prepares the data for template evaluation
    getData: null,
    
    getNextLevelRestriction: null,
    
    // reference to the next (child) level
    nextLevel: null,
    
    // parent Ab.view.DataView control
    dataView: null,
    
    
    constructor: function(config) {
        Ext.apply(this, config);
        
        this.bodyXTemplate = Ab.view.DataView.getTemplate(this.bodyTemplate);
    },
    
    
    getDataSource: function() {
        return View.dataSources.get(this.dataSourceId);
    },

    
    refresh: function(restriction) {
        var ds = this.getDataSource();
        if (ds) {
            var records = ds.getRecords(restriction);
            this.setRecords(records);
        }
    },

    
    setRecords: function(records) {
        for (var i = 0; i < records.length; i++) {
            // render this level record
            this.dataView.renderRecord(
                records[i], this.getDataSource(), this.getData, this.bodyXTemplate);
        
            if (this.nextLevel) {
                // render next level records restricted by this record
                var restrictionForNextLevel = null;
                if (valueExists(this.getNextLevelRestriction)) {
                    restrictionForNextLevel = this.getNextLevelRestriction(records[i]);
                } else {
                    restrictionForNextLevel = records[i].toRestriction();
                }
                this.nextLevel.refresh(restrictionForNextLevel);
            }
        }
    }
});


Ab.view.DataView = Base.extend({
    
    // Ext.Panel that displays the control
    panel: null,
    
    // Ext.Panel that displays the content
    body: null,
    
    // id of the parent HTML panel
    id: '',
    
    // id of the DataSource
    dataSourceId: '',
    
    // array of Ab.view.DataViewLevel objects
    levels: null,
    
	// buffer where we build the HTML content
	buffer: null,
    
    // parent AXVW panel
    parentPanel: null,
    
    // expression evaluation context
    evaluationContext: null,
    
    // HTML template DOM element ids
    headerTemplate: 'headerTemplate',
    footerTemplate: 'footerTemplate',
    
    // Ext.XTemplate objects that generates the content
    headerXTemplate: null,
    footerXTemplate: null,
    
    // optional callbacks that prepares the data for template evaluation
    getHeaderData: null,
    getFooterData: null,
    
    
    constructor: function(id, config) {
        this.id = id;
        Ext.apply(this, config);
        
        this.levels = [];
        if (valueExists(config.levels) && config.levels.length > 0) {
            // create levels
            for (var i = 0; i < config.levels.length; i++) {
                var level = new Ab.view.DataViewLevel(config.levels[i]);
                level.dataView = this;
                this.levels.push(level);
            }
            // set nextLevel references for all but the last level
            for (var i = 0; i < this.levels.length - 1; i++) {
                var level = this.levels[i];
                var nextLevel = this.levels[i + 1];
                level.nextLevel = nextLevel;
            }
        } else {
            // if levels are not specified in config, create default single level
            var level = new Ab.view.DataViewLevel(config);
            level.dataView = this;
            this.levels.push(level);
        }

        if (valueExistsNotEmpty(this.headerTemplate)) {
            this.headerXTemplate = Ab.view.DataView.getTemplate(this.headerTemplate);
        }

        if (valueExistsNotEmpty(this.footerTemplate)) {
            this.footerXTemplate = Ab.view.DataView.getTemplate(this.footerTemplate);
        }
       
        this.body = new Ext.Panel({
            border: false
        });
        this.panel = new Ext.Panel({
            border: false,
            renderTo: this.id,
            autoHeight: true,
            autoWidth: true,
            autoScroll: true,
            items: [this.body]
        });

        this.parentPanel = View.panels.get(this.id);
        if (this.parentPanel && this.parentPanel.setContentPanel) {
            this.parentPanel.setContentPanel(this.panel);
        }
    },
    
    
    getContentBuffer: function() {
        return this.buffer;
    },
    
    
    refresh: function(restriction) {
        this.renderBegin();
        this.levels[0].refresh(restriction);
        this.renderEnd();
    },
    
    
    setRecords: function(records) {
        this.renderBegin();
        this.levels[0].setRecords(records);
        this.renderEnd();
    },
    
    // ----------------------- implementation -----------------------------------------------------
    
    
    renderBegin: function() {
        this.evaluationContext = {};
        if (this.parentPanel) {
            this.evaluationContext = this.parentPanel.createEvaluationContext();
        }
        
        this.buffer = '<table cellspacing="0" class="dataView">';
		
        if (this.headerTemplate) {

            // if custom callback is provided, call it
            var data = {};            
            if (this.getHeaderData) {
                data = this.getHeaderData();
            }
            
            // evaluate Ext.XTemplate {} expressions 
            var html = this.headerXTemplate.apply(data);
			
            // evaluate WebCentral ${} expressions
            html = View.evaluateString(html, this.evaluationContext);
        
            this.buffer = this.buffer + html;
		}
    },
    
    renderRecord: function(record, dataSource, getData, bodyXTemplate) {
        // add record values to the evaluation context
        var recordValues = record.values;
        if (dataSource) {
            // if DataSource is available, format record values
            recordValues = dataSource.formatValues(recordValues, true);
        }
        this.evaluationContext.record = recordValues;
        
        // if custom callback is provided, call it
        var data = record;
        if (getData) {
            data = getData(data);
        }
        
        // evaluate Ext.XTemplate {} expressions 
        var html = bodyXTemplate.apply(data);
        
        // evaluate WebCentral ${} expressions
        html = View.evaluateString(html, this.evaluationContext);
        
        this.buffer = this.buffer + html;
    },
    
    
    renderEnd: function() {
        if (this.footerTemplate) {

            // if custom callback is provided, call it
            var data = {};            
            if (this.getFooterData) {
                data = this.getFooterData();
            }
            
            // evaluate Ext.XTemplate {} expressions 
            var html = this.footerXTemplate.apply(data);
            
            // evaluate WebCentral ${} expressions
            html = View.evaluateString(html, this.evaluationContext);
        
            this.buffer = this.buffer + html;
        }

		this.buffer = this.buffer + '</table>';
		this.body.body.dom.innerHTML = '';
		Ext.DomHelper.append(this.body.body, this.buffer);
    },
    
    renderClear: function() {
        this.body.body.dom.innerHTML = '';
    }
}, {
    
     
    getTemplate: function(id) {
        var html = '';
        var templateEl = Ext.get(id);
        if (templateEl) {
            var templateTableEl = templateEl.child('table');
            if (templateTableEl) {
                html = templateTableEl.dom.innerHTML;
            }
            else {
                html = templateEl.dom.innerHTML;
            }
            templateEl.remove();
        }
        return new Ext.XTemplate(html);
    }
});



Ab.view.DataViewPanel = Ab.view.Component.extend({
    
    // Ab.view.DataView
    dataView: null,
    
    
    constructor: function(id, config) {
        this.inherit(id, 'dataView', config);
        
        this.showOnLoad = config.getConfigParameter('showOnLoad', false);

        this.dataView = new Ab.view.DataView(id, config);
    },
    
    
    initialDataFetch: function() {
        if (this.showOnLoad || this.restriction != null) {
            this.refresh();
            this.show(true);
        }
    },
    
    
    doRefresh: function() {
        this.dataView.refresh(this.restriction);
    },
    
    
    clear: function() {
        this.dataView.renderClear();
    }
});


Ab.view.CrossTable = Ab.view.Component.extend({
    
	// view definition to be displayed
	viewDef: null,
    
    // whether the panel should display its field values on load
    showOnLoad: false,
    
    // name of the default WFR used to get the record
    refreshWorkflowRuleId: '',
    
    // user function to call after refresh()
    afterRefreshListener: null,
    
	// array of Ab.data.FieldDef for groupBy fields
	groupByFields: null,
	
    // array of Ab.data.FieldDef for calculated fields
    calculatedFields: null,
    
    // data record retrieved from the server
    dataSet: null,
	
	// 1d or 2d
	dataType: '',
	
	//drill-down
	clickable: true,
	
    // optional: name of the first (row) dimension data source 
	rowDimensionDataSourceId: '',
	
    // optional: name of the second (column) dimension data source 
	columnDimensionDataSourceId: '',
    
    // optional: first (row) dimension data source 
	rowDataSource: null,
	
    // optional: second (column) dimension data source 
	columnDataSource: null,
	
	// array of Ab.data.FieldDef for row measures
	rowMeasureFields: null,
	
	// id for click-able link. It's started with clicked field's full name followed by a semicolon and the rest part
	clickableId: null,
	
    // ----------------------- initialization ------------------------------------------------------
    
    
	constructor: function(id, configObject) {
        this.inherit(id, 'crossTable', configObject);  
        
        this.clickableId = this.id;

        this.viewDef = new Ab.view.ViewDef(configObject.getConfigParameter('viewDef'), configObject.getConfigParameter('groupIndex'), null, null, configObject.getConfigParameter('dataSourceId'));
                
        this.columns = configObject.getConfigParameter('columns', 1);
        this.showOnLoad = configObject.getConfigParameter('showOnLoad', false);
		this.refreshWorkflowRuleId = configObject.getConfigParameterNotEmpty('refreshWorkflowRuleId', 
            Ab.view.CrossTable.WORKFLOW_RULE_REFRESH);
        this.fieldDefs = configObject.getConfigParameter('fieldDefs', []);

        this.addEventListenerFromConfig('afterGetData', configObject);
		
		var groupByFields = [];
		var calculatedFields = [];
		this.getDataSource().fieldDefs.each(function (fieldDef) {
			if (fieldDef.groupBy) {
				groupByFields.push(fieldDef);
			} else {
				calculatedFields.push(fieldDef);
			}
		});
		this.groupByFields = groupByFields;
		this.calculatedFields = calculatedFields;

        this.rowDimensionDataSourceId = configObject.getConfigParameter('rowDimensionDataSourceId', '');
        this.columnDimensionDataSourceId = configObject.getConfigParameter('columnDimensionDataSourceId', '');
        
        var rowMeasureFields = [];        		
        if (valueExistsNotEmpty(this.rowDimensionDataSourceId)) {
        	this.rowDataSource = View.dataSources.get(this.rowDimensionDataSourceId);
        	var skipField = true; // skip the first field
    		this.rowDataSource.fieldDefs.each(function (fieldDef) {
    			if (skipField) {
    				skipField = false;
    			} else {
                    rowMeasureFields.push(fieldDef);
    			}
    		});
        }
        if (valueExistsNotEmpty(this.columnDimensionDataSourceId)) {
        	this.columnDataSource = View.dataSources.get(this.columnDimensionDataSourceId);
        }
        this.rowMeasureFields = rowMeasureFields;
		
        this.dataType = (this.groupByFields.length == 2) ? '2d' : '1d';
                    
        this.visible = true;
        
        this.parentEl.addClass('AbMdx_Table');
    },
    
    // ------------------------ common control API methods -----------------------------------------

    
    getEl: function() {
        var el = this.inherit();
        var layoutWrapperEl = Ext.get(this.getWrapperElementId());
        if (layoutWrapperEl) {
            // KB 3038565: handle the case when the panel and an action button have the same ID
            // in the view file (not recommended, but not prohibited either).
            el = layoutWrapperEl.child('.crossTable');
        }
        return el;
    },

    
    initialDataFetch: function() {
    	this.clickable = (this.getEventListener('onClickItem')) ? true : false;
    	
        if (this.showOnLoad || this.restriction != null) {
            this.getDataSet(true);
        }  

        this.show(this.showOnLoad);
    },
    
    
    refresh: function(restriction) {
        // store the restriction if specified
        // if restriction is not specified, keep the current one
        if (typeof(restriction) != 'undefined' && restriction != null && restriction != '') {
            this.restriction = restriction;
        }

        this.getDataSet(false);
    },
    
    
    afterGetData: function(dataSet) {
        var listener = this.getEventListener('afterGetData');
        if (listener) {
            listener(this, dataSet);
        }
    },
    
    
    clear: function() {
        var tableId = this.parentElementId + '_table';
        var table = Ext.get(tableId);
        if (table != null) {
            table.remove();
        }
    },
    
    
    setDataSet: function(dataSet) {
        this.clear();
        this.dataSet = dataSet;
        this.formatDataRecords();
        this.onModelUpdate();
    },
    
    // ----------------------- implementation ------------------------------------------------------
    
	
    formatDataRecords: function(result) {
		var ds = this.getDataSource();
		if (valueExists(ds)) {
			var processRecords = function(records) {
				if (valueExists(records)) {
			        for (var i = 0; i < records.length; i++) {
			            var formattedValues = ds.formatCurrencyValues(records[i].localizedValues, false);
			            Ext.apply(records[i].localizedValues, formattedValues);
			        }
				}
			};
	
			if(valueExists(this.dataSet.records)){
				processRecords(this.dataSet.records);
			}
			if(valueExists(this.dataSet.columnSubtotals)){
				processRecords(this.dataSet.columnSubtotals);
			}
			if(valueExists(this.dataSet.rowSubtotals)){
				processRecords(this.dataSet.rowSubtotals);
			}
			if(valueExists(this.dataSet.totals)){
				processRecords(this.dataSet.totals);
			}
		}
	},
	
    
    onModelUpdate: function() {
        this.clear();

        var tableId = this.parentElementId + '_table';
        var html = '<table id="' + tableId + '" class="AbMdx_Table">';

		if (this.dataType == '1d') {
			html = html + this.render1D();
		} else {
			html = html + this.render2D();
		}

        html = html + '</table>';
        var table = Ext.DomHelper.insertHtml('afterBegin', this.parentElement, html);
		
        // attach drill-down event listeners
		var panel = this;
	    var links = Ext.DomQuery.select('a', table);
	    var listener = this.getEventListener('onClickItem');
		for (var i = 0; i < links.length; i++) {
			if (listener) {
				Ext.get(links[i]).addListener('click', function(){
					panel.onClickItem(this.id);
				});
			} 
		}
    },
    
    
    showTotals: function() {
    	showTotals = false;
		for (var i = 0; i < this.calculatedFields.length; i++) {
            if (this.calculatedFields[i].showTotals) {
            	showTotals = true;
            	break;
            }
		}
		
		if (this.dataSet.totals.length == 0) {
			showTotals = false;
		}
    	
    	return showTotals;
    },
    
    
    render1D: function() {
    	var html = '';
        var totalsTitle = this.getLocalizedString(Ab.view.CrossTable.z_MESSAGE_TOTALS);
        
		// add title row
		html = html + '<tr class="first">';
	    html = html + '<td class="AbMdx_DimensionNames first">' + convertFromXMLValue(this.groupByFields[0].title) + '</td>';
		for (var i = 0; i < this.rowMeasureFields.length; i++) {
			html = html + '<td class="AbMdx_DimensionNames">' + convertFromXMLValue(this.rowMeasureFields[i].title) + '</td>';
		}
		for (var i = 0; i < this.calculatedFields.length; i++) {
			html = html + '<td class="AbMdx_DimensionColumnHeader">' + convertFromXMLValue(this.calculatedFields[i].title) + '</td>';
		}
		html = html + '</tr>';
		
		// add totals row
		if (this.showTotals()) {
			html = html + '<tr>';
			html = html + '<td class="AbMdx_TotalCellHeader first">' + totalsTitle + '</td>';
			for (var i = 0; i < this.rowMeasureFields.length; i++) {
				html = html + '<td class="AbMdx_SubTotalRowData"></td>';
			}
			for (var i = 0; i < this.calculatedFields.length; i++) {
				var totalValue = this.dataSet.totals[0].getLocalizedValue(this.calculatedFields[i].id);
	            if (!this.calculatedFields[i].showTotals) {
	            	totalValue = '';
	            }
	            this.clickableId = this.calculatedFields[i].id + ';' + this.id;
				html = html + '<td class="AbMdx_SubTotalRowData">' + this.getTotalsHtml(totalValue) + '</td>';
			}
			html = html + '</tr>';
		}
		
		// add data rows
		for (var r = 0; r < this.dataSet.records.length; r++) {
			var record = this.dataSet.records[r];
			var rowTitle = this.dataSet.rowValues[r].l;
			var rowRecord = this.dataSet.rowRecords[r];
			
			html = html + '<tr class="' + ((r % 2 == 0) ? 'dataRow' : 'dataRow odd') + '">';
			html = html + '<td class="AbMdx_DimensionRowHeader first">' + this.getRowHtml(r, rowTitle)  + '</td>';
			for (var f = 0; f < this.rowMeasureFields.length; f++) {
				this.clickableId = this.rowMeasureFields[f].id + ';' + this.id;
				var cellValue = rowRecord.getLocalizedValue(this.rowMeasureFields[f].id);
				html = html + '<td class="AbMdx_MeasureCellData">' + this.getCellHtml(r, 0, f, cellValue) + '</td>';
			}
			for (var f = 0; f < this.calculatedFields.length; f++) {
				this.clickableId = this.calculatedFields[f].id + ';' + this.id;
				var cellValue = record.getLocalizedValue(this.calculatedFields[f].id);
				html = html + '<td class="AbMdx_MeasureCellData">' + this.getCellHtml(r, 0, f, cellValue) + '</td>';
			}
            html = html + '</tr>';
		}
		
		return html;
    },
    
    
    render2D: function() {
    	var html = '';
        var totalsTitle = this.getLocalizedString(Ab.view.CrossTable.z_MESSAGE_TOTALS);
        
        // get the number of row dimension fields (eg. department|division)
        var nRowDimensionFields = this.getNumberOfRowDimensionFields();
        var nRowMeasureFields = this.rowMeasureFields.length;
        var nMeasureFields = this.calculatedFields.length;
	    
		// row 1: 2nd dimension name
		html = html + '<tr class="first">';
        html = html + '<td class="AbMdx_DimensionNames first" colspan="' + (nRowDimensionFields + nRowMeasureFields + 1) + '"><br/></td>';
        html = html + '<td class="AbMdx_DimensionNames" colspan="' + (this.dataSet.columnValues.length + 1) + '">' + convertFromXMLValue(this.groupByFields[1].title) + '</td>';
        html = html + '</tr>';
		
		// row 2: 1st dimension name, 2nd dimension values
        html = html + '<tr>';
        html = html + '<td class="AbMdx_DimensionNames first">' + convertFromXMLValue(this.groupByFields[0].title) + '</td>';
        if (nRowDimensionFields > 1) {
            html = html + '<td  class="AbMdx_DimensionNames"></td>';
        }
        for (var i = 0; i < nRowMeasureFields; i++) {
			html = html + '<td class="AbMdx_DimensionNames">' + convertFromXMLValue(this.rowMeasureFields[i].title) + '</td>';
        }
        html = html + '<td class="AbMdx_DimensionNames"><br/></td>';
        
        if (this.showTotals()) {
            html = html + '<td class="AbMdx_TotalCellHeader">' + totalsTitle + '</td>';
        }
        
        for (var c = 0; c < this.dataSet.columnValues.length; c++) {
			var columnTitle = this.dataSet.columnValues[c].l;
            html = html + '<td class="AbMdx_DimensionColumnHeader">' + this.getColumnHtml(c, columnTitle) + '</td>';
        }
        html = html + '</tr>';
		
		// row 3 (multiple sub-rows): 2st dimension subtotals for all measures
        if (this.showTotals()) {
            var totalValue = this.dataSet.totals[0].getLocalizedValue(this.calculatedFields[0].id);
            if (!this.calculatedFields[0].showTotals) {
            	totalValue = '';
            }
            
            html = html + '<tr>';
            html = html + '<td class="AbMdx_TotalCellHeader first" rowspan="' + this.calculatedFields.length + '">' + totalsTitle + '</td>';
            for (var i = 0; i < nRowMeasureFields; i++) {
    			html = html + '<td class="AbMdx_TotalCellData"></td>';
            }
            this.clickableId = this.calculatedFields[0].id + ';' + this.id;
            html = html + '<td class="AbMdx_MeasureName">' + convertFromXMLValue(this.calculatedFields[0].title) + '</td>';
            html = html + '<td class="AbMdx_TotalCellData">' + this.getTotalsHtml(totalValue) + '</td>';
            for (var c = 0; c < this.dataSet.columnValues.length; c++) {
            	var columnSubtotal = this.dataSet.columnSubtotals[c];

            	var subtotalValue = '';
            	if (valueExists(columnSubtotal) && this.calculatedFields[0].showTotals) {
            		subtotalValue = this.dataSet.columnSubtotals[c].getLocalizedValue(this.calculatedFields[0].id);
            	}
            	
                html = html + '<td class="AbMdx_SubTotalColumnData">' + this.getColumnTotalsHtml(c, subtotalValue) + '</td>';
            }
            html = html + '</tr>';

            for (var f = 1; f < this.calculatedFields.length; f++) {
                totalValue = this.dataSet.totals[0].getLocalizedValue(this.calculatedFields[f].id);
                if (!this.calculatedFields[f].showTotals) {
                	totalValue = '';
                }
                
				html = html + '<tr>';
	            for (var i = 0; i < nRowMeasureFields; i++) {
	    			html = html + '<td class="AbMdx_TotalCellData"></td>';
	            }
	            this.clickableId = this.calculatedFields[f].id + ';' + this.id;
	            html = html + '<td class="AbMdx_MeasureName">' + convertFromXMLValue(this.calculatedFields[f].title) + '</td>';
	            html = html + '<td class="AbMdx_TotalCellData">' + this.getTotalsHtml(totalValue) + '</td>';
	            for (var c = 0; c < this.dataSet.columnValues.length; c++) {
	                var subtotalValue = this.dataSet.columnSubtotals[c].getLocalizedValue(this.calculatedFields[f].id);
                    if (!this.calculatedFields[f].showTotals) {
                    	subtotalValue = '';
                    }
                    
	                html = html + '<td class="AbMdx_SubTotalColumnData">' + this.getColumnTotalsHtml(c, subtotalValue) + '</td>';
	            }
				html = html + '</tr>';
			}
        }
			
		// rows for all row dimension values (multiple sub-rows)
        var trCounter = 0;
		for (var r = 0; r < this.dataSet.rowValues.length; r++) {
            var rowTitle = this.dataSet.rowValues[r].l;
			var rowValue = this.dataSet.rowValues[r].n;
			var rowRecord = this.dataSet.rowRecords[r];
			
            var calculatedField = this.calculatedFields[0];
            this.clickableId = calculatedField.id + ';' + this.id;
            
			html = html + '<tr class="' + ((trCounter++ % 2 == 0) ? 'dataRow' : 'dataRow odd') + '">';
			
            var separatorIndex = rowTitle.indexOf('|');
            if (separatorIndex >= 0 && nRowDimensionFields > 1) {
                var firstTitle = rowTitle.slice(0, separatorIndex);
                var secondTitle = rowTitle.slice(separatorIndex + 1);
                html = html + '<td class="AbMdx_DimensionRowHeader first" rowspan="' + this.calculatedFields.length + '">' + this.getRowHtml(r, firstTitle) + '</td>';
                html = html + '<td class="AbMdx_DimensionRowHeader" rowspan="' + this.calculatedFields.length + '">' + this.getRowHtml(r, secondTitle) + '</td>';
            } else {
                html = html + '<td class="AbMdx_DimensionRowHeader first" rowspan="' + this.calculatedFields.length + '">' + this.getRowHtml(r, rowTitle) + '</td>';
            }
            for (var f = 0; f < nRowMeasureFields; f++) {
				var cellValue = rowRecord.getLocalizedValue(this.rowMeasureFields[f].id);
				html = html + '<td class="AbMdx_DimensionRowHeader" style="font-weight:normal;" rowSpan="' + this.calculatedFields.length + '">' + this.getCellHtml(r, 0, f, cellValue, false) + '</td>';
            }
            html = html + '<td class="AbMdx_MeasureColumn">' + convertFromXMLValue(calculatedField.title) + '</td>';
            
            if (this.showTotals()) {
                var subtotalValue = this.dataSet.rowSubtotals[r].getLocalizedValue(calculatedField.id);
                if (!calculatedField.showTotals) {
                	subtotalValue = '';
                }
               
                html = html + '<td class="AbMdx_SubTotalRowData">' + this.getRowTotalsHtml(r, subtotalValue) + '</td>';
            }
			
            for (var c = 0; c < this.dataSet.columnValues.length; c++) {
                var columnValue = this.dataSet.columnValues[c].n;
                var cellValue = this.getCellValue(rowValue, columnValue, calculatedField);
                html = html + '<td class="AbMdx_MeasureCellData">' + this.getCellHtml(r, c, 0, cellValue) + '</td>';
            }
            html = html + '</tr>';

            for (var f = 1; f < this.calculatedFields.length; f++) {
				calculatedField = this.calculatedFields[f];
				this.clickableId = calculatedField.id + ';' + this.id;
				
				html = html + '<tr class="' + ((trCounter++ % 2 == 0) ? 'dataRow' : 'dataRow odd') + '">';

				html = html + '<td class="AbMdx_MeasureColumn">' + convertFromXMLValue(calculatedField.title)  + '</td>';

                if (this.showTotals()) {
                    var subtotalValue = this.dataSet.rowSubtotals[r].getLocalizedValue(calculatedField.id);
                    if (!calculatedField.showTotals) {
                    	subtotalValue = '';
                    }
                  
                    html = html + '<td class="AbMdx_SubTotalRowData">' + this.getRowTotalsHtml(r, subtotalValue) + '</td>';
                }
				
                for (var c = 0; c < this.dataSet.columnValues.length; c++) {
					var columnValue = this.dataSet.columnValues[c].n;
					var cellValue = this.getCellValue(rowValue, columnValue, calculatedField);
                    html = html + '<td class="AbMdx_MeasureCellData">' + this.getCellHtml(r, c, f, cellValue) + '</td>';
                }
                html = html + '</tr>';
            }
		}      
    	
    	return html;
    },
    
    
    getNumberOfRowDimensionFields: function() {
        var nRowDimensionFields = 1;
        if (this.dataSet.rowValues.length > 0) {
	        var firstRowTitle = this.dataSet.rowValues[0].l;
	        var separatorIndex = firstRowTitle.indexOf('|');
	        if (separatorIndex >= 0) {
	        	nRowDimensionFields = 2;
	        }
        }
        
        return nRowDimensionFields;
    },
	
	
	getCellValue: function(rowValue, columnValue, calculatedField) {
        var cellValue = this.getLocalizedString(Ab.view.CrossTable.z_MESSAGE_NODATA);
        var record = this.dataSet.getRecordForRowAndColumn(rowValue, columnValue);
        if (valueExists(record)) {
            cellValue = record.getLocalizedValue(calculatedField.id);
        }
        return cellValue;
	},
	
    
    getTotalsHtml: function(cellValue) {
        return this.getItemHtml(this.clickableId + '_totals', cellValue);
    },
    
    
    getRowHtml: function(r, cellValue) {
        return this.getItemHtml(this.clickableId + '_row_r' + r, cellValue);
    },
    
    
    getRowTotalsHtml: function(r, cellValue) {
        return this.getItemHtml(this.clickableId + '_rowTotals_r' + r, cellValue);
    },
    
    
    getColumnHtml: function(c, cellValue) {
        return this.getItemHtml(this.clickableId + '_column_c' + c, cellValue);
    },
    
    
    getColumnTotalsHtml: function(c, cellValue) {
        return this.getItemHtml(this.clickableId + '_columnTotals_c' + c, cellValue);
    },
    
    
    getCellHtml: function(r, c, f, cellValue, clickable) {
        if (!valueExists(clickable)) {
            clickable = this.clickable;
        }
        return this.getItemHtml(this.clickableId + '_cell_r' + r + '_c' + c + '_f' + f, cellValue, clickable);
    },
	
    
    getItemHtml: function(cellId, cellValue, clickable) {
        if (!valueExists(clickable)) {
            clickable = this.clickable;
        }
        if (clickable) {
            return ('<a id="' + cellId + '" href="javascript: //">' + cellValue + '</a>');
        } else {
            return ('<span id="' + cellId + '">' + cellValue + '</span>'); 
        }
    },
    
	
	onClickItem: function(id) {
		var listener = this.getEventListener('onClickItem');

		if (listener) {
			var restriction = this.getRestrictionFromId(id);

			// kb3025051
			var parameters = this.getParameters();
			var parameterRestriction = eval("(" + parameters.restriction + ")");
			if (typeof(parameterRestriction) != 'undefined' && parameterRestriction  != null && parameterRestriction  != '') {
				for(name in parameterRestriction){
					// kb3025500
					if(name != 'clauses' && name.indexOf('.') > 0 && parameterRestriction[name]){
						restriction.addClause(name, parameterRestriction[name], "=");
					}
				}				
			}
			
			// KB 3025051, 3025500: the panel might have additional restriction applied from another 
			// panel (console, tree, etc); it must be added to the drill-down restriction
			if (this.restriction != null && this.restriction.constructor != String) {
				restriction.addClauses(this.restriction, false, true);
			}

			if (listener.call) {
				// event listener is a function
				listener(this, restriction);
			} else {
				// event listener is a Command
				listener.restriction = restriction;
				listener.handle();
			}
		}
	},
	
	
	getRestrictionFromId: function(id) {
        var restriction = new Ab.view.Restriction();
        
        id = this.parsedClickableId(id);
       
		if (id.indexOf('_rowTotals') == 0) {
            var rowIndex = id.slice(12);
            var rowValue = (this.dataSet.nullValueTitle == this.dataSet.rowValues[rowIndex].n) ? '' : this.dataSet.rowValues[rowIndex].n;
            var rowName = this.groupByFields[0].id;
            this.addRestrictionClause(restriction, rowName, rowValue);
            
        } else if (id.indexOf('_row') == 0) {
            var rowIndex = id.slice(6);
            var rowValue = this.dataSet.rowValues[rowIndex].n;
            var rowName = this.groupByFields[0].id;
            this.addRestrictionClause(restriction, rowName, rowValue);
            
        } else if (id.indexOf('_columnTotals') == 0) {
            var columnIndex = id.slice(15);
            var columnValue = this.dataSet.columnValues[columnIndex].n;
            var columnName = this.groupByFields[1].id;
            this.addRestrictionClause(restriction, columnName, columnValue);
            
        } else if (id.indexOf('_column') == 0) {
            var columnIndex = id.slice(9);
            var columnValue = this.dataSet.columnValues[columnIndex].n;
            var columnName = this.groupByFields[1].id;
            this.addRestrictionClause(restriction, columnName, columnValue);
            
		} else if (id.indexOf('_cell') == 0) {
			var parts = id.slice(6).split('_');

			var rowIndex = parts[0].slice(1);
            var rowValue = (this.dataSet.nullValueTitle == this.dataSet.rowValues[rowIndex].n) ? '' : this.dataSet.rowValues[rowIndex].n;
            var rowName = this.groupByFields[0].id;
            this.addRestrictionClause(restriction, rowName, rowValue);

            if (valueExists(this.dataSet.columnValues)) {
				var columnIndex = parts[1].slice(1);
				var columnValue = this.dataSet.columnValues[columnIndex].n;
				var columnName = this.groupByFields[1].id;
				this.addRestrictionClause(restriction, columnName, columnValue);
			}
		}

		return restriction;
	},
	
	
	parsedClickableId: function(clickableId){
		var id = clickableId;
		
		//separate field name with the rest of id if the id includes a semicolon.
		var idsArray = id.split(';');
		if(idsArray.length===1){
			id = idsArray[0];
		}else{
			id = idsArray[1];
		}
		
		// remove this id prefix
		id = id.replace(this.id, '');
		
		return id;
	},
	
	
	getClickedFieldName: function(clickableId){
		var idsArray = clickableId.split(';');
		if(idsArray.length > 1){
			return idsArray[0];
		}

		return null;
	},
	
	
	getCellElement: function(rowIndex, columnIndex, fieldIndex){
		var cellId = this.calculatedFields[fieldIndex].id + ';' + this.id + '_cell_r' + rowIndex + '_c' + columnIndex + '_f' + fieldIndex;
		var cellDom = Ext.get(cellId);
		if(cellDom != null){
			return cellDom.dom;
		}
		return null;
	},
	
	
	addRestrictionClause: function(restriction, name, value) {
	    if (value.indexOf('no value') != -1) {
            restriction.addClause(name, '', 'IS NULL');
	    } else {
            restriction.addClause(name, value, '=');
	    }
	},
    
        
    getDataSet: function(isInitialDataFetch) {
		// if a custom WFR is specified, call it 
		if (this.refreshWorkflowRuleId !== Ab.view.CrossTable.WORKFLOW_RULE_REFRESH) {
			this.getData();
			return;
		}

        this.beforeRefresh();

		// try to call the new WFR
        try {
        	var restriction = '';
            if (this.restriction != null) {
                restriction = toJSON(this.restriction);
            }
            
            // start the getGroupingDataSet job
            var jobId = Workflow.startJob('AbCommonResources-DataSourceService-getGroupingDataSet', 
            		this.viewDef.viewName,
            		this.viewDef.dataSourceId,
            		this.rowDimensionDataSourceId,
            		this.columnDimensionDataSourceId,
            		this.dataType,
            		this.getGroupByFieldNames(),
            		this.getDataSource().sortFieldDefs,
            		restriction,
            		this.parameters);
            
            var message = this.getLocalizedString(Ab.view.CrossTable.z_MESSAGE_WORKING);
            var panel = this;

            // open the progress bar and wait until the job is complete
            View.openJobProgressBar(message, jobId, null, function(status) {
            	
		        // call user-defined afterGetData listener
            	panel.afterGetData(status.dataSet);

                // render the data
				panel.setDataSet(status.dataSet);
				
				// show the panel if hidden
		        panel.show(true);
	            
		        // call user-defined afterRefresh listener
		        if (!isInitialDataFetch) {
		            panel.afterRefresh();
		        }
            }, 
            function(status) {
            	panel.handleError(status);
            });
            
        } catch (e) {
        	panel.handleError(e);
        }
    },
    
        
    getData: function(isInitialDataFetch) {
        this.beforeRefresh();

        try {
            var result = Ab.workflow.Workflow.call(this.refreshWorkflowRuleId, this.getParameters());
            if (valueExists(result.dataSet)) {
                
		        // call user-defined afterGetData listener
            	this.afterGetData(result.dataSet);

                // render the data
				this.setDataSet(result.dataSet);
				
				// show the panel if hidden
		        this.show(true);
	            
		        // call user-defined afterRefresh listener
		        if (!isInitialDataFetch) {
		            this.afterRefresh();
		        }
            }
        } catch (e) {
            this.handleError(e);
        }
    },
    
    
    getParameters: function() {
        var parameters = {
            viewName:          this.viewDef.viewName,
            dataSourceId:      this.viewDef.dataSourceId,
            rowDimensionDataSourceId: this.rowDimensionDataSourceId,
            columnDimensionDataSourceId: this.columnDimensionDataSourceId,
			dataType:          this.dataType,
			groupByFieldNames: toJSON(this.getGroupByFieldNames()),
			sortFieldDefs:     toJSON(this.getDataSource().sortFieldDefs),
			recordLimit:       -1
        };
		
        if (this.restriction != null) {
            parameters.restriction = toJSON(this.restriction);
        }
        
        Ext.apply(parameters, this.parameters);

        return parameters;
    },
    
    getGroupByFieldNames: function() {
		var groupByFieldNames = [];
		for (var i = 0; i < this.groupByFields.length; i++) {
			groupByFieldNames.push(this.groupByFields[i].id);
		}
		return groupByFieldNames;
    },
    
 // ----------------------- export report selection --------------------------------------------------
    
    callReportJob: function(reportProperties){
    	var outputType = reportProperties.outputType;
    	if(outputType === 'xls'){
    		var reportTitle = this.title;
    		if(reportTitle==''){
    			reportTitle = Ab.view.View.title;
    		}
    		return this.callXLSReportJob(reportTitle, this.restriction);
    	}else if(outputType === 'docx'){
    		//no translatable since it's only for viwew designers.
    		View.showMessage('error', 'DOCX action is NOT supported for a Cross-table panel.');
    	}
    	return null;
    },
    
    callXLSReportJob: function(reportTitle, restriction){
    	var reportViewName = this.viewDef.viewName + '.axvw';
		var parameters = this.getParameters();
		
		var jobId = Workflow.startJob(Ab.view.CrossTable.WORKFLOW_RULE_XLS_REPORT, reportViewName, this.dataSourceId, this.dataType, reportTitle, this.groupByFields, 
				this.calculatedFields, this.getDataSource().sortFieldDefs, this.rowDimensionDataSourceId,  this.columnDimensionDataSourceId, this.rowMeasureFields, toJSON(restriction), parameters);
		
		return jobId;
    }
    
}, {
    // ----------------------- constants -----------------------------------------------------------
    
    // @begin_translatable
    z_MESSAGE_TOTALS: 'Total',
    z_MESSAGE_WORKING: 'Retrieving the data',
    // @end_translatable
    
    z_MESSAGE_NODATA: '',
	
    // name of the default WFR used to get the record
    WORKFLOW_RULE_REFRESH: 'AbCommonResources-getDataRecords',
    
    // name of the WFR used to invoke XLS report
    WORKFLOW_RULE_XLS_REPORT: 'AbSystemAdministration-generatePaginatedReport-generateCrossTabXLSReport'
});


//
// NOTES
// 
// handles the object/embed tag placed in the div/span/other element within a panel
//
//	the config parameter 'swfPath' should be a path from ab-core (e.g., /controls/drawing/ArchibusSwf or /controls/chart/AbColumnChart)
// note that the extension is added within AC_GetArgs()
//
//   


Ab.namespace('flash');




Ab.flash.FlashComponent = Ab.view.Component.extend({

	// booleans for browser detection
	isIE: (navigator.appVersion.indexOf("MSIE") != -1) ? true : false,

	isWin: (navigator.appVersion.toLowerCase().indexOf("win") != -1) ? true : false,

	isOpera: (navigator.userAgent.indexOf("Opera") != -1) ? true : false,

	
	// member variables controlling the initial layout
	swfPath: "ArchibusSwf",
	
	bgColor: "#dddddd",
	    
	
	constructor:function(id, type, config) {
	    this.inherit(id, type, config);

	    this.swfPath 		= config.getConfigParameter('swf', 'abDrawing');
	    this.bgColor 		= config.getConfigParameter('bgcolor', '#dddddd');			
	},
 	
 	
 	
 	flashAppLoaded: function() {
 	},
 	
 	flashDocLoaded: function() {
 	},
 	

	
	runContent: function() {
		var ret = this.AC_GetArgs(arguments, ".swf", "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000", "application/x-shockwave-flash");
		var tag = this.generateEmbedObjectTag(ret.objAttrs, ret.params, ret.embedAttrs);
		this.injectFlashTag(tag);
	},


	
	returnContent: function() {
		var ret = this.AC_GetArgs(arguments, ".swf", "movie", "clsid:d27cdb6e-ae6d-11cf-96b8-444553540000", "application/x-shockwave-flash");
		return this.generateEmbedObjectTag(ret.objAttrs, ret.params, ret.embedAttrs);
	},


	
	generateEmbedObjectTag: function(objAttrs, params, embedAttrs, parentElementId, parentPanelId)  { 
    	var str = '';
    	if (this.isIE && this.isWin && !this.isOpera) {
  			str += '<object ';
  			for (var i in objAttrs) {
  				str += i + '="' + objAttrs[i] + '" ';
			}
            str += '>';
  			for (var i in params) {
  				str += '<param name="' + i + '" value="' + params[i] + '" /> ';
			}
			str += '<param name="wmode" value="transparent"/>';
  			str += '</object>';
    	} 
		else {
  			str += '<embed ';
  			for (var i in embedAttrs) {
  				str += i + '="' + embedAttrs[i] + '" ';
			}
  			str += ' wmode="opaque"> </embed>';
    	}		
		return str;
	},


	
	injectFlashTag: function(tagString) {
		if (valueExists(this.parentEl)) {
            var lastChild = this.parentEl.last();
            if (lastChild && (lastChild.dom.tagName.toLowerCase() === 'embed' || lastChild.dom.tagName.toLowerCase() === 'object')) {
                // replace the previous SWF object
                this.parentEl.dom.innerHTML = tagString;
            } else {
                // append the SWF object to the parent element
                try {
                    if (this.parentEl.last()) {
                        Ext.DomHelper.insertHtml('afterBegin', lastChild.dom, tagString);
                    } else {
                        Ext.DomHelper.insertHtml('afterBegin', this.parentEl.dom, tagString);
                    }
                } catch (error) {
                    this.parentEl.dom.innerHTML = tagString;
                }
            }

            View.log('Flash control [' + this.id + ']: loading SWF content', 'debug');
		}
	},

    	
	afterInitialDataFetch: function() {
		// we have to defer the execution because in IE the layout manager initialization is also deferred
		this.syncHeight.defer(100, this, [this.parentEl]);
	},
	
	ControlVersion: function () {
		var version;
		var axo;
		var e;
		// NOTE : new ActiveXObject(strFoo) throws an exception if strFoo isn't in the registry
		try {
			// version will be set for 7.X or greater players
			axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");
			version = axo.GetVariable("$version");
		} 
		catch (e) {
		}
		if (!version) {
			try {
				// version will be set for 6.X players only
				axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6");	
				// installed player is some revision of 6.0
				// GetVariable("$version") crashes for versions 6.0.22 through 6.0.29,
				// so we have to be careful. 
				//			
				// default to the first public version
				version = "WIN 6,0,21,0";
				// throws if AllowScripAccess does not exist (introduced in 6.0r47)		
				axo.AllowScriptAccess = "always";
				// safe to call for 6.0r47 or greater
				version = axo.GetVariable("$version");
			} 
			catch (e) {
			}
		}
		if (!version) {
			try {
				// version will be set for 4.X or 5.X player
				axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
				version = axo.GetVariable("$version");
			} 
			catch (e) {
			}
		}
		if (!version) {
			try {
				// version will be set for 3.X player
				axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.3");
				version = "WIN 3,0,18,0";
			} 
			catch (e) {
			}
		}
		if (!version) {
			try {
				// version will be set for 2.X player
				axo = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
				version = "WIN 2,0,0,11";
			} 
			catch (e) {
				version = -1;
			}
		}
		return version;
	},


	// JavaScript helper required to detect Flash Player PlugIn version information
	GetSwfVer: function(){
		// NS/Opera version >= 3 check for Flash plugin in plugin array
		var flashVer = -1;
	
		if (navigator.plugins != null && navigator.plugins.length > 0) {
			if (navigator.plugins["Shockwave Flash 2.0"] || navigator.plugins["Shockwave Flash"]) {
				var swVer2 = navigator.plugins["Shockwave Flash 2.0"] ? " 2.0" : "";
				var flashDescription = navigator.plugins["Shockwave Flash" + swVer2].description;
				var descArray = flashDescription.split(" ");
				var tempArrayMajor = descArray[2].split(".");			
				var versionMajor = tempArrayMajor[0];
				var versionMinor = tempArrayMajor[1];
				var versionRevision = descArray[3];
				if (versionRevision == "") {
					versionRevision = descArray[4];
				}
				if (versionRevision[0] == "d") {
					versionRevision = versionRevision.substring(1);
				} 
				else if (versionRevision[0] == "r") {
					versionRevision = versionRevision.substring(1);
					if (versionRevision.indexOf("d") > 0) {
						versionRevision = versionRevision.substring(0, versionRevision.indexOf("d"));
					}
				}
				var flashVer = versionMajor + "." + versionMinor + "." + versionRevision;
			}
		}
		// MSN/WebTV 2.6 supports Flash 4
		else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.6") != -1) {
			flashVer = 4;
		}
		// WebTV 2.5 supports Flash 3
		else if (navigator.userAgent.toLowerCase().indexOf("webtv/2.5") != -1) {
			flashVer = 3;
		}
		// older WebTV supports Flash 2
		else if (navigator.userAgent.toLowerCase().indexOf("webtv") != -1) {
			flashVer = 2;
		}
		else if (this.isIE && this.isWin && !this.isOpera ) {
			flashVer = this.ControlVersion();
		}	
		return flashVer;
	},

	// When called with reqMajorVer, reqMinorVer, reqRevision returns true if that version or greater is available
	DetectFlashVer: function(reqMajorVer, reqMinorVer, reqRevision) {
		versionStr = this.GetSwfVer();
		if (versionStr == -1 ) {
			return false;
		} 
		else if (versionStr != 0) {
			if (this.isIE && this.isWin && !this.isOpera) {
				// Given "WIN 2,0,0,11"
				tempArray         = versionStr.split(" "); 	// ["WIN", "2,0,0,11"]
				tempString        = tempArray[1];			// "2,0,0,11"
				versionArray      = tempString.split(",");	// ['2', '0', '0', '11']
			} 
			else {
				versionArray      = versionStr.split(".");
			}
			var versionMajor      = versionArray[0];
			var versionMinor      = versionArray[1];
			var versionRevision   = versionArray[2];

		   	// is the major.revision >= requested major.revision AND the minor version >= requested minor
			if (versionMajor > parseFloat(reqMajorVer)) {
				return true;
			} 
			else if (versionMajor == parseFloat(reqMajorVer)) {
				if (versionMinor > parseFloat(reqMinorVer)) {
					return true;
				}
				else if (versionMinor == parseFloat(reqMinorVer)) {
					if (versionRevision >= parseFloat(reqRevision)) {
						return true;
					}
				}
			}
			return false;
		}
	},


	AC_AddExtension: function (src, ext) {
		if (src.indexOf('?') != -1) {
		    return src.replace(/\?/, ext+'?'); 
		}
		else {
		    return src + ext;
		}
	},


	AC_GetArgs: function(args, ext, srcParamName, classid, mimeType){
	    var ret = new Object();
	    ret.embedAttrs = new Object();
	    ret.params = new Object();
	    ret.objAttrs = new Object();
	    for (var i=0; i < args.length; i=i+2){
  		    var currArg = args[i].toLowerCase();    

  		    switch (currArg) {	
		        case "classid":
  			        break;
		        case "pluginspage":
	  		        ret.embedAttrs[args[i]] = args[i+1];
			        break;
		        case "src":
		        case "movie":	
			        args[i+1] = this.AC_AddExtension(args[i+1], ext);
			        ret.embedAttrs["src"] = args[i+1];
			        ret.params[srcParamName] = args[i+1];
			        break;
		        case "onafterupdate":
		        case "onbeforeupdate":
		        case "onblur":
		        case "oncellchange":
		        case "onclick":
		        case "ondblClick":
		        case "ondrag":
		        case "ondragend":
		        case "ondragenter":
		        case "ondragleave":
		        case "ondragover":
		        case "ondrop":
		        case "onfinish":
		        case "onfocus":
		        case "onhelp":
		        case "onmousedown":
		        case "onmouseup":
		        case "onmouseover":
		        case "onmousemove":
		        case "onmouseout":
		        case "onkeypress":
		        case "onkeydown":
		        case "onkeyup":
		        case "onload":
		        case "onlosecapture":
		        case "onpropertychange":
		        case "onreadystatechange":
		        case "onrowsdelete":
		        case "onrowenter":
		        case "onrowexit":
		        case "onrowsinserted":
		        case "onstart":
		        case "onscroll":
		        case "onbeforeeditfocus":
		        case "onactivate":
		        case "onbeforedeactivate":
		        case "ondeactivate":
		        case "type":
		        case "codebase":
			        ret.objAttrs[args[i]] = args[i+1];
			        break;
		        case "id":
		        case "width":
		        case "height":
		        case "align":
		        case "vspace": 
		        case "hspace":
		        case "class":
		        case "title":
		        case "accesskey":
		        case "name":
		        case "tabindex":
			        ret.embedAttrs[args[i]] = ret.objAttrs[args[i]] = args[i+1];
			        break;
		        default:
	  		      ret.embedAttrs[args[i]] = ret.params[args[i]] = args[i+1];
		    }
	    }
	    ret.objAttrs["classid"] = classid;
	    if (mimeType) ret.embedAttrs["type"] = mimeType;
	    return ret;
	}
});


 



Ab.namespace('drawing');


//
// Required global variable, providing a hook into the javascript
// handlers for access from the flex application.
//
var jsAccessFromFlex = null;

// Required global variable to support mousewheel action in various browsers
var dwgControlId = '';


Ab.drawing.DrawingControl = Ab.flash.FlashComponent.extend({

	// @begin_translatable
    z_MESSAGE_BORDER_HIGHLIGHTS: 'Border Highlights',
    z_MESSAGE_ROOM_HIGHLIGHTS: 'Room Highlights',
	z_MESSAGE_HIGHLIGHTS: 'Highlights',
	z_MESSAGE_LABELS: 'Labels',
	z_MESSAGE_TB_SELECT: 'Select',
    z_MESSAGE_TB_PAN: 'Pan',
    z_MESSAGE_TB_ZOOMWINDOW: 'Zoom Window',           
    z_MESSAGE_TB_ZOOMIN: 'Zoom In',
    z_MESSAGE_TB_ZOOMOUT: 'Zoom out',
    z_MESSAGE_TB_ZOOMEXTENTS: 'Zoom Extents',
    z_MESSAGE_TB_AUTOCENTER: 'Center',
    z_MESSAGE_TB_ISO: 'Isometric',
    z_MESSAGE_TB_RESETASSETS: 'Reset Assets',
    z_MESSAGE_TB_CLEARASSETS: 'Clear Assets',
    z_MESSAGE_PROMPT_ERROR: 'Error',
    z_MESSAGE_PROMPT_NODOC: 'No document specified to load',
    z_MESSAGE_PROMPT_UNABLETOLOAD: 'Unable to load',
    z_MESSAGE_PROMPT_SELECTEDROOM: 'Selected room',
    z_MESSAGE_PROMPT_ALREADYASSIGNEDTO:  'already assigned to', 
    z_MESSAGE_PROMPT_NONE: 'None', 
    z_DRAWING_PRINTING: 'It will take a moment to export the drawing into Microsoft Word, do you want to continue?',
	z_MESSAGE_PROMPT_LEAVEREDMARKSINVISIBLE: 'Some of the redlines you created are currently not visible on the drawing view and will not be printed. Do you still want to continue?',

	z_MESSAGE_FILTER: 'Filter:',
	z_MESSAGE_BORDERS: 'Borders:',
	// @end_translatable
		
	ver: '18.10.00.06',
	
	// member variables controlling the initial layout
	swf: "abDrawing",
	
	application: "abDrawing",
	
	bgColor: "#dddddd",
	
	onLoadDcl: null,
	
	onLoadOpts: null,
	
	roomToHighlight: null,
	
    // Data source for initial highlighting
    highlightDataSource: '',
    
    // Data source labels
    labelsDataSource: '',
    highlightDataSourcePanel: '',
    
    labelsDataSourcePanel: '',
    
    // Highlight type
    highlightType: '',
    
    thematicHighlightStyle: '',
    
    projectionType: 'tiled',
    
    columnsGroupedBy: '',
    
    borderHighlightLegendPanel: '',
    
	legendPanel: '',			// The id of the legend panel, if any
	legendPanelDs: '',
	legendPanelSelectable: false,
	
	initialData: '',			// The primary key info used to add a drawing on startup
	
	multiple: '',				// Controls whether or not more than 1 drawing can be loaded at a time
    
    //highlightValueField: '',	// not currently supported
    
    assetTypes: '',
    
    selectionMode: '2',			// Graphics are selectable, possible values: 
    							//	0: None
    							//  1: Only Assigned (per highlightDataSource results)
    							//  2: All
    
   	assignMode: '0',			// Deterimes how the Drawing Control should function per this mode
   								// If > 0, this overrides the multipleSelectionEnabled setting
   								//	0: Disabled
   								//	1: One to One
   								//	2: One to Many
   								//  3: Many to One
    							
    multipleSelectionEnabled: true,	// Allow multiple assets to be selected
    
    nofillField: '',			// Field name associated with nofillValues
    
    nofillValues: null,			// Array of values to have no fill associated with them
    
    toolbarSettings: '',		// A string that specifies toolbar settings
    							// Format of toolbarSettings
								//		action1=commaDelimitedListOfButtonNames;action2=...
								//
								//	Examples:
								//		show=resetAssets,clearAssets;
								//		hide=iso;
								//		enalbe=iso,autoCenter;
								//		disable=zoomIn;
								//		hide=all;
								//		hide=zoomOut;disable=autoScale,iso,etc;
								//
								//	List of valid actions:
								//		show
								//		hide
								//		enable
								//		disable
								//
								//	List of currently supported button names
								//		all
								//		state    (group of state buttons are only supported as group:  
								//					select, pan, and zoomWindow)
								//		resetAssets
								//		clearAssets
								//		zoomIn
								//		zoomOut
								//		autoScale
								//		autoCenter
								//		iso
								//

    // private specified member variables
    
    dwgConfig: null,
    
    labelSelector: true,		// TODO: add to config options
    
   	highlightSelector: true,	// TODO: add to config options

    
    showLegendOverlay: false,

    
	bordersHighlightSelector: false,	
	
	
	highlightFilterSelector: false,	
   	
    currentHighlightDS: '',
    
    
    currentBordersHighlightDS: null,
    
    
    currentHighlightFilterDS: null,
    
    
    currentHighlightRestriction: null,
    
    currentLabelsDS: '',
    
    initialized: false,
    
    legendCtrlInit: false,		// If the legend is enabled, has it been initialized
    
    dwgLoaded: false,			// Is only set to true if a drawing has been successfully loaded
    
    noneTxt: 'None',			// The None value displayed in highlight and label selectors
	
	ruleSets: null,				// An array of rule sets used for highlights, if any
	
	instructs: null,			// An object that keeps track of specified instructions, if any
	
	_delim: ';',
	
	
	_draggableAssets: [],        //asset in room to be dragged.
	
	
	_displayDiagonalSelectionPattern: false, 
											
	
	optionalPKFields: null,		// An array of optional array of full field names, to instruct the 
								// onclick handler to return that extra information.
	redmarksEnabled : false,
	
	zoomToRoom: false,
	
    liteDisplay: true,          // enables display of the current room ID in the panel title
	
	constructor:function(id, config){	
	    // Global variable used for javascript access from the flex app
		jsAccessFromFlex = this;
	
	    this.inherit(id, 'drawing', config);

	    this.swf 					= config.getConfigParameter('swf', 'abDrawing');
	    this.application 			= config.getConfigParameter('application', 'abDrawing');
	    this.bgColor 				= config.getConfigParameter('bgColor', '#dddddd');
	
		this.highlightDataSource 	= config.getConfigParameter('highlightDataSource', '');
		this.labelsDataSource 		= config.getConfigParameter('labelsDataSource', '');
		this.highlightType			= config.getConfigParameter('highlightType', '');
		this.thematicHighlightStyle = config.getConfigParameter('thematicHighlightStyle', '');
		this.projectionType			= config.getConfigParameter('projectionType', 'tiled');
		this.columnsGroupedBy		= config.getConfigParameter('columnsGroupedBy', '');
		//this.highlightValueField	= config.getConfigParameter('highlightValueField', ''); not currently supported
		this.assetTypes				= config.getConfigParameter('assetTypes', '');
		this.legendPanel			= config.getConfigParameter('legendPanel', '');
		this.borderHighlightLegendPanel = config.getConfigParameter('borderHighlightLegendPanel', '');
		
		this.initialData			= config.getConfigParameter('initialData', '');
		this.multiple				= config.getConfigParameter('multiple', '');
		this.selectionMode			= config.getConfigParameter('selectionMode', '2');
		this.multipleSelectionEnabled = config.getConfigParameter('multipleSelectionEnabled', 'true');
		this.assignMode				= config.getConfigParameter('assignMode', '0');
		this.toolbarSettings		= config.getConfigParameter('toolbarSettings', '');
		
		this.bordersHighlightSelector = config.getConfigParameter('bordersHighlightSelector', 'false');
		this.highlightFilterSelector = config.getConfigParameter('highlightFilterSelector', 'false');
        this.showLegendOverlay = config.getConfigParameter('showLegendOverlay', false);

		if (!valueExistsNotEmpty(this.selectionMode))
			this.selectionMode = '2';
					  
        // Initialize the configuration object
		this.initConfig();
		this.localize();
		this.currentHighlightDS = this.highlightDataSource;
		this.currentLabelsDS = this.labelsDataSource;

		// add listener for afterResize()
		this.addEventListenerFromConfig('afterResize', config);
	},
				
	initConfig:function(){
    	AdminService.getDrawingControlConfig({
        	callback: function(ob){
        		var a = jsAccessFromFlex;
        		a.dwgConfig = ob;
        		gAcadColorMgr.setAssignedInitConfig(ob.highlights);
        		gAcadColorMgr.setUnassignedInitConfig(ob.highlights);
        		gAcadColorMgr.setSelectedInitConfig(ob.highlights);
        		gAcadColorMgr.setNoFillInitConfig(ob.highlights);

        		// add the default assigned color as the first auto assigned color
        		// then add the rest of auto colors.
        		var autoColors = new Array();
        		autoColors[0] = '0x' + gAcadColorMgr.getRGB(ob.highlights.assigned.fill.color, true, true);
        		var index = 1;
        		for (var i=0;i<ob.autoAssignColors.length;i++){
        			//do not add the auto color if it is the same as the default assigned color
        			if(ob.autoAssignColors[i].toLowerCase() != autoColors[0].toLowerCase()){
        				autoColors[index] = ob.autoAssignColors[i];
        				index++;
        			}
        		}
        		gAcadColorMgr.setAutoAssignColors(autoColors);
        		
        		gAcadColorMgr.setIdealLabelTextSize(ob.idealLabelTextSize);
        		gAcadColorMgr.setMinimumLabelTextSize(ob.minimumLabelTextSize);
        		gAcadColorMgr.setShrinkLabelTextToFit(ob.shrinkLabelTextToFit);
        	},
        	
        	errorHandler: function(m, e){
            	Ab.view.View.showException(e);
       	 }
		});
	},
	
	getDrawingControl:function(){
		if(FABridge.abDrawing && FABridge.abDrawing.root())
			return FABridge.abDrawing.root();
		else
			this.getDrawingControl.defer(100);
	},
	
	localize:function() {
	   this.noneTxt = this.getLocalizedString(this.z_MESSAGE_PROMPT_NONE);
	},
	
	localizeFlash:function(){
	   // load localized strings that are used by the Flash Control itself
        var ob = new Object();
        
        ob['TB_SELECT'] = this.getLocalizedString(this.z_MESSAGE_TB_SELECT);
        ob['TB_PAN'] = this.getLocalizedString(this.z_MESSAGE_TB_PAN);
        ob['TB_ZOOMWINDOW'] = this.getLocalizedString(this.z_MESSAGE_TB_ZOOMWINDOW);
        ob['TB_ZOOMIN'] = this.getLocalizedString(this.z_MESSAGE_TB_ZOOMIN);
        ob['TB_ZOOMOUT'] = this.getLocalizedString(this.z_MESSAGE_TB_ZOOMOUT);
        ob['TB_ZOOMEXTENTS'] = this.getLocalizedString(this.z_MESSAGE_TB_ZOOMEXTENTS);
        ob['TB_AUTOCENTER'] = this.getLocalizedString(this.z_MESSAGE_TB_AUTOCENTER);
        ob['TB_ISO'] = this.getLocalizedString(this.z_MESSAGE_TB_ISO);
        ob['TB_RESETASSETS'] = this.getLocalizedString(this.z_MESSAGE_TB_RESETASSETS);
        ob['TB_CLEARASSETS'] = this.getLocalizedString(this.z_MESSAGE_TB_CLEARASSETS);
        
        ob['PROMPT_ERROR'] = this.getLocalizedString(this.z_MESSAGE_PROMPT_ERROR);
        ob['PROMPT_NODOC'] = this.getLocalizedString(this.z_MESSAGE_PROMPT_NODOC);
        ob['PROMPT_UNABLETOLOAD'] = this.getLocalizedString(this.z_MESSAGE_PROMPT_UNABLETOLOAD);    
             
        ob['PROMPT_SELECTEDROOM']  = this.getLocalizedString(this.z_MESSAGE_PROMPT_SELECTEDROOM);
        ob['PROMPT_ALREADYASSIGNEDTO'] = this.getLocalizedString(this.z_MESSAGE_PROMPT_ALREADYASSIGNEDTO);
        
        return ob;
	},

    getContainerElementId: function() {
        return this.parentElementId + '_container';
    },
	
	initialDataFetch: function() {
		this.appendDatasourceSelectors();

		FABridge.addInitializationCallback(this.application, this.initAfterLoad);

        if(window.addEventListener) {
            var eventType = (navigator.userAgent.indexOf('Firefox') !=-1) ? "DOMMouseScroll" : "mousewheel";            
            window.addEventListener(eventType, handleWheel, false);
            dwgControlId = this.application;
        }

		var containerHtml = '<div id="' + this.getContainerElementId() + '"></div>';
        if (this.parentEl.first()) {
            Ext.DomHelper.insertHtml('afterEnd', this.parentEl.first().dom, containerHtml);
        } else {
            Ext.DomHelper.insertHtml('afterBegin', this.parentEl.dom, containerHtml);
        }

		var fullPath = View.contextPath + "/schema/ab-core/controls/drawing/" + this.swf;
		this.runContent(
				"src", fullPath,
				"width", "100%",
				"height", "100%",
				"align", "middle",
				"id", this.application,
				"quality", "high",
				"bgcolor", this.bgColor,
				"name", this.application,
				"flashvars", "bridgeName="+this.application,
				"allowScriptAccess","sameDomain",
				"type", "application/x-shockwave-flash",
				"wmode", "window", //opaque cause the mousewheel not working in IE and Chrome
				"pluginspage", "http://www.adobe.com/go/getflashplayer"
		);		

        this.visible = true;
        // show|hide the panel instructions
        if (this.getInstructionsEl()) {
            this.showElement(this.getInstructionsEl(), true);
        }
	},

    afterResize: function() {
        this.syncHeight();
    },

    
    syncHeight: function() {
        if (Ext.get(this.getContainerElementId())) {
            var availableHeight = this.determineHeight() - this.getActionbarHeight() - this.getInstructionsHeight() - 2;
            Ext.get(this.getContainerElementId()).setHeight(availableHeight);
        }
    },

    
    refresh: function(restriction) {
    	if (valueExists(restriction)) {
    		var dcl = new Ab.drawing.DwgCtrlLoc(restriction);
	    	if (dcl.containsFloor()) {
	    		this.clear();
				this.addDrawing(dcl);
			}
        }
        this.applyDS('labels');
        this.applyDS('highlight');
    },
    
    // ----------------------- export report selection --------------------------------------------------
    
    callReportJob: function(reportProperties){
    	var outputType = reportProperties.outputType, printRestriction = reportProperties.printRestriction, orientation = reportProperties.orientation;
    	if(outputType === 'docx'){
    		var doIt = confirm(View.getLocalizedString(this.z_DRAWING_PRINTING));
    		if(!doIt) return;
    		
    		var parameters = {};
    		if(valueExists(printRestriction) && valueExists(this.restriction)){
				parameters.printRestriction = printRestriction;
				parameters.restriction = toJSON(this.restriction);
			}
			if(valueExistsNotEmpty(orientation)){
				parameters.orientation = orientation;
			}
			
    		var reportTitle = this.title;
    		if(reportTitle==''){
    			reportTitle = Ab.view.View.title;
    		}
    		return this.callDOCXReportJob(reportTitle, null, parameters);
    	}else if(outputType === 'xls'){
    		//no translatable since it's only for viwew designers.
    		View.showMessage('error', 'XLS action is NOT supported for a Drawing panel.');
    	}
    	return null;
    },
    
	callDOCXReportJob: function(title, restriction, parameters){
		var viewName = this.config.viewDef + '.axvw'; 
		if(valueExists(parameters) && valueExists(parameters.printRestriction)){
			//TODO: check
			parameters.dataSourceId = this.highlightDataSource;
		}
		
		//drawing image will occupy whole page
		parameters.fullPage = true;
		
		return Workflow.startJob("AbSystemAdministration-generatePaginatedReport-buildDocxFromChart", viewName, this.getImageBytes(), title, parameters);
	},
	
    //TODO: refactoring js and UploadMgr.as to make createImage() and getImageBytes()
    //simpler and more efficiency
    getImageBytes:function(){	
    	var quality = 100;
    	var result = [];
    	var arTmp = null;
    	//XXX: createImage() hold browser's JS engine???
    	//var arInfo = FABridge.abDrawing.root().createImage("JPG", quality, true);
    	var arInfo = FABridge.abDrawing.root().createImage("PNG", quality, true);	
    	var size = arInfo[0];
    	var max = arInfo[1];

    	for (var iPos = 0; iPos < size; iPos += max){
    		var arTmp = FABridge.abDrawing.root().getImageBytes(iPos);
    		if (arTmp != null) {
    			for (var k = 0, l = 0; k < arTmp.length && l < size; k++, l++){
    				result[iPos + k] = arTmp[k];
    			}
    		 } else{
    			iPos = size;
    		 }
    	}
    	return result;
	 },
	 
	 //------------------------------------ end of report section ----------------------------------------------------------
	 
	clear:function(){
		FABridge.abDrawing.root().removeAllDrawings('');
	},
	
	getSelectedAssetIds:function() {
		return FABridge.abDrawing.root().getSelectedAssetIds();
	},
	
	initAfterLoad: function()
	{
		var a = jsAccessFromFlex;
		a.onLoadHandler();
		a.initialized = true;
		// Initialize the isometric setting in the viewer
		a.isometric((a.projectionType == 'isometric'), false);
		if (a.onLoadDcl != null) {
			var opts = new DwgOpts(a.onLoadOpts);
			if(a.zoomToRoom){
				FABridge.abDrawing.root().findRoom(a.onLoadDcl,opts);
			} else {				
				a.addDrawing(a.onLoadDcl, opts);
			}			
		} else if (a.initialData.length) {
			var dcl = new Ab.drawing.DwgCtrlLoc();
			dcl.setFromArray(eval(a.initialData));
			a.initialData = '';
			a.addDrawing(dcl);
		} else if (a.roomToHighlight){
			a.highlightAssets(a.roomToHighlight);
		}
		if(a.redmarksEnabled){
			a.enableRedmarks();
		} else {
			a.disableRedmarks();
		}
	},
	
	
	addDrawing:function(dcl, optsIn){
		if (!valueExists(dcl))
			return;
			
		if (!this.initialized) {
		    dcl = new Ab.drawing.DwgCtrlLoc(dcl);
			this.onLoadDcl = dcl;
			this.onLoadOpts = optsIn;
			return;
		}

		var load = true;
		
		if (valueExists(dcl.row))
	 		load = dcl.row.isSelected();
		
		if (!valueExists(dcl.pks))
			dcl = new Ab.drawing.DwgCtrlLoc(dcl);

	
		if(load){		
			var pkId = dcl.getPkValueString();
			var opts = new DwgOpts(optsIn);	// set default options
			if (valueExistsNotEmpty(pkId))
				opts.highlightId = pkId;
			if (!this.assetTypes == '')
				opts.assetTypes = this.assetTypes;
			if (this.multiple == 'false')
				opts.multiple = false;

			FABridge.abDrawing.root().addDrawing(dcl, opts);
		} else {
			this.removeDrawing(dcl);
		}
		
		return true;
	},

	
	
	removeDrawing:function(value){
		FABridge.abDrawing.root().removeDrawing(value);	
	},	

	
	clearHighlights:function(){
		FABridge.abDrawing.root().clearRooms();
	},
	
	
	isometric:function(isometric, apply){
		FABridge.abDrawing.root().setIsometric(isometric, apply);		
	},
	
	
	setSelectColor:function(color) {
		FABridge.abDrawing.root().setSelectColor(color);
	},
	
	
	setToAssign:function(field, val, color) {
		FABridge.abDrawing.root().setToAssign(field, val, color);
	},
	
	
	unassign:function(field, val) {
		FABridge.abDrawing.root().unassign(field, val);
	},
	
	
		
	findAsset:function(ob, opts, zoomToId, loadDwg, bSelected) {
		var opts = new DwgOpts(opts);
		var dcl = new Ab.drawing.DwgCtrlLoc(ob);
		
		if (valueExists(ob.row)) {		
			if (valueExists(bSelected)) {
				if (!bSelected)
					opts.mode = 'unselected';
			}
			else if (!row.row.isSelected())
				opts.mode = 'unselected';
		} 
		
		var pkId = dcl.getPkValueString();
		if (valueExists(pkId)) {
			opts.appendRec(pkId);
			opts.highlightId = pkId;
		}
		
		opts.dwgName = dcl.toArray(true);
		if (valueExists(zoomToId))
			opts.zoomToId = zoomToId;
		if (valueExists(loadDwg))
			opts.forceload = loadDwg;
		opts.exclusive = true;
		
		if (!this.initialized) {
			this.zoomToRoom = true;
			this.onLoadDcl = dcl;
			this.onLoadOpts = opts;
		} else {
			FABridge.abDrawing.root().findRoom(dcl, opts);
		} 
		
		return true;
	},	
	
		
	highlightAssets:function(optsIn, rows) {
		// if it is a single row, make it an array to support backward compatibility.
		if (valueExists(rows) && Object.prototype.toString.call(rows) != '[object Array]'){
	 		rows = [rows];
	 	}
	 	
		
	 	if(valueExists(rows) && rows.length > 0) {
		 	//retrieve all the drawing names from the rows as an array
		 	var drawingNamesAndNumbers = this.getDrawingNamesFromRows(rows);
		 	
		 	//looping through each drawing, highlight them.
			for(var index = 0; index < drawingNamesAndNumbers.length; index++){
				var drawingNameCount = drawingNamesAndNumbers[index];
	
				//defer each highlightAsset calling based on the number of records (each record is give 30 milliseconds).
				this.highlightAssetsForDrawing.defer(30*drawingNameCount.count, this.highlightAssetsForDrawing, [optsIn, rows, drawingNameCount.name, this.assetTypes, this.multiple]);
			}
	 	} else {
	 		//fix for kb#3038096 - highlight when no rows are passed (the records are passed from optsIn.recs value)
	 		var opts = new DwgOpts(optsIn);
			opts.zoomToId = false;	// is not supported in highlight mode, ensure is off
		    
			FABridge.abDrawing.root().highlightAssets(opts);
			return true;
	 	}
	 	
	 },

		
	highlightAssetsForDrawing:function(optsIn, rows, drawingName, assetTypes, multiple){
	
		 	var opts = new DwgOpts(optsIn);
			
			//set assetTypes for non-room assets
			if (assetTypes)
				opts.assetTypes = assetTypes;
	
			//set if the multiple assets can be displayed on the drawing.
			if (multiple == 'false')
				opts.multiple = false;
	
			// zooming to id is not supported in highlight mode, ensure is off
			opts.zoomToId = false;	
	
			//record the first row of the specified drawing
			var firstIndex = 0;
			
			//append the each row's record into drawing option object
			var numberOfRows = 0;
			for(var i = 0; i < rows.length; i++){	
		 		var dcl = new Ab.drawing.DwgCtrlLoc();
		 		dcl.setFromCtrlOb(rows[i], rows[i].row.isSelected());
		 		var id = dcl.getPkValueString();
		 		if (id && id.length>0 && valueExists(dcl.dwgname) && drawingName==dcl.dwgname.toLowerCase()) {
	 		 		var fl_id = '';
	 		 		var bl_id = '';
	 		 		for (var name in rows[i].row.record) {
	 					if (name.indexOf('.bl_id') >= 0)
	 						bl_id = rows[i].row.record[name];
	 					else if (name.indexOf('.fl_id') >= 0)
	 						fl_id = rows[i].row.record[name];
	 				}
	 		 		
	 		 		if(numberOfRows==0)
	 		 			firstIndex = i;
	 		 		
	 		 		opts.appendRecNonRm(bl_id, fl_id, id);
	 		 		numberOfRows++;
	 			}
			}
		 	
			if (!valueExists(opts.mode))
				opts.mode = rows[firstIndex].row.isSelected() ? 'selected' : 'unselected';
			
			if (valueExists(drawingName))
			    opts.rawDwgName = drawingName;
	
			//call highlightAssets function once.
			// YQ - Do not use the getDrawingControl() function.
			FABridge.abDrawing.root().highlightAssets(opts);
				
			return numberOfRows;

	},
	
	
	
	getDrawingNamesFromRows:function(rows){
	
	 	var drawingNames = new Array();
	 	var numberOfRows = new Array();
	 	
	 	//loop through the rows to store new drawing names and its counts
		for(var i = 0; i < rows.length; i++){	
	 		var dcl = new Ab.drawing.DwgCtrlLoc();
	 		dcl.setFromCtrlOb(rows[i], rows[i].row.isSelected());
	 		
	 		// add the drawing name if not yet.
	 		if (valueExists(dcl.dwgname)){
	 			if(drawingNames.indexOf(dcl.dwgname) == -1){
	 				drawingNames.push(dcl.dwgname.toLowerCase());
	 				numberOfRows.push(0);
	 			}
	 			
	 			//increment the number of records for the specified drawing name
	 			var index = drawingNames.indexOf(dcl.dwgname);
	 			numberOfRows[index] = numberOfRows[index]+1;
	 		}
		}
		
		//add the drawing name and count object into the array
		var drawingNamesAndNumbers = new Array();
		for(i = 0; i < drawingNames.length; i++){
			var dwgNameCount = new Object();
			dwgNameCount.name = drawingNames[i];
			dwgNameCount.count = numberOfRows[i];
			drawingNamesAndNumbers.push(dwgNameCount); 
		}
		
		return  drawingNamesAndNumbers;
	},
	
	
	highlightAssetsFromDcl:function(optsIn, dcl) {
	 	var opts = new DwgOpts(optsIn);
 		
 		var s = dcl.getPkValueString();
 		if (!s.length)
 			return false;
 		
		opts.appendRec(s);
		if (valueExists(dcl.dwgname))
			opts.rawDwgName = dcl.dwgname;
		
		opts.zoomToId = false;	// is not supported in highlight mode, ensure is off
		if (!this.initialized) {
			this.roomToHighlight = opts;
		} else {
			FABridge.abDrawing.root().highlightAssets(opts);
		}		
		return true;
	},
	
	clearPersistFills:function() {
		FABridge.abDrawing.root().clearPersistFills();
	},
	
		
	setSelectability:function(opts, selectable)
	{
		FABridge.abDrawing.root().makeAssetsSelectable(opts, selectable);
	},
	
	labelData: null,
	
		
	setLabels:function(loc, opts, mode) {
		this.labelData = new Array();
		this.labelData[0] = loc;
		this.labelData[1] = opts;
		this.labelData[2] = mode;
		FABridge.abDrawing.root().applyLabels();
	},
	
	getLabelData:function() {
		return this.labelData;
	},
	
	appendNofillValue: function(val, fill) {
		if (!valueExists(this.nofillValues))
			this.nofillValues = new Array();
		var ob = new Object();
		ob.value = val;
		ob.fill = fill;
		this.nofillValues[this.nofillValues.length] = ob;
	},
	
	appendInstruction: function(ctrlId, eventName, msg, onlyIfDwgLoaded) {
		var instr = new DwgInstruction(ctrlId, eventName, msg, onlyIfDwgLoaded);
		if (!valueExists(this.instructs))
			this.instructs = new Object();
		this.instructs[ctrlId+eventName] = instr;
	},
	
 	
	clearAssignCache: function(resetColors) {
		if (resetColors == true)
			gAcadColorMgr.reset();
		FABridge.abDrawing.root().clearAssignCache();
	},
	
 	
 	toolbarCmd: function(buttonName) {
 		FABridge.abDrawing.root().toolbarCmd(buttonName);
 	},
	
 	
 	getDataSource: function(type, dataSourceName){
 		if(valueExistsNotEmpty(dataSourceName) && dataSourceName != 'None'){
 			return View.dataSources.get(dataSourceName);	
 		}
 		
 		if (type == 1 && valueExistsNotEmpty(this.labelsDataSourcePanel)){
 			var contentFrame = View.panels.get(this.labelsDataSourcePanel).getContentFrame();
 			var contentView = contentFrame.View;
 			var labelDS = contentView.dataSources.get(this.getDSName(type));
 			return new Ab.data.DataSource(this.getDSName(type), labelDS.config);
 			
 			//return contentView.dataSources.get(this.labelsDataSource); 			
 		} else if (type == 2 && valueExistsNotEmpty(this.highlightDataSourcePanel)){
 			var contentFrame = View.panels.get(this.highlightDataSourcePanel).getContentFrame();
 			var contentView = contentFrame.View;
 			var hlDS = contentView.dataSources.get(this.getDSName(type));
 			return new Ab.data.DataSource(this.getDSName(type), hlDS.config);
 			
 			//return contentView.dataSources.get(this.highlightDataSource);
 		} 	 	
 		
		return View.dataSources.get(this.getDSName(type));	
 	},
 	
  	currentRecSet: null,
 
 	
 	getDataSourceRecords: function(type, pks, datasourceName, runTimeRestriction){
 		var dsName = this.getDSName(type);
 		if(valueExistsNotEmpty(datasourceName)){
 			dsName = datasourceName;
 		}
 		var ds = View.dataSources.get(dsName);
 		
 		var restriction = null;
 		
 		
 		var loc = this.getPkFieldNames(ds);
 	
 		//
 		// Note: Current implementation of pks Array
 		//			pks[n] == fieldname
 		//			pks[n + 1] == value
 		//
 		if (valueExistsNotEmpty(pks)){
 			restriction = new Ab.view.Restriction();
 			// <clause relop="AND" op="=" value="HQ" name="bl_id" table="rm"/>
 			// addClause: function(name, value, op, replace) {
 			
 			// Note: the field value used is the one from the datasource
 			//		 Ignoring values passed in from the flash component
 			var j = 1;
 			for (var i = 0; j < pks.length; i++) {
 				restriction.addClause(loc.pks[i], pks[j], "=", true);
 				j += 2;
 			}
 		}

 		try {
 			if(valueExistsNotEmpty(this.currentHighlightRestriction)){
 				if(valueExistsNotEmpty(restriction)){
 					//allow overwritting
 					restriction.addClauses(this.currentHighlightRestriction, true, false);
 				}else{
 					restriction = this.currentHighlightRestriction;
 				}
 			}
			// Always retrieve all records
	 		if(ds != null){
	 			if(valueExistsNotEmpty(this.currentHighlightFilterDS) && this.currentHighlightFilterDS != 'None'){
	 				
	 				var datasource = View.dataSources.get(this.currentHighlightFilterDS);
	 				if(datasource !== null){
	 					var records = datasource.getRecords(restriction, { recordLimit: 0 });
	 					var filterRestriction = this.getFilterRestriction(datasource, records);
	 					if(filterRestriction.length > 0){
	 						if(valueExistsNotEmpty(restriction)){
	 		 					for(var i=0; i<filterRestriction.length; i++){
	 		 						filterRestriction[i].addClauses(restriction, false, false);
	 		 					}
	 		 				}
	 						restriction = filterRestriction;
	 					}
	 				}
	 			}
	 			
	 			if(restriction!=null && valueExistsNotEmpty(runTimeRestriction)){
	 				restriction.addClauses(runTimeRestriction, true, false);
	 			}else if(restriction == null && valueExistsNotEmpty(runTimeRestriction)){
	 				restriction = runTimeRestriction;
	 			}
	 			this.currentRecSet = ds.getRecords(restriction, { recordLimit: 0 });
	 		}
	 		return this.currentRecSet;
		} catch (e) {
			this.handleError(e);
		}
 	},
 	
	query: function(type, pks, datasourceName, restriction){
 		this.getDataSourceRecords(type, pks, datasourceName, restriction);
 		return (this.currentRecSet != null) ? this.currentRecSet.length : 0;
 	},
 	
 	getRecValues: function(pos)
 	{
 		if (this.currentRecSet == null || pos >= this.currentRecSet.length)
 			return null;
 			
 		return this.currentRecSet[pos].values;
 	},
 
 	getDSName:function(type)
 	{
 		// Note: A type of 0 == NONE
  		var dsName = "";
 		if (type == 1)	// Labels
 			dsName = this.currentLabelsDS;
 		else if (type == 2)	// Hilite
 			dsName = this.currentHighlightDS;
 		return dsName;
 	},
 	
 	getColumnsGroupedBy:function()
 	{
 		return this.columnsGroupedBy;
 	},
 	
 	getDwgConfig: function() {
 		return toJSON(this.dwgConfig);
 	},
 	
 	getAcadColor: function(colorNum)
 	{
 		return gAcadColorMgr.getRGB(colorNum);
 	},
 	
 	getColorFromValue: function(fullfield, val, asHex, ruleVal) {
 		var color = "";
 		if (this.ruleSets != null && valueExists(ruleVal)) {
 			var ruleSet = this.ruleSets[this.currentHighlightDS];
 			if (valueExists(ruleSet)) {
 				color = ruleSet.getColorFromValue(fullfield, ruleVal);
 				if (valueExists(color))	// is a hex string at this point
 					color = "" + parseInt("0x" + color, 16);
 			}
 		}
 		if (!valueExistsNotEmpty(color))
 			color = gAcadColorMgr.getColorFromValue(fullfield, val, asHex);
 		return color;
 	},
 	
 	decodePattern: function(patternString) {
 		var parameters = {
            "patternString": patternString
        };
        
        try {
            var result = Workflow.call('AbCommonResources-HighlightPatternService-decodePattern', parameters);
        } 
        catch (e) {
            Workflow.handleError(e);
        }
        
        var res = eval("(" + result.jsonExpression + ")");
        res.color = parseInt(res.rgbColor, 16);
        
        return res;
        //return { color: parseInt("ff0000", 16) };
 	},
 	
 	getColorFromPattern: function(pattern, asHex) {
 		return gAcadColorMgr.getRGBFromPattern(pattern, asHex);
 	},
 	
 	getUnassignedColor: function(asHex) {
 		return gAcadColorMgr.getUnassignedColor(asHex);
 	},
 	
 	getNofillField: function() { 
 		return this.nofillField;
 	},
 	
 	getNofillValues: function() {
 		return this.nofillValues;
 	},
 	
 	getHighlightRuleValueField: function() {
 		var s = "";
 		if (this.ruleSets != null) {
 			var ruleSet = this.ruleSets[this.currentHighlightDS];
 			if (valueExists(ruleSet))
 				s = ruleSet.getField();
 		}
 		return s;
 	},
 	
 	getDelim: function() {
 		return this._delim;
 	},
 	
 	
 	getDraggableAssets:function(){
 		return this._draggableAssets;
 	},
 	
 	setDraggableAssets: function(draggableAssets){
 		this._draggableAssets = draggableAssets;
 	},
 	
 	
 	setDiagonalSelectionPattern:function(isDiplayed){
 		this._displayDiagonalSelectionPattern = isDiplayed;
 	},
 	
 	
 	getDiagonalSelectionPattern:function(){
 		return this._displayDiagonalSelectionPattern;
 	},
 	
 	getHighlightSettings: function() {
 		var ob = new Object();
 		ob.highlightType = this.highlightType;
 		ob.thematicHighlightStyle = this.thematicHighlightStyle;
    	return ob;
 	},
 	
 	getToolbarSettings: function() {
 		return this.toolbarSettings;
 	},
 	
 	getOptionalPkFields: function() {
 		return this.optionalPKFields;
 	},
 	
 	onClickHandler: function(pks, selected, color)
 	{
 		this.processInstruction(this.id, "onclick");
	    var listener = this.getEventListener('onclick');
	    if (listener != null){
	        listener(pks, selected, color);
	     }
 	},

 	
 	onMultipleSelectHandler: function()
 	{
 		//only allow multiple select if 'multipleSelectionEnabled' is true
 		if(!this.multipleSelectionEnabled)
 			return;
 		
 		this.processInstruction(this.id, "onMultipleSelectionChange");
	    
 		var listener = this.getEventListener('onMultipleSelectionChange');
	    if (listener != null){
	        listener();
	     } 
 	},
 	
 	
 	isMultipleSelectHandlerDefined: function(){
 		var handlerDefined = false;
 		
 		if(this.multipleSelectionEnabled && this.getEventListener('onMultipleSelectionChange') != null){
 			handlerDefined = true;
 		}

 		return handlerDefined;
 	
 	},
 	
 	
 	getMultipleSelectedAssets:function()
 	{
 		return FABridge.abDrawing.root().getMultipleSelectedAssets();
 	},
 	
 	
 	getAssignedValue:function()
 	{
 		return FABridge.abDrawing.root().getAssignedValue();
 	},
 	
 	
 	getAssignOneToManyAssets:function()
 	{
 		return FABridge.abDrawing.root().getAssignOneToManyAssets();
 	},
 	
 	onResetAssetsHandler: function()
 	{
 		var listener = this.getEventListener('onresetassets');
	    if (listener != null)
	        listener(); 
 	},
 	
 	onLoadHandler: function()
 	{
 		var listener = this.getEventListener('onload');
	    if (listener != null)
	        listener(); 
	        
	    this.processInstruction("default", "");
 	},
 	
 	onDatasourceChanged: function(type)
 	{
 		this.onDsChange('ondatasourcechanged', type);
 	},
 	
 	onSelectedDatasourceChanged: function(type)
 	{
	    this.onDsChange('onselecteddatasourcechanged', type);	
 	},
 	
 	onDsChange: function(funcname, type)
 	{
 		this.listenerHandler(funcname, type, this.getDSName(((type == 'highlight') ? 2 : 1)));
 	},
 	
 	listenerHandler: function(name, arg1, arg2)
 	{
 		var listener = this.getEventListener(name);
	    if (listener != null)
	        listener(arg1, arg2); 
 	},
 	
 	onHighlightsChanged: function()
 	{
  		var listener = this.getEventListener('onhighlightschanged');
	    if (listener != null)
	        listener(this.getDSName(2)); 
 	},
 	
    enableLiteDisplay: function(enabled) {
        this.liteDisplay = enabled;
 	},
 	
 	setLiteDisplay: function(pks)
 	{
 		// Only set if instructions are not being displayed
 		if (this.instructs != null || !this.liteDisplay)
			return;
			
		var val = '';
		for (var i = 0; i < pks.length; i++)
			val += ' : ' + pks[i];
			
		this.setTitleMsg('[' + val.substr(3) + ']');
 	},
 	
 	setTitleMsg: function(msg) {
		var tn = document.getElementById(this.id + '_title');
		if (tn == null)
			return;
			
		this.setTitle(msg);	
 	},

 	
 	
 	setDrawingTitle: function(loc, txt, af) {
 		FABridge.abDrawing.root().setTitleText(loc, txt, af);
 	},
 	
 	flashAppLoaded: function()
 	{

 	},
 	
 	flashDocLoaded: function()
 	{

 	},
 	
  	
 	flashDocLoadFailed: function(ob)
 	{

 	},
 	
 	flashAssetsLoaded: function()
 	{
 		this.dwgLoaded = true;
 		this.processInstruction("ondwgload", "");
 		this.refreshLegendPanel();	// attempt to update the legend at this point after we are sure doc is fully loaded	
 	    var listener = this.getEventListener('ondwgload');
	    if (listener != null)
	        listener();
 	},
 	
 	appendRuleSet: function(dsName, ruleSet) {
 		if (this.ruleSets == null)
 			this.ruleSets = new Array();
 		ruleSet.ds = dsName;
 		this.ruleSets[dsName] = ruleSet;
 	},
 	
 	
 	appendDatasourceSelectors: function() {
 		if (this.toolbar) {
 	         this.toolbar.addSeparator();
 	    }

 		if (this.highlightSelector) {
 			this.appendSelector('hilite', 'DrawingControlHighlight', this.getLocalizedString(this.z_MESSAGE_HIGHLIGHTS)+":", this.highlightDataSource);
            if (this.showLegendOverlay) {
                this.appendLegendButton(this.legendPanel, false);
            }
        }
 		
 		if(this.bordersHighlightSelector){
 			//borders highlight datasource select list
 			this.appendSelector('IBorders', 'DrawingControlHighlight', this.getLocalizedString(this.z_MESSAGE_BORDERS), '');
            if (this.showLegendOverlay) {
                this.appendLegendButton(this.borderHighlightLegendPanel, true);
            }
        }

         if (this.labelSelector) {
 			this.appendSelector('labels', 'DrawingControlLabels', this.getLocalizedString(this.z_MESSAGE_LABELS) + ":", this.labelsDataSource);
        }
 		
 		if(this.highlightFilterSelector){
 			//filter datasource select list
 			this.appendSelector('IFilter', 'DrawingControlHighlight', this.getLocalizedString(this.z_MESSAGE_FILTER), '');
 		}
 		
     },

    
    appendLegendButton: function(legendPanelId, isBorderHighlight) {
        var titleNode = document.getElementById(this.id + '_title');
        if (titleNode === null){
            return;
        }

        var drawingPanel = this;

        this.addAction({
            id: 'legendButton_' + legendPanelId,
            icon: '/schema/ab-core/graphics/icons/legend.png',
            listener: function() {
                var legendPanel = View.panels.get(legendPanelId);
                if (legendPanel) {
                    legendPanel.showInWindow({
                        anchor: this.el.dom,
                        width: 300,
                        title: isBorderHighlight ?
                            drawingPanel.getLocalizedString(drawingPanel.z_MESSAGE_BORDER_HIGHLIGHTS) :
                            drawingPanel.getLocalizedString(drawingPanel.z_MESSAGE_ROOM_HIGHLIGHTS)
                    });
                    drawingPanel._refreshLegendPanel(legendPanel,
                        isBorderHighlight ?
                            drawingPanel.currentBordersHighlightDS :
                            drawingPanel.currentHighlightDS);
                    legendPanel.updateWindowHeight();
                }
            },
            separator: false
        });
    },

     
 	appendSelector: function(comboId, dsFilter, prompt, defaultVal) {
		var titleNode = document.getElementById(this.id + '_title');
		if (titleNode === null){
			return;
		}

		var datasources = this.getSelectorDatasources(dsFilter);

		if(comboId.lastIndexOf('IBorders') >= 0){
			var ds = this.getSelectorDatasources(dsFilter, 'IBorder');
			if(ds.names.length > 0){
				datasources = ds;
			}
		}else if(comboId.lastIndexOf('IFilter') >= 0){
			var ds = this.getSelectorDatasources(dsFilter, 'IFilter');
			if(ds.names.length > 0){
				datasources = ds;
			}
		}


		var names = datasources.names;
		var nameIdMap = datasources.IDs;

		// If there are 0 or 1 records, there is no need to display the combo
		if (names.length < 2){
			return;
		}

		var pn = titleNode.parentNode.parentNode;
		var cell = Ext.DomHelper.append(pn, {tag: 'td'});
		var tn = Ext.DomHelper.append(cell, '<p>' + prompt + '</p>', true);
		Ext.DomHelper.applyStyles(tn, "x-btn-text");
		cell = Ext.DomHelper.append(pn, {tag: 'td'});
		var combo = Ext.DomHelper.append(cell, {tag: 'select', id: 'selector_' + comboId}, true);
		
		names.sort();	// sort the entries
		names[names.length] = this.noneTxt;	// always include at the end of the list
		nameIdMap[this.noneTxt] = this.noneTxt;
    
		for (var i = 0; i < names.length; i++) {
			combo.dom.options[i] = new Option(names[i], nameIdMap[names[i]]);
		}
     
		combo.on('change', this.changeDS, this, {
			delay: 100,
			single: false
		}); 	
		
		if (defaultVal === ''){
			defaultVal = this.noneTxt;
		}
			
    	
		combo.dom.value = defaultVal;
 	},
 	
 	
 	getSelectorDatasources: function(dsFilter, nameFilter){
 		var results = {};
 		results.names = [];
 		results.IDs = {};
 		var dataSources = View.dataSources;
 		for (var i = 0; i < dataSources.length; i++) {
			var ds = dataSources.items[i];
			if (ds.type != dsFilter){
				continue;
			}
			var name = (ds.title == undefined) ? ds.id : ds.title;
			
			if(valueExistsNotEmpty(nameFilter)){
				if((nameFilter==='IFilter' &&  ds.id.indexOf('iFilter') >= 0 )
						||( nameFilter==='IBorder' &&  ds.id.indexOf('iBorder') >= 0)){
					results.names[results.names.length] = name;
					results.IDs[name] = ds.id;
				}
			}else{
				if(ds.id.indexOf('iFilter') >= 0 || ds.id.indexOf('iBorder') >= 0){
					continue;
				}
				results.names[results.names.length] = name;
				results.IDs[name] = ds.id;
			}
		
 		}
 		return results;
 	},
 	
 	
 	changeDS: function(e, combo) {
 		var tmp = combo.value;
 		var type = '';
		if (combo.id.lastIndexOf('hilite') >= 0) {
			if (tmp === this.currentHighlightDS){
				return;
			}
				
	    	this.currentHighlightDS = tmp;
	    	type = 'highlight';
	    }else if(combo.id.lastIndexOf('IBorders') >= 0){
	    	if (tmp === this.currentBordersHighlightDS){
				return;
			}
			//set currentBordersHighlightDS
	    	this.currentBordersHighlightDS = tmp;
	    	type = 'bordersHighlight';
	    }else if (combo.id.lastIndexOf('labels') >= 0) {
	    	if (tmp === this.currentLabelsDS){
	    		return;
	    	}
	    		
	    	this.currentLabelsDS = tmp;
	    	type = 'labels'
	    }else if(combo.id.lastIndexOf('IFilter') >= 0){
	    	if(tmp === this.currentHighlightFilterDS){
	    		return;
	    	}
	    	
	    	this.currentHighlightFilterDS = tmp;
	    	this.doFilterRestriction();	
	    }else{
	    	return;
	    }
	    	
	    	
	    this.onSelectedDatasourceChanged(type);
	    
	    this.applyDS(type);
 	},
 	
 	 
    setDataSource: function(type, dataSourceId) {
        if (type === 'highlight') {
            this.currentHighlightDS = dataSourceId;
            this.applyDS('highlight');
            document.getElementById('selector_hilite').value = dataSourceId;

        } else if (type === 'labels') {
            this.currentLabelsDS = dataSourceId;
            this.applyDS('labels');
            document.getElementById('selector_labels').value = dataSourceId;
        }
    },
 	
 	//When user selects highlight dataSource from comblist, apply the change into drawing
 	applyDS: function(type, roomHighlightDS, bodersHighlightDS) {
 		
 		if (valueExists(roomHighlightDS))
 			this.currentHighlightDS = roomHighlightDS;
 		
 		if (valueExists(bodersHighlightDS))
 			this.bodersHighlightDS = bodersHighlightDS;
 		
		if (type === 'highlight'){
			this.clearLegendPanel();
			this.doHighlight(this.currentHighlightDS, this.currentBordersHighlightDS);
			this.refreshLegendPanel();
		}else if(type ===  'bordersHighlight'){
			this.clearBorderHighlightLegendPanel();
			this.doHighlight(this.currentHighlightDS, this.currentBordersHighlightDS);
			this.refreshBorderHighlightLegendPanel();
		}else{
			FABridge.abDrawing.root().applyDS(type);	
		}
			
 		this.onDatasourceChanged(type);
	},
	
	
	doHighlight: function(roomHighlightDS, bodersHighlightDS){
		FABridge.abDrawing.root().applyDS('highlight', roomHighlightDS, bodersHighlightDS);	
	},
	
	
	doFilterRestriction: function(){
		this.clearLegendPanel();
		this.clearBorderHighlightLegendPanel();
		this.doHighlight(this.currentHighlightDS, this.currentBordersHighlightDS);
		this.refreshLegendPanel();
		this.refreshBorderHighlightLegendPanel();
	},
	
	
	getFilterRestriction: function (datasource, records){
		var result = [];
		if(datasource !== null){
			if(records.length > 0){
				var fieldDefs = [];
				datasource.fieldDefs.each(function (fieldDef) {
					 if (fieldDef.primaryKey) {
						 fieldDefs.push(fieldDef);
					 }
	        	});
				for (var i = 0; i < records.length; i++) {
					var restriction = new Ab.view.Restriction();
					for (var j = 0, pkField; pkField = fieldDefs[j]; j++) {
						   var pkValue = records[i].getValue(pkField.fullName);
						   restriction.addClause(pkField.fullName, pkValue, "=", true);
					}
					result.push(restriction);
				}
			}
		}
	
		return result;
	},
	
	
	setHighlightRestriction: function(highlightRestriction){
		this.currentHighlightRestriction = highlightRestriction;
	},
	
	
	applyHighlightRestriction: function(highlightRestriction){
		this.setHighlightRestriction( highlightRestriction);
		this.doHighlight(this.currentHighlightDS, this.currentBordersHighlightDS);
	},
	
	
	enableAssetPanel: function(assetType, title, datasourceName, configOptions){
		var actions = []
		if(valueExists(configOptions)){
			if(valueExists(configOptions.actions)){
				for(var i=0; i<configOptions.actions.length; i++){
					var action = configOptions.actions[i];
					var actionID = (assetType + action.title).replace(/\s/g, "");
					this.addEventListener(actionID, action.handler);
					var newAction = {title:action.title, actionID:actionID};
					if(action.icon){
						newAction.icon = action.icon;
					}
					actions.push(newAction);
				}
				configOptions.actions = actions;
			}
		}
	
		FABridge.abDrawing.root().enableAssetPanel(assetType, title, datasourceName, configOptions);
	},

	
	onAssetPaneltitleBarAction: function(actionID, dataSourceName){
		 this.processInstruction(this.id, actionID);
		 var listener = this.getEventListener(actionID);
	     if (listener != null){
	        listener(dataSourceName);
	     }
	},
	
	
	addAssetPanelRowAction:function(actionConfig){
		 var actionID = (actionConfig.type + actionConfig.title).replace(/\s/g, "");
		 this.addEventListener(actionID, actionConfig.handler);
		 actionConfig.actionID = actionID;
		FABridge.abDrawing.root().addAssetPanelRowAction(actionConfig);
	},
	
	addAssetPanelRowActions:function(actionConfigs){
		for(var i=0; i<actionConfigs.length; i++){
			this.addAssetPanelRowAction(actionConfigs[i]);
		}
	},
	
	onAssetPanelRowAction: function(actionID, record, dataSourceName){
		 this.processInstruction(this.id, actionID);
		 var listener = this.getEventListener(actionID);
	     if (listener != null){
	        listener(record, dataSourceName);
	     }
	},
	
	
	refreshAssetPanel: function(assetType, restriction){
		FABridge.abDrawing.root().refreshAssetPanel(assetType, restriction);
	},
	
	
	closeAssetPanel: function(assetType){
		FABridge.abDrawing.root().closeAssetPanel(assetType);
	},
	
	
	showAssetPanel: function(assetType){
		FABridge.abDrawing.root().showAssetPanel(assetType);
	},
	
	
	onAssetLocationChangeHanlder: function(record, type){
		this.processInstruction(this.id, "onAssetLocationChange");
	    var listener = this.getEventListener('onAssetLocationChange');
	    if (listener != null){
	        return listener(record, type);
	    }
	},
	
	
	unselectAssets: function(ids){
		FABridge.abDrawing.root().unselectAssets(ids);
	},
	
	selectAssets: function(ids){
		FABridge.abDrawing.root().selectAssets(ids);
	},
	
	
	 
	 addContextMenuAction: function(title, callBackFunction){
		 var actionID = title.replace(/\s/g, "");
		 this.addEventListener(actionID, callBackFunction);
		 FABridge.abDrawing.root().addContextMenuAction(title, actionID);
	 },
	 
	 onContextMenuAction: function(actionID, record){
		 this.processInstruction(this.id, actionID);
		 var listener = this.getEventListener(actionID);
	     if (listener != null){
	        listener(record);
	     }
	 },
	
	
 	
	
	_refreshLegendPanel: function(legendPanel, dataSourceName) {
        if (this.showLegendOverlay && !legendPanel.isShownInWindow()) {
            return;
        }

		legendPanel.show(true);
		legendPanel.clear();
		
		var i = 0;
 		var items = null;
 		var map = new Object();
 		var ruleSet = null;
 			
 		// If there is a ruleset, use it to define the legend
  		if (this.ruleSets != null) {
 			ruleSet = this.ruleSets[dataSourceName];
 			if (!valueExists(ruleSet)) {
 				ruleSet = null;
 			}
 		} 
 		
 		if (ruleSet == null) {
 			items = FABridge.abDrawing.root().getAppliedValueColorList(dataSourceName);

 			if (!valueExists(items)){
 				return;
 			}
 		}
 			
 		if (this.legendCtrlInit == false) {
 			legendPanel.sortEnabled = false;
  			// the color cell size is set in ab-grid.js
			// grid.columns[0].width="7";	// Reasonable size for the color column
 			this.legendCtrlInit = true;
 		}
 
 	
		for (i = 0; i < legendPanel.gridRows.length; i++){
			legendPanel.removeGridRow(0);
		}
			
		legendPanel.update();
		
		// create list to sort on
		var val = null;
		var rec = null;
		var item = null;
		var ar = new Array();
		
		legendPanel.setColorOpacity(this.getFillOpacity() * 0.8);
				
		if (ruleSet == null) {
 			for (i = 0; i < items.length; i++) {
 				val = items[i].value;
				ar[ar.length] = val;
				map[val] = i;
			}
		
			ar.sort();
 			for (i = 0; i < ar.length; i++) {
 				val = ar[i];
 				item = items[map[val]];
				this.appendGridRow(legendPanel, item.color, val);	
 			}
 		} else {	// from rules
 			if (ruleSet.isRange) {
 				for (i = 0; i < ruleSet.rules.length; i++) {
 					item = ruleSet.rules[i];
					this.appendGridRow(legendPanel, "0x" + item.color, item.getLabelOper() + " " + item.getLabel());
				}	
 			} else {
 				items = ruleSet.getNonRangeItems();
 				for (i = 0; i < items.length; i++) {
 					item = items[i];
					this.appendGridRow(legendPanel, "0x" + item.color, item.val);
 				}
 			}
 			
 			// Append the 'default'
 			item = ruleSet.defaultRule;
 			if (valueExists(item)) {
 				val = (ruleSet.isRange) ? (item.getLabelOper() + " ") : "";
 				this.appendGridRow(legendPanel, "0x" + item.color, val + item.getLabel());
			}
 		}
 		
		legendPanel.update();
	},
	
	
	refreshBorderHighlightLegendPanel: function(){
		if (!valueExistsNotEmpty(this.borderHighlightLegendPanel)){
 			return;
 		}
			
 		var grid = View.getControl("", this.borderHighlightLegendPanel);
 		if (!valueExists(grid)){
 			return;
 		}
 			
 		this._refreshLegendPanel(grid, this.currentBordersHighlightDS);
 		
	},
	
	
	clearBorderHighlightLegendPanel: function() {
		if (!valueExistsNotEmpty(this.borderHighlightLegendPanel)){
 			return;
 		}
			
 		var grid = View.getControl("", this.borderHighlightLegendPanel);
 		if (!valueExists(grid)){
 			return;
 		}
 			
 			
 		grid.clear();	
	},
	
	
	clearLegendPanel: function() {
		if (!valueExistsNotEmpty(this.legendPanel)){
 			return;
 		}
			
 		var grid = View.getControl("", this.legendPanel);
 		if (!valueExists(grid)){
 			return;
 		}
 			
 		grid.clear();	
	},
	
	
 	refreshLegendPanel: function() {
 		if (!valueExistsNotEmpty(this.legendPanel)){
 			return;
 		}
			
 		var grid = View.getControl("", this.legendPanel);
 		if (!valueExists(grid)){
 			return;
 		}

 		this._refreshLegendPanel(grid, this.currentHighlightDS);

        if (this.showLegendOverlay && grid.isShownInWindow()) {
            grid.updateWindowHeight();
        }
 	},
 	
 	
 	addLabels: function(labels){
 		FABridge.abDrawing.root().addLabels(labels);
 	},
 	
 	
 	removeLabels: function(labels){
 		FABridge.abDrawing.root().removeLabels(labels);
 	},
 	
 	
 	setToolbar: function(oper, option, names) {
 		if (!valueExistsNotEmpty(oper) || !valueExists(option))
 			return;
 		if (!valueExistsNotEmpty(names))
 			names = 'all';
 		FABridge.abDrawing.root().toolbar(oper, option, names);
 	},
 	
 	appendGridRow: function(grid, color, val) {
		var rec = new Ab.data.Record({
					'legend.color': '0x' + gAcadColorMgr.formatColor(color, true),
					'legend.value':  val
		}); 
		grid.addGridRow(rec);	
 	},
 	
 	// utility methods
 	getPkFieldNames: function (ds) {
 		var loc = new Ab.drawing.DwgCtrlLoc();
		if (!valueExists(ds))
	 		return loc;
	 		
	 	// only primary keys that have field name containing bl_id, fl_id, or rm_id will be returned
	 	for (var i = 0; i < ds.fieldDefs.length; i++) {
	 		var id = ds.fieldDefs.items[i].id;
	 		if (id.indexOf('.bl_id') > 0)
	 			loc.pks[0] = id;
	 		else if (id.indexOf('.fl_id') > 0)
	 			loc.pks[1] = id;
	 		else if (id.indexOf('.rm_id') > 0)
	 			loc.pks[2] = id;
	 	}
	 	return loc;
	 },
	 
	 processInstruction: function(ctrlId, eventName, msg2) {
	 	if (!valueExists(this.instructs))
	 		return;
	 	
	 	var instruct = this.instructs[ctrlId+eventName];
	 	if (!valueExists(instruct))
	 	{		
	 		// check for the default message to display
	 		instruct = this.instructs["default"];
	 		if (!valueExists(instruct))
	 			return;
	 	} else if (instruct.dwgLoaded && !this.dwgLoaded) {
	 		return;
	 }

	 	var msg = instruct.msg;
	 		
	 	if (valueExistsNotEmpty(msg)) {
	 		if (valueExistsNotEmpty(msg2))
	 			msg = msg.replace(/%s/, msg2);
			this.setTitleMsg(msg);
		}
			
		//if (instruct.disable)
			//View.getControl('', instruct.ctrlId).disable();
	 },
	 
	 getFillOpacity : function() {
		 if(this.dwgConfig){
				return this.dwgConfig.highlights.assigned.fill.opacity * 0.8;
		 }else{
			 //XXX: ???
			return 0.5;
		 }
	 },
	 
	 
	 setMinimumLabelTextSize : function(textSize) {
	 	FABridge.abDrawing.root().setMinimumLabelTextSize(textSize);
	 },
	 
	 setIdealLabelTextSize : function(textSize) {
	 	FABridge.abDrawing.root().setIdealLabelTextSize(textSize);
	 },
	 
	 setShrinkLabelTextToFit : function(val) {
	 	FABridge.abDrawing.root().setShrinkLabelTextToFit(val);
	 },

	 setRightClickMenu: function(contents) {
	     FABridge.abDrawing.root().setRightClickMenu(contents);
	 },
	 
	 
	 	getHatchPatterns: function() {
	 		try {
	            var result = Workflow.call('AbCommonResources-HighlightPatternService-getHatchPatterns');
	            if(result && result.jsonExpression)
	            	return result.jsonExpression;
	            else
	            	return "";
	        } 
	        catch (e) {
	            Workflow.handleError(e);
	        }
	 	},

	 
	 enableRedmarks: function() {
	 	if (this.initialized) {
	 		FABridge.abDrawing.root().enableRedmarks();
	 		this.redmarksEnabled=true;
	 	} 
	 },
	 
	 
	 disableRedmarks: function() {
	 	if (this.initialized) {
	 		FABridge.abDrawing.root().disableRedmarks();
	 		this.redmarksEnabled=false;
	 	} 
	 },
	 
	 
	 getRedMarks : function(){
	 	return FABridge.abDrawing.root().getRedmarks();
	 },
	 
	 
	 saveRedmarksForServiceRequest: function(activityLogId){
		 var visible = FABridge.abDrawing.root().checkAllRedmarksVisible();
		 if(visible || (!visible && confirm(this.z_MESSAGE_PROMPT_LEAVEREDMARKSINVISIBLE))){
			var redMarks = FABridge.abDrawing.root().getRedmarks();
		 	if(valueExistsNotEmpty(this.currentHighlightDS)){
		 		redMarks.highlightds = this.currentHighlightDS;
		 		var highlightDS = View.dataSources.get(this.currentHighlightDS);
		 		if(valueExistsNotEmpty(highlightDS)){
		 			var hlDSview = highlightDS.viewName+".axvw";
			 		redMarks.highlightds_view_name = hlDSview;
		 		}		 		
		 	}
		 	if(valueExistsNotEmpty(this.currentLabelsDS)){
		 		redMarks.labelds = this.currentLabelsDS;
		 		var labelDS = View.dataSources.get(this.currentLabelsDS);
		 		if(valueExistsNotEmpty(labelDS)){
		 			var labelDSView = labelDS.viewName+".axvw";
			 		redMarks.labelds_view_name = labelDSView;
		 		}
		 	}
		 	try {
	            var result = Workflow.callMethod('AbCommonResources-DrawingService-saveRedMarksForServiceRequest', redMarks,parseInt(activityLogId),this.getImageBytes(),"");
	            return true;
	        } 
	        catch (e) {
	            Workflow.handleError(e);
	        }
		 }
		 return false;
	 },
	 
	 
	 saveRedmarksAsServiceRequest: function(viewName){
		 var visible = FABridge.abDrawing.root().checkAllRedmarksVisible();
		 if(visible || (!visible && confirm(this.z_MESSAGE_PROMPT_LEAVEREDMARKSINVISIBLE))){
			var redMarks = FABridge.abDrawing.root().getRedmarks();
		 	if(valueExistsNotEmpty(this.currentHighlightDS)){
		 		redMarks.highlightds = this.currentHighlightDS;
		 		var highlightDS = View.dataSources.get(this.currentHighlightDS);
		 		if(valueExistsNotEmpty(highlightDS)){
		 			var hlDSview = highlightDS.viewName+".axvw";
		 			redMarks.highlightds_view_name = hlDSview;
		 		}
		 	}
		 	if(valueExistsNotEmpty(this.currentLabelsDS)){
		 		redMarks.labelds = this.currentLabelsDS;
		 		var labelDS = View.dataSources.get(this.currentLabelsDS);
		 		if(valueExistsNotEmpty(labelDS)){
		 			var labelDSView = labelDS.viewName+".axvw";
		 			redMarks.labelds_view_name = labelDSView;
		 		}
		 	}
		 	try {
	            var result = Workflow.callMethod('AbCommonResources-DrawingService-prepareRedmarksForServiceRequest', redMarks,this.getImageBytes(),viewName);
	            if(result.code == 'executed'){
	            	return result.data;
	            } else {
	            	Workflow.handleError(result);
	            }
	        } 
	        catch (e) {
	            Workflow.handleError(e);
	        }
		 }
		 return 0;
	 },
	 
	 
	 saveRedmarks: function(){
		var visible = FABridge.abDrawing.root().checkAllRedmarksVisible();
		if(visible || (!visible && confirm(this.z_MESSAGE_PROMPT_LEAVEREDMARKSINVISIBLE))){
			var redMarks = FABridge.abDrawing.root().getRedmarks();
		 	if(valueExistsNotEmpty(this.currentHighlightDS)){
		 		redMarks.highlightds = this.currentHighlightDS;
		 		var highlightDS = View.dataSources.get(this.currentHighlightDS);
		 		var hlDSview = highlightDS.viewName+".axvw";
		 		redMarks.highlightds_view_name = hlDSview;
		 	}
		 	if(valueExistsNotEmpty(this.currentLabelsDS)){
		 		redMarks.labelds = this.currentLabelsDS;
		 		var labelDS = View.dataSources.get(this.currentLabelsDS);
		 		var labelDSView = labelDS.viewName+".axvw";
		 		redMarks.labelds_view_name = labelDSView;
		 	}
		 	try {
	            var result = Workflow.callMethod('AbCommonResources-DrawingService-saveRedMarks', redMarks);
	        } 
	        catch (e) {
	            Workflow.handleError(e);
	        }
		}
	 	
	 },
	 
	 drawRedmarks: function(opts){
	 	FABridge.abDrawing.root().drawRedmarks(opts);
	 	this.processInstruction("onredlinesload", "");
	 },
	 
	 clearRedmarks: function(){
	 	FABridge.abDrawing.root().clearRedmarks();
	 }
});


DwgFill = Base.extend ({
    key: null,	// value that this fill is associated with.  e.g.  vacant, workstation, etc.
	fc: undefined,		// the fill color.  if not specified, app defaults will be applied
	fo: undefined,	// the fill opacity.  number in range 0.0 to 1.0
	bc: undefined,		// the boundary color.  if not specifid, app defaults will be applied
	bo: undefined,	// the boundary opacity.  number in range 0.0 to 1.0
	bt: undefined,
	
	constructor: function(key, fc, fo, bc, bo, bt) {
		if (key != undefined)
			this.key = key;
			
		if (fc != undefined)
			this.fc = fc;
	},
	
	set: function(ob) {
		// tbd
	}
	
});
							
							
DwgLabel = Base.extend ({
	font: "Arial",
	color: 0x000000,
	textHeight: 12,
	justification: "center",
	bold: false,
	italic: false,
	underline: false,
	field: '',
	value: '',
	
	constructor: function(field, val, ht, color, just, font, bold, italic, underline) {
		if (!valueExistsNotEmpty(field) || !valueExistsNotEmpty(val))
			return;
			
		this.field = field;
		this.value = val;
		if (valueExists(ht))
			this.textHeight = ht;
		if (valueExists(color))
			this.color = color;
		if (valueExistsNotEmpty(just))
			this.justification = just;
		if (valueExists(bold))
			this.bold = bold;
		if (valueExists(italic))
			this.italic = italic;
		if (valueExists(underline))
			this.underline = underline;
	}
	
});


DwgRec = Base.extend({
	id: null,	// required: id of the asset
	f: null,	// optional: unique fill to apply to this asset
	l: null,	// optional: array of DwgLabel objects to apply to this asset
	v: null,	// optional: value to link this asset with a related external fill
	
	constructor: function(id, fill, labels) {
		if (id == undefined)
			return;
			
		this.id = id;
		if (valueExists(fill))
			this.f = fill;
			
		if (valueExists(labels))
			this.l = labels;
	}

});


//Fix for no MouseWheel in a Flex app when wmode="opaque" (it actually works in IE, just not Firefox or Chrome, probably not Safari or Opera either). 
//This also fixes the different MouseWheel scroller rates between Firefox and everything else.
function handleWheel(event) {
    var app = document.getElementById(dwgControlId);
    

	// only invoke mouse wheel when the mouse is over the drawing control
    if(event.rangeParent && event.target.id == dwgControlId){
	    var edelta = (navigator.userAgent.indexOf('Firefox') !=-1) ? -event.detail : event.wheelDelta/40;                                   
	    var o = {x: event.screenX, y: event.screenY, 
	        delta: edelta,
	        ctrlKey: event.ctrlKey, altKey: event.altKey, 
	        shiftKey: event.shiftKey}
	
	    app.handleWheel(o);
    }
}

DwgOpts = Base.extend({
	ver: 1.0,				// version of this DwgOpts object
	folder: '',				// folder to load drawings from
	dwgName: null,			// name of drawing file containing included records, array of field/ids
	rawDwgName: '',         // actual name of a drawing file to load, not the pkeys that define it
	assetTypes: '',			// optional: list of asset file types to load, comma delimited strings
	zoomToId: false,		// zoom in to the specified highlightId, default is false
	multiple: true,			// controls whether or not more than 1 drawing can be loaded at a time
	exclusive: false,		// only the specified highlightId will be highlighted, any others will be unhighlighted
	highlightId: undefined,	// an asset id to be highlighted
	forceload: true,		// force the load of a drawing if needed
	fill: undefined,		// fill settings that override the mode setting
	mode: undefined,		// assigned, unassigned, selected, unselected, none, or empty string
	selectionMode: '2',				// allows onclick events to modify the graphics
	assignMode:	'0',				// determines how the Flash control should respond to onclick events
	multipleSelectionEnabled: true,	// allow more than one asset to be selected
	recs: undefined,		// array of DrawingRec objects
	persistRecFills: true,	// if highlightAssets called with this set true, these will override datasource changes
	backgroundSuffix: '',   // optional suffix to be applied to the drawing name for loading different backgrounds
	assetSuffix: '',        // optional suffix to be applied to the asset file name to load
	primaryKeyFieldsHighlights: null, // optional, array of field names to supercede DataSource primary keys
	primaryKeyFieldsLabels: null, // optional, array of field names to supercede DataSource primary keys
	
	constructor: function (opts) {
		var ja = jsAccessFromFlex;
		this.selectionMode = ja.selectionMode;
		this.assignMode = ja.assignMode;
		this.multipleSelectionEnabled = ja.multipleSelectionEnabled;
		if (opts != null && opts != undefined)
			this.copy(opts);	
		this.folder = View.project.enterpriseGraphicsFolder;
	},
	
	copy: function(opts) {
		if (opts == null || opts == undefined)
			return;
		if (valueExists(opts.folder))
			this.folder = opts.folder;
		if (valueExists(opts.dwgName))
			this.dwgName = opts.dwgName;
		if (valueExists(opts.rawDwgName))
		    this.rawDwgName = opts.rawDwgName;
		if (valueExists(opts.highlightId))
			this.highlightId = opts.highlightId;
		if (valueExists(opts.assetTypes))
			this.assetTypes = opts.assetTypes;
		if (valueExists(opts.zoomToId))
			this.zoomToId = opts.zoomToId;
		if (valueExists(opts.forceload))
			this.forceload = opts.forceload;
		if (valueExists(opts.exclusive))
			this.exclusive = opts.exclusive;
		if (valueExists(opts.multiple))
			this.multiple = opts.multiple;
		if (valueExists(opts.fill))
			this.fill = opts.fill;	
		if (valueExists(opts.mode))
			this.mode = opts.mode;
		if (valueExists(opts.selectionMode), true)
			this.selectionMode = opts.selectionMode;
		if (valueExists(opts.assignMode), true)
			this.assignMode = opts.assignMode;
		if (valueExists(opts.multipleSelectionEnabled))
			this.multipleSelectionEnabled = opts.multipleSelectionEnabled;
		if (valueExists(opts.recs))
			this.recs = opts.recs;
		if (valueExists(opts.persistRecFills))
			this.persistRecFills = opts.persistRecFills;
		if (valueExists(opts.backgroundSuffix))
			this.backgroundSuffix = opts.backgroundSuffix;
		if (valueExists(opts.assetSuffix))
			this.assetSuffix = opts.assetSuffix;
		if (valueExists(opts.primaryKeyFieldsHighlights))
			this.primaryKeyFieldsHighlights = opts.primaryKeyFieldsHighlights;
		if (valueExists(opts.primaryKeyFieldsLabels))
			this.primaryKeyFieldsLabels = opts.primaryKeyFieldsLabels;
	},
	
	
	appendRec: function(id, fill, labels, asHighlight) {

		var ar = id.split(jsAccessFromFlex.getDelim());
		
		if(!valueExistsNotEmpty(this.assetTypes)) {
			var bl_id = (ar != null && ar.length > 0 ? ar[0] : null);
			var fl_id = (ar != null && ar.length > 1 ? ar[1] : null);
		}
		
		this.appendRecNonRm(bl_id, fl_id, id, fill, labels, asHighlight);
	},
	
	
	appendRecFromRow: function(row, id){
		var fl_id = '';
 		var bl_id = '';
 		for (var name in row.row.record) {
			if (name.indexOf('.bl_id') >= 0)
				bl_id = row.row.record[name];
			else if (name.indexOf('.fl_id') >= 0)
				fl_id = row.row.record[name];
		}
 		this.appendRecNonRm(bl_id, fl_id, id);
	},
	
	
	appendRecNonRm: function(bl_id, fl_id, id, fill, labels, asHighlight) {
		if (id == undefined)
			return;
			
		if (this.recs == undefined)
			this.recs = new Array();
			
		if (asHighlight == true)
			this.highlightId = id;
			
		this.recs[this.recs.length] = new DwgRec(id, fill, labels);
		
		// Ensure that the drawing name is included in this package
		// in a form that the flex 'addDrawing' method takes
		if (this.dwgName == null) {
			this.dwgName = new Array();
			if (bl_id != null && fl_id != null) {
				this.dwgName[0] = 'fl.bl_id';
				this.dwgName[1] = bl_id;
				this.dwgName[2] = 'fl.fl_id';
				this.dwgName[3] = fl_id;
			}
		}
	},
	
	setFillColor: function(color) {
		if (this.fill == undefined)
			this.fill = new DwgFill();
		this.fill.fc = color;
	}
	
});



DwgInstruction = Base.extend({
	//name: '',				// the name of this instruction
	ctrlId: '',				// the control id that this is to be executed on
	eventName: 'onclick',	// the event to execute on
	msg: '',				// the message to be displayed for this instruction
	//nextName: true,		// the name of the next instruction that follows this
	dwgLoaded: false,		// disable the specified control when displaying message
	
	constructor: function (ctrlId, eventName, msg, dwgLoaded) {
		this.ctrlId = ctrlId;
		this.eventName = eventName;
		this.msg = msg;
		this.dwgLoaded = dwgLoaded;
	}
});


DwgHighlightRule = Base.extend({
	ver: 1.0,				// version of this DwgHighlightRule object
	fullfield: "",			// the tablename.fieldname
	val: "",				// the value for this rule
	color: "",				// the colot to be associated with this value
	oper: "==",				// the operator to test with
	label: "",				// the display value, will override the val for the legend if specified
	selectable: true,		// wehther or not highlighted objects are selectable or not
	
	constructor: function () {

	},
	
	getLabel: function() {
		return this.label.length ? this.label : this.val;
	},
	
	
	getLabelOper: function() {
		return this.label.length ? "" : this.oper;
	}
});



DwgHighlightRuleSet = Base.extend({
	ver: 1.0,					// version of this DwgHighlightRuleSet object
	ds: "",						// the datasource these rules are associated with
	isRange: false,				// whether or not this rule set is a range of values
	fullfield: "",				// the table.fieldname used for this ruleset
	valColorMap: new Array(),	// simple map of values to colors when not a range
	nonRangeVals: new Array(),	// list of values asssociated with the valColorMap, used for lookup
	rules: new Array(),			// the list of rules that define this rule set
	defaultRule: null,			// specifies the default rule to apply for this set of rules
	
	constructor: function (ds) {
		this.ds = ds;
	},
	
	
	appendRule: function (fullfield, val, color, oper, label, selectable, isDefault) {
		var dr = new DwgHighlightRule();
		dr.fullfield = fullfield;
		if (oper == "==" || isDefault == true)
			dr.val = val;
		else
			dr.val = parseInt(val, 10);
		dr.color = color;
		if (valueExists(oper))
			dr.oper = oper;
		if (valueExists(label))
			dr.label = label;
		
		this.fullfield = fullfield;
		
		if (isDefault == true) {
			this.defaultRule = dr;
		} else if (oper != "==") {
			this.isRange = true;	

			if (valueExists(selectable))
				dr.selectable = selectable;
		
			if (isDefault == true)
				this.defaultRule = dr;
			else
				this.rules[this.rules.length] = dr;	
		} else {
			var ff = fullfield + "." + val;
			this.valColorMap[ff] = color;
			this.nonRangeVals[this.nonRangeVals.length] = ff;
		}
	},
	
	getColorFromValue: function(fullfield, val) {
		var color = "";
		var b = false;
		var dr = null;
		
		if (this.isRange) {
			val = parseInt(val, 10);
			for (var i = 0; i < this.rules.length && !b; i++) {
				dr = this.rules[i];
				if (dr.oper == "==") {
					b = (val == dr.val);
				} else if (dr.oper == "<") {
					b = (val < dr.val);
				} else if (dr.oper == "<=") { 
					b = (val <= dr.val);
				} else if (dr.oper == ">") {
					b = (val > dr.val);
				} else if (dr.oper == ">=") {
					b = (val = dr.val);
				}
			
				if (b)
					color = dr.color;
			}
		} else {
			color = this.valColorMap[fullfield + "." + val];
			if (valueExists(color))
				b = true;
		}
		
		if (!b && valueExists(this.defaultRule))
			color = this.defaultRule.color;
		
		return color;
	},
	
	getNonRangeItems: function() {
		var items = new Array();
		for (var i = 0; i < this.nonRangeVals.length; i++) {
			var fullval = this.nonRangeVals[i];
			var ar = fullval.split(".");
			var val = ar[ar.length - 1];
			items[i] = { "val": val, "color": this.valColorMap[fullval] };
		}
		return items;
	},
	
	getField: function() {
		return this.fullfield;
	}
});


Ab.drawing.DwgCtrlLoc = Base.extend({
    pks: ['rm.bl_id', 'rm.fl_id', 'rm.rm_id'],
    map: new Object(),
    dwgname: '',
	
	constructor: function (bl_id, fl_id, rm_id, dwgname) {
		this.set(bl_id, fl_id, rm_id, dwgname);
	},
	
	set: function(ob, fl_id, rm_id, dwgname) {
		this.map = new Object();
		if (!valueExists(ob))
			return;
			
		// ob is an Ab.drawing.DwgCtrlLoc object
		if (valueExists(ob.pks)) {							
			this.pks = ob.pks;
			this.map = ob.map;
			this.dwgname = ob.dwgname;
		} else if (valueExists(ob.row)) {		
			// ob is an Ab.grid.Row object
			this.setFromCtrlOb(ob);
		} else if (ob.constructor == Ab.view.Restriction) {	
			// ob is an Ab.view.Restriction object
			this.setFromRestriction(ob);
		} else {											
			// working with raw values
			this.map[this.pks[0]] = ob;
			if (valueExists(fl_id))
				this.map[this.pks[1]] = fl_id;
			if (valueExists(rm_id))
				this.map[this.pks[2]] = rm_id;
			if (valueExists(dwgname))
			    this.dwgname = dwgname;
		}
	},
	
	setFromArray: function(ar) {
		if (!valueExistsNotEmpty(ar))
			return;
		
		//modify to work with non-room assets where pks can be an array of any length
		for (var i = 0; i < this.pks.length; i++) {
			if (valueExistsNotEmpty(ar[i*2])) {
				this.pks[i] = ar[i*2];
				this.map[this.pks[i]] = ar[i*2+1];
			}
		}
	},
	
	
 	setFromCtrlOb: function (ob, bMsg) {
		if (!valueExists(ob) || !valueExists(ob.grid) || !valueExists(ob.row))
	 		return null;
	 		
	 	//reset the primary fields
	 	this.pks = new Array();
	 	var pkIndex = 0;
	 	
	 	// only primary keys that have field name containing bl_id, fl_id, or rm_id will be handled
	 	for (var i = 0; i < ob.grid.fieldDefs.length; i++) {
	 		var id = ob.grid.fieldDefs[i].id;
	 		if (ob.grid.fieldDefs[i].primaryKey){
	 			//make sure bl_id, fl_id, rm_id is stored into primary key array in the right order.
	 			if(id.indexOf('.bl_id')>=0)
	 				this.pks[0] = id;
	 			else if(id.indexOf('.fl_id')>=0)
	 				this.pks[1] = id;
	 			else if(id.indexOf('.rm_id')>=0)
	 				this.pks[2] = id;
	 			else
	 				this.pks[pkIndex] = id;
	 			pkIndex++;
	 		}
	 		else if (id.indexOf('.dwgname') > 0)
	 		    this.dwgname = ob[id];
	 		}
	 	
	 	//if the main table is not room, but the asset need to connect with the room, such as employee in a room, use the rm table's pks
	 	if(this.pks.length < 1){
	 		this.pks = ['rm.bl_id', 'rm.fl_id', 'rm.rm_id'];
	 	}
	 	
	 	// Verify that there is an asset (i.e. room) associated with this row
	 	// If not, inform the user that there is no info to display
		for (i = 0; i < this.pks.length; i++){
			var pk = this.pks[i];
			this.map[pk] = ob[pk];
			if (bMsg == true && !valueExistsNotEmpty(this.map[pk])) {
				View.alert(View.getLocalizedString(this.z_MESSAGE_NO_PKEY_FOR_RECORD));
				return;
			}
		}
	 },
	 
	 setFromRestriction: function (res) {
	 	var tmp = res.clauses;

		for (var i = 0; i < tmp.length; i++) {
			var tmp2 = tmp[i];
			this.pks[i] = tmp2.name;
			this.map[tmp2.name] = tmp2.value;
		}
	},
	
	
	setFromTreeClick: function (ob, panelId) {
        this.setFromRestriction(ob.restriction);
        var panel = View.panels.get(panelId);
        if (valueExists(panel) && valueExists(panel._levels)) {
            var i = panel._levels.length;
            var ds = View.dataSources.get(panel._levels[panel._levels.length - 1].dataSourceId);
            if (valueExists(ds)) {
                // check to see if there is a 'dwgname' field
                var fn = null;
                var keys = ds.fieldDefs.keys;
                for (i = 0; i < keys.length; i++) {
                    var id = keys[i];
                    if (id.indexOf('.dwgname') > 0)
                        fn = id;
                }
        
                if (fn != null) {
                    var node = panel.lastNodeClicked;
                    var dwgname = node.data[fn];
                    if (valueExists(dwgname))
                        this.dwgname = dwgname;
                }
            }
        }
	},
	
	getBuilding: function() {
		var id = this.pks[0];
		if (id!=null && id.indexOf('.bl_id') >= 0) {
			return this.map[id];
		}
		
		return null;
	},
	
	getFloor: function() {
		var id = this.pks[1];
		if (id!=null && id.indexOf('.fl_id') >= 0) {
			return this.map[id];
		}
		
		return null;
	},
	
	getRoom: function() {
		var id = this.pks[2];
		if (id!=null && id.indexOf('.rm_id') >= 0) {
			return this.map[this.pks[i]];
		}
		
		return null;
	},
	
	getPkValueString: function() {
		var s = '';
		var d = jsAccessFromFlex.getDelim();
		
		for(var i=0; i <this.pks.length; i++){
			if(s.length > 0)
				s += d;
			
			if (valueExistsNotEmpty(this.map[this.pks[i]]))
				s += this.map[this.pks[i]];
		}
		return s;
	},
	
	getDwgname:function() {
		return this.dwgname;
	},
	
	containsFloor: function() {
		return (valueExistsNotEmpty(this.getBuilding()) && valueExistsNotEmpty(this.getFloor()));
	},
	
	toArray: function(asDwgName) {
		var ar = new Array();
		if (!valueExists(this.pks))
			return ar;
		
		var tot = this.pks.length;
		if (asDwgName == true)
			tot = tot-1;
		for (var i = 0; i < tot; i++) {
			ar[i*2] = this.pks[i];
			ar[i*2+1] = this.map[this.pks[i]];
		}
		
		return ar;
	},
	
	// @begin_translatable
	z_MESSAGE_NO_PKEY_FOR_RECORD: 'No asset associated with the selected record can be found.'
	// @end_translatable	


});










 

function getChartType_JS(panelId){
	var chart = Ab.view.View.getControl('', panelId);
	return chart.type;
	
}

function getChartConfigObj_JS(panelId){
	var chart = Ab.view.View.getControl('', panelId);
	return toJSON(chart.configObj);
}




function getChartData_JS(panelId) {
		var chart = Ab.view.View.getControl('', panelId);
		return chart.data;
}



function loadComplete_JS(panelId) {
	var chart = Ab.view.View.getControl('', panelId);
	chart.afterLoadComplete();
}


function afterCreateControl_JS(panelId) {
	var chart = View.getControl('', panelId);
	chart.afterCreateControl();
}


function onClickChart_JS(panelId){
	var chart = Ab.view.View.getControl('', panelId);
	chart.addLink(chart.getEventCommands("onClickChart"));
}

function onClickItem_JS(panelId, selectedChartData, dataSeriesDisplayName){
	//clikedChartData in json format as string
	selectedChartData = eval('(' + selectedChartData + ')');
	
	var chart = Ab.view.View.getControl('', panelId);
	
	if(chart.secondaryGroupingAxis != null && chart.secondaryGroupingAxis.length > 0 ) {
		var secondaryGroupingAxisID = chart.secondaryGroupingAxis[0].table + "." + chart.secondaryGroupingAxis[0].field;
		selectedChartData[secondaryGroupingAxisID]=dataSeriesDisplayName;
	}
	
	var pkFieldFullName = "";
	if(chart.groupingAxis != null){
		pkFieldFullName = chart.groupingAxis[0].table + "." + chart.groupingAxis[0].field;
	}
	
	
	
	var pkFieldValue = "";
	for(var key in selectedChartData){
		if(key == pkFieldFullName){
			pkFieldValue = selectedChartData[key];
			break;
		}
	}
	
	if(valueExistsNotEmpty(pkFieldFullName) && valueExistsNotEmpty(pkFieldValue)){
		var pkFieldDef = chart.getFieldDef(pkFieldFullName);
		if(valueExists(pkFieldDef) && pkFieldDef.isEnum){
			//XXX: replace enum's displayed value by its stored value
			for(var enumKey in pkFieldDef.enumValues){
				if(pkFieldDef.enumValues[enumKey] === pkFieldValue){
					pkFieldValue = enumKey; break;
				}
			}
			
			//XXX: change selectedChartData so that application level would also get enum's stored value rather than displayed value
			for(var key in selectedChartData){
				if(key === pkFieldFullName){
					selectedChartData[key] = pkFieldValue;
					break;
				}
			}
		}
	}
	
	var restriction = new Ab.view.Restriction();
	if(pkFieldFullName != ""){
		if ((pkFieldValue.indexOf(selectedChartData['nullValueTitle']) != -1)) { 
			 restriction.addClause(pkFieldFullName, '', 'IS NULL');
		} else {
		  	 restriction.addClause(pkFieldFullName, pkFieldValue, '=');
		}
    }
    
    // KB 3027177: the panel might have additional restriction applied from another 
	// panel (console, tree, etc); it must be added to the drill-down restriction
	if (chart.restriction != null && chart.restriction.constructor != String) {
		restriction.addClauses(chart.restriction, false, true);
	}
    
	
	chart.addLink(chart.getEventCommands("onClickItem"), restriction, selectedChartData);
}

function onClickSeries_JS(panelId, e){
	alert("onClickSeries - " + e);
	
}

function getLocalizedString_JS(panelId, key){
	var chart = Ab.view.View.getControl('', panelId);
	return chart.getLocalizedString(key);

}

function getDecimalSeparator_JS(){
	return strDecimalSeparator;
}

function getGroupingSeparator_JS(){
	return strGroupingSeparator;
}





Ab.namespace('chart');


Ab.chart.ChartControl = Ab.flash.FlashComponent.extend({

	// ------------------- public properties ----------------------------------
    configObj: null,
    
    
    

    
    chartType: this.CHARTTYPE_PIE,
    
        
    supportedTypes: [],

	
	width: "100%",
	height: "100%",
	 
	
	
    showLegendOnLoad: true,
   
   	
    showLegendAsPopUp: false,
       
    
    legendLocation: null,
    
      
    
    showDataTips: true,
           
	
    refreshWorkflowRuleId: '',
    
   
    backgroundColor: '',

	
    
	
    //color for data series
	FILLCOLOR_SATURATED:  	['0xF79646', '0x4BACC6', '0x8064A2', '0x9BBB59', '0xC0504D', '0x4F81BD', '0x1F497D', '0x938953', '0x000000', '0x7F7F7F', '0x974806','0x205867','0x3F3151','0x4F6128','0x5E1C1B','0x244061','0x0F243E','0x1D1B10','0x0C0C0C','0x7F7F7F'],
	
    //color for gradient
	FILLCOLOR_DESATURATED:  ['0xFDEADA', '0xDBEEF3', '0xE5E0EC', '0xEBF1DD', '0xF2DCDB', '0xDBE5F1', '0xC6D9F0', '0xDDD9C3', '0x7F7F7F', '0xD8D8D8','0xFBD5B5','0xB7DDE8','0xCCC1D9','0xD7E3BC','0xE5B9B7','0x95B3D7','0x548DD4','0x938953','0x3F3F3F','0xBFBFBF'],
 
    
 	 
    
    fillColor: [],
    
    
    fillColorDesaturated: [],
	
    
    fillType: this.FILLTYPE_SOLID,
	
	    
	supportedFillTypes:  [],
	   
    
    percentGradientChange: 1.0,
    
    
    percentTransparency: 1.0,   
    
    
    events: null,
    
    
    groupingAxis: null,
    
    
    secondaryGroupingAxis: null,
    
    
    dataAxis: null,
    
    
    data: null,
    
    
    fieldDefs: null,
    
    showOnLoad: true,
    
    isLoadComplete: false,
    
    // user function to call after refresh()
    afterRefreshListener: null,
    
    // user function to call after Flash control has been created
    afterCreateControlListener: null,

    // user function to call after Flash control content has been loaded
    afterLoadCompleteListener: null,
    
	// ------------------- private properties ----------------------------------
    
    
    
    

    
    // Flash required version parameters
	requiredMajorVersion: '9',
	requiredMinorVersion: '0',	
	requiredRevision: '115',
    
    // ----------------------- public methods ----------------------------------

    
    constructor: function(controlId, configObject) {

        // call the base FlashComponent constructor to set the base properties
        // and register the control in the view, so that other view parts can find it
        //this.inherit(controlId, this.type, configObject);
		this.inherit(controlId, 'chart', configObject);
        
        this.configObj = configObject;
       
        // the title for the chart control is set in the component constructor 

		// set the chart type
		this.supportedTypes.push(
				this.CHARTTYPE_PIE, 
				this.CHARTTYPE_PIE_3D, 
				this.CHARTTYPE_LINE, 
				this.CHARTTYPE_LINE_3D, 
				this.CHARTTYPE_BAR, 
				this.CHARTTYPE_STACKEDBAR, 
				this.CHARTTYPE_COLUMN, 
				this.CHARTTYPE_COLUMN_3D, 
				this.CHARTTYPE_AREA, 
				this.CHARTTYPE_AREA_3D, 
				this.CHARTTYPE_STACKEDAREA, 
				this.CHARTTYPE_PLOT, 
				this.CHARTTYPE_COLUMNLINE, 
				this.CHARTTYPE_COLUMNLINE_3D );
    	var chartType = configObject.getConfigParameterIfExists('controlType');
		if (valueExists(chartType) && chartType != '') {
        	for (var i=0; i < this.supportedTypes.length; i++) { 
				if (this.supportedTypes[i] == chartType) {
					this.chartType = chartType;
					break;
				}			
			}
		}
		
        // set the width for the chart control
        var width = configObject.getConfigParameterIfExists('width');
        if (valueExists(width) && width != '') {
            this.width = width;
        }

        // set the height for the chart control
        var height = configObject.getConfigParameterIfExists('height');
        if (valueExists(height) && height != '') {
        	
            this.height = height;
        }

        // the dataSource id for the chart control is set in the component constructor (dataSourceId)

        // set the showLegendOnLoad for the chart control
        var showLegendOnLoad = configObject.getConfigParameterIfExists('showLegendOnLoad');
        if (valueExists(showLegendOnLoad)) {
            this.showLegendOnLoad = showLegendOnLoad;
        }

        // set the showLegendAsPopUp for the chart control
        var showLegendAsPopUp = configObject.getConfigParameterIfExists('showLegendAsPopUp');
        if (valueExists(showLegendAsPopUp)) {
            this.showLegendAsPopUp = showLegendAsPopUp;
        }


        // set the legendLocation value for the chart control
    	var legendLocation = configObject.getConfigParameterIfExists('legendLocation');
        if (valueExists(legendLocation) && legendLocation != '') {        	
			this.legendLocation = legendLocation;					
		}

        // set the showDataTips for the chart control
        var showDataTips = configObject.getConfigParameterIfExists('showDataTips');
        if (valueExists(showDataTips)) {
            this.showDataTips = showDataTips;
        } else {
        	this.configObj.setConfigParameter("showDataTips", this.showDataTips);
        } 	 

        // set the showAllDataTips for the chart control
        var showAllDataTips = configObject.getConfigParameterIfExists('showAllDataTips');
        if (valueExists(showAllDataTips)) {
            this.setDataTipFunction(showAllDataTips);
        } else {
        	this.configObj.setConfigParameter("showAllDataTips", this.showAllDataTips);
        } 
        
	    this.refreshWorkflowRuleId = this.WORKFLOW_RULE_REFRESH;
		var refreshWorkflowRuleId = configObject.getConfigParameterIfExists('refreshWorkflowRuleId');        
		if (valueExists(refreshWorkflowRuleId) && refreshWorkflowRuleId != '') {
		    this.refreshWorkflowRuleId = refreshWorkflowRuleId;
		}

 		var backgroundColor = configObject.getConfigParameterIfExists('backgroundColor');        
		if (valueExists(backgroundColor) && backgroundColor != '') {
		    this.backgroundColor = backgroundColor;
		} 

 		var fillColor = configObject.getConfigParameterIfExists('fillColor');        
		if (valueExists(fillColor) && fillColor.length > 0) {
		    this.fillColor = fillColor;
		} else { 
			this.fillColor = this.FILLCOLOR_SATURATED;
			this.configObj.setConfigParameter("fillColor", this.fillColor);
		}
		
 		var fillColorDesaturated = configObject.getConfigParameterIfExists('fillColorDesaturated');        
		if (valueExists(fillColorDesaturated) && fillColorDesaturated.length > 0) {
		    this.fillColorDesaturated = fillColorDesaturated;
		} else { 
			this.fillColorDesaturated = this.FILLCOLOR_DESATURATED;
			this.configObj.setConfigParameter("fillColorDesaturated", this.fillColorDesaturated);
		}
		
		
		this.supportedFillTypes.push(this.FILLTYPE_SOLID, this.FILLTYPE_LINEARGRADIENT, this.FILLTYPE_RADIALGRADIENT);
        var fillType = configObject.getConfigParameterIfExists('fillType');
        if (valueExists(fillType) && fillType != '') {
        	for (var i=0; i < this.supportedFillTypes.length; i++) { 
				if (this.supportedFillTypes[i] == fillType) {
					this.fillType = fillType;
					break;
				}
			}			
		}

 		var percentGradientChange = configObject.getConfigParameterIfExists('percentGradientChange');        
		if (valueExists(percentGradientChange) && percentGradientChange>=0.0 && percentGradientChange<=1.0) {
		    this.percentGradientChange = percentGradientChange;
		} else {
			this.configObj.setConfigParameter("percentGradientChange", this.percentGradientChange);
		}

 		var percentTransparency = configObject.getConfigParameterIfExists('percentTransparency');        
		if (valueExists(percentTransparency) && percentTransparency>=0.0 && percentTransparency<=1.0) {
		    this.percentTransparency = percentTransparency;
		} else {
			this.configObj.setConfigParameter("percentTransparency", this.percentTransparency);
		}
		
	    // create field definitions
        var groupingAxis = configObject.getConfigParameter('groupingAxis');
        this.groupingAxis = new Array();
        if (valueExists(groupingAxis) && groupingAxis.length > 0) {
        	// construct the grouping axis with the first of the groupingAxis JSON array
        	// since we only one and only one grouping axis
	        this.groupingAxis[0] = new Ab.chart.ChartAxis(this.dataSourceId, groupingAxis[0]);
	        this.configObj.setConfigParameter("groupingAxis", this.groupingAxis);
	        
        }
 
        var secondaryGroupingAxis = configObject.getConfigParameter('secondaryGroupingAxis');
        this.secondaryGroupingAxis = new Array();
        if (valueExists(secondaryGroupingAxis) && secondaryGroupingAxis.length > 0) {
        	// construct the secondary grouping axis with the first of the secondaryGroupingAxis JSON array
        	// since we allow at most one secondary grouping axis
	        this.secondaryGroupingAxis[0] = new Ab.chart.ChartAxis(this.dataSourceId, secondaryGroupingAxis[0]);
	        this.configObj.setConfigParameter("secondaryGroupingAxis", this.secondaryGroupingAxis);
        }
		
        var dataAxis = configObject.getConfigParameter('dataAxis');
		this.dataAxis = new Array();
        if (valueExists(dataAxis) && dataAxis.length > 0) {
       		for (var i = 0; i < dataAxis.length; i++) {
       			var _dataAxis = new Ab.chart.ChartDataAxis(this.dataSourceId, dataAxis[i]);
	            this.dataAxis[i] = _dataAxis;
    	    }

            this.configObj.setConfigParameter("dataAxis", this.dataAxis);
        }

		// add default data axis title related config parameters if they are not defined in AXVW
		this.configObj.addParameterIfNotExists('dataAxisTitle', '');

 		var events = configObject.getConfigParameter('events');
 		if (valueExists(events) && events != null) {
         	this.events = events;
		}
	
		// create field definitions
		var fieldDefs = configObject.getConfigParameter('fieldDefs');
        if (valueExists(fieldDefs) && fieldDefs != null) {
         	//add or overwrite the config field defs for parsed expression
        	var ds = View.dataSources.get(this.dataSourceId);
        	//kb#3032301 - check if the data source is defined.
     		if(ds!=null){
     			var dsFieldDefsExists = (valueExists(ds.fieldDefs) && ds.fieldDefs != null);

     			this.fieldDefs = new Array();
		        for (var i = 0; i < fieldDefs.length; i++) {
		        	this.fieldDefs[i] = fieldDefs[i];
		        	if(dsFieldDefsExists){
		        		for(var j=0; j < ds.fieldDefs.length; j++) {
		         			if(fieldDefs[i].id == ds.fieldDefs.items[j].id){
		         				this.fieldDefs[i] = ds.fieldDefs.items[j];
		         			}
		         		}
		         	}
		        	if (valueExists(this.fieldDefs[i].currency)) {
		        		this.fieldDefs[i].currencySymbol = View.currencySymbolFor(this.fieldDefs[i].currency);
		            } 
	     		}
	         	this.configObj.setConfigParameter("fieldDefs", this.fieldDefs);
     		}
        }
		
		this.showOnLoad = configObject.getConfigParameter('showOnLoad', true);

       this.setSwfPath();
        // Set required version info for Flash	
        var reqMajorVersion = configObject.getConfigParameterIfExists('requiredMajorVersion');
        if (valueExists(reqMajorVersion)) {
			this.requiredMajorVersion = reqMajorVersion;
		}
        var reqMinorVersion = configObject.getConfigParameterIfExists('requiredMinorVersion');
        if (valueExists(reqMinorVersion)) {
			this.requiredMinorVersion = reqMinorVersion;
		}
        var reqRevision = configObject.getConfigParameterIfExists('requiredRevision');
        if (valueExists(reqRevision)) {
			this.requiredRevision = reqRevision;
		}
		
		this.isLoadComplete = false;
		
		this.addEventListenerFromConfig('afterCreateControl', configObject);
		this.addEventListenerFromConfig('afterLoadComplete', configObject);
	
		this.evaluateExpressionsAfterLoad();
    },

    
    isScrollInLayout: function() {
        return false;
    },

    
    evaluateExpressionsAfterLoad: function(ctx) {
    	var ctx = this.createEvaluationContext();
    	
    	var dataAxisTitle = this.configObj.getConfigParameter('dataAxisTitle')
		if(valueExistsNotEmpty(dataAxisTitle)){
			dataAxisTitle = View.evaluateString(dataAxisTitle, ctx);
			this.configObj.setConfigParameter("dataAxisTitle", dataAxisTitle);
		}
    	
		// enable|disable action buttons based on enabled attribute to allow data binding
        this.actions.each(function(action) {
			var enabled = Ab.view.View.evaluateBoolean(action.enabled, ctx);
            action.forceDisable(!action.show || !action.enabled);
        });

        if(valueExists(this.fieldDefs)){
            // evaluate fieldDefs titles
            for (var i = 0; i < this.fieldDefs.length; i++) {
        		var fieldDef = this.fieldDefs[i];
        		fieldDef.title = View.evaluateString(fieldDef.title, ctx);
        	}
        }
        
        if(valueExists(this.groupingAxis)){
            // evaluate grouping axis titles
            for (var i = 0; i < this.groupingAxis.length; i++) {
        		var axis = this.groupingAxis[i];
    	        axis.title = View.evaluateString(axis.title, ctx);
        	}
        }
        
        if(valueExists(this.secondaryGroupingAxis)){
            // evaluate second grouping axis titles
            for (var i = 0; i < this.secondaryGroupingAxis.length; i++) {
        		var axis = this.secondaryGroupingAxis[i];
    	        axis.title = View.evaluateString(axis.title, ctx);
        	}
        }
   
        if(valueExists(this.dataAxis)){
	        // evaluate data axis titles
	    	for (var i = 0; i < this.dataAxis.length; i++) {
	    		var axis = this.dataAxis[i];
		        axis.title = View.evaluateString(axis.title, ctx);
	    	}
        }
    },
    
    
    getFieldDef: function(fieldFullName){
    	 if(valueExists(this.fieldDefs)){
             // evaluate fieldDefs titles
             for (var i = 0; i < this.fieldDefs.length; i++) {
         		var fieldDef = this.fieldDefs[i];
         		if(fieldDef.fullName === fieldFullName){
         			return fieldDef;
         		}
         	}
         }
    	 return null;
    },
    
    
    showDataAxisTitle: function(axisId, showTitle) {
    
        if (valueExists(this.dataAxis) && this.dataAxis.length > 0) {
       		for (var i = 0; i < this.dataAxis.length; i++) {
       			if(this.dataAxis[i].id = axisId){
       				var _dataAxis = new Ab.chart.ChartDataAxis(this.dataSourceId, this.dataAxis[i]);
       				_dataAxis.showTitle = showTitle;
       				this.dataAxis[i] = _dataAxis;
       			}
    	    }
            this.configObj.setConfigParameter("dataAxis", this.dataAxis);
        }
    	
    },
   
    showDataAxisTick: function(axisId, showTick) {
        if (valueExists(this.dataAxis) && this.dataAxis.length > 0) {
       		for (var i = 0; i < this.dataAxis.length; i++) {
       			if(this.dataAxis[i].id = axisId){
       				var _dataAxis = new Ab.chart.ChartDataAxis(this.dataSourceId, this.dataAxis[i]);
       				_dataAxis.showTick = showTick;
       				this.dataAxis[i] = _dataAxis;
       			}
    	    }
            this.configObj.setConfigParameter("dataAxis", this.dataAxis);
        }
    },

    showDataAxisMinorTick: function(axisId, showMinorTick) {
        if (valueExists(this.dataAxis) && this.dataAxis.length > 0) {
       		for (var i = 0; i < this.dataAxis.length; i++) {
       			if(this.dataAxis[i].id = axisId){
       				var _dataAxis = new Ab.chart.ChartDataAxis(this.dataSourceId, this.dataAxis[i]);
       				_dataAxis.showMinorTick = showMinorTick;
       				this.dataAxis[i] = _dataAxis;
       			}
    	    }
            this.configObj.setConfigParameter("dataAxis", this.dataAxis);
        }
    },

    setDataAxisUnit: function(axisId, uKey, uSuffix) {
        if (valueExists(this.dataAxis) && this.dataAxis.length > 0) {
       		for (var i = 0; i < this.dataAxis.length; i++) {
       			if(this.dataAxis[i].id = axisId){
       				var _dataAxis = new Ab.chart.ChartDataAxis(this.dataSourceId, this.dataAxis[i]);
       				_dataAxis.setUnit(uKey, uSuffix);
       				this.dataAxis[i] = _dataAxis;
       			}
    	    }
            this.configObj.setConfigParameter("dataAxis", this.dataAxis);
        }
    	
    },

    
    showGroupingAxisTitle: function(showTitle) {
    	if (valueExists(this.groupingAxis) && this.groupingAxis.length > 0) {
   			var _groupingAxis = new Ab.chart.ChartAxis(this.dataSourceId, this.groupingAxis[0]);
   			_groupingAxis.showTitle = showTitle;
   			this.groupingAxis[0] = _groupingAxis;
            this.configObj.setConfigParameter("groupingAxis", this.groupingAxis);
        }
    },

    showGroupingAxisTick: function(showTick) {
    	if (valueExists(this.groupingAxis) && this.groupingAxis.length > 0) {
   			var _groupingAxis = new Ab.chart.ChartAxis(this.dataSourceId, this.groupingAxis[0]);
   			_groupingAxis.showTick = showTick;
   			this.groupingAxis[0] = _groupingAxis;
            this.configObj.setConfigParameter("groupingAxis", this.groupingAxis);
        }
    },
    
    showGroupingAxisMinorTick: function(showMinorTick) {
    	if (valueExists(this.groupingAxis) && this.groupingAxis.length > 0) {
   			var _groupingAxis = new Ab.chart.ChartAxis(this.dataSourceId, this.groupingAxis[0]);
   			_groupingAxis.showMinorTick = showMinorTick;
   			this.groupingAxis[0] = _groupingAxis;
            this.configObj.setConfigParameter("groupingAxis", this.groupingAxis);
        }
    },
    
    
    setDataAxisTitle: function(title) {
    	
    	//add the parameter to config object if not exist.
    	this.configObj.addParameterIfNotExists('dataAxisTitle', ''); 

    	//set the value
    	this.configObj.setConfigParameter("dataAxisTitle", title);
    	
    },
    
    setCalloutGap: function(gap){
    	if(gap < 0)
    		gap = 10;
    	
    	var chartControl = this.getSWFControl();		
		
		if(chartControl != null){
			try{
				chartControl.setSeriesStyleProperty("calloutGap", gap);
				chartControl.refreshData(this.data);
			}catch(e){}
		}
    },

    setInsideLabelSizeLimit: function(sizeLimit){
    	if(sizeLimit < 0)
    		sizeLimit = 9;
    	
    	var chartControl = this.getSWFControl();		
		
		if(chartControl != null){
			try{
				chartControl.setSeriesStyleProperty("insideLabelSizeLimit", sizeLimit);
				chartControl.refreshData(this.data);
			}catch(e){}
		}
    },

    
    setSolidFillColors: function(fillColors){
		if (valueExists(fillColors) && fillColors.length > 0) {
			this.fillColor = fillColors;
		} else {
			this.fillColor = this.FILLCOLOR_SATURATED;
		}

		this.fillType = this.FILLTYPE_SOLID;
			
		var chartControl = this.getSWFControl();		
		
		 if(chartControl != null){
			try{
				chartControl.setFillColors(this.fillType, this.fillColor, this.FILLCOLOR_DESATURATED, this.percentGradientChange, this.percentTransparency);
			}catch(e){}
		}
			
	},
    
	
    setGradientFillColors: function(fillType, fillColors1, fillColors2, percentGradientChange, percentTransparency) {
    	
    	if(fillType == this.FILLTYPE_RADIALGRADIENT){
    		this.fillType = this.FILLTYPE_RADIALGRADIENT;
    	} else {
    		this.fillType = this.FILLTYPE_LINEARGRADIENT;
    	}
    	
    	if (valueExists(fillColors1) && fillColors1.length > 0) {
    		this.fillColor = fillColors1;
    	} else {
			this.fillColor = this.FILLCOLOR_SATURATED;
		}
    	
    	if (valueExists(fillColors2) && fillColors2.length > 0) {
    		this.fillColorDesaturated = fillColors2;
    	} else {
			this.fillColorDesaturated = this.FILLCOLOR_DESATURATED;
		}
    	
		if (valueExists(percentGradientChange) && percentGradientChange>=0.0 && percentGradientChange<=1.0) {
    		this.percentGradientChange = percentGradientChange;
    	} else {
    		this.percentGradientChange = 1.0;
    	}
    	
    	if (valueExists(percentTransparency) && percentTransparency>=0.0 && percentTransparency<=1.0) {
    	   	this.percentTransparency = percentTransparency;
    	} else {
    		this.percentTransparency = 1.0;
    	}

		var chartControl = this.getSWFControl();		
		
		if(chartControl != null){
			try{
				chartControl.setFillColors(this.fillType, this.fillColor, this.FILLCOLOR_DESATURATED, this.percentGradientChange, this.percentTransparency);
			}catch(e){}
		}

    },

    
    setDataTipFunction: function(showAllTips) {
    	
    	var chartControl = this.getSWFControl();		
		
		if(chartControl != null){
			try{
				chartControl.setDataTipFunction(showAllTips);
				chartControl.refreshData(this.data);
			}catch(e){}
		}
    	
    	
    	
    },
    
    
    afterCreateControl: function() {
		// call user-defined callback function
        var listener = this.getEventListener('afterCreateControl');
        if (listener) {
            listener(this);
        }
    },
    
    
    afterLoadComplete: function() {
    	this.isLoadComplete = true;
		// call user-defined callback function
        var listener = this.getEventListener('afterLoadComplete');
        if (listener) {
            listener(this);
        }
    },
    
    		
    setControlProperty: function(propertyName, propertyValue) {
	 	var control = this.getSWFControl();		
        if (control) {
        	control.setControlProperty(propertyName, propertyValue);
        }
    },
    
    		
    setStyleProperty: function(propertyName, propertyValue) {
	 	var control = this.getSWFControl();		
        if (control) {
        	control.setStyleProperty(propertyName, propertyValue);
        }
    },
    
    initialDataFetch: function() {
    	if(this.showOnLoad){
	      	this.data = this.getDataFromDataSources(this.restriction);   
   		}
   		//XXX: loading flash control and swf chart
	   	this.loadChartSWFIntoFlash();
	   	
	    // show|hide the panel instructions
        if (this.getInstructionsEl()) {
            this.showElement(this.getInstructionsEl(), true);
        }
    },
    
    //called when drill-down
	refresh: function (restriction){
    	 if (valueExists(restriction)) {
             this.restriction = restriction;
         }
  
		//XXX: update data	
		this.data = this.getDataFromDataSources(restriction);
		this.refreshControl();
	},	 
	 
	 refreshControl: function(){
		 
		 //flash control object
	 	 var chartControl = this.getSWFControl();
		//XXX: if flash object is not ready, this function will just update data 
		//which will be used by later chart initializing
		if(chartControl != null){
			try{
				chartControl.refreshData(this.data);
			}catch(e){}
		}
		
		// afterRefresh handler
		this.afterRefresh();
	 },
	 
	 
	 getSWFControl:function(){
	 	var obj = $(this.id+"_OE");
	 	if(obj != null){
	 		try{
	 			obj.isReady();
	 		}catch(error){
	 			return null;
	 		}
	 	}
		return obj;
	 },
	 
	 
	 getImageBytes:function(){
		var chart = this.getSWFControl();
 		if(chart && chart.getImageBytes){
 			return chart.getImageBytes();
 		}
 		return [];
	 },
	 
	 
	
    loadChartSWFIntoFlash: function(){
		// Version check for the Flash Player that has the ability to start Player Product Install (6.0r65)
		var hasProductInstall = this.DetectFlashVer(6, 0, 65);
	
		// Version check based upon the values defined in globals
		var hasRequestedVersion = this.DetectFlashVer(this.requiredMajorVersion, this.requiredMinorVersion, this.requiredRevision);

		if ( hasProductInstall && !hasRequestedVersion ) {
			// DO NOT MODIFY THE FOLLOWING FOUR LINES
			// Location visited after installation is complete if installation is required
			var MMPlayerType = (this.isIE == true) ? "ActiveX" : "PlugIn";
			var MMredirectURL = window.location;
		    document.title = document.title.slice(0, 47) + " - Flash Player Installation";
		    var MMdoctitle = document.title;

			var embedObjectString = this.returnContent(
				"src", this.getPlayerProductInstallName(),
				"FlashVars", "MMredirectURL="+MMredirectURL+'&MMplayerType='+MMPlayerType+'&MMdoctitle='+MMdoctitle+"",
				"width", this.width,
				"height", this.height,
				"id", this.id,
				"quality", "high",
				"bgcolor", '#FFFFFF',
				"name", this.id,
				"allowScriptAccess","sameDomain",
				"type", "application/x-shockwave-flash",
				"pluginspage", "http://www.adobe.com/go/getflashplayer",
				"codebase","http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab"
			);
			this.injectFlashTag(embedObjectString, this.id);			
		} else if ( hasRequestedVersion ) {
			var embedObjectString = this.returnContent(
				"id", this.id + "_OE",
				"src", this.getSwfPath(),
				"width", this.width,
				"height", this.height,
				"quality", "high",
				"bgcolor",'#FFFFFF',
				"name", this.id + "OE",
				"allowScriptAccess","sameDomain",
				"type", "application/x-shockwave-flash",
				"pluginspage", "http://www.adobe.com/go/getflashplayer",
				"codebase","http://fpdownload.macromedia.com/get/flashplayer/current/swflash.cab"
			);
			this.injectFlashTag(embedObjectString, this.id);
	  	} else {  // flash is too old or we can't detect the plugin
		    var alternateContent = 'To display the chart, you need the Adobe Flash Player version 9.0.115 or higher.'
		   						 + '<a href=http://www.adobe.com/go/getflash/>Get Flash</a>';
			this.injectFlashTag(alternateContent, this.id);
		}

        // chart can be seen as soon as SWF loads
        this.visible = true;
    },
    
  	
	 getDataFromDataSources: function(restriction){	 
		try {
		    var parameters = this.getParameters(restriction);
		    //XXX: default time-out is 20S, but for charts, it should be longer (120S?)
	        var result = Workflow.call(this.refreshWorkflowRuleId, parameters, 120);
	    
	        return toJSON(result.data);
		} catch (e) {
			this.handleError(e);
		}
	 },
	
	 //
	 getParameters: function(restriction){
		var viewName = this.configObj.getConfigParameter('viewDef');
		var groupingAxis = this.configObj.getConfigParameter('groupingAxis');
		var dataAxis = this.configObj.getConfigParameter('dataAxis');
		
		var  parameters = {
		           version: '2',
		           viewName: viewName,
		           groupingAxis: toJSON(groupingAxis),
		           dataAxis: toJSON(dataAxis),
		           type: 'chart'
		 };
		 
		 var secondaryGroupingAxis = this.configObj.getConfigParameter('secondaryGroupingAxis');
		 if (valueExists(secondaryGroupingAxis) && secondaryGroupingAxis.length > 0) {
	         parameters.secondaryGroupingAxis = toJSON(secondaryGroupingAxis);
	     }
	     
	     if (valueExists(restriction)) {
	         parameters.restriction = toJSON(restriction);
	     }
	     
		 Ext.apply(parameters, this.parameters);
		 
		 return parameters;
	 },
	
	
	setSwfPath: function(){
		switch (this.chartType) {
	        case this.CHARTTYPE_PIE:
	        	this.swfPath = "AbPieChart";
	        	break;
	        case this.CHARTTYPE_PIE_3D:
	        	this.swfPath = "AbPieChart3D";
	        	break;
	        case this.CHARTTYPE_LINE:
	        	this.swfPath = "AbLineChart";
	        	break;
	        case this.CHARTTYPE_LINE_3D:
	        	this.swfPath = "AbLineChart3D";
	        	break;
	        case this.CHARTTYPE_BAR:
	        	this.swfPath = "AbBarChart";
	        	break;
	        case this.CHARTTYPE_COLUMN:
	        	this.swfPath = "AbColumnChart";
	        	break;
	        case this.CHARTTYPE_COLUMN_3D:
	        	this.swfPath = "AbColumnChart3D";
	        	break;
	        case this.CHARTTYPE_AREA:
	        	this.swfPath = "AbAreaChart";
	        	break;
	        case this.CHARTTYPE_AREA_3D:
	        	this.swfPath = "AbAreaChart3D";
	        	break;
	        case this.CHARTTYPE_STACKEDBAR:
	        	this.swfPath = "AbBarChart";
	        	break;
	        case this.CHARTTYPE_STACKEDAREA:
	        	this.swfPath = "AbAreaChart";
	        	break;
	        case this.CHARTTYPE_PLOT:
	        	this.swfPath = "AbPlotChart";
	        	break;
	        case this.CHARTTYPE_COLUMNLINE:
	        	this.swfPath = "AbColumnChart";
	        	break;
	        case this.CHARTTYPE_COLUMNLINE_3D:
	        	this.swfPath = "AbColumnChart3D";
	        	break;
	        default:
	        	this.swfPath = "AbPieChart";
	        	break;
		}
		// AC_OETags.AC_GetArgs uses AC_AddExtension to add the parameter to the swfFileName
		if (this.id != null) {
			this.swfPath += '?panelId=' + this.id;
		}
	},
 	
	
 	getSwfPath: function(){
 		return View.contextPath + "/schema/ab-core/controls/chart/" + this.swfPath;
 	},
 	
	
 	getPlayerProductInstallName: function(){
 		return View.contextPath + "/schema/ab-core/libraries/flex/playerProductInstall";
 	},
 	

 	
    addLink: function(commandsData, restriction, selectedChartData) {
        // create command chain
        var command = new Ab.command.commandChain(this.id, restriction);
        command.addCommands(commandsData);

        // add command as a link property
        var link = $(this.id);
        link.command = command;
        //create context so that caller could get chart's info
        if(typeof selectedChartData == "undefined"){
       		selectedChartData = null;
        }
        var context = {"restriction":restriction,"selectedChartData":selectedChartData,"chart":this};
     	command.handle(context); 
    },
 	
	
 	getEventCommands: function(eventType) { 	
 		for(var index = 0; index < this.events.length; index++){
 			if(this.events[index]["type"] == eventType)
 				return this.events[index]["commands"];
 		}	
		
		return null;
 	},
 	
 	
	getLocalizedString: function(key) {
		return Ab.view.View.getLocalizedString(key);
	},
	
	// ----------------------- drawing support -----------------------------------------------------

      
	addLine: function(x1, y1, x2, y2, color, title) {
		var chart = this.getSWFControl();
 		if (chart && chart.addLine) {
 			chart.addLine(x1, y1, x2, y2, color, title);
 		}
	},

      
	addTargetLine: function(y, color, title) {
		var chart = this.getSWFControl();
 		if (chart && chart.addTargetLine) {
 			chart.addTargetLine(y, color, title);
 		}
	},
	
	 // ----------------------- export report selection --------------------------------------------------
    
    callReportJob: function(reportProperties){
    	var outputType = reportProperties.outputType, printRestriction = reportProperties.printRestriction, orientation = reportProperties.orientation;
    	if(outputType === 'docx'){
    		//XXX: don't call getParameters() for default parameters since custom javascript overwrite it to reload chart.
    		var parameters = {};
    		if(valueExists(printRestriction)){
				parameters.printRestriction = printRestriction;
				parameters.restriction = toJSON(this.restriction);
			}
			if(valueExistsNotEmpty(orientation)){
				parameters.orientation = orientation;
			}
			
    		var reportTitle = this.title;
    		if(reportTitle==''){
    			reportTitle = Ab.view.View.title;
    		}
    		return this.callDOCXReportJob(reportTitle, null, parameters);
    	}else if(outputType === 'xls'){
    		//no translatable since it's only for viwew designers.
    		View.showMessage('error', 'XLS action is NOT supported for a Chart panel.');
    	}
    	return null;
    },
    
	callDOCXReportJob: function(title, restriction, parameters){
		var viewName = this.config.viewDef + '.axvw'; 
		if(valueExists(parameters) && valueExists(parameters.printRestriction)){
			parameters.dataSourceId = this.dataSourceId;
		}
		return Workflow.startJob(this.WORKFLOW_RULE_DOCX_REPORT, viewName, this.getImageBytes(), title, parameters);
	},

    // ----------------------- constants -----------------------------------------------------------
	   
	 // @begin_translatable
	CHART_LEGEND_ASPOPUP: 'Display Legend As Popup',
	CHART_LEGEND_ATBOTTOM: 'Display Legend At Bottom',
	CHART_LEGEND_HIDE: 'Hide Legend',
	CHART_TOTAL: 'Total',
	// @end_translatable
	
    // name of the default WFR used to render the data
    WORKFLOW_RULE_REFRESH: 'AbCommonResources-getDataRecords',
    
    //WFR to generate a DOCX report
    WORKFLOW_RULE_DOCX_REPORT: 'AbSystemAdministration-generatePaginatedReport-buildDocxFromChart',
	
	// supported chart types
	CHARTTYPE_PIE: 'pieChart', // default
	CHARTTYPE_PIE_3D: 'pieChart3D',
	CHARTTYPE_LINE: 'lineChart', 
	CHARTTYPE_LINE_3D: 'lineChart3D', 
	CHARTTYPE_BAR: 'barChart',
	CHARTTYPE_COLUMN: 'columnChart', 
	CHARTTYPE_COLUMN_3D: 'columnChart3D', 
	CHARTTYPE_AREA: 'areaChart', 
	CHARTTYPE_AREA_3D: 'areaChart3D', 
	CHARTTYPE_STACKEDBAR: 'stackedBarChart', 
	CHARTTYPE_STACKEDAREA: 'stackedAreaChart',
	CHARTTYPE_PLOT: 'plotChart',
	CHARTTYPE_COLUMNLINE: 'columnLineChart', 
	CHARTTYPE_COLUMNLINE_3D: 'columnLineChart3D', 

	// legend locations
	LEGENDLOC_RIGHT: 'right',
	LEGENDLOC_LEFT: 'left',
	LEGENDLOC_TOP: 'top',
	LEGENDLOC_BOTTOM: 'bottom', //default
		
	// data fill types
	FILLTYPE_SOLID: 'solid',    //default
	FILLTYPE_LINEARGRADIENT: 'linearGradient',
	FILLTYPE_RADIALGRADIENT: 'radialGradient',
	
	DATA_LABEL_POSITION_CALLOUT: 'callout',
	DATA_LABEL_POSITION_INSIDE: 'inside',  
	DATA_LABEL_POSITION_OUTSIDE: 'outside',
	DATA_LABEL_POSITION_NONE: 'none',
	DATA_LABEL_POSITION__INSIDEWITHOUTCALLOUT: 'insideWithCallout'
});

Ab.chart.ChartAxis = Base.extend({    
    // the unique id to define this chart axis
    id: '',
    
    // the custom axis for the chart axis
    title: '',
    
    // the table name for the chart axis
    table: '',
    
    // the field name for the chart axis
    field: '',
    
    dataSourceId: '',
    
    // define the custom javascript function for the label
	labelFunction: '',
	
	showLabel: true,
	
	showTitle: true,
	
	labelRotation: 0,
	
	unitKey: '1',
	supportedUnitKeys: ['1', 'K', 'M', 'B'],
	unitSuffix: '',
	
	showTick: true,
	showMinorTick: true,
	
	parameterType: 'text',
	supportedParameterTypes: ['text', 'date', 'time', 'number'],
	
	displayAxis: false,
	
	constructor: function(dsId, chartAxis) {
		
		this.id = chartAxis.id;
		this.table = chartAxis.table;
		this.field = chartAxis.field;
		this.labelFunction = chartAxis.labelFunction;    
    	this.showLabel = chartAxis.showLabel;
    	this.labelRotation = chartAxis.labelRotation;
    	this.title = chartAxis.title;
    	this.showTick = chartAxis.showTick;
    	this.showMinorTick = chartAxis.showMinorTick;
    	    		
    	// if the dataSource parameter is not defined, we use the default chart's dataSource parameter
    	if(chartAxis.dataSourceId == null || chartAxis.dataSourceId == '') {
    		this.dataSourceId = dsId;
    	} else {
    		this.dataSourceId = chartAxis.dataSourceId;
    	}

    	if(chartAxis.showTitle!=null){
    		this.showTitle = chartAxis.showTitle;
    	}
    	
    	if(chartAxis.showTick!=null){
    		this.showTick = chartAxis.showTick;
    	}
    	
    	if(chartAxis.showMinorTick!=null){
    		this.showMinorTick = chartAxis.showMinorTick;
    	}

    	this.setUnit(chartAxis.unitKey, chartAxis.unitSuffix);
    
    	if(chartAxis.displayAxis!=null){
    		this.displayAxis = chartAxis.displayAxis;
    	}
    
	},

    setUnit: function(uKey, uSuffix){
		if(uKey != null && uKey != ''){
    		for (var i=0; i < this.supportedUnitKeys.length; i++) { 
    			if (this.supportedUnitKeys[i] == uKey) {
    				this.unitKey = uKey;
    				break;
    			}			
    		}
    	}

    	if(uSuffix != null && uSuffix != ''){
    		this.unitSuffix = uSuffix;
    	}

    }
});

Ab.chart.ChartDataAxis = Ab.chart.ChartAxis.extend({    
    // the type to specify for mixed data axis types. The values could be 'default', 'column' or 'line'.
    // The 'column' and 'line' are used for 'columnLineChart' type
    // The 'default' applies to the rest of chart types.
    type: this.DATAAXIS_TYPE_DEFAULT,
    
    supportedTypes: [],
    
    // the lable position for pie chart only
    labelPosition: this.PIELABEL_TYPE_NONE,

    calloutGap: 10,
    
    insideLabelSizeLimit: 9,
    
	supportedlabelPosition: [],   
    
    // define if we let the chart to automatically calculate the tick size interval or define it in
    // the 'tickSizeInterval' parameter. 
    autoCalculateTickSizeInterval: true,
    
    //define the tick size interval. Used only when autoCalculateTickSizeInterval is false
    tickSizeInterval: 1000,
    
    constructor: function(chart, chartDataAxis) {
		
		this.inherit(chart, chartDataAxis);
		
		this.supportedTypes.push(this.DATAAXIS_TYPE_DEFAULT, this.DATAAXIS_TYPE_COLUMN, this.DATAAXIS_TYPE_LINE);
		for (var i=0; i < this.supportedTypes.length; i++) { 
			if (this.supportedTypes[i] == chartDataAxis.type) {
				this.type = chartDataAxis.type;
				break;
			}			
		}
		
		this.supportedlabelPosition.push(this.PIELABEL_TYPE_CALLOUT, this.PIELABEL_TYPE_INSIDE, this.PIELABEL_TYPE_OUTSIDE, this.PIELABEL_TYPE_NONE, this.PIELABEL_TYPE_INSIDEWITHOUTCALLOUT);
		if(chartDataAxis.labelPosition != ''){
			for (var i=0; i < this.supportedlabelPosition.length; i++) { 
				if (this.supportedlabelPosition[i] == chartDataAxis.labelPosition) {
					this.labelPosition = chartDataAxis.labelPosition;
				}
			}
		}
		
		this.autoCalculateTickSizeInterval = chartDataAxis.autoCalculateTickSizeInterval;
		
		if(!this.autoCalculateTickSizeInterval) {
			this.tickSizeInterval = chartDataAxis.tickSizeInterval;
		}
		
		var calloutGap = chartDataAxis.calloutGap;
		if(calloutGap!=null) {
			this.calloutGap = calloutGap;
		}
		
		var insideLabelSizeLimit = chartDataAxis.insideLabelSizeLimit;
		if(insideLabelSizeLimit!=null) {
			this.insideLabelSizeLimit = insideLabelSizeLimit;
		}
    },
    
    
   	// ----------------------- constants -----------------------------------------------------------
    DATAAXIS_TYPE_DEFAULT: 'default',
	DATAAXIS_TYPE_COLUMN: 'column',
	DATAAXIS_TYPE_LINE: 'line',
		
	PIELABEL_TYPE_CALLOUT: 'callout',
	PIELABEL_TYPE_INSIDE: 'inside',
	PIELABEL_TYPE_OUTSIDE: 'outside',
	PIELABEL_TYPE_NONE: 'none',
	PIELABEL_TYPE_INSIDEWITHOUTCALLOUT: 'insideWithCallout'

});


Ab.namespace('paginate');

Ab.paginate.BaseReport = Base.extend({	

	// the panel object that the progress/result report resides
    panel: null,
    
    // JSON map tp hold the job progresses/results for all job statuses
    result: null,
    
    constructor: function(panel, result) {
   		//set the progress panel object
		this.panel = panel;
	
		this.result = result;
		
    },
   	
	removeHeader: function(){   
		// remove the header to avoid the space bar
	    var oHeader = this.panel.getTableHeadElement();
	   	oHeader.parentNode.removeChild(oHeader);
	},
	
	removeFooter: function(){
		// remove the footer to avoid "Not all record can be shown" message
	    var oFooter = this.panel.tableFootElement;
	    
	    if(oFooter==null){
	    	return;
		}
			    
	   	while (oFooter.firstChild) 
		{
		    //The list is LIVE so it will re-index each call
		    oFooter.removeChild(oFooter.firstChild);
		 };
	},
	
	addFooter: function(colSpan, content){
		var oFooter = this.panel.tableFootElement;
		var oTr = this.insertChild(oFooter, "tr", {height:"25px"});
		var oTd = this.insertChild(oTr, "td", null, "");
		if(oTd!=null){
			oTd.colSpan = colSpan;
		}
		
		oTr = this.insertChild(oFooter, "tr", {"class":"instruction"});
		oTd = this.insertChild(oTr, "td", null, "<i>" + content + "</i>");
		if(oTd!=null){
			oTd.colSpan = colSpan;
		}
	},
	
	getValidDataResult: function(index, data){
		if(typeof(data.jobId) == 'undefined'){
			return data[index];
		} else {
			return data;
		}
		return data;
	},

	insertChild: function(oParent, childTag, params, innerHTML, oTrAfter){
		if(oParent==null){
			return null;
		}
	
		var oChild = document.createElement(childTag);
	
		if( typeof(params) !== 'undefined' && params != null) {
			for(key in params){
				oChild.setAttribute(key, params[key]);
			}
		}
				
		if( typeof(innerHTML) !== 'undefined' && innerHTML != null) {
			oChild.innerHTML = innerHTML;
		}
		
		if( typeof(oTrAfter) !== 'undefined') { 
			oParent.insertBefore(oChild, oTrAfter);
		} else {
			oParent.appendChild(oChild);
		}
	
		return oChild;
	},

    // @begin_translatable
    REPORT_GENERATING: 'Still Generating...',
	REPORT_USELINK_PREVIEW_MESSAGE: 'Use these links to preview portions of the report as it generates.'
	// @end_translatable

});




Ab.namespace('paginate');

Ab.paginate.ResultsReport = Ab.paginate.BaseReport.extend({	

	// the panel object that the progress report resides
    panel: null,
    
    // JSON map tp hold the job progresses for all job statuses
    result: null,
    
   	constructor: function(panel, result) {

   		this.inherit(panel, result);
		
		this.addDataRows();
	 	
	 	this.removeFooter();
	 	
	 	this.addFooter("2",  Ab.view.View.getLocalizedString(this.REPORT_USELINK_PREVIEW_MESSAGE));
	},
   	
   	    
    refresh: function(result){

		this.result = result;

		this.removeDataRows();

   		this.addDataRows();
   	},
   	
	addDataRows: function(){
	
		if(typeof this.result != 'undefined'){
			
			//get the result
			this.result = Workflow.getJobStatus(this.result.jobId);
			
	        // store the number of partial results
			if(this.result.jobPartialResults!=null){
				var resultLength = this.result.jobPartialResults.length;
		   		for(var index=0; index < resultLength; index++){
			   		this.addDataRow(index, this.result.jobPartialResults[index]);
				}
			}
		}
	},
	
	// remove all the table rows from the table	
	removeDataRows: function(){

		var oTBody = this.panel.tableBodyElement;
	   	
	   	if(oTBody==null){
			return;
		}
	   	
	   	while (oTBody.firstChild) 
		{
		    //The list is LIVE so it will re-index each call
		    oTBody.removeChild(oTBody.firstChild);
		 };
	},
	
	addDataRow: function(index, dataRow){

		var	oTr = this.insertChild(this.panel.tableBodyElement, "tr");
		
		if(this.result.jobPartialResults!=null){
			this.insertChild(oTr, "td",  null, "<i>" + this.result.jobPartialResults[index].title + "</i>");
				   	
		   	if(index == this.result.jobPartialResults.length-1 && parseInt(dataRow.jobPercentComplete) < 100){
				this.insertChild(oTr, "td", null, "<i>" + Ab.view.View.getLocalizedString(this.REPORT_GENERATING) + "</i>");
			} else {
				this.insertChild(oTr, "td",  null, "<i><a href='" + this.result.jobPartialResults[index].url + "' target='_blank'>" + this.result.jobPartialResults[index].name + "</a></i>");
			}
		}
	},
	
	// @begin_translatable
    REPORT_GENERATING: 'Still Generating...',
	REPORT_USELINK_PREVIEW_MESSAGE: 'Use these links to preview portions of the report as it generates.'
	// @end_translatable

});




Ab.namespace('paginate');

Ab.paginate.ProgressReport = Ab.paginate.BaseReport.extend({	

	pBars: null,
    
    progressColSpan: '5',
    
    footerMsg: '',
    
   	constructor: function(panel, result, progressColSpan) {
  		
  		this.inherit(panel, result);
  
  		this.progressColSpan = progressColSpan;
  
  		this.footerMsg = this.PROCESS_LEAVEWINDOW_MESSAGE;
  		
		this.pBars = new Array();
		
		//we will only add header once
		this.processHeader();	
		
		//only add the job header for a list of jobs
		if(this.result!= null && typeof(this.result.jobId) == 'undefined'){
			this.addHeaderInstruction();
		}
		
		if(result != null){
			this.addDataRows();
		} 	
	 	
		// KB 3026447: Attach event listener that will be called if the window is resized.
		Ext.EventManager.onWindowResize(this.onWindowResize, this);
   },
   
   setFooterMsgForSingleJob:function(){
   
   		this.footerMsg = this.PROCESS_LEAVEJOB_MESSAGE;

  		this.removeFooter();
		this.addFooter(this.progressColSpan+1,  Ab.view.View.getLocalizedString(this.footerMsg));
   },
   
   refresh: function(result){
   
		this.result = result;

		this.removeDataRows();

   		this.addDataRows();
   },
   
   
   setResultViewLink: function(){
		var dataRows = Ext.query('.dataRow',  this.panel.tableBodyElement);
		var row = dataRows[0];			
		// test column name & value to see if row should be set as a link
		for (var j = 0; j < this.panel.columns.length ; j++) {
			if (this.panel.columns[j].id == 'afm_tbls.result_view') {
				var docFile = row.childNodes[j].innerHTML;
				if( this.result.jobFile.url.lastIndexOf(".pdf") > 0){
					//open PDF in a new tab
					row.childNodes[j].innerHTML = '<a class="prominent" onclick="window.open(\'' + this.result.jobFile.url + '\')" />' + docFile + '</a>';
				}else{
					row.childNodes[j].innerHTML = '<a class="prominent" href="' + this.result.jobFile.url + '" />' + docFile + '</a>';
				}	
			}
		}
},


	 
	processHeader: function(){

		var headerRows = this.panel.headerRows;
	   	if (headerRows.length > 0) {
			//?? does not seem to work!
			headerRows[0].vAlign = "top";
		   
		    // loop through each of the header cell
			for (var i=0; i < headerRows[0].childNodes.length; i++) {
			
				// retain the cell value
				var cellTitle = headerRows[0].childNodes[i].innerHTML;
				
				// clear the cell value
				headerRows[0].childNodes[i].innerHTML = "";
			    
			    // add a <span> object so that all the styles to the title can be applied
			    var spanCell = document.createElement("span");
			    headerRows[0].childNodes[i].appendChild(spanCell);

				// replace the special chars
			    this.replaceSpecialChars(spanCell, cellTitle, true);
			}
		}
	},

   	// remove all the table rows from the table	
	removeDataRows: function(){

		var dataRows = this.panel.rows;
		
		if(dataRows==null){
			return;
		}

		// remove the progress table content
		if(dataRows.length > 0){
		    this.panel.removeRows(0);
			this.panel.clear();
		}
	},
   
	addDataRows: function(){

		// table body object to hold all the data rows
		var oTBody = this.panel.tableBodyElement;
		
		if(oTBody==null){
			return;
		}
		
		// this is used to record the total number of data rows
		var resultSize = 0;
		
		if(typeof(this.result.jobId) == 'undefined'){
			// loop through the WFR result and add all the data rows first, 
			// get the total number of the data rows to add
			for(var dataIndex in this.result){
				resultSize++;
			}
			
			// add the data row
			for(var index = 0;  index < resultSize; index++){		
				this.addDataRow(this.result[index]);
			}	
		} else {
			this.addDataRow(this.result);
			resultSize++;
		}

		// add the progress bars, note we need to add the progress bar from the bottom to the top
		// in order to keep the child node index consistent
		var dataResult = null;
		for(var index = resultSize-1; index >=0; index--){
			dataResult = this.getValidDataResult(index, this.result);
			if(index<resultSize-1){
				// for the non-last record, we will insert the progress bar before the next data
			    this.insertProgressBar(index, dataResult.jobId, oTBody.childNodes[index+1]);
			} else {
			    // for the last record, append the progress bar
			    this.insertProgressBar(index, dataResult.jobId);
			}
		    this.updateButtonValue(index, this.result);
		}
		
		if(resultSize>0){
			this.removeFooter();
			this.addFooter(this.progressColSpan+1,  Ab.view.View.getLocalizedString(this.footerMsg));
		}
	},
	
	addDataRow: function(dataRow){
		var record = new Ab.data.Record({
							'afm_tbls.job_name':dataRow.jobFile.title,
							'afm_tbls.result_view': dataRow.jobFile.name,
							'afm_tbls.pct_complete': dataRow.jobPercentComplete,
							'afm_tbls.eclapsed_time':dataRow.jobElapsedTime,
							'afm_tbls.est_time_remain':dataRow.jobEstimatedTimeRemaining},true);
		
		this.panel.addGridRow(record);
		this.panel.update();
	},
	
	addHeaderInstruction: function(){
		var oPanel = this.panel.parentElement;
		var oTable = this.panel.divHeadElement;
		var oNewTable = this.insertChild(oPanel, "table", {"class":"panelReport"}, null, oTable);
		var oTr = this.insertChild(oNewTable, "tr");
		var oTd = this.insertChild(oTr, "td", {"class":"instruction"}, "<i>" + Ab.view.View.getLocalizedString(this.PROGRESS_LEAVE_RETURN) + "</i>");
		if(oTd!=null){
			oTd.colSpan = this.progressColSpan;
		}
		oTr = this.insertChild(oNewTable, "tr");
		oTd = this.insertChild(oTr, "td", {"class":"instruction"}, "<i>" + Ab.view.View.getLocalizedString(this.PROGRESS_ALLRESULT_REMAIN) + "</i>");
		if(oTd!=null){
			oTd.colSpan = this.progressColSpan;
		}
		
	},
		
	// internal helper function to replace the < and >
	replaceSpecialChars: function(elem, text, replace){
		if(replace){
			text = text.replace(/&lt;/g, "<");
			text = text.replace(/&gt;/g, ">");
		}
		elem.innerHTML = text;   
	},
	
	insertProgressBar: function(index, jobId, oTrAfter) {
		
		var oTBody = this.panel.tableBodyElement;
			
		var oTr = null;
		
		if(index % 2 == 0){
			oTr = this.insertChild(oTBody, "tr", {"class":"dataRow"}, null, oTrAfter);
		} else {
			oTr = this.insertChild(oTBody, "tr", {"class":"dataRow odd"}, null, oTrAfter);
		}
		
		var oTd = this.insertChild(oTr, "td", {"id":"pb_" + jobId, "class":"text",align:"center"} );
		if(oTd!=null){
			oTd.colSpan = this.progressColSpan;
		}

		
		var oDiv = this.insertChild(oTd, "div", {id:jobId+"_div"});
			
		var progressDiv = document.getElementById(jobId);
		
		var progressBar = new Ext.ProgressBar({text:this.PROGRESSBAR_READY,
			          id:jobId+ "_bar_div",
        			  cls:'x-progress-wrap',
        			  width: '70%',
        			  renderTo:jobId+"_div"
    				});
    				
		this.pBars[index] = progressBar;
			
	},
		
	updateButtonValue: function(index, result) {
		var dataResult = this.getValidDataResult(index, result);
		var jobPercentNum = parseInt(dataResult.jobPercentComplete);
		
		var statusText = dataResult.jobStatusMessage;

		if (valueExistsNotEmpty(dataResult.jobMessage)) {
			statusText = statusText + ' - ' + dataResult.jobMessage; 
		}
		
		var pBar = this.pBars[index]; 
		pBar.updateProgress(jobPercentNum/100, statusText);

		// KB 3026447: fix Ext.JS 2.0.2 bug. 
		// The progress bar area width is not in sync with the progress border width. 
		if (jobPercentNum == 100) {
	        var w = Math.floor(1.0 * pBar.el.parent().dom.offsetWidth);
	        pBar.progressBar.setWidth(w);
		}

		var progressButton = document.getElementById(this.panel.id + "_row" + index + "_progressButton");
        if (progressButton) {		
			progressButton.value = Ab.view.View.getLocalizedString(this.PROGRESS_STOP_JOB);
			
			// user can only stop the job when the job status is "Job Started"
			if(dataResult.jobStatusCode==2){
				progressButton.disabled = false;
			} else {
				progressButton.disabled = true;
			}
        }
	},
	
	onWindowResize: function() {
		this.refresh(this.result);
		
		if(this.result.jobFinished){
			this.setResultViewLink();
		}
	},

	// ----------------------- constants -----------------------------------------------------------
	   
	 // @begin_translatable
	PROGRESSBAR_READY: 'Ready',
	PROCESS_LEAVEWINDOW_MESSAGE: "If you leave this window, your report will continue generating. You can access it later from Web Central's <b>My Jobs</b> view.",
	PROCESS_LEAVEJOB_MESSAGE: "If you leave this window, your job will continue running. You can access it later from Web Central's <b>My Jobs</b> view.",
	PROGRESS_STOP_JOB:  'Stop Job',
	PROGRESS_LEAVE_RETURN: 'You can leave this view and return using the <b>My Jobs</b> selection in the main menu bar',
	PROGRESS_ALLRESULT_REMAIN: 'All jobs will continue and all job results will remain until you remove them or until you end your Web Central session.'
	// @end_translatable

});


Ab.paginate.ProgressPanel = Base.extend({
	
	// view panel that displays the progress report
	panel: '',
	
    // job ID
    jobId: '',
    
    // current job status
    status: null,
    
    // background task that refreshes the UI while the job is running
    progressTask: null,
    
    // task runner for that background task
    progressTaskRunner: null,
    
    // progress refresh interval in seconds
    progressRefreshInterval: 5,
    
    // Ab.paginate.ProgressReport instance
    progressReport: null,
    
    // custom application function to call when the job status is updated
    onJobStatusUpdated: null,
    
    // custom application function to call when the job is finished
    afterJobFinished: null,
    
    // the Start/Stop Job button in the first grid row 
    jobButton: null,

    
    constructor: function(panel, afterJobFinished, onJobStatusUpdated) {
	    this.panel = panel;
	    this.panel.sortEnabled = false;
	    
	    if (valueExists(afterJobFinished)) {
	    	this.afterJobFinished = afterJobFinished;
	    }
	    
	    if (valueExists(onJobStatusUpdated)) {
	    	this.onJobStatusUpdated = onJobStatusUpdated;
	    }
	    
	    this.jobButton = $(this.panel.getParentElementId() + "_row0_progressButton"); 
    },
    
    
    onJobStarted: function(jobId) {
    	// store the job ID
    	this.jobId = jobId;
        this.status = Workflow.getJobStatus(this.jobId);
        
        // create the progress bar based on the grid panel
        if (this.progressReport == null) {
            this.progressReport = new Ab.paginate.ProgressReport(this.panel, this.status, "6");
        }
        
        // start the background progress update task
        this.startProgressTask();
        
        // change the button title to Stop Job
        if (this.jobButton) {
            this.jobButton.value = this.progressReport.PROGRESS_STOP_JOB;
        }
    },
    
    
    startProgressTask: function() {
    	var controller = this;
        this.progressTask = {
            run: function() {
        	    // get the job status and refresh the UI
                controller.status = Workflow.getJobStatus(controller.jobId);
                controller.progressReport.refresh(controller.status);

                // if the onJobStatusUpdated is defined, call it
                if (controller.onJobStatusUpdated) {
                	controller.onJobStatusUpdated(controller.status);
                }
                
                // if the job has completed, stop the task
                if (controller.status.jobFinished) {
                    controller.progressTaskRunner.stop(controller.progressTask);

                    // if the afterJobFinished is defined, call it
                    if (controller.afterJobFinished) {
                    	controller.afterJobFinished(controller.status);
                    }
                }
            },
            interval: 1000 * controller.progressRefreshInterval
        }
        this.progressTaskRunner = new Ext.util.TaskRunner();
        this.progressTaskRunner.start(this.progressTask);
    },
    
    
    stopJob: function() {
    	// stop the server job
        Workflow.stopJob(this.jobId);
        
        // stop the task runner
        this.progressTaskRunner.stop(this.progressTask);
        
        // get the result and update the progress bar
        var status = Workflow.getJobStatus(this.jobId);
        this.progressReport.refresh(status);

        // disable the Stop Job button
        if (this.jobButton) {
            this.jobButton.disabled = true;
        }
    },
    
    
    isJobStarted: function() {
    	return valueExists(this.status);
    },
    
    
    isJobFinished: function() {
    	return valueExists(this.status) && this.status.jobFinished;
    },
    
    
    clear: function() {
    	this.jobId = null;
    	this.status = null;

    	if (this.jobButton) {
	        // change the button title to Start Job
	        this.jobButton.value = this.PROGRESS_START_JOB;
	        
	        // enable the Stop Job button
	        this.jobButton.disabled = false;
    	}
    },
    
    
    getJobButton: function() {
    	return $(this.panel.getParentElementId() + "_row0_progressButton");    
    },
    
	// ----------------------- constants -----------------------------------------------------------
	   
	 // @begin_translatable
	PROGRESS_START_JOB:  'Start Job'
	// @end_translatable
});


///////////////////////////////////////////////////////
var key = "0@1Z2y3X4^5w6*7=8-9+";

function permutationGenerator(nNumElements){
    this.nNumElements = nNumElements;
    this.antranspositions = new Array;
    
    var k = 0;
    for (i = 0; i < nNumElements - 1; i++) {
        for (j = i + 1; j < nNumElements; j++) {
            this.antranspositions[k++] = (i << 8) | j;
        }
    }
    
    // keep two positions as lo and hi byte!
    this.nNumtranspositions = k;
    this.fromCycle = permutationGenerator_fromCycle;
}

function permutationGenerator_fromCycle(anCycle){
    var anpermutation = new Array(this.nNumElements);
    for (var i = 0; i < this.nNumElements; i++) {
        anpermutation[i] = i;
    }
    
    for (var i = 0; i < anCycle.length; i++) {
        var nT = this.antranspositions[anCycle[i]];
        var n1 = nT & 255;
        var n2 = (nT >> 8) & 255;
        nT = anpermutation[n1];
        anpermutation[n1] = anpermutation[n2];
        anpermutation[n2] = nT;
    }
    
    return anpermutation;
}

function password(strpasswd){
    this.strpasswd = strpasswd;
    this.getHashValue = password_getHashValue;
    this.getpermutation = password_getpermutation;
}

function password_getHashValue(){
    var m = 907633409;
    var a = 65599;
    var h = 0;
    for (var i = 0; i < this.strpasswd.length; i++) {
        h = (h % m) * a + this.strpasswd.charCodeAt(i);
    }
    
    return h;
}

function password_getpermutation(){
    var nNUMELEMENTS = 4;
    var nCYCLELENGTH = 9;
    pg = new permutationGenerator(nNUMELEMENTS);
    var anCycle = new Array(nCYCLELENGTH);
    var npred = this.getHashValue();
    
    for (var i = 0; i < nCYCLELENGTH; i++) {
        npred = 11 * npred + 11;
        anCycle[i] = npred % pg.nNumtranspositions;
    }
    
    return pg.fromCycle(anCycle);
}

function SecureContext(strText, strSignature, bEscape){
    this.strSIGNATURE = strSignature || '';
    this.bESCApE = bEscape || false;
    this.strText = strText;
    this.escape = SecureContext_escape;
    this.unescape = SecureContext_unescape;
    this.transliterate = SecureContext_transliterate;
    this.encypher = SecureContext_encypher;
    this.decypher = SecureContext_decypher;
    this.sign = SecureContext_sign;
    this.unsign = SecureContext_unsign;
    this.secure = SecureContext_secure;
    this.unsecure = SecureContext_unsecure;
}

function SecureContext_escape(strToEscape){
    var strEscaped = '';
    for (var i = 0; i < strToEscape.length; i++) {
        var chT = strToEscape.charAt(i);
        switch (chT) {
            case '\r':
                strEscaped += '\\r';
                break;
            case '\n':
                strEscaped += '\\n';
                break;
            case '\\':
                strEscaped += '\\\\';
                break;
            default:
                strEscaped += chT;
        }
    }
    
    return strEscaped;
}

function SecureContext_unescape(strToUnescape){
    var strUnescaped = '';
    var i = 0;
    while (i < strToUnescape.length) {
        var chT = strToUnescape.charAt(i++);
        if ('\\' == chT) {
            chT = strToUnescape.charAt(i++);
            switch (chT) {
                case 'r':
                    strUnescaped += '\r';
                    break;
                case 'n':
                    strUnescaped += '\n';
                    break;
                case '\\':
                    strUnescaped += '\\';
                    break;
                default: // not possible
            }
        }
        else {
            strUnescaped += chT;
        }
    }
    
    return strUnescaped;
}

function SecureContext_transliterate(btransliterate){
    var strDest = '';
    
    var nTextIter = 0;
    var nTexttrail = 0;
    
    while (nTextIter < this.strText.length) {
        var strRun = '';
        var cSkipped = 0;
        while (cSkipped < 7 && nTextIter < this.strText.length) {
            var chT = this.strText.charAt(nTextIter++);
            if (-1 == strRun.indexOf(chT)) {
                strRun += chT;
                cSkipped = 0;
            }
            else {
                cSkipped++;
            }
        }
        
        while (nTexttrail < nTextIter) {
            var nRunIdx = strRun.indexOf(this.strText.charAt(nTexttrail++));
            if (btransliterate) {
                nRunIdx++
                if (nRunIdx == strRun.length) 
                    nRunIdx = 0;
            }
            else {
                nRunIdx--;
                if (nRunIdx == -1) 
                    nRunIdx += strRun.length;
            }
            strDest += strRun.charAt(nRunIdx);
        }
    }
    
    this.strText = strDest;
}

function SecureContext_encypher(anperm){
    var strEncyph = '';
    var nCols = anperm.length;
    var nRows = this.strText.length / nCols;
    
    for (var i = 0; i < nCols; i++) {
        var k = anperm[i];
        for (var j = 0; j < nRows; j++) {
            strEncyph += this.strText.charAt(k);
            k += nCols;
        }
    }
    
    this.strText = strEncyph;
}

function SecureContext_decypher(anperm){
    var nRows = anperm.length;
    var nCols = this.strText.length / nRows;
    var anRowOfs = new Array;
    
    for (var i = 0; i < nRows; i++) {
        anRowOfs[anperm[i]] = i * nCols;
    }
    
    var strplain = '';
    
    for (var i = 0; i < nCols; i++) {
        for (var j = 0; j < nRows; j++) {
            strplain += this.strText.charAt(anRowOfs[j] + i);
        }
    }
    
    this.strText = strplain;
}

function SecureContext_sign(nCols){
    if (this.bESCApE) {
        this.strText = this.escape(this.strText);
        this.strSIGNATURE = this.escape(this.strSIGNATURE);
    }
    
    var nTextLen = this.strText.length + this.strSIGNATURE.length;
    var nMissingCols = nCols - (nTextLen % nCols);
    var strpadding = '';
    if (nMissingCols < nCols) {
        for (var i = 0; i < nMissingCols; i++) {
            strpadding += ' ';
        }
    }
    
    var x = this.strText.length;
    this.strText += strpadding + this.strSIGNATURE;
}

function SecureContext_unsign(nCols){
    if (this.bESCApE) {
        this.strText = this.unescape(this.strText);
        this.strSIGNATURE = this.unescape(this.strSIGNATURE);
    }
    if ('' == this.strSIGNATURE) {
        return true;
    }
    
    var nTextLen = this.strText.lastIndexOf(this.strSIGNATURE);
    if (-1 == nTextLen) {
        return false;
    }
    
    this.strText = this.strText.substr(0, nTextLen);
    
    return true;
}

function SecureContext_secure(strpasswd){
    var passwd = new password(strpasswd);
    var anperm = passwd.getpermutation()
    
    this.sign(anperm.length);
    this.transliterate(true);
    this.encypher(anperm);
}

function SecureContext_unsecure(strpasswd){
    var passwd = new password(strpasswd);
    var anperm = passwd.getpermutation()
    
    this.decypher(anperm);
    this.transliterate(false);
    
    return this.unsign(anperm.length);
}

function doSecure(str){
    var sc = new SecureContext(str, key, false);
    sc.secure(key);
    
    return sc.strText;
}

function doUnsecure(str){
    var sc = new SecureContext(str, key, false);
    sc.unsecure(key);
    
    return sc.strText;
}

